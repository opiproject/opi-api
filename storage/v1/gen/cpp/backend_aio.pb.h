// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backend_aio.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_backend_5faio_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_backend_5faio_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "object_key.pb.h"
#include "uuid.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_backend_5faio_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_backend_5faio_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_backend_5faio_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class AioController;
struct AioControllerDefaultTypeInternal;
extern AioControllerDefaultTypeInternal _AioController_default_instance_;
class AioControllerCreateRequest;
struct AioControllerCreateRequestDefaultTypeInternal;
extern AioControllerCreateRequestDefaultTypeInternal _AioControllerCreateRequest_default_instance_;
class AioControllerDeleteRequest;
struct AioControllerDeleteRequestDefaultTypeInternal;
extern AioControllerDeleteRequestDefaultTypeInternal _AioControllerDeleteRequest_default_instance_;
class AioControllerGetListRequest;
struct AioControllerGetListRequestDefaultTypeInternal;
extern AioControllerGetListRequestDefaultTypeInternal _AioControllerGetListRequest_default_instance_;
class AioControllerGetRequest;
struct AioControllerGetRequestDefaultTypeInternal;
extern AioControllerGetRequestDefaultTypeInternal _AioControllerGetRequest_default_instance_;
class AioControllerGetStatsRequest;
struct AioControllerGetStatsRequestDefaultTypeInternal;
extern AioControllerGetStatsRequestDefaultTypeInternal _AioControllerGetStatsRequest_default_instance_;
class AioControllerList;
struct AioControllerListDefaultTypeInternal;
extern AioControllerListDefaultTypeInternal _AioControllerList_default_instance_;
class AioControllerStats;
struct AioControllerStatsDefaultTypeInternal;
extern AioControllerStatsDefaultTypeInternal _AioControllerStats_default_instance_;
class AioControllerStatsRequest;
struct AioControllerStatsRequestDefaultTypeInternal;
extern AioControllerStatsRequestDefaultTypeInternal _AioControllerStatsRequest_default_instance_;
class AioControllerUpdateRequest;
struct AioControllerUpdateRequestDefaultTypeInternal;
extern AioControllerUpdateRequestDefaultTypeInternal _AioControllerUpdateRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::AioController* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioController>(Arena*);
template<> ::opi_api::storage::v1::AioControllerCreateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerCreateRequest>(Arena*);
template<> ::opi_api::storage::v1::AioControllerDeleteRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerDeleteRequest>(Arena*);
template<> ::opi_api::storage::v1::AioControllerGetListRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerGetListRequest>(Arena*);
template<> ::opi_api::storage::v1::AioControllerGetRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerGetRequest>(Arena*);
template<> ::opi_api::storage::v1::AioControllerGetStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerGetStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::AioControllerList* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerList>(Arena*);
template<> ::opi_api::storage::v1::AioControllerStats* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerStats>(Arena*);
template<> ::opi_api::storage::v1::AioControllerStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::AioControllerUpdateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::AioControllerUpdateRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

// ===================================================================

class AioController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioController) */ {
 public:
  inline AioController() : AioController(nullptr) {}
  ~AioController() override;
  explicit constexpr AioController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioController(const AioController& from);
  AioController(AioController&& from) noexcept
    : AioController() {
    *this = ::std::move(from);
  }

  inline AioController& operator=(const AioController& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioController& operator=(AioController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioController& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioController* internal_default_instance() {
    return reinterpret_cast<const AioController*>(
               &_AioController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AioController& a, AioController& b) {
    a.Swap(&b);
  }
  inline void Swap(AioController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioController& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioController";
  }
  protected:
  explicit AioController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kFilenameFieldNumber = 6,
    kHandleFieldNumber = 1,
    kUuidFieldNumber = 5,
    kBlockSizeFieldNumber = 3,
    kNumBlocksFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string filename = 6;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // .opi_api.common.v1.ObjectKey handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::opi_api::common::v1::ObjectKey& handle() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_handle();
  ::opi_api::common::v1::ObjectKey* mutable_handle();
  void set_allocated_handle(::opi_api::common::v1::ObjectKey* handle);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_handle() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::opi_api::common::v1::ObjectKey* handle);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_handle();

  // .opi_api.common.v1.Uuid uuid = 5;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::opi_api::common::v1::Uuid& uuid() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::Uuid* release_uuid();
  ::opi_api::common::v1::Uuid* mutable_uuid();
  void set_allocated_uuid(::opi_api::common::v1::Uuid* uuid);
  private:
  const ::opi_api::common::v1::Uuid& _internal_uuid() const;
  ::opi_api::common::v1::Uuid* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::opi_api::common::v1::Uuid* uuid);
  ::opi_api::common::v1::Uuid* unsafe_arena_release_uuid();

  // int64 block_size = 3;
  void clear_block_size();
  int64_t block_size() const;
  void set_block_size(int64_t value);
  private:
  int64_t _internal_block_size() const;
  void _internal_set_block_size(int64_t value);
  public:

  // int64 num_blocks = 4;
  void clear_num_blocks();
  int64_t num_blocks() const;
  void set_num_blocks(int64_t value);
  private:
  int64_t _internal_num_blocks() const;
  void _internal_set_num_blocks(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::opi_api::common::v1::ObjectKey* handle_;
  ::opi_api::common::v1::Uuid* uuid_;
  int64_t block_size_;
  int64_t num_blocks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerCreateRequest) */ {
 public:
  inline AioControllerCreateRequest() : AioControllerCreateRequest(nullptr) {}
  ~AioControllerCreateRequest() override;
  explicit constexpr AioControllerCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerCreateRequest(const AioControllerCreateRequest& from);
  AioControllerCreateRequest(AioControllerCreateRequest&& from) noexcept
    : AioControllerCreateRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerCreateRequest& operator=(const AioControllerCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerCreateRequest& operator=(AioControllerCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerCreateRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerCreateRequest*>(
               &_AioControllerCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AioControllerCreateRequest& a, AioControllerCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerCreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerCreateRequest";
  }
  protected:
  explicit AioControllerCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
  };
  // .opi_api.storage.v1.AioController device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::opi_api::storage::v1::AioController& device() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::AioController* release_device();
  ::opi_api::storage::v1::AioController* mutable_device();
  void set_allocated_device(::opi_api::storage::v1::AioController* device);
  private:
  const ::opi_api::storage::v1::AioController& _internal_device() const;
  ::opi_api::storage::v1::AioController* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::opi_api::storage::v1::AioController* device);
  ::opi_api::storage::v1::AioController* unsafe_arena_release_device();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::AioController* device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerDeleteRequest) */ {
 public:
  inline AioControllerDeleteRequest() : AioControllerDeleteRequest(nullptr) {}
  ~AioControllerDeleteRequest() override;
  explicit constexpr AioControllerDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerDeleteRequest(const AioControllerDeleteRequest& from);
  AioControllerDeleteRequest(AioControllerDeleteRequest&& from) noexcept
    : AioControllerDeleteRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerDeleteRequest& operator=(const AioControllerDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerDeleteRequest& operator=(AioControllerDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerDeleteRequest*>(
               &_AioControllerDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AioControllerDeleteRequest& a, AioControllerDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerDeleteRequest";
  }
  protected:
  explicit AioControllerDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::opi_api::common::v1::ObjectKey& handle() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_handle();
  ::opi_api::common::v1::ObjectKey* mutable_handle();
  void set_allocated_handle(::opi_api::common::v1::ObjectKey* handle);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_handle() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::opi_api::common::v1::ObjectKey* handle);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerUpdateRequest) */ {
 public:
  inline AioControllerUpdateRequest() : AioControllerUpdateRequest(nullptr) {}
  ~AioControllerUpdateRequest() override;
  explicit constexpr AioControllerUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerUpdateRequest(const AioControllerUpdateRequest& from);
  AioControllerUpdateRequest(AioControllerUpdateRequest&& from) noexcept
    : AioControllerUpdateRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerUpdateRequest& operator=(const AioControllerUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerUpdateRequest& operator=(AioControllerUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerUpdateRequest*>(
               &_AioControllerUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AioControllerUpdateRequest& a, AioControllerUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerUpdateRequest";
  }
  protected:
  explicit AioControllerUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
  };
  // .opi_api.storage.v1.AioController device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::opi_api::storage::v1::AioController& device() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::AioController* release_device();
  ::opi_api::storage::v1::AioController* mutable_device();
  void set_allocated_device(::opi_api::storage::v1::AioController* device);
  private:
  const ::opi_api::storage::v1::AioController& _internal_device() const;
  ::opi_api::storage::v1::AioController* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::opi_api::storage::v1::AioController* device);
  ::opi_api::storage::v1::AioController* unsafe_arena_release_device();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::AioController* device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerList) */ {
 public:
  inline AioControllerList() : AioControllerList(nullptr) {}
  ~AioControllerList() override;
  explicit constexpr AioControllerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerList(const AioControllerList& from);
  AioControllerList(AioControllerList&& from) noexcept
    : AioControllerList() {
    *this = ::std::move(from);
  }

  inline AioControllerList& operator=(const AioControllerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerList& operator=(AioControllerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerList* internal_default_instance() {
    return reinterpret_cast<const AioControllerList*>(
               &_AioControllerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AioControllerList& a, AioControllerList& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerList";
  }
  protected:
  explicit AioControllerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
  };
  // repeated .opi_api.storage.v1.AioController device = 1;
  int device_size() const;
  private:
  int _internal_device_size() const;
  public:
  void clear_device();
  ::opi_api::storage::v1::AioController* mutable_device(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::AioController >*
      mutable_device();
  private:
  const ::opi_api::storage::v1::AioController& _internal_device(int index) const;
  ::opi_api::storage::v1::AioController* _internal_add_device();
  public:
  const ::opi_api::storage::v1::AioController& device(int index) const;
  ::opi_api::storage::v1::AioController* add_device();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::AioController >&
      device() const;

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::AioController > device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerGetRequest) */ {
 public:
  inline AioControllerGetRequest() : AioControllerGetRequest(nullptr) {}
  ~AioControllerGetRequest() override;
  explicit constexpr AioControllerGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerGetRequest(const AioControllerGetRequest& from);
  AioControllerGetRequest(AioControllerGetRequest&& from) noexcept
    : AioControllerGetRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerGetRequest& operator=(const AioControllerGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerGetRequest& operator=(AioControllerGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerGetRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerGetRequest*>(
               &_AioControllerGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AioControllerGetRequest& a, AioControllerGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerGetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerGetRequest";
  }
  protected:
  explicit AioControllerGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::opi_api::common::v1::ObjectKey& handle() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_handle();
  ::opi_api::common::v1::ObjectKey* mutable_handle();
  void set_allocated_handle(::opi_api::common::v1::ObjectKey* handle);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_handle() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::opi_api::common::v1::ObjectKey* handle);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerGetListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerGetListRequest) */ {
 public:
  inline AioControllerGetListRequest() : AioControllerGetListRequest(nullptr) {}
  explicit constexpr AioControllerGetListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerGetListRequest(const AioControllerGetListRequest& from);
  AioControllerGetListRequest(AioControllerGetListRequest&& from) noexcept
    : AioControllerGetListRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerGetListRequest& operator=(const AioControllerGetListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerGetListRequest& operator=(AioControllerGetListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerGetListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerGetListRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerGetListRequest*>(
               &_AioControllerGetListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AioControllerGetListRequest& a, AioControllerGetListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerGetListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerGetListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerGetListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerGetListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AioControllerGetListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AioControllerGetListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerGetListRequest";
  }
  protected:
  explicit AioControllerGetListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerGetListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerGetStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerGetStatsRequest) */ {
 public:
  inline AioControllerGetStatsRequest() : AioControllerGetStatsRequest(nullptr) {}
  ~AioControllerGetStatsRequest() override;
  explicit constexpr AioControllerGetStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerGetStatsRequest(const AioControllerGetStatsRequest& from);
  AioControllerGetStatsRequest(AioControllerGetStatsRequest&& from) noexcept
    : AioControllerGetStatsRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerGetStatsRequest& operator=(const AioControllerGetStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerGetStatsRequest& operator=(AioControllerGetStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerGetStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerGetStatsRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerGetStatsRequest*>(
               &_AioControllerGetStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AioControllerGetStatsRequest& a, AioControllerGetStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerGetStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerGetStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerGetStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerGetStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerGetStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerGetStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerGetStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerGetStatsRequest";
  }
  protected:
  explicit AioControllerGetStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::opi_api::common::v1::ObjectKey& handle() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_handle();
  ::opi_api::common::v1::ObjectKey* mutable_handle();
  void set_allocated_handle(::opi_api::common::v1::ObjectKey* handle);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_handle() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::opi_api::common::v1::ObjectKey* handle);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerGetStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerStatsRequest) */ {
 public:
  inline AioControllerStatsRequest() : AioControllerStatsRequest(nullptr) {}
  ~AioControllerStatsRequest() override;
  explicit constexpr AioControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerStatsRequest(const AioControllerStatsRequest& from);
  AioControllerStatsRequest(AioControllerStatsRequest&& from) noexcept
    : AioControllerStatsRequest() {
    *this = ::std::move(from);
  }

  inline AioControllerStatsRequest& operator=(const AioControllerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerStatsRequest& operator=(AioControllerStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const AioControllerStatsRequest*>(
               &_AioControllerStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AioControllerStatsRequest& a, AioControllerStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerStatsRequest";
  }
  protected:
  explicit AioControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::opi_api::common::v1::ObjectKey& handle() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_handle();
  ::opi_api::common::v1::ObjectKey* mutable_handle();
  void set_allocated_handle(::opi_api::common::v1::ObjectKey* handle);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_handle() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::opi_api::common::v1::ObjectKey* handle);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// -------------------------------------------------------------------

class AioControllerStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.AioControllerStats) */ {
 public:
  inline AioControllerStats() : AioControllerStats(nullptr) {}
  ~AioControllerStats() override;
  explicit constexpr AioControllerStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AioControllerStats(const AioControllerStats& from);
  AioControllerStats(AioControllerStats&& from) noexcept
    : AioControllerStats() {
    *this = ::std::move(from);
  }

  inline AioControllerStats& operator=(const AioControllerStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline AioControllerStats& operator=(AioControllerStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AioControllerStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const AioControllerStats* internal_default_instance() {
    return reinterpret_cast<const AioControllerStats*>(
               &_AioControllerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AioControllerStats& a, AioControllerStats& b) {
    a.Swap(&b);
  }
  inline void Swap(AioControllerStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AioControllerStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AioControllerStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AioControllerStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AioControllerStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AioControllerStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AioControllerStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.AioControllerStats";
  }
  protected:
  explicit AioControllerStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 2,
    kHandleFieldNumber = 1,
  };
  // string stats = 2;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // .opi_api.common.v1.ObjectKey handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::opi_api::common::v1::ObjectKey& handle() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_handle();
  ::opi_api::common::v1::ObjectKey* mutable_handle();
  void set_allocated_handle(::opi_api::common::v1::ObjectKey* handle);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_handle() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::opi_api::common::v1::ObjectKey* handle);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.AioControllerStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  ::opi_api::common::v1::ObjectKey* handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_backend_5faio_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AioController

// .opi_api.common.v1.ObjectKey handle = 1;
inline bool AioController::_internal_has_handle() const {
  return this != internal_default_instance() && handle_ != nullptr;
}
inline bool AioController::has_handle() const {
  return _internal_has_handle();
}
inline const ::opi_api::common::v1::ObjectKey& AioController::_internal_handle() const {
  const ::opi_api::common::v1::ObjectKey* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& AioController::handle() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioController.handle)
  return _internal_handle();
}
inline void AioController::unsafe_arena_set_allocated_handle(
    ::opi_api::common::v1::ObjectKey* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioController.handle)
}
inline ::opi_api::common::v1::ObjectKey* AioController::release_handle() {
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioController::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioController.handle)
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioController::_internal_mutable_handle() {
  
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    handle_ = p;
  }
  return handle_;
}
inline ::opi_api::common::v1::ObjectKey* AioController::mutable_handle() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioController.handle)
  return _msg;
}
inline void AioController::set_allocated_handle(::opi_api::common::v1::ObjectKey* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioController.handle)
}

// string name = 2;
inline void AioController::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AioController::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioController.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AioController::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.AioController.name)
}
inline std::string* AioController::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioController.name)
  return _s;
}
inline const std::string& AioController::_internal_name() const {
  return name_.Get();
}
inline void AioController::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AioController::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AioController::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioController.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AioController::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioController.name)
}

// int64 block_size = 3;
inline void AioController::clear_block_size() {
  block_size_ = int64_t{0};
}
inline int64_t AioController::_internal_block_size() const {
  return block_size_;
}
inline int64_t AioController::block_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioController.block_size)
  return _internal_block_size();
}
inline void AioController::_internal_set_block_size(int64_t value) {
  
  block_size_ = value;
}
inline void AioController::set_block_size(int64_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.AioController.block_size)
}

// int64 num_blocks = 4;
inline void AioController::clear_num_blocks() {
  num_blocks_ = int64_t{0};
}
inline int64_t AioController::_internal_num_blocks() const {
  return num_blocks_;
}
inline int64_t AioController::num_blocks() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioController.num_blocks)
  return _internal_num_blocks();
}
inline void AioController::_internal_set_num_blocks(int64_t value) {
  
  num_blocks_ = value;
}
inline void AioController::set_num_blocks(int64_t value) {
  _internal_set_num_blocks(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.AioController.num_blocks)
}

// .opi_api.common.v1.Uuid uuid = 5;
inline bool AioController::_internal_has_uuid() const {
  return this != internal_default_instance() && uuid_ != nullptr;
}
inline bool AioController::has_uuid() const {
  return _internal_has_uuid();
}
inline const ::opi_api::common::v1::Uuid& AioController::_internal_uuid() const {
  const ::opi_api::common::v1::Uuid* p = uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::Uuid&>(
      ::opi_api::common::v1::_Uuid_default_instance_);
}
inline const ::opi_api::common::v1::Uuid& AioController::uuid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioController.uuid)
  return _internal_uuid();
}
inline void AioController::unsafe_arena_set_allocated_uuid(
    ::opi_api::common::v1::Uuid* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  uuid_ = uuid;
  if (uuid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioController.uuid)
}
inline ::opi_api::common::v1::Uuid* AioController::release_uuid() {
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::Uuid* AioController::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioController.uuid)
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::Uuid* AioController::_internal_mutable_uuid() {
  
  if (uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::Uuid>(GetArenaForAllocation());
    uuid_ = p;
  }
  return uuid_;
}
inline ::opi_api::common::v1::Uuid* AioController::mutable_uuid() {
  ::opi_api::common::v1::Uuid* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioController.uuid)
  return _msg;
}
inline void AioController::set_allocated_uuid(::opi_api::common::v1::Uuid* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid));
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    
  } else {
    
  }
  uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioController.uuid)
}

// string filename = 6;
inline void AioController::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& AioController::filename() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioController.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AioController::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.AioController.filename)
}
inline std::string* AioController::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioController.filename)
  return _s;
}
inline const std::string& AioController::_internal_filename() const {
  return filename_.Get();
}
inline void AioController::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AioController::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AioController::release_filename() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioController.filename)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AioController::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioController.filename)
}

// -------------------------------------------------------------------

// AioControllerCreateRequest

// .opi_api.storage.v1.AioController device = 1;
inline bool AioControllerCreateRequest::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool AioControllerCreateRequest::has_device() const {
  return _internal_has_device();
}
inline void AioControllerCreateRequest::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::opi_api::storage::v1::AioController& AioControllerCreateRequest::_internal_device() const {
  const ::opi_api::storage::v1::AioController* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::AioController&>(
      ::opi_api::storage::v1::_AioController_default_instance_);
}
inline const ::opi_api::storage::v1::AioController& AioControllerCreateRequest::device() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerCreateRequest.device)
  return _internal_device();
}
inline void AioControllerCreateRequest::unsafe_arena_set_allocated_device(
    ::opi_api::storage::v1::AioController* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerCreateRequest.device)
}
inline ::opi_api::storage::v1::AioController* AioControllerCreateRequest::release_device() {
  
  ::opi_api::storage::v1::AioController* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::AioController* AioControllerCreateRequest::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerCreateRequest.device)
  
  ::opi_api::storage::v1::AioController* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::AioController* AioControllerCreateRequest::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::AioController>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::opi_api::storage::v1::AioController* AioControllerCreateRequest::mutable_device() {
  ::opi_api::storage::v1::AioController* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerCreateRequest.device)
  return _msg;
}
inline void AioControllerCreateRequest::set_allocated_device(::opi_api::storage::v1::AioController* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::AioController>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerCreateRequest.device)
}

// -------------------------------------------------------------------

// AioControllerDeleteRequest

// .opi_api.common.v1.ObjectKey handle = 1;
inline bool AioControllerDeleteRequest::_internal_has_handle() const {
  return this != internal_default_instance() && handle_ != nullptr;
}
inline bool AioControllerDeleteRequest::has_handle() const {
  return _internal_has_handle();
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerDeleteRequest::_internal_handle() const {
  const ::opi_api::common::v1::ObjectKey* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerDeleteRequest::handle() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerDeleteRequest.handle)
  return _internal_handle();
}
inline void AioControllerDeleteRequest::unsafe_arena_set_allocated_handle(
    ::opi_api::common::v1::ObjectKey* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerDeleteRequest.handle)
}
inline ::opi_api::common::v1::ObjectKey* AioControllerDeleteRequest::release_handle() {
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerDeleteRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerDeleteRequest.handle)
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerDeleteRequest::_internal_mutable_handle() {
  
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    handle_ = p;
  }
  return handle_;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerDeleteRequest::mutable_handle() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerDeleteRequest.handle)
  return _msg;
}
inline void AioControllerDeleteRequest::set_allocated_handle(::opi_api::common::v1::ObjectKey* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerDeleteRequest.handle)
}

// -------------------------------------------------------------------

// AioControllerUpdateRequest

// .opi_api.storage.v1.AioController device = 1;
inline bool AioControllerUpdateRequest::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool AioControllerUpdateRequest::has_device() const {
  return _internal_has_device();
}
inline void AioControllerUpdateRequest::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::opi_api::storage::v1::AioController& AioControllerUpdateRequest::_internal_device() const {
  const ::opi_api::storage::v1::AioController* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::AioController&>(
      ::opi_api::storage::v1::_AioController_default_instance_);
}
inline const ::opi_api::storage::v1::AioController& AioControllerUpdateRequest::device() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerUpdateRequest.device)
  return _internal_device();
}
inline void AioControllerUpdateRequest::unsafe_arena_set_allocated_device(
    ::opi_api::storage::v1::AioController* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerUpdateRequest.device)
}
inline ::opi_api::storage::v1::AioController* AioControllerUpdateRequest::release_device() {
  
  ::opi_api::storage::v1::AioController* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::AioController* AioControllerUpdateRequest::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerUpdateRequest.device)
  
  ::opi_api::storage::v1::AioController* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::AioController* AioControllerUpdateRequest::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::AioController>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::opi_api::storage::v1::AioController* AioControllerUpdateRequest::mutable_device() {
  ::opi_api::storage::v1::AioController* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerUpdateRequest.device)
  return _msg;
}
inline void AioControllerUpdateRequest::set_allocated_device(::opi_api::storage::v1::AioController* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::AioController>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerUpdateRequest.device)
}

// -------------------------------------------------------------------

// AioControllerList

// repeated .opi_api.storage.v1.AioController device = 1;
inline int AioControllerList::_internal_device_size() const {
  return device_.size();
}
inline int AioControllerList::device_size() const {
  return _internal_device_size();
}
inline void AioControllerList::clear_device() {
  device_.Clear();
}
inline ::opi_api::storage::v1::AioController* AioControllerList::mutable_device(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerList.device)
  return device_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::AioController >*
AioControllerList::mutable_device() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.AioControllerList.device)
  return &device_;
}
inline const ::opi_api::storage::v1::AioController& AioControllerList::_internal_device(int index) const {
  return device_.Get(index);
}
inline const ::opi_api::storage::v1::AioController& AioControllerList::device(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerList.device)
  return _internal_device(index);
}
inline ::opi_api::storage::v1::AioController* AioControllerList::_internal_add_device() {
  return device_.Add();
}
inline ::opi_api::storage::v1::AioController* AioControllerList::add_device() {
  ::opi_api::storage::v1::AioController* _add = _internal_add_device();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.AioControllerList.device)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::AioController >&
AioControllerList::device() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.AioControllerList.device)
  return device_;
}

// -------------------------------------------------------------------

// AioControllerGetRequest

// .opi_api.common.v1.ObjectKey handle = 1;
inline bool AioControllerGetRequest::_internal_has_handle() const {
  return this != internal_default_instance() && handle_ != nullptr;
}
inline bool AioControllerGetRequest::has_handle() const {
  return _internal_has_handle();
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerGetRequest::_internal_handle() const {
  const ::opi_api::common::v1::ObjectKey* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerGetRequest::handle() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerGetRequest.handle)
  return _internal_handle();
}
inline void AioControllerGetRequest::unsafe_arena_set_allocated_handle(
    ::opi_api::common::v1::ObjectKey* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerGetRequest.handle)
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetRequest::release_handle() {
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerGetRequest.handle)
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetRequest::_internal_mutable_handle() {
  
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    handle_ = p;
  }
  return handle_;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetRequest::mutable_handle() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerGetRequest.handle)
  return _msg;
}
inline void AioControllerGetRequest::set_allocated_handle(::opi_api::common::v1::ObjectKey* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerGetRequest.handle)
}

// -------------------------------------------------------------------

// AioControllerGetListRequest

// -------------------------------------------------------------------

// AioControllerGetStatsRequest

// .opi_api.common.v1.ObjectKey handle = 1;
inline bool AioControllerGetStatsRequest::_internal_has_handle() const {
  return this != internal_default_instance() && handle_ != nullptr;
}
inline bool AioControllerGetStatsRequest::has_handle() const {
  return _internal_has_handle();
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerGetStatsRequest::_internal_handle() const {
  const ::opi_api::common::v1::ObjectKey* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerGetStatsRequest::handle() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerGetStatsRequest.handle)
  return _internal_handle();
}
inline void AioControllerGetStatsRequest::unsafe_arena_set_allocated_handle(
    ::opi_api::common::v1::ObjectKey* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerGetStatsRequest.handle)
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetStatsRequest::release_handle() {
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetStatsRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerGetStatsRequest.handle)
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetStatsRequest::_internal_mutable_handle() {
  
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    handle_ = p;
  }
  return handle_;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerGetStatsRequest::mutable_handle() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerGetStatsRequest.handle)
  return _msg;
}
inline void AioControllerGetStatsRequest::set_allocated_handle(::opi_api::common::v1::ObjectKey* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerGetStatsRequest.handle)
}

// -------------------------------------------------------------------

// AioControllerStatsRequest

// .opi_api.common.v1.ObjectKey handle = 1;
inline bool AioControllerStatsRequest::_internal_has_handle() const {
  return this != internal_default_instance() && handle_ != nullptr;
}
inline bool AioControllerStatsRequest::has_handle() const {
  return _internal_has_handle();
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerStatsRequest::_internal_handle() const {
  const ::opi_api::common::v1::ObjectKey* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerStatsRequest::handle() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerStatsRequest.handle)
  return _internal_handle();
}
inline void AioControllerStatsRequest::unsafe_arena_set_allocated_handle(
    ::opi_api::common::v1::ObjectKey* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerStatsRequest.handle)
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStatsRequest::release_handle() {
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStatsRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerStatsRequest.handle)
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStatsRequest::_internal_mutable_handle() {
  
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    handle_ = p;
  }
  return handle_;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStatsRequest::mutable_handle() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerStatsRequest.handle)
  return _msg;
}
inline void AioControllerStatsRequest::set_allocated_handle(::opi_api::common::v1::ObjectKey* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerStatsRequest.handle)
}

// -------------------------------------------------------------------

// AioControllerStats

// .opi_api.common.v1.ObjectKey handle = 1;
inline bool AioControllerStats::_internal_has_handle() const {
  return this != internal_default_instance() && handle_ != nullptr;
}
inline bool AioControllerStats::has_handle() const {
  return _internal_has_handle();
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerStats::_internal_handle() const {
  const ::opi_api::common::v1::ObjectKey* p = handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& AioControllerStats::handle() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerStats.handle)
  return _internal_handle();
}
inline void AioControllerStats::unsafe_arena_set_allocated_handle(
    ::opi_api::common::v1::ObjectKey* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  handle_ = handle;
  if (handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.AioControllerStats.handle)
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStats::release_handle() {
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStats::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerStats.handle)
  
  ::opi_api::common::v1::ObjectKey* temp = handle_;
  handle_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStats::_internal_mutable_handle() {
  
  if (handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    handle_ = p;
  }
  return handle_;
}
inline ::opi_api::common::v1::ObjectKey* AioControllerStats::mutable_handle() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerStats.handle)
  return _msg;
}
inline void AioControllerStats::set_allocated_handle(::opi_api::common::v1::ObjectKey* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    
  } else {
    
  }
  handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerStats.handle)
}

// string stats = 2;
inline void AioControllerStats::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& AioControllerStats::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.AioControllerStats.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AioControllerStats::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.AioControllerStats.stats)
}
inline std::string* AioControllerStats::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.AioControllerStats.stats)
  return _s;
}
inline const std::string& AioControllerStats::_internal_stats() const {
  return stats_.Get();
}
inline void AioControllerStats::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AioControllerStats::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AioControllerStats::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.AioControllerStats.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AioControllerStats::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.AioControllerStats.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_backend_5faio_2eproto
