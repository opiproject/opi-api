// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#include "frontend_nvme_pcie.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace opi_api {
namespace storage {
namespace v1 {
constexpr NVMeSubsystem::NVMeSubsystem(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nqn_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , firmware_revision_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fru_guid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr)
  , max_ns_(int64_t{0}){}
struct NVMeSubsystemDefaultTypeInternal {
  constexpr NVMeSubsystemDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemDefaultTypeInternal() {}
  union {
    NVMeSubsystem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemDefaultTypeInternal _NVMeSubsystem_default_instance_;
constexpr NVMeController::NVMeController(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr)
  , subsystem_id_(nullptr)
  , pcie_id_(nullptr)
  , nvme_controller_id_(0u)
  , max_nsq_(0u)
  , max_ncq_(0u)
  , sqes_(0u)
  , cqes_(0u)
  , max_ns_(0u){}
struct NVMeControllerDefaultTypeInternal {
  constexpr NVMeControllerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerDefaultTypeInternal() {}
  union {
    NVMeController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerDefaultTypeInternal _NVMeController_default_instance_;
constexpr NVMeNamespace::NVMeNamespace(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nguid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr)
  , subsystem_id_(nullptr)
  , controller_id_(nullptr)
  , uuid_(nullptr)
  , volume_id_(nullptr)
  , block_size_(int64_t{0})
  , num_blocks_(int64_t{0})
  , host_nsid_(0u)
  , optimal_write_size_(0u)
  , eui64_(uint64_t{0u})
  , pref_write_granularity_(0u){}
struct NVMeNamespaceDefaultTypeInternal {
  constexpr NVMeNamespaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceDefaultTypeInternal() {}
  union {
    NVMeNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceDefaultTypeInternal _NVMeNamespace_default_instance_;
constexpr NVMeSubsystemCreateRequest::NVMeSubsystemCreateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(nullptr){}
struct NVMeSubsystemCreateRequestDefaultTypeInternal {
  constexpr NVMeSubsystemCreateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemCreateRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemCreateRequestDefaultTypeInternal _NVMeSubsystemCreateRequest_default_instance_;
constexpr NVMeSubsystemDeleteRequest::NVMeSubsystemDeleteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemDeleteRequestDefaultTypeInternal {
  constexpr NVMeSubsystemDeleteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemDeleteRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemDeleteRequestDefaultTypeInternal _NVMeSubsystemDeleteRequest_default_instance_;
constexpr NVMeSubsystemUpdateRequest::NVMeSubsystemUpdateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(nullptr){}
struct NVMeSubsystemUpdateRequestDefaultTypeInternal {
  constexpr NVMeSubsystemUpdateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemUpdateRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemUpdateRequestDefaultTypeInternal _NVMeSubsystemUpdateRequest_default_instance_;
constexpr NVMeSubsystemListRequest::NVMeSubsystemListRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct NVMeSubsystemListRequestDefaultTypeInternal {
  constexpr NVMeSubsystemListRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemListRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemListRequestDefaultTypeInternal _NVMeSubsystemListRequest_default_instance_;
constexpr NVMeSubsystemListResponse::NVMeSubsystemListResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(){}
struct NVMeSubsystemListResponseDefaultTypeInternal {
  constexpr NVMeSubsystemListResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemListResponseDefaultTypeInternal() {}
  union {
    NVMeSubsystemListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemListResponseDefaultTypeInternal _NVMeSubsystemListResponse_default_instance_;
constexpr NVMeSubsystemGetRequest::NVMeSubsystemGetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemGetRequestDefaultTypeInternal {
  constexpr NVMeSubsystemGetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemGetRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemGetRequestDefaultTypeInternal _NVMeSubsystemGetRequest_default_instance_;
constexpr NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemStatsRequestDefaultTypeInternal {
  constexpr NVMeSubsystemStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatsRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatsRequestDefaultTypeInternal _NVMeSubsystemStatsRequest_default_instance_;
constexpr NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct NVMeSubsystemStatsResponseDefaultTypeInternal {
  constexpr NVMeSubsystemStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatsResponseDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatsResponseDefaultTypeInternal _NVMeSubsystemStatsResponse_default_instance_;
constexpr NVMeControllerCreateRequest::NVMeControllerCreateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(nullptr){}
struct NVMeControllerCreateRequestDefaultTypeInternal {
  constexpr NVMeControllerCreateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerCreateRequestDefaultTypeInternal() {}
  union {
    NVMeControllerCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerCreateRequestDefaultTypeInternal _NVMeControllerCreateRequest_default_instance_;
constexpr NVMeControllerDeleteRequest::NVMeControllerDeleteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_id_(nullptr){}
struct NVMeControllerDeleteRequestDefaultTypeInternal {
  constexpr NVMeControllerDeleteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerDeleteRequestDefaultTypeInternal() {}
  union {
    NVMeControllerDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerDeleteRequestDefaultTypeInternal _NVMeControllerDeleteRequest_default_instance_;
constexpr NVMeControllerUpdateRequest::NVMeControllerUpdateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(nullptr){}
struct NVMeControllerUpdateRequestDefaultTypeInternal {
  constexpr NVMeControllerUpdateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerUpdateRequestDefaultTypeInternal() {}
  union {
    NVMeControllerUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerUpdateRequestDefaultTypeInternal _NVMeControllerUpdateRequest_default_instance_;
constexpr NVMeControllerListRequest::NVMeControllerListRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeControllerListRequestDefaultTypeInternal {
  constexpr NVMeControllerListRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerListRequestDefaultTypeInternal() {}
  union {
    NVMeControllerListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerListRequestDefaultTypeInternal _NVMeControllerListRequest_default_instance_;
constexpr NVMeControllerListResponse::NVMeControllerListResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(){}
struct NVMeControllerListResponseDefaultTypeInternal {
  constexpr NVMeControllerListResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerListResponseDefaultTypeInternal() {}
  union {
    NVMeControllerListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerListResponseDefaultTypeInternal _NVMeControllerListResponse_default_instance_;
constexpr NVMeControllerGetRequest::NVMeControllerGetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_id_(nullptr){}
struct NVMeControllerGetRequestDefaultTypeInternal {
  constexpr NVMeControllerGetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerGetRequestDefaultTypeInternal() {}
  union {
    NVMeControllerGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerGetRequestDefaultTypeInternal _NVMeControllerGetRequest_default_instance_;
constexpr NVMeControllerStatsRequest::NVMeControllerStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr){}
struct NVMeControllerStatsRequestDefaultTypeInternal {
  constexpr NVMeControllerStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatsRequestDefaultTypeInternal() {}
  union {
    NVMeControllerStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatsRequestDefaultTypeInternal _NVMeControllerStatsRequest_default_instance_;
constexpr NVMeControllerStatsResponse::NVMeControllerStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr){}
struct NVMeControllerStatsResponseDefaultTypeInternal {
  constexpr NVMeControllerStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatsResponseDefaultTypeInternal() {}
  union {
    NVMeControllerStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatsResponseDefaultTypeInternal _NVMeControllerStatsResponse_default_instance_;
constexpr NVMeNamespaceCreateRequest::NVMeNamespaceCreateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(nullptr){}
struct NVMeNamespaceCreateRequestDefaultTypeInternal {
  constexpr NVMeNamespaceCreateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceCreateRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceCreateRequestDefaultTypeInternal _NVMeNamespaceCreateRequest_default_instance_;
constexpr NVMeNamespaceDeleteRequest::NVMeNamespaceDeleteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceDeleteRequestDefaultTypeInternal {
  constexpr NVMeNamespaceDeleteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceDeleteRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceDeleteRequestDefaultTypeInternal _NVMeNamespaceDeleteRequest_default_instance_;
constexpr NVMeNamespaceUpdateRequest::NVMeNamespaceUpdateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(nullptr){}
struct NVMeNamespaceUpdateRequestDefaultTypeInternal {
  constexpr NVMeNamespaceUpdateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceUpdateRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceUpdateRequestDefaultTypeInternal _NVMeNamespaceUpdateRequest_default_instance_;
constexpr NVMeNamespaceListRequest::NVMeNamespaceListRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr)
  , controller_id_(nullptr){}
struct NVMeNamespaceListRequestDefaultTypeInternal {
  constexpr NVMeNamespaceListRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceListRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceListRequestDefaultTypeInternal _NVMeNamespaceListRequest_default_instance_;
constexpr NVMeNamespaceListResponse::NVMeNamespaceListResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(){}
struct NVMeNamespaceListResponseDefaultTypeInternal {
  constexpr NVMeNamespaceListResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceListResponseDefaultTypeInternal() {}
  union {
    NVMeNamespaceListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceListResponseDefaultTypeInternal _NVMeNamespaceListResponse_default_instance_;
constexpr NVMeNamespaceGetRequest::NVMeNamespaceGetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceGetRequestDefaultTypeInternal {
  constexpr NVMeNamespaceGetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceGetRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceGetRequestDefaultTypeInternal _NVMeNamespaceGetRequest_default_instance_;
constexpr NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceStatsRequestDefaultTypeInternal {
  constexpr NVMeNamespaceStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatsRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatsRequestDefaultTypeInternal _NVMeNamespaceStatsRequest_default_instance_;
constexpr NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr){}
struct NVMeNamespaceStatsResponseDefaultTypeInternal {
  constexpr NVMeNamespaceStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatsResponseDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatsResponseDefaultTypeInternal _NVMeNamespaceStatsResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_frontend_5fnvme_5fpcie_2eproto[27];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto = nullptr;

const uint32_t TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, nqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, serial_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, model_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, max_ns_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, firmware_revision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, fru_guid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, nvme_controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, pcie_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, max_nsq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, max_ncq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, sqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, cqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, max_ns_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, host_nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, block_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, num_blocks_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, uuid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, volume_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, optimal_write_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, pref_write_granularity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemCreateRequest, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemDeleteRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemUpdateRequest, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemListResponse, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemGetRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerCreateRequest, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerDeleteRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerUpdateRequest, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListResponse, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerGetRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsRequest, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceCreateRequest, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceDeleteRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceUpdateRequest, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListRequest, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListResponse, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceGetRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, stats_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystem)},
  { 13, -1, -1, sizeof(::opi_api::storage::v1::NVMeController)},
  { 28, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespace)},
  { 46, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemCreateRequest)},
  { 53, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemDeleteRequest)},
  { 60, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemUpdateRequest)},
  { 67, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemListRequest)},
  { 73, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemListResponse)},
  { 80, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemGetRequest)},
  { 87, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatsRequest)},
  { 94, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatsResponse)},
  { 101, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerCreateRequest)},
  { 108, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerDeleteRequest)},
  { 115, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerUpdateRequest)},
  { 122, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerListRequest)},
  { 129, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerListResponse)},
  { 136, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerGetRequest)},
  { 143, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatsRequest)},
  { 150, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatsResponse)},
  { 158, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceCreateRequest)},
  { 165, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceDeleteRequest)},
  { 172, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceUpdateRequest)},
  { 179, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceListRequest)},
  { 187, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceListResponse)},
  { 194, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceGetRequest)},
  { 201, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatsRequest)},
  { 208, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatsResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeController_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemCreateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemDeleteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemUpdateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemListRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemListResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemGetRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerCreateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerDeleteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerUpdateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerListRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerListResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerGetRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceCreateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceDeleteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceUpdateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceListRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceListResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceGetRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatsResponse_default_instance_),
};

const char descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030frontend_nvme_pcie.proto\022\022opi_api.stor"
  "age.v1\032\014common.proto\032\nuuid.proto\032\020object"
  "_key.proto\032\033google/protobuf/empty.proto\""
  "\260\001\n\rNVMeSubsystem\022(\n\002id\030\001 \001(\0132\034.opi_api."
  "common.v1.ObjectKey\022\013\n\003nqn\030\002 \001(\t\022\025\n\rseri"
  "al_number\030\003 \001(\t\022\024\n\014model_number\030\004 \001(\t\022\016\n"
  "\006max_ns\030\005 \001(\003\022\031\n\021firmware_revision\030\006 \001(\t"
  "\022\020\n\010fru_guid\030\007 \001(\014\"\222\002\n\016NVMeController\022(\n"
  "\002id\030\001 \001(\0132\034.opi_api.common.v1.ObjectKey\022"
  "\032\n\022nvme_controller_id\030\002 \001(\r\0222\n\014subsystem"
  "_id\030\003 \001(\0132\034.opi_api.common.v1.ObjectKey\022"
  "8\n\007pcie_id\030\004 \001(\0132\'.opi_api.storage.v1.Nv"
  "meControllerPciId\022\017\n\007max_nsq\030\005 \001(\r\022\017\n\007ma"
  "x_ncq\030\006 \001(\r\022\014\n\004sqes\030\007 \001(\r\022\014\n\004cqes\030\010 \001(\r\022"
  "\016\n\006max_ns\030\t \001(\r\"\217\003\n\rNVMeNamespace\022(\n\002id\030"
  "\001 \001(\0132\034.opi_api.common.v1.ObjectKey\0222\n\014s"
  "ubsystem_id\030\002 \001(\0132\034.opi_api.common.v1.Ob"
  "jectKey\0223\n\rcontroller_id\030\003 \001(\0132\034.opi_api"
  ".common.v1.ObjectKey\022\021\n\thost_nsid\030\004 \001(\r\022"
  "\022\n\nblock_size\030\005 \001(\003\022\022\n\nnum_blocks\030\006 \001(\003\022"
  "\r\n\005nguid\030\007 \001(\t\022\r\n\005eui64\030\010 \001(\006\022%\n\004uuid\030\t "
  "\001(\0132\027.opi_api.common.v1.Uuid\022/\n\tvolume_i"
  "d\030\n \001(\0132\034.opi_api.common.v1.ObjectKey\022\032\n"
  "\022optimal_write_size\030\013 \001(\r\022\036\n\026pref_write_"
  "granularity\030\014 \001(\r\"R\n\032NVMeSubsystemCreate"
  "Request\0224\n\tsubsystem\030\001 \001(\0132!.opi_api.sto"
  "rage.v1.NVMeSubsystem\"P\n\032NVMeSubsystemDe"
  "leteRequest\0222\n\014subsystem_id\030\001 \001(\0132\034.opi_"
  "api.common.v1.ObjectKey\"R\n\032NVMeSubsystem"
  "UpdateRequest\0224\n\tsubsystem\030\001 \001(\0132!.opi_a"
  "pi.storage.v1.NVMeSubsystem\"\032\n\030NVMeSubsy"
  "stemListRequest\"Q\n\031NVMeSubsystemListResp"
  "onse\0224\n\tsubsystem\030\001 \003(\0132!.opi_api.storag"
  "e.v1.NVMeSubsystem\"M\n\027NVMeSubsystemGetRe"
  "quest\0222\n\014subsystem_id\030\001 \001(\0132\034.opi_api.co"
  "mmon.v1.ObjectKey\"O\n\031NVMeSubsystemStatsR"
  "equest\0222\n\014subsystem_id\030\001 \001(\0132\034.opi_api.c"
  "ommon.v1.ObjectKey\"+\n\032NVMeSubsystemStats"
  "Response\022\r\n\005stats\030\001 \001(\t\"U\n\033NVMeControlle"
  "rCreateRequest\0226\n\ncontroller\030\001 \001(\0132\".opi"
  "_api.storage.v1.NVMeController\"R\n\033NVMeCo"
  "ntrollerDeleteRequest\0223\n\rcontroller_id\030\001"
  " \001(\0132\034.opi_api.common.v1.ObjectKey\"U\n\033NV"
  "MeControllerUpdateRequest\0226\n\ncontroller\030"
  "\001 \001(\0132\".opi_api.storage.v1.NVMeControlle"
  "r\"O\n\031NVMeControllerListRequest\0222\n\014subsys"
  "tem_id\030\001 \001(\0132\034.opi_api.common.v1.ObjectK"
  "ey\"T\n\032NVMeControllerListResponse\0226\n\ncont"
  "roller\030\001 \003(\0132\".opi_api.storage.v1.NVMeCo"
  "ntroller\"O\n\030NVMeControllerGetRequest\0223\n\r"
  "controller_id\030\001 \001(\0132\034.opi_api.common.v1."
  "ObjectKey\"F\n\032NVMeControllerStatsRequest\022"
  "(\n\002id\030\001 \001(\0132\034.opi_api.common.v1.ObjectKe"
  "y\"V\n\033NVMeControllerStatsResponse\022(\n\002id\030\001"
  " \001(\0132\034.opi_api.common.v1.ObjectKey\022\r\n\005st"
  "ats\030\002 \001(\t\"R\n\032NVMeNamespaceCreateRequest\022"
  "4\n\tnamespace\030\001 \001(\0132!.opi_api.storage.v1."
  "NVMeNamespace\"P\n\032NVMeNamespaceDeleteRequ"
  "est\0222\n\014namespace_id\030\001 \001(\0132\034.opi_api.comm"
  "on.v1.ObjectKey\"R\n\032NVMeNamespaceUpdateRe"
  "quest\0224\n\tnamespace\030\001 \001(\0132!.opi_api.stora"
  "ge.v1.NVMeNamespace\"\203\001\n\030NVMeNamespaceLis"
  "tRequest\0222\n\014subsystem_id\030\001 \001(\0132\034.opi_api"
  ".common.v1.ObjectKey\0223\n\rcontroller_id\030\002 "
  "\001(\0132\034.opi_api.common.v1.ObjectKey\"Q\n\031NVM"
  "eNamespaceListResponse\0224\n\tnamespace\030\001 \003("
  "\0132!.opi_api.storage.v1.NVMeNamespace\"M\n\027"
  "NVMeNamespaceGetRequest\0222\n\014namespace_id\030"
  "\001 \001(\0132\034.opi_api.common.v1.ObjectKey\"O\n\031N"
  "VMeNamespaceStatsRequest\0222\n\014namespace_id"
  "\030\001 \001(\0132\034.opi_api.common.v1.ObjectKey\"U\n\032"
  "NVMeNamespaceStatsResponse\022(\n\002id\030\001 \001(\0132\034"
  ".opi_api.common.v1.ObjectKey\022\r\n\005stats\030\002 "
  "\001(\t2\240\005\n\024NVMeSubsystemService\022j\n\023NVMeSubs"
  "ystemCreate\022..opi_api.storage.v1.NVMeSub"
  "systemCreateRequest\032!.opi_api.storage.v1"
  ".NVMeSubsystem\"\000\022_\n\023NVMeSubsystemDelete\022"
  "..opi_api.storage.v1.NVMeSubsystemDelete"
  "Request\032\026.google.protobuf.Empty\"\000\022j\n\023NVM"
  "eSubsystemUpdate\022..opi_api.storage.v1.NV"
  "MeSubsystemUpdateRequest\032!.opi_api.stora"
  "ge.v1.NVMeSubsystem\"\000\022r\n\021NVMeSubsystemLi"
  "st\022,.opi_api.storage.v1.NVMeSubsystemLis"
  "tRequest\032-.opi_api.storage.v1.NVMeSubsys"
  "temListResponse\"\000\022d\n\020NVMeSubsystemGet\022+."
  "opi_api.storage.v1.NVMeSubsystemGetReque"
  "st\032!.opi_api.storage.v1.NVMeSubsystem\"\000\022"
  "u\n\022NVMeSubsystemStats\022-.opi_api.storage."
  "v1.NVMeSubsystemStatsRequest\032..opi_api.s"
  "torage.v1.NVMeSubsystemStatsResponse\"\0002\262"
  "\005\n\025NVMeControllerService\022m\n\024NVMeControll"
  "erCreate\022/.opi_api.storage.v1.NVMeContro"
  "llerCreateRequest\032\".opi_api.storage.v1.N"
  "VMeController\"\000\022a\n\024NVMeControllerDelete\022"
  "/.opi_api.storage.v1.NVMeControllerDelet"
  "eRequest\032\026.google.protobuf.Empty\"\000\022m\n\024NV"
  "MeControllerUpdate\022/.opi_api.storage.v1."
  "NVMeControllerUpdateRequest\032\".opi_api.st"
  "orage.v1.NVMeController\"\000\022u\n\022NVMeControl"
  "lerList\022-.opi_api.storage.v1.NVMeControl"
  "lerListRequest\032..opi_api.storage.v1.NVMe"
  "ControllerListResponse\"\000\022g\n\021NVMeControll"
  "erGet\022,.opi_api.storage.v1.NVMeControlle"
  "rGetRequest\032\".opi_api.storage.v1.NVMeCon"
  "troller\"\000\022x\n\023NVMeControllerStats\022..opi_a"
  "pi.storage.v1.NVMeControllerStatsRequest"
  "\032/.opi_api.storage.v1.NVMeControllerStat"
  "sResponse\"\0002\240\005\n\024NVMeNamespaceService\022j\n\023"
  "NVMeNamespaceCreate\022..opi_api.storage.v1"
  ".NVMeNamespaceCreateRequest\032!.opi_api.st"
  "orage.v1.NVMeNamespace\"\000\022_\n\023NVMeNamespac"
  "eDelete\022..opi_api.storage.v1.NVMeNamespa"
  "ceDeleteRequest\032\026.google.protobuf.Empty\""
  "\000\022j\n\023NVMeNamespaceUpdate\022..opi_api.stora"
  "ge.v1.NVMeNamespaceUpdateRequest\032!.opi_a"
  "pi.storage.v1.NVMeNamespace\"\000\022r\n\021NVMeNam"
  "espaceList\022,.opi_api.storage.v1.NVMeName"
  "spaceListRequest\032-.opi_api.storage.v1.NV"
  "MeNamespaceListResponse\"\000\022d\n\020NVMeNamespa"
  "ceGet\022+.opi_api.storage.v1.NVMeNamespace"
  "GetRequest\032!.opi_api.storage.v1.NVMeName"
  "space\"\000\022u\n\022NVMeNamespaceStats\022-.opi_api."
  "storage.v1.NVMeNamespaceStatsRequest\032..o"
  "pi_api.storage.v1.NVMeNamespaceStatsResp"
  "onse\"\000B1Z/github.com/opiproject/opi-api/"
  "storage/v1/gen/gob\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps[4] = {
  &::descriptor_table_common_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_object_5fkey_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_frontend_5fnvme_5fpcie_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto = {
  false, false, 5025, descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto, "frontend_nvme_pcie.proto", 
  &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once, descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps, 4, 27,
  schemas, file_default_instances, TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets,
  file_level_metadata_frontend_5fnvme_5fpcie_2eproto, file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto, file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter() {
  return &descriptor_table_frontend_5fnvme_5fpcie_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_frontend_5fnvme_5fpcie_2eproto(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {

// ===================================================================

class NVMeSubsystem::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeSubsystem* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystem::_Internal::id(const NVMeSubsystem* msg) {
  return *msg->id_;
}
void NVMeSubsystem::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeSubsystem::NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystem)
}
NVMeSubsystem::NVMeSubsystem(const NVMeSubsystem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nqn().empty()) {
    nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nqn(), 
      GetArenaForAllocation());
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial_number(), 
      GetArenaForAllocation());
  }
  model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_number().empty()) {
    model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_number(), 
      GetArenaForAllocation());
  }
  firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_revision().empty()) {
    firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_firmware_revision(), 
      GetArenaForAllocation());
  }
  fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fru_guid().empty()) {
    fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_fru_guid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  max_ns_ = from.max_ns_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystem)
}

inline void NVMeSubsystem::SharedCtor() {
nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_ns_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_ns_));
}

NVMeSubsystem::~NVMeSubsystem() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystem)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nqn_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  firmware_revision_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fru_guid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeSubsystem::ArenaDtor(void* object) {
  NVMeSubsystem* _this = reinterpret_cast< NVMeSubsystem* >(object);
  (void)_this;
}
void NVMeSubsystem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystem::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nqn_.ClearToEmpty();
  serial_number_.ClearToEmpty();
  model_number_.ClearToEmpty();
  firmware_revision_.ClearToEmpty();
  fru_guid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  max_ns_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nqn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nqn();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystem.nqn"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystem.serial_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_model_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystem.model_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_ns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_ns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string firmware_revision = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_firmware_revision();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystem.firmware_revision"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes fru_guid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_fru_guid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string nqn = 2;
  if (!this->_internal_nqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nqn().data(), static_cast<int>(this->_internal_nqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystem.nqn");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nqn(), target);
  }

  // string serial_number = 3;
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystem.serial_number");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_serial_number(), target);
  }

  // string model_number = 4;
  if (!this->_internal_model_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_number().data(), static_cast<int>(this->_internal_model_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystem.model_number");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_model_number(), target);
  }

  // int64 max_ns = 5;
  if (this->_internal_max_ns() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_max_ns(), target);
  }

  // string firmware_revision = 6;
  if (!this->_internal_firmware_revision().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_revision().data(), static_cast<int>(this->_internal_firmware_revision().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystem.firmware_revision");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_firmware_revision(), target);
  }

  // bytes fru_guid = 7;
  if (!this->_internal_fru_guid().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_fru_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystem)
  return target;
}

size_t NVMeSubsystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nqn = 2;
  if (!this->_internal_nqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nqn());
  }

  // string serial_number = 3;
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // string model_number = 4;
  if (!this->_internal_model_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_number());
  }

  // string firmware_revision = 6;
  if (!this->_internal_firmware_revision().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_revision());
  }

  // bytes fru_guid = 7;
  if (!this->_internal_fru_guid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fru_guid());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // int64 max_ns = 5;
  if (this->_internal_max_ns() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_max_ns());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystem::GetClassData() const { return &_class_data_; }

void NVMeSubsystem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystem *>(to)->MergeFrom(
      static_cast<const NVMeSubsystem &>(from));
}


void NVMeSubsystem::MergeFrom(const NVMeSubsystem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nqn().empty()) {
    _internal_set_nqn(from._internal_nqn());
  }
  if (!from._internal_serial_number().empty()) {
    _internal_set_serial_number(from._internal_serial_number());
  }
  if (!from._internal_model_number().empty()) {
    _internal_set_model_number(from._internal_model_number());
  }
  if (!from._internal_firmware_revision().empty()) {
    _internal_set_firmware_revision(from._internal_firmware_revision());
  }
  if (!from._internal_fru_guid().empty()) {
    _internal_set_fru_guid(from._internal_fru_guid());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_max_ns() != 0) {
    _internal_set_max_ns(from._internal_max_ns());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystem::CopyFrom(const NVMeSubsystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystem::IsInitialized() const {
  return true;
}

void NVMeSubsystem::InternalSwap(NVMeSubsystem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nqn_, lhs_arena,
      &other->nqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_number_, lhs_arena,
      &other->serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_number_, lhs_arena,
      &other->model_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &firmware_revision_, lhs_arena,
      &other->firmware_revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &fru_guid_, lhs_arena,
      &other->fru_guid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeSubsystem, max_ns_)
      + sizeof(NVMeSubsystem::max_ns_)
      - PROTOBUF_FIELD_OFFSET(NVMeSubsystem, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystem::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[0]);
}

// ===================================================================

class NVMeController::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeController* msg);
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeController* msg);
  static const ::opi_api::storage::v1::NvmeControllerPciId& pcie_id(const NVMeController* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeController::_Internal::id(const NVMeController* msg) {
  return *msg->id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeController::_Internal::subsystem_id(const NVMeController* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::storage::v1::NvmeControllerPciId&
NVMeController::_Internal::pcie_id(const NVMeController* msg) {
  return *msg->pcie_id_;
}
void NVMeController::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void NVMeController::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeController::clear_pcie_id() {
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
}
NVMeController::NVMeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeController)
}
NVMeController::NVMeController(const NVMeController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_pcie_id()) {
    pcie_id_ = new ::opi_api::storage::v1::NvmeControllerPciId(*from.pcie_id_);
  } else {
    pcie_id_ = nullptr;
  }
  ::memcpy(&nvme_controller_id_, &from.nvme_controller_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_ns_) -
    reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_ns_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeController)
}

inline void NVMeController::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_ns_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_ns_));
}

NVMeController::~NVMeController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeController)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete pcie_id_;
}

void NVMeController::ArenaDtor(void* object) {
  NVMeController* _this = reinterpret_cast< NVMeController* >(object);
  (void)_this;
}
void NVMeController::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeController::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
  ::memset(&nvme_controller_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_ns_) -
      reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_ns_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeController::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nvme_controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          nvme_controller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey subsystem_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeControllerPciId pcie_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pcie_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_nsq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_nsq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_ncq = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          max_ncq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sqes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          sqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 cqes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          cqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_ns = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          max_ns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // uint32 nvme_controller_id = 2;
  if (this->_internal_nvme_controller_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nvme_controller_id(), target);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.storage.v1.NvmeControllerPciId pcie_id = 4;
  if (this->_internal_has_pcie_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::pcie_id(this), target, stream);
  }

  // uint32 max_nsq = 5;
  if (this->_internal_max_nsq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_max_nsq(), target);
  }

  // uint32 max_ncq = 6;
  if (this->_internal_max_ncq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_max_ncq(), target);
  }

  // uint32 sqes = 7;
  if (this->_internal_sqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_sqes(), target);
  }

  // uint32 cqes = 8;
  if (this->_internal_cqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_cqes(), target);
  }

  // uint32 max_ns = 9;
  if (this->_internal_max_ns() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_max_ns(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeController)
  return target;
}

size_t NVMeController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.storage.v1.NvmeControllerPciId pcie_id = 4;
  if (this->_internal_has_pcie_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pcie_id_);
  }

  // uint32 nvme_controller_id = 2;
  if (this->_internal_nvme_controller_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_nvme_controller_id());
  }

  // uint32 max_nsq = 5;
  if (this->_internal_max_nsq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_max_nsq());
  }

  // uint32 max_ncq = 6;
  if (this->_internal_max_ncq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_max_ncq());
  }

  // uint32 sqes = 7;
  if (this->_internal_sqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_sqes());
  }

  // uint32 cqes = 8;
  if (this->_internal_cqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_cqes());
  }

  // uint32 max_ns = 9;
  if (this->_internal_max_ns() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_max_ns());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeController::GetClassData() const { return &_class_data_; }

void NVMeController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeController *>(to)->MergeFrom(
      static_cast<const NVMeController &>(from));
}


void NVMeController::MergeFrom(const NVMeController& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeController)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_pcie_id()) {
    _internal_mutable_pcie_id()->::opi_api::storage::v1::NvmeControllerPciId::MergeFrom(from._internal_pcie_id());
  }
  if (from._internal_nvme_controller_id() != 0) {
    _internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_max_nsq() != 0) {
    _internal_set_max_nsq(from._internal_max_nsq());
  }
  if (from._internal_max_ncq() != 0) {
    _internal_set_max_ncq(from._internal_max_ncq());
  }
  if (from._internal_sqes() != 0) {
    _internal_set_sqes(from._internal_sqes());
  }
  if (from._internal_cqes() != 0) {
    _internal_set_cqes(from._internal_cqes());
  }
  if (from._internal_max_ns() != 0) {
    _internal_set_max_ns(from._internal_max_ns());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeController::CopyFrom(const NVMeController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeController::IsInitialized() const {
  return true;
}

void NVMeController::InternalSwap(NVMeController* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeController, max_ns_)
      + sizeof(NVMeController::max_ns_)
      - PROTOBUF_FIELD_OFFSET(NVMeController, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeController::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[1]);
}

// ===================================================================

class NVMeNamespace::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeNamespace* msg);
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeNamespace* msg);
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeNamespace* msg);
  static const ::opi_api::common::v1::Uuid& uuid(const NVMeNamespace* msg);
  static const ::opi_api::common::v1::ObjectKey& volume_id(const NVMeNamespace* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespace::_Internal::id(const NVMeNamespace* msg) {
  return *msg->id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespace::_Internal::subsystem_id(const NVMeNamespace* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespace::_Internal::controller_id(const NVMeNamespace* msg) {
  return *msg->controller_id_;
}
const ::opi_api::common::v1::Uuid&
NVMeNamespace::_Internal::uuid(const NVMeNamespace* msg) {
  return *msg->uuid_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespace::_Internal::volume_id(const NVMeNamespace* msg) {
  return *msg->volume_id_;
}
void NVMeNamespace::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void NVMeNamespace::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeNamespace::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
void NVMeNamespace::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
}
void NVMeNamespace::clear_volume_id() {
  if (GetArenaForAllocation() == nullptr && volume_id_ != nullptr) {
    delete volume_id_;
  }
  volume_id_ = nullptr;
}
NVMeNamespace::NVMeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespace)
}
NVMeNamespace::NVMeNamespace(const NVMeNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nguid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  if (from._internal_has_uuid()) {
    uuid_ = new ::opi_api::common::v1::Uuid(*from.uuid_);
  } else {
    uuid_ = nullptr;
  }
  if (from._internal_has_volume_id()) {
    volume_id_ = new ::opi_api::common::v1::ObjectKey(*from.volume_id_);
  } else {
    volume_id_ = nullptr;
  }
  ::memcpy(&block_size_, &from.block_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&pref_write_granularity_) -
    reinterpret_cast<char*>(&block_size_)) + sizeof(pref_write_granularity_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespace)
}

inline void NVMeNamespace::SharedCtor() {
nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pref_write_granularity_) -
    reinterpret_cast<char*>(&id_)) + sizeof(pref_write_granularity_));
}

NVMeNamespace::~NVMeNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespace)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nguid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete controller_id_;
  if (this != internal_default_instance()) delete uuid_;
  if (this != internal_default_instance()) delete volume_id_;
}

void NVMeNamespace::ArenaDtor(void* object) {
  NVMeNamespace* _this = reinterpret_cast< NVMeNamespace* >(object);
  (void)_this;
}
void NVMeNamespace::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nguid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
  if (GetArenaForAllocation() == nullptr && volume_id_ != nullptr) {
    delete volume_id_;
  }
  volume_id_ = nullptr;
  ::memset(&block_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pref_write_granularity_) -
      reinterpret_cast<char*>(&block_size_)) + sizeof(pref_write_granularity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey subsystem_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey controller_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 host_nsid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          host_nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 block_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          num_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_nguid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeNamespace.nguid"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed64 eui64 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey volume_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 optimal_write_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          optimal_write_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 pref_write_granularity = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          pref_write_granularity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::controller_id(this), target, stream);
  }

  // uint32 host_nsid = 4;
  if (this->_internal_host_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_host_nsid(), target);
  }

  // int64 block_size = 5;
  if (this->_internal_block_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_block_size(), target);
  }

  // int64 num_blocks = 6;
  if (this->_internal_num_blocks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_num_blocks(), target);
  }

  // string nguid = 7;
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeNamespace.nguid");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_nguid(), target);
  }

  // fixed64 eui64 = 8;
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(8, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 9;
  if (this->_internal_has_uuid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::uuid(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  if (this->_internal_has_volume_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::volume_id(this), target, stream);
  }

  // uint32 optimal_write_size = 11;
  if (this->_internal_optimal_write_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_optimal_write_size(), target);
  }

  // uint32 pref_write_granularity = 12;
  if (this->_internal_pref_write_granularity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_pref_write_granularity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespace)
  return target;
}

size_t NVMeNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nguid = 7;
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  // .opi_api.common.v1.Uuid uuid = 9;
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *uuid_);
  }

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  if (this->_internal_has_volume_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *volume_id_);
  }

  // int64 block_size = 5;
  if (this->_internal_block_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_block_size());
  }

  // int64 num_blocks = 6;
  if (this->_internal_num_blocks() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_num_blocks());
  }

  // uint32 host_nsid = 4;
  if (this->_internal_host_nsid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_host_nsid());
  }

  // uint32 optimal_write_size = 11;
  if (this->_internal_optimal_write_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_optimal_write_size());
  }

  // fixed64 eui64 = 8;
  if (this->_internal_eui64() != 0) {
    total_size += 1 + 8;
  }

  // uint32 pref_write_granularity = 12;
  if (this->_internal_pref_write_granularity() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_pref_write_granularity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespace::GetClassData() const { return &_class_data_; }

void NVMeNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespace *>(to)->MergeFrom(
      static_cast<const NVMeNamespace &>(from));
}


void NVMeNamespace::MergeFrom(const NVMeNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nguid().empty()) {
    _internal_set_nguid(from._internal_nguid());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  if (from._internal_has_uuid()) {
    _internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(from._internal_uuid());
  }
  if (from._internal_has_volume_id()) {
    _internal_mutable_volume_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_volume_id());
  }
  if (from._internal_block_size() != 0) {
    _internal_set_block_size(from._internal_block_size());
  }
  if (from._internal_num_blocks() != 0) {
    _internal_set_num_blocks(from._internal_num_blocks());
  }
  if (from._internal_host_nsid() != 0) {
    _internal_set_host_nsid(from._internal_host_nsid());
  }
  if (from._internal_optimal_write_size() != 0) {
    _internal_set_optimal_write_size(from._internal_optimal_write_size());
  }
  if (from._internal_eui64() != 0) {
    _internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_pref_write_granularity() != 0) {
    _internal_set_pref_write_granularity(from._internal_pref_write_granularity());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespace::CopyFrom(const NVMeNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespace::IsInitialized() const {
  return true;
}

void NVMeNamespace::InternalSwap(NVMeNamespace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nguid_, lhs_arena,
      &other->nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespace, pref_write_granularity_)
      + sizeof(NVMeNamespace::pref_write_granularity_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespace, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespace::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[2]);
}

// ===================================================================

class NVMeSubsystemCreateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystem& subsystem(const NVMeSubsystemCreateRequest* msg);
};

const ::opi_api::storage::v1::NVMeSubsystem&
NVMeSubsystemCreateRequest::_Internal::subsystem(const NVMeSubsystemCreateRequest* msg) {
  return *msg->subsystem_;
}
NVMeSubsystemCreateRequest::NVMeSubsystemCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemCreateRequest)
}
NVMeSubsystemCreateRequest::NVMeSubsystemCreateRequest(const NVMeSubsystemCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem()) {
    subsystem_ = new ::opi_api::storage::v1::NVMeSubsystem(*from.subsystem_);
  } else {
    subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemCreateRequest)
}

inline void NVMeSubsystemCreateRequest::SharedCtor() {
subsystem_ = nullptr;
}

NVMeSubsystemCreateRequest::~NVMeSubsystemCreateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_;
}

void NVMeSubsystemCreateRequest::ArenaDtor(void* object) {
  NVMeSubsystemCreateRequest* _this = reinterpret_cast< NVMeSubsystemCreateRequest* >(object);
  (void)_this;
}
void NVMeSubsystemCreateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemCreateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemCreateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  return target;
}

size_t NVMeSubsystemCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemCreateRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemCreateRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemCreateRequest &>(from));
}


void NVMeSubsystemCreateRequest::MergeFrom(const NVMeSubsystemCreateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem()) {
    _internal_mutable_subsystem()->::opi_api::storage::v1::NVMeSubsystem::MergeFrom(from._internal_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemCreateRequest::CopyFrom(const NVMeSubsystemCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemCreateRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemCreateRequest::InternalSwap(NVMeSubsystemCreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_, other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemCreateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[3]);
}

// ===================================================================

class NVMeSubsystemDeleteRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemDeleteRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemDeleteRequest::_Internal::subsystem_id(const NVMeSubsystemDeleteRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemDeleteRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemDeleteRequest::NVMeSubsystemDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
}
NVMeSubsystemDeleteRequest::NVMeSubsystemDeleteRequest(const NVMeSubsystemDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
}

inline void NVMeSubsystemDeleteRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemDeleteRequest::~NVMeSubsystemDeleteRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemDeleteRequest::ArenaDtor(void* object) {
  NVMeSubsystemDeleteRequest* _this = reinterpret_cast< NVMeSubsystemDeleteRequest* >(object);
  (void)_this;
}
void NVMeSubsystemDeleteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemDeleteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  return target;
}

size_t NVMeSubsystemDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemDeleteRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemDeleteRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemDeleteRequest &>(from));
}


void NVMeSubsystemDeleteRequest::MergeFrom(const NVMeSubsystemDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemDeleteRequest::CopyFrom(const NVMeSubsystemDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemDeleteRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemDeleteRequest::InternalSwap(NVMeSubsystemDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemDeleteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[4]);
}

// ===================================================================

class NVMeSubsystemUpdateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystem& subsystem(const NVMeSubsystemUpdateRequest* msg);
};

const ::opi_api::storage::v1::NVMeSubsystem&
NVMeSubsystemUpdateRequest::_Internal::subsystem(const NVMeSubsystemUpdateRequest* msg) {
  return *msg->subsystem_;
}
NVMeSubsystemUpdateRequest::NVMeSubsystemUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
}
NVMeSubsystemUpdateRequest::NVMeSubsystemUpdateRequest(const NVMeSubsystemUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem()) {
    subsystem_ = new ::opi_api::storage::v1::NVMeSubsystem(*from.subsystem_);
  } else {
    subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
}

inline void NVMeSubsystemUpdateRequest::SharedCtor() {
subsystem_ = nullptr;
}

NVMeSubsystemUpdateRequest::~NVMeSubsystemUpdateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_;
}

void NVMeSubsystemUpdateRequest::ArenaDtor(void* object) {
  NVMeSubsystemUpdateRequest* _this = reinterpret_cast< NVMeSubsystemUpdateRequest* >(object);
  (void)_this;
}
void NVMeSubsystemUpdateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  return target;
}

size_t NVMeSubsystemUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemUpdateRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemUpdateRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemUpdateRequest &>(from));
}


void NVMeSubsystemUpdateRequest::MergeFrom(const NVMeSubsystemUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem()) {
    _internal_mutable_subsystem()->::opi_api::storage::v1::NVMeSubsystem::MergeFrom(from._internal_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemUpdateRequest::CopyFrom(const NVMeSubsystemUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemUpdateRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemUpdateRequest::InternalSwap(NVMeSubsystemUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_, other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemUpdateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[5]);
}

// ===================================================================

class NVMeSubsystemListRequest::_Internal {
 public:
};

NVMeSubsystemListRequest::NVMeSubsystemListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemListRequest)
}
NVMeSubsystemListRequest::NVMeSubsystemListRequest(const NVMeSubsystemListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemListRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemListRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemListRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[6]);
}

// ===================================================================

class NVMeSubsystemListResponse::_Internal {
 public:
};

NVMeSubsystemListResponse::NVMeSubsystemListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  subsystem_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemListResponse)
}
NVMeSubsystemListResponse::NVMeSubsystemListResponse(const NVMeSubsystemListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      subsystem_(from.subsystem_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemListResponse)
}

inline void NVMeSubsystemListResponse::SharedCtor() {
}

NVMeSubsystemListResponse::~NVMeSubsystemListResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemListResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeSubsystemListResponse::ArenaDtor(void* object) {
  NVMeSubsystemListResponse* _this = reinterpret_cast< NVMeSubsystemListResponse* >(object);
  (void)_this;
}
void NVMeSubsystemListResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemListResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subsystem_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemListResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subsystem(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_subsystem_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_subsystem(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemListResponse)
  return target;
}

size_t NVMeSubsystemListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  total_size += 1UL * this->_internal_subsystem_size();
  for (const auto& msg : this->subsystem_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemListResponse::GetClassData() const { return &_class_data_; }

void NVMeSubsystemListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemListResponse *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemListResponse &>(from));
}


void NVMeSubsystemListResponse::MergeFrom(const NVMeSubsystemListResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  subsystem_.MergeFrom(from.subsystem_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemListResponse::CopyFrom(const NVMeSubsystemListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemListResponse::IsInitialized() const {
  return true;
}

void NVMeSubsystemListResponse::InternalSwap(NVMeSubsystemListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  subsystem_.InternalSwap(&other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemListResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[7]);
}

// ===================================================================

class NVMeSubsystemGetRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemGetRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemGetRequest::_Internal::subsystem_id(const NVMeSubsystemGetRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemGetRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemGetRequest::NVMeSubsystemGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemGetRequest)
}
NVMeSubsystemGetRequest::NVMeSubsystemGetRequest(const NVMeSubsystemGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemGetRequest)
}

inline void NVMeSubsystemGetRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemGetRequest::~NVMeSubsystemGetRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemGetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemGetRequest::ArenaDtor(void* object) {
  NVMeSubsystemGetRequest* _this = reinterpret_cast< NVMeSubsystemGetRequest* >(object);
  (void)_this;
}
void NVMeSubsystemGetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemGetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemGetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemGetRequest)
  return target;
}

size_t NVMeSubsystemGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemGetRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemGetRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemGetRequest &>(from));
}


void NVMeSubsystemGetRequest::MergeFrom(const NVMeSubsystemGetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemGetRequest::CopyFrom(const NVMeSubsystemGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemGetRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemGetRequest::InternalSwap(NVMeSubsystemGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemGetRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[8]);
}

// ===================================================================

class NVMeSubsystemStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemStatsRequest::_Internal::subsystem_id(const NVMeSubsystemStatsRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemStatsRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
}
NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(const NVMeSubsystemStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
}

inline void NVMeSubsystemStatsRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemStatsRequest::~NVMeSubsystemStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemStatsRequest::ArenaDtor(void* object) {
  NVMeSubsystemStatsRequest* _this = reinterpret_cast< NVMeSubsystemStatsRequest* >(object);
  (void)_this;
}
void NVMeSubsystemStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  return target;
}

size_t NVMeSubsystemStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatsRequest &>(from));
}


void NVMeSubsystemStatsRequest::MergeFrom(const NVMeSubsystemStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatsRequest::CopyFrom(const NVMeSubsystemStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatsRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatsRequest::InternalSwap(NVMeSubsystemStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[9]);
}

// ===================================================================

class NVMeSubsystemStatsResponse::_Internal {
 public:
};

NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
}
NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(const NVMeSubsystemStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
}

inline void NVMeSubsystemStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NVMeSubsystemStatsResponse::~NVMeSubsystemStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NVMeSubsystemStatsResponse::ArenaDtor(void* object) {
  NVMeSubsystemStatsResponse* _this = reinterpret_cast< NVMeSubsystemStatsResponse* >(object);
  (void)_this;
}
void NVMeSubsystemStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string stats = 1;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  return target;
}

size_t NVMeSubsystemStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 1;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatsResponse &>(from));
}


void NVMeSubsystemStatsResponse::MergeFrom(const NVMeSubsystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatsResponse::CopyFrom(const NVMeSubsystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatsResponse::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatsResponse::InternalSwap(NVMeSubsystemStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[10]);
}

// ===================================================================

class NVMeControllerCreateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeController& controller(const NVMeControllerCreateRequest* msg);
};

const ::opi_api::storage::v1::NVMeController&
NVMeControllerCreateRequest::_Internal::controller(const NVMeControllerCreateRequest* msg) {
  return *msg->controller_;
}
NVMeControllerCreateRequest::NVMeControllerCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerCreateRequest)
}
NVMeControllerCreateRequest::NVMeControllerCreateRequest(const NVMeControllerCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::opi_api::storage::v1::NVMeController(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerCreateRequest)
}

inline void NVMeControllerCreateRequest::SharedCtor() {
controller_ = nullptr;
}

NVMeControllerCreateRequest::~NVMeControllerCreateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerCreateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_;
}

void NVMeControllerCreateRequest::ArenaDtor(void* object) {
  NVMeControllerCreateRequest* _this = reinterpret_cast< NVMeControllerCreateRequest* >(object);
  (void)_this;
}
void NVMeControllerCreateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerCreateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerCreateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerCreateRequest)
  return target;
}

size_t NVMeControllerCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerCreateRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerCreateRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerCreateRequest &>(from));
}


void NVMeControllerCreateRequest::MergeFrom(const NVMeControllerCreateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller()) {
    _internal_mutable_controller()->::opi_api::storage::v1::NVMeController::MergeFrom(from._internal_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerCreateRequest::CopyFrom(const NVMeControllerCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerCreateRequest::IsInitialized() const {
  return true;
}

void NVMeControllerCreateRequest::InternalSwap(NVMeControllerCreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_, other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerCreateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[11]);
}

// ===================================================================

class NVMeControllerDeleteRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeControllerDeleteRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerDeleteRequest::_Internal::controller_id(const NVMeControllerDeleteRequest* msg) {
  return *msg->controller_id_;
}
void NVMeControllerDeleteRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
NVMeControllerDeleteRequest::NVMeControllerDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerDeleteRequest)
}
NVMeControllerDeleteRequest::NVMeControllerDeleteRequest(const NVMeControllerDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerDeleteRequest)
}

inline void NVMeControllerDeleteRequest::SharedCtor() {
controller_id_ = nullptr;
}

NVMeControllerDeleteRequest::~NVMeControllerDeleteRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerDeleteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_id_;
}

void NVMeControllerDeleteRequest::ArenaDtor(void* object) {
  NVMeControllerDeleteRequest* _this = reinterpret_cast< NVMeControllerDeleteRequest* >(object);
  (void)_this;
}
void NVMeControllerDeleteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerDeleteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerDeleteRequest)
  return target;
}

size_t NVMeControllerDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerDeleteRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerDeleteRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerDeleteRequest &>(from));
}


void NVMeControllerDeleteRequest::MergeFrom(const NVMeControllerDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerDeleteRequest::CopyFrom(const NVMeControllerDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerDeleteRequest::IsInitialized() const {
  return true;
}

void NVMeControllerDeleteRequest::InternalSwap(NVMeControllerDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_id_, other->controller_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerDeleteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[12]);
}

// ===================================================================

class NVMeControllerUpdateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeController& controller(const NVMeControllerUpdateRequest* msg);
};

const ::opi_api::storage::v1::NVMeController&
NVMeControllerUpdateRequest::_Internal::controller(const NVMeControllerUpdateRequest* msg) {
  return *msg->controller_;
}
NVMeControllerUpdateRequest::NVMeControllerUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerUpdateRequest)
}
NVMeControllerUpdateRequest::NVMeControllerUpdateRequest(const NVMeControllerUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::opi_api::storage::v1::NVMeController(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerUpdateRequest)
}

inline void NVMeControllerUpdateRequest::SharedCtor() {
controller_ = nullptr;
}

NVMeControllerUpdateRequest::~NVMeControllerUpdateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerUpdateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_;
}

void NVMeControllerUpdateRequest::ArenaDtor(void* object) {
  NVMeControllerUpdateRequest* _this = reinterpret_cast< NVMeControllerUpdateRequest* >(object);
  (void)_this;
}
void NVMeControllerUpdateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerUpdateRequest)
  return target;
}

size_t NVMeControllerUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerUpdateRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerUpdateRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerUpdateRequest &>(from));
}


void NVMeControllerUpdateRequest::MergeFrom(const NVMeControllerUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller()) {
    _internal_mutable_controller()->::opi_api::storage::v1::NVMeController::MergeFrom(from._internal_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerUpdateRequest::CopyFrom(const NVMeControllerUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerUpdateRequest::IsInitialized() const {
  return true;
}

void NVMeControllerUpdateRequest::InternalSwap(NVMeControllerUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_, other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerUpdateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[13]);
}

// ===================================================================

class NVMeControllerListRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeControllerListRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerListRequest::_Internal::subsystem_id(const NVMeControllerListRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeControllerListRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeControllerListRequest::NVMeControllerListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerListRequest)
}
NVMeControllerListRequest::NVMeControllerListRequest(const NVMeControllerListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerListRequest)
}

inline void NVMeControllerListRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeControllerListRequest::~NVMeControllerListRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerListRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeControllerListRequest::ArenaDtor(void* object) {
  NVMeControllerListRequest* _this = reinterpret_cast< NVMeControllerListRequest* >(object);
  (void)_this;
}
void NVMeControllerListRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerListRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerListRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerListRequest)
  return target;
}

size_t NVMeControllerListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerListRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerListRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerListRequest &>(from));
}


void NVMeControllerListRequest::MergeFrom(const NVMeControllerListRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerListRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerListRequest::CopyFrom(const NVMeControllerListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerListRequest::IsInitialized() const {
  return true;
}

void NVMeControllerListRequest::InternalSwap(NVMeControllerListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerListRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[14]);
}

// ===================================================================

class NVMeControllerListResponse::_Internal {
 public:
};

NVMeControllerListResponse::NVMeControllerListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  controller_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerListResponse)
}
NVMeControllerListResponse::NVMeControllerListResponse(const NVMeControllerListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      controller_(from.controller_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerListResponse)
}

inline void NVMeControllerListResponse::SharedCtor() {
}

NVMeControllerListResponse::~NVMeControllerListResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerListResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeControllerListResponse::ArenaDtor(void* object) {
  NVMeControllerListResponse* _this = reinterpret_cast< NVMeControllerListResponse* >(object);
  (void)_this;
}
void NVMeControllerListResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerListResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  controller_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerListResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_controller(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_controller_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_controller(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerListResponse)
  return target;
}

size_t NVMeControllerListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  total_size += 1UL * this->_internal_controller_size();
  for (const auto& msg : this->controller_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerListResponse::GetClassData() const { return &_class_data_; }

void NVMeControllerListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerListResponse *>(to)->MergeFrom(
      static_cast<const NVMeControllerListResponse &>(from));
}


void NVMeControllerListResponse::MergeFrom(const NVMeControllerListResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerListResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  controller_.MergeFrom(from.controller_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerListResponse::CopyFrom(const NVMeControllerListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerListResponse::IsInitialized() const {
  return true;
}

void NVMeControllerListResponse::InternalSwap(NVMeControllerListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  controller_.InternalSwap(&other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerListResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[15]);
}

// ===================================================================

class NVMeControllerGetRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeControllerGetRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerGetRequest::_Internal::controller_id(const NVMeControllerGetRequest* msg) {
  return *msg->controller_id_;
}
void NVMeControllerGetRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
NVMeControllerGetRequest::NVMeControllerGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerGetRequest)
}
NVMeControllerGetRequest::NVMeControllerGetRequest(const NVMeControllerGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerGetRequest)
}

inline void NVMeControllerGetRequest::SharedCtor() {
controller_id_ = nullptr;
}

NVMeControllerGetRequest::~NVMeControllerGetRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerGetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_id_;
}

void NVMeControllerGetRequest::ArenaDtor(void* object) {
  NVMeControllerGetRequest* _this = reinterpret_cast< NVMeControllerGetRequest* >(object);
  (void)_this;
}
void NVMeControllerGetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerGetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerGetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerGetRequest)
  return target;
}

size_t NVMeControllerGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerGetRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerGetRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerGetRequest &>(from));
}


void NVMeControllerGetRequest::MergeFrom(const NVMeControllerGetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerGetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerGetRequest::CopyFrom(const NVMeControllerGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerGetRequest::IsInitialized() const {
  return true;
}

void NVMeControllerGetRequest::InternalSwap(NVMeControllerGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_id_, other->controller_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerGetRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[16]);
}

// ===================================================================

class NVMeControllerStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerStatsRequest::_Internal::id(const NVMeControllerStatsRequest* msg) {
  return *msg->id_;
}
void NVMeControllerStatsRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeControllerStatsRequest::NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatsRequest)
}
NVMeControllerStatsRequest::NVMeControllerStatsRequest(const NVMeControllerStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatsRequest)
}

inline void NVMeControllerStatsRequest::SharedCtor() {
id_ = nullptr;
}

NVMeControllerStatsRequest::~NVMeControllerStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
}

void NVMeControllerStatsRequest::ArenaDtor(void* object) {
  NVMeControllerStatsRequest* _this = reinterpret_cast< NVMeControllerStatsRequest* >(object);
  (void)_this;
}
void NVMeControllerStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatsRequest)
  return target;
}

size_t NVMeControllerStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatsRequest &>(from));
}


void NVMeControllerStatsRequest::MergeFrom(const NVMeControllerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatsRequest::CopyFrom(const NVMeControllerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatsRequest::IsInitialized() const {
  return true;
}

void NVMeControllerStatsRequest::InternalSwap(NVMeControllerStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[17]);
}

// ===================================================================

class NVMeControllerStatsResponse::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerStatsResponse* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerStatsResponse::_Internal::id(const NVMeControllerStatsResponse* msg) {
  return *msg->id_;
}
void NVMeControllerStatsResponse::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeControllerStatsResponse::NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatsResponse)
}
NVMeControllerStatsResponse::NVMeControllerStatsResponse(const NVMeControllerStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatsResponse)
}

inline void NVMeControllerStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = nullptr;
}

NVMeControllerStatsResponse::~NVMeControllerStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeControllerStatsResponse::ArenaDtor(void* object) {
  NVMeControllerStatsResponse* _this = reinterpret_cast< NVMeControllerStatsResponse* >(object);
  (void)_this;
}
void NVMeControllerStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeControllerStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeControllerStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatsResponse)
  return target;
}

size_t NVMeControllerStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeControllerStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatsResponse &>(from));
}


void NVMeControllerStatsResponse::MergeFrom(const NVMeControllerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatsResponse::CopyFrom(const NVMeControllerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatsResponse::IsInitialized() const {
  return true;
}

void NVMeControllerStatsResponse::InternalSwap(NVMeControllerStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[18]);
}

// ===================================================================

class NVMeNamespaceCreateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespace& namespace_(const NVMeNamespaceCreateRequest* msg);
};

const ::opi_api::storage::v1::NVMeNamespace&
NVMeNamespaceCreateRequest::_Internal::namespace_(const NVMeNamespaceCreateRequest* msg) {
  return *msg->namespace__;
}
NVMeNamespaceCreateRequest::NVMeNamespaceCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceCreateRequest)
}
NVMeNamespaceCreateRequest::NVMeNamespaceCreateRequest(const NVMeNamespaceCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_()) {
    namespace__ = new ::opi_api::storage::v1::NVMeNamespace(*from.namespace__);
  } else {
    namespace__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceCreateRequest)
}

inline void NVMeNamespaceCreateRequest::SharedCtor() {
namespace__ = nullptr;
}

NVMeNamespaceCreateRequest::~NVMeNamespaceCreateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace__;
}

void NVMeNamespaceCreateRequest::ArenaDtor(void* object) {
  NVMeNamespaceCreateRequest* _this = reinterpret_cast< NVMeNamespaceCreateRequest* >(object);
  (void)_this;
}
void NVMeNamespaceCreateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceCreateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceCreateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  return target;
}

size_t NVMeNamespaceCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceCreateRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceCreateRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceCreateRequest &>(from));
}


void NVMeNamespaceCreateRequest::MergeFrom(const NVMeNamespaceCreateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_()) {
    _internal_mutable_namespace_()->::opi_api::storage::v1::NVMeNamespace::MergeFrom(from._internal_namespace_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceCreateRequest::CopyFrom(const NVMeNamespaceCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceCreateRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceCreateRequest::InternalSwap(NVMeNamespaceCreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace__, other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceCreateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[19]);
}

// ===================================================================

class NVMeNamespaceDeleteRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceDeleteRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceDeleteRequest::_Internal::namespace_id(const NVMeNamespaceDeleteRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceDeleteRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceDeleteRequest::NVMeNamespaceDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
}
NVMeNamespaceDeleteRequest::NVMeNamespaceDeleteRequest(const NVMeNamespaceDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
}

inline void NVMeNamespaceDeleteRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceDeleteRequest::~NVMeNamespaceDeleteRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceDeleteRequest::ArenaDtor(void* object) {
  NVMeNamespaceDeleteRequest* _this = reinterpret_cast< NVMeNamespaceDeleteRequest* >(object);
  (void)_this;
}
void NVMeNamespaceDeleteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceDeleteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  return target;
}

size_t NVMeNamespaceDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceDeleteRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceDeleteRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceDeleteRequest &>(from));
}


void NVMeNamespaceDeleteRequest::MergeFrom(const NVMeNamespaceDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceDeleteRequest::CopyFrom(const NVMeNamespaceDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceDeleteRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceDeleteRequest::InternalSwap(NVMeNamespaceDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceDeleteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[20]);
}

// ===================================================================

class NVMeNamespaceUpdateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespace& namespace_(const NVMeNamespaceUpdateRequest* msg);
};

const ::opi_api::storage::v1::NVMeNamespace&
NVMeNamespaceUpdateRequest::_Internal::namespace_(const NVMeNamespaceUpdateRequest* msg) {
  return *msg->namespace__;
}
NVMeNamespaceUpdateRequest::NVMeNamespaceUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
}
NVMeNamespaceUpdateRequest::NVMeNamespaceUpdateRequest(const NVMeNamespaceUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_()) {
    namespace__ = new ::opi_api::storage::v1::NVMeNamespace(*from.namespace__);
  } else {
    namespace__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
}

inline void NVMeNamespaceUpdateRequest::SharedCtor() {
namespace__ = nullptr;
}

NVMeNamespaceUpdateRequest::~NVMeNamespaceUpdateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace__;
}

void NVMeNamespaceUpdateRequest::ArenaDtor(void* object) {
  NVMeNamespaceUpdateRequest* _this = reinterpret_cast< NVMeNamespaceUpdateRequest* >(object);
  (void)_this;
}
void NVMeNamespaceUpdateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  return target;
}

size_t NVMeNamespaceUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceUpdateRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceUpdateRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceUpdateRequest &>(from));
}


void NVMeNamespaceUpdateRequest::MergeFrom(const NVMeNamespaceUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_()) {
    _internal_mutable_namespace_()->::opi_api::storage::v1::NVMeNamespace::MergeFrom(from._internal_namespace_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceUpdateRequest::CopyFrom(const NVMeNamespaceUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceUpdateRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceUpdateRequest::InternalSwap(NVMeNamespaceUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace__, other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceUpdateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[21]);
}

// ===================================================================

class NVMeNamespaceListRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeNamespaceListRequest* msg);
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeNamespaceListRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceListRequest::_Internal::subsystem_id(const NVMeNamespaceListRequest* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceListRequest::_Internal::controller_id(const NVMeNamespaceListRequest* msg) {
  return *msg->controller_id_;
}
void NVMeNamespaceListRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeNamespaceListRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
NVMeNamespaceListRequest::NVMeNamespaceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceListRequest)
}
NVMeNamespaceListRequest::NVMeNamespaceListRequest(const NVMeNamespaceListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceListRequest)
}

inline void NVMeNamespaceListRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&subsystem_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&controller_id_) -
    reinterpret_cast<char*>(&subsystem_id_)) + sizeof(controller_id_));
}

NVMeNamespaceListRequest::~NVMeNamespaceListRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceListRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete controller_id_;
}

void NVMeNamespaceListRequest::ArenaDtor(void* object) {
  NVMeNamespaceListRequest* _this = reinterpret_cast< NVMeNamespaceListRequest* >(object);
  (void)_this;
}
void NVMeNamespaceListRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceListRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceListRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceListRequest)
  return target;
}

size_t NVMeNamespaceListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceListRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceListRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceListRequest &>(from));
}


void NVMeNamespaceListRequest::MergeFrom(const NVMeNamespaceListRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceListRequest::CopyFrom(const NVMeNamespaceListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceListRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceListRequest::InternalSwap(NVMeNamespaceListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespaceListRequest, controller_id_)
      + sizeof(NVMeNamespaceListRequest::controller_id_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespaceListRequest, subsystem_id_)>(
          reinterpret_cast<char*>(&subsystem_id_),
          reinterpret_cast<char*>(&other->subsystem_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceListRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[22]);
}

// ===================================================================

class NVMeNamespaceListResponse::_Internal {
 public:
};

NVMeNamespaceListResponse::NVMeNamespaceListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  namespace__(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceListResponse)
}
NVMeNamespaceListResponse::NVMeNamespaceListResponse(const NVMeNamespaceListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      namespace__(from.namespace__) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceListResponse)
}

inline void NVMeNamespaceListResponse::SharedCtor() {
}

NVMeNamespaceListResponse::~NVMeNamespaceListResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceListResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeNamespaceListResponse::ArenaDtor(void* object) {
  NVMeNamespaceListResponse* _this = reinterpret_cast< NVMeNamespaceListResponse* >(object);
  (void)_this;
}
void NVMeNamespaceListResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceListResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  namespace__.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceListResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_namespace_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_namespace__size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_namespace_(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceListResponse)
  return target;
}

size_t NVMeNamespaceListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  total_size += 1UL * this->_internal_namespace__size();
  for (const auto& msg : this->namespace__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceListResponse::GetClassData() const { return &_class_data_; }

void NVMeNamespaceListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceListResponse *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceListResponse &>(from));
}


void NVMeNamespaceListResponse::MergeFrom(const NVMeNamespaceListResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  namespace__.MergeFrom(from.namespace__);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceListResponse::CopyFrom(const NVMeNamespaceListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceListResponse::IsInitialized() const {
  return true;
}

void NVMeNamespaceListResponse::InternalSwap(NVMeNamespaceListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  namespace__.InternalSwap(&other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceListResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[23]);
}

// ===================================================================

class NVMeNamespaceGetRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceGetRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceGetRequest::_Internal::namespace_id(const NVMeNamespaceGetRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceGetRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceGetRequest::NVMeNamespaceGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceGetRequest)
}
NVMeNamespaceGetRequest::NVMeNamespaceGetRequest(const NVMeNamespaceGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceGetRequest)
}

inline void NVMeNamespaceGetRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceGetRequest::~NVMeNamespaceGetRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceGetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceGetRequest::ArenaDtor(void* object) {
  NVMeNamespaceGetRequest* _this = reinterpret_cast< NVMeNamespaceGetRequest* >(object);
  (void)_this;
}
void NVMeNamespaceGetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceGetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceGetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceGetRequest)
  return target;
}

size_t NVMeNamespaceGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceGetRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceGetRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceGetRequest &>(from));
}


void NVMeNamespaceGetRequest::MergeFrom(const NVMeNamespaceGetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceGetRequest::CopyFrom(const NVMeNamespaceGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceGetRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceGetRequest::InternalSwap(NVMeNamespaceGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceGetRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[24]);
}

// ===================================================================

class NVMeNamespaceStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceStatsRequest::_Internal::namespace_id(const NVMeNamespaceStatsRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceStatsRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
}
NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(const NVMeNamespaceStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
}

inline void NVMeNamespaceStatsRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceStatsRequest::~NVMeNamespaceStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceStatsRequest::ArenaDtor(void* object) {
  NVMeNamespaceStatsRequest* _this = reinterpret_cast< NVMeNamespaceStatsRequest* >(object);
  (void)_this;
}
void NVMeNamespaceStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  return target;
}

size_t NVMeNamespaceStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatsRequest &>(from));
}


void NVMeNamespaceStatsRequest::MergeFrom(const NVMeNamespaceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatsRequest::CopyFrom(const NVMeNamespaceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatsRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatsRequest::InternalSwap(NVMeNamespaceStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[25]);
}

// ===================================================================

class NVMeNamespaceStatsResponse::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeNamespaceStatsResponse* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceStatsResponse::_Internal::id(const NVMeNamespaceStatsResponse* msg) {
  return *msg->id_;
}
void NVMeNamespaceStatsResponse::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
}
NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(const NVMeNamespaceStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
}

inline void NVMeNamespaceStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = nullptr;
}

NVMeNamespaceStatsResponse::~NVMeNamespaceStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeNamespaceStatsResponse::ArenaDtor(void* object) {
  NVMeNamespaceStatsResponse* _this = reinterpret_cast< NVMeNamespaceStatsResponse* >(object);
  (void)_this;
}
void NVMeNamespaceStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeNamespaceStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeNamespaceStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  return target;
}

size_t NVMeNamespaceStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatsResponse &>(from));
}


void NVMeNamespaceStatsResponse::MergeFrom(const NVMeNamespaceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatsResponse::CopyFrom(const NVMeNamespaceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatsResponse::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatsResponse::InternalSwap(NVMeNamespaceStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[26]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystem* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystem >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeController* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespace* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemCreateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemDeleteRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemUpdateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemListRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemListResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemGetRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerCreateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerDeleteRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerUpdateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerListRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerListResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerGetRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceCreateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceDeleteRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceUpdateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceListRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceListResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceGetRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatsResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
