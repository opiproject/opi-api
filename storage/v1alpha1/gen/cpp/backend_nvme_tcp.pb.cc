// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backend_nvme_tcp.proto

#include "backend_nvme_tcp.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace opi_api {
namespace storage {
namespace v1 {
PROTOBUF_CONSTEXPR NvmeRemoteController::NvmeRemoteController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.psk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.io_queues_count_)*/int64_t{0}
  , /*decltype(_impl_.queue_size_)*/int64_t{0}
  , /*decltype(_impl_.multipath_)*/0
  , /*decltype(_impl_.hdgst_)*/false
  , /*decltype(_impl_.ddgst_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeRemoteControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeRemoteControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeRemoteControllerDefaultTypeInternal() {}
  union {
    NvmeRemoteController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeRemoteControllerDefaultTypeInternal _NvmeRemoteController_default_instance_;
PROTOBUF_CONSTEXPR NvmePath::NvmePath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controller_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.traddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.subnqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_traddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostnqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.trtype_)*/0
  , /*decltype(_impl_.adrfam_)*/0
  , /*decltype(_impl_.trsvcid_)*/int64_t{0}
  , /*decltype(_impl_.source_trsvcid_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmePathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmePathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmePathDefaultTypeInternal() {}
  union {
    NvmePath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmePathDefaultTypeInternal _NvmePath_default_instance_;
PROTOBUF_CONSTEXPR NvmeRemoteNamespace::NvmeRemoteNamespace(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controller_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nguid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.eui64_)*/int64_t{0}
  , /*decltype(_impl_.nsid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeRemoteNamespaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeRemoteNamespaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeRemoteNamespaceDefaultTypeInternal() {}
  union {
    NvmeRemoteNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeRemoteNamespaceDefaultTypeInternal _NvmeRemoteNamespace_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controller_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_remote_controller_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    CreateNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmeRemoteControllerRequestDefaultTypeInternal _CreateNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmeRemoteControllerRequestDefaultTypeInternal _DeleteNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controller_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmeRemoteControllerRequestDefaultTypeInternal _UpdateNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteControllersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteControllersRequestDefaultTypeInternal() {}
  union {
    ListNvmeRemoteControllersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteControllersRequestDefaultTypeInternal _ListNvmeRemoteControllersRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controllers_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteControllersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteControllersResponseDefaultTypeInternal() {}
  union {
    ListNvmeRemoteControllersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteControllersResponseDefaultTypeInternal _ListNvmeRemoteControllersResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    GetNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeRemoteControllerRequestDefaultTypeInternal _GetNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResetNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    ResetNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetNvmeRemoteControllerRequestDefaultTypeInternal _ResetNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    StatsNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeRemoteControllerRequestDefaultTypeInternal _StatsNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeRemoteControllerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeRemoteControllerResponseDefaultTypeInternal() {}
  union {
    StatsNvmeRemoteControllerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeRemoteControllerResponseDefaultTypeInternal _StatsNvmeRemoteControllerResponse_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteNamespacesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteNamespacesRequestDefaultTypeInternal() {}
  union {
    ListNvmeRemoteNamespacesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteNamespacesRequestDefaultTypeInternal _ListNvmeRemoteNamespacesRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_namespaces_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteNamespacesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteNamespacesResponseDefaultTypeInternal() {}
  union {
    ListNvmeRemoteNamespacesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteNamespacesResponseDefaultTypeInternal _ListNvmeRemoteNamespacesResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeRemoteNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeRemoteNamespaceRequestDefaultTypeInternal() {}
  union {
    GetNvmeRemoteNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeRemoteNamespaceRequestDefaultTypeInternal _GetNvmeRemoteNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmePathRequest::CreateNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_path_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_path_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmePathRequestDefaultTypeInternal() {}
  union {
    CreateNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmePathRequestDefaultTypeInternal _CreateNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmePathRequest::DeleteNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmePathRequestDefaultTypeInternal() {}
  union {
    DeleteNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmePathRequestDefaultTypeInternal _DeleteNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmePathRequest::UpdateNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_path_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmePathRequestDefaultTypeInternal() {}
  union {
    UpdateNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmePathRequestDefaultTypeInternal _UpdateNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmePathsRequest::ListNvmePathsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmePathsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmePathsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmePathsRequestDefaultTypeInternal() {}
  union {
    ListNvmePathsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmePathsRequestDefaultTypeInternal _ListNvmePathsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmePathsResponse::ListNvmePathsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_paths_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmePathsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmePathsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmePathsResponseDefaultTypeInternal() {}
  union {
    ListNvmePathsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmePathsResponseDefaultTypeInternal _ListNvmePathsResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmePathRequest::GetNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmePathRequestDefaultTypeInternal() {}
  union {
    GetNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmePathRequestDefaultTypeInternal _GetNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmePathRequest::StatsNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmePathRequestDefaultTypeInternal() {}
  union {
    StatsNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmePathRequestDefaultTypeInternal _StatsNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmePathResponse::StatsNvmePathResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmePathResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmePathResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmePathResponseDefaultTypeInternal() {}
  union {
    StatsNvmePathResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmePathResponseDefaultTypeInternal _StatsNvmePathResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::_pb::Metadata file_level_metadata_backend_5fnvme_5ftcp_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_backend_5fnvme_5ftcp_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_backend_5fnvme_5ftcp_2eproto = nullptr;

const uint32_t TableStruct_backend_5fnvme_5ftcp_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.multipath_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.io_queues_count_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.queue_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.hdgst_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.ddgst_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.psk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.controller_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.trtype_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.adrfam_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.traddr_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.trsvcid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.subnqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.source_traddr_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.source_trsvcid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.hostnqn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.controller_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.uuid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _impl_.nvme_remote_controllers_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse, _impl_.stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _impl_.nvme_remote_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.nvme_path_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.nvme_path_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.nvme_path_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _impl_.nvme_paths_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmePathRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathResponse, _impl_.stats_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NvmeRemoteController)},
  { 13, -1, -1, sizeof(::opi_api::storage::v1::NvmePath)},
  { 29, -1, -1, sizeof(::opi_api::storage::v1::NvmeRemoteNamespace)},
  { 41, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest)},
  { 49, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest)},
  { 57, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest)},
  { 66, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteControllersRequest)},
  { 75, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteControllersResponse)},
  { 83, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeRemoteControllerRequest)},
  { 90, -1, -1, sizeof(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest)},
  { 97, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest)},
  { 104, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse)},
  { 111, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest)},
  { 120, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse)},
  { 128, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest)},
  { 135, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmePathRequest)},
  { 143, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmePathRequest)},
  { 151, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmePathRequest)},
  { 160, -1, -1, sizeof(::opi_api::storage::v1::ListNvmePathsRequest)},
  { 169, -1, -1, sizeof(::opi_api::storage::v1::ListNvmePathsResponse)},
  { 177, -1, -1, sizeof(::opi_api::storage::v1::GetNvmePathRequest)},
  { 184, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmePathRequest)},
  { 191, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmePathResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::opi_api::storage::v1::_NvmeRemoteController_default_instance_._instance,
  &::opi_api::storage::v1::_NvmePath_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeRemoteNamespace_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteControllersRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteControllersResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ResetNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeRemoteControllerResponse_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteNamespacesRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteNamespacesResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeRemoteNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmePathsRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmePathsResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmePathResponse_default_instance_._instance,
};

const char descriptor_table_protodef_backend_5fnvme_5ftcp_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026backend_nvme_tcp.proto\022\022opi_api.storag"
  "e.v1\032\027google/api/client.proto\032\031google/ap"
  "i/resource.proto\032\033google/protobuf/empty."
  "proto\032\034google/api/annotations.proto\032\037goo"
  "gle/api/field_behavior.proto\032 google/pro"
  "tobuf/field_mask.proto\032\017opicommon.proto\032"
  "\nuuid.proto\"\365\002\n\024NvmeRemoteController\022@\n\004"
  "name\030\001 \001(\tB2\340A\003\340A\005\372A)\n\'opi_api.storage.v"
  "1/NvmeRemoteController\0229\n\tmultipath\030\002 \001("
  "\0162!.opi_api.storage.v1.NvmeMultipathB\003\340A"
  "\002\022\034\n\017io_queues_count\030\003 \001(\003B\003\340A\001\022\027\n\nqueue"
  "_size\030\004 \001(\003B\003\340A\001\022\022\n\005hdgst\030\005 \001(\010B\003\340A\001\022\022\n\005"
  "ddgst\030\006 \001(\010B\003\340A\001\022\020\n\003psk\030\007 \001(\014B\003\340A\001:o\352Al\n"
  "+storage.opiproject.org/NvmeRemoteContro"
  "ller\022\020volumes/{volume}*\025nvmeRemoteContro"
  "llers2\024nvmeRemoteController\"\342\003\n\010NvmePath"
  "\0224\n\004name\030\001 \001(\tB&\340A\003\340A\005\372A\035\n\033opi_api.stora"
  "ge.v1/NvmePath\022L\n\023controller_name_ref\030\002 "
  "\001(\tB/\340A\002\372A)\n\'opi_api.storage.v1/NvmeRemo"
  "teController\022:\n\006trtype\030\003 \001(\0162%.opi_api.s"
  "torage.v1.NvmeTransportTypeB\003\340A\002\022:\n\006adrf"
  "am\030\004 \001(\0162%.opi_api.storage.v1.NvmeAddres"
  "sFamilyB\003\340A\001\022\023\n\006traddr\030\005 \001(\tB\003\340A\002\022\024\n\007trs"
  "vcid\030\006 \001(\003B\003\340A\001\022\023\n\006subnqn\030\007 \001(\tB\003\340A\001\022\032\n\r"
  "source_traddr\030\010 \001(\tB\003\340A\001\022\033\n\016source_trsvc"
  "id\030\t \001(\003B\003\340A\001\022\024\n\007hostnqn\030\n \001(\tB\003\340A\001:K\352AH"
  "\n\037storage.opiproject.org/NvmePath\022\020volum"
  "es/{volume}*\tnvmePaths2\010nvmePath\"\371\002\n\023Nvm"
  "eRemoteNamespace\022\?\n\004name\030\001 \001(\tB1\340A\003\340A\005\372A"
  "(\n&opi_api.storage.v1/NvmeRemoteNamespac"
  "e\022L\n\023controller_name_ref\030\002 \001(\tB/\340A\003\372A)\n\'"
  "opi_api.storage.v1/NvmeRemoteController\022"
  "\021\n\004nsid\030\003 \001(\005B\003\340A\003\022\022\n\005nguid\030\004 \001(\tB\003\340A\003\022\022"
  "\n\005eui64\030\005 \001(\003B\003\340A\003\022*\n\004uuid\030\006 \001(\0132\027.opi_a"
  "pi.common.v1.UuidB\003\340A\003:l\352Ai\n*storage.opi"
  "project.org/NvmeRemoteNamespace\022\020volumes"
  "/{volume}*\024nvmeRemoteNamespaces2\023nvmeRem"
  "oteNamespace\"\232\001\n!CreateNvmeRemoteControl"
  "lerRequest\022M\n\026nvme_remote_controller\030\001 \001"
  "(\0132(.opi_api.storage.v1.NvmeRemoteContro"
  "llerB\003\340A\002\022&\n\031nvme_remote_controller_id\030\002"
  " \001(\tB\003\340A\001\"~\n!DeleteNvmeRemoteControllerR"
  "equest\022=\n\004name\030\001 \001(\tB/\340A\002\372A)\n\'opi_api.st"
  "orage.v1/NvmeRemoteController\022\032\n\rallow_m"
  "issing\030\002 \001(\010B\003\340A\001\"\304\001\n!UpdateNvmeRemoteCo"
  "ntrollerRequest\022M\n\026nvme_remote_controlle"
  "r\030\001 \001(\0132(.opi_api.storage.v1.NvmeRemoteC"
  "ontrollerB\003\340A\002\0224\n\013update_mask\030\002 \001(\0132\032.go"
  "ogle.protobuf.FieldMaskB\003\340A\001\022\032\n\rallow_mi"
  "ssing\030\003 \001(\010B\003\340A\001\"\224\001\n ListNvmeRemoteContr"
  "ollersRequest\022\?\n\006parent\030\001 \001(\tB/\340A\002\372A)\n\'o"
  "pi_api.storage.v1/NvmeRemoteController\022\026"
  "\n\tpage_size\030\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 \001"
  "(\tB\003\340A\001\"\207\001\n!ListNvmeRemoteControllersRes"
  "ponse\022I\n\027nvme_remote_controllers\030\001 \003(\0132("
  ".opi_api.storage.v1.NvmeRemoteController"
  "\022\027\n\017next_page_token\030\002 \001(\t\"_\n\036GetNvmeRemo"
  "teControllerRequest\022=\n\004name\030\001 \001(\tB/\340A\002\372A"
  ")\n\'opi_api.storage.v1/NvmeRemoteControll"
  "er\"a\n ResetNvmeRemoteControllerRequest\022="
  "\n\004name\030\001 \001(\tB/\340A\002\372A)\n\'opi_api.storage.v1"
  "/NvmeRemoteController\"a\n StatsNvmeRemote"
  "ControllerRequest\022=\n\004name\030\001 \001(\tB/\340A\002\372A)\n"
  "\'opi_api.storage.v1/NvmeRemoteController"
  "\"S\n!StatsNvmeRemoteControllerResponse\022.\n"
  "\005stats\030\001 \001(\0132\037.opi_api.storage.v1.Volume"
  "Stats\"\222\001\n\037ListNvmeRemoteNamespacesReques"
  "t\022>\n\006parent\030\001 \001(\tB.\340A\002\372A(\n&opi_api.stora"
  "ge.v1/NvmeRemoteNamespace\022\026\n\tpage_size\030\002"
  " \001(\005B\003\340A\001\022\027\n\npage_token\030\003 \001(\tB\003\340A\001\"\204\001\n L"
  "istNvmeRemoteNamespacesResponse\022G\n\026nvme_"
  "remote_namespaces\030\001 \003(\0132\'.opi_api.storag"
  "e.v1.NvmeRemoteNamespace\022\027\n\017next_page_to"
  "ken\030\002 \001(\t\"]\n\035GetNvmeRemoteNamespaceReque"
  "st\022<\n\004name\030\001 \001(\tB.\340A\002\372A(\n&opi_api.storag"
  "e.v1/NvmeRemoteNamespace\"h\n\025CreateNvmePa"
  "thRequest\0224\n\tnvme_path\030\001 \001(\0132\034.opi_api.s"
  "torage.v1.NvmePathB\003\340A\002\022\031\n\014nvme_path_id\030"
  "\002 \001(\tB\003\340A\001\"f\n\025DeleteNvmePathRequest\0221\n\004n"
  "ame\030\001 \001(\tB#\340A\002\372A\035\n\033opi_api.storage.v1/Nv"
  "mePath\022\032\n\rallow_missing\030\002 \001(\010B\003\340A\001\"\237\001\n\025U"
  "pdateNvmePathRequest\0224\n\tnvme_path\030\001 \001(\0132"
  "\034.opi_api.storage.v1.NvmePathB\003\340A\002\0224\n\013up"
  "date_mask\030\002 \001(\0132\032.google.protobuf.FieldM"
  "askB\003\340A\001\022\032\n\rallow_missing\030\003 \001(\010B\003\340A\001\"|\n\024"
  "ListNvmePathsRequest\0223\n\006parent\030\001 \001(\tB#\340A"
  "\002\372A\035\n\033opi_api.storage.v1/NvmePath\022\026\n\tpag"
  "e_size\030\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 \001(\tB\003\340"
  "A\001\"b\n\025ListNvmePathsResponse\0220\n\nnvme_path"
  "s\030\001 \003(\0132\034.opi_api.storage.v1.NvmePath\022\027\n"
  "\017next_page_token\030\002 \001(\t\"G\n\022GetNvmePathReq"
  "uest\0221\n\004name\030\001 \001(\tB#\340A\002\372A\035\n\033opi_api.stor"
  "age.v1/NvmePath\"I\n\024StatsNvmePathRequest\022"
  "1\n\004name\030\001 \001(\tB#\340A\002\372A\035\n\033opi_api.storage.v"
  "1/NvmePath\"G\n\025StatsNvmePathResponse\022.\n\005s"
  "tats\030\001 \001(\0132\037.opi_api.storage.v1.VolumeSt"
  "ats*\264\001\n\021NvmeTransportType\022#\n\037NVME_TRANSP"
  "ORT_TYPE_UNSPECIFIED\020\000\022\025\n\021NVME_TRANSPORT"
  "_FC\020\001\022\027\n\023NVME_TRANSPORT_PCIE\020\002\022\027\n\023NVME_T"
  "RANSPORT_RDMA\020\003\022\026\n\022NVME_TRANSPORT_TCP\020\004\022"
  "\031\n\025NVME_TRANSPORT_CUSTOM\020\005*\250\001\n\021NvmeAddre"
  "ssFamily\022#\n\037NVME_ADDRESS_FAMILY_UNSPECIF"
  "IED\020\000\022\024\n\020NVME_ADRFAM_IPV4\020\001\022\024\n\020NVME_ADRF"
  "AM_IPV6\020\002\022\022\n\016NVME_ADRFAM_IB\020\003\022\022\n\016NVME_AD"
  "RFAM_FC\020\004\022\032\n\026NVME_ADRFAM_INTRA_HOST\020\005*\206\001"
  "\n\rNvmeMultipath\022\036\n\032NVME_MULTIPATH_UNSPEC"
  "IFIED\020\000\022\032\n\026NVME_MULTIPATH_DISABLE\020\001\022\033\n\027N"
  "VME_MULTIPATH_FAILOVER\020\002\022\034\n\030NVME_MULTIPA"
  "TH_MULTIPATH\020\0032\224\024\n\033NvmeRemoteControllerS"
  "ervice\022\335\001\n\032CreateNvmeRemoteController\0225."
  "opi_api.storage.v1.CreateNvmeRemoteContr"
  "ollerRequest\032(.opi_api.storage.v1.NvmeRe"
  "moteController\"^\202\323\344\223\002%\"\013/v1/volumes:\026nvm"
  "e_remote_controller\332A0nvme_remote_contro"
  "ller,nvme_remote_controller_id\022\236\001\n\032Delet"
  "eNvmeRemoteController\0225.opi_api.storage."
  "v1.DeleteNvmeRemoteControllerRequest\032\026.g"
  "oogle.protobuf.Empty\"1\202\323\344\223\002$*\"/v1/{name="
  "NvmeRemoteControllers/*}\332A\004name\022\360\001\n\032Upda"
  "teNvmeRemoteController\0225.opi_api.storage"
  ".v1.UpdateNvmeRemoteControllerRequest\032(."
  "opi_api.storage.v1.NvmeRemoteController\""
  "q\202\323\344\223\002F2,/v1/{nvme_remote_controller.nam"
  "e=subsystems}:\026nvme_remote_controller\332A\""
  "nvme_remote_controller,update_mask\022\262\001\n\031L"
  "istNvmeRemoteControllers\0224.opi_api.stora"
  "ge.v1.ListNvmeRemoteControllersRequest\0325"
  ".opi_api.storage.v1.ListNvmeRemoteContro"
  "llersResponse\"(\202\323\344\223\002\031\022\027/v1/{parent=subsy"
  "stems}\332A\006parent\022\252\001\n\027GetNvmeRemoteControl"
  "ler\0222.opi_api.storage.v1.GetNvmeRemoteCo"
  "ntrollerRequest\032(.opi_api.storage.v1.Nvm"
  "eRemoteController\"1\202\323\344\223\002$\022\"/v1/{name=Nvm"
  "eRemoteControllers/*}\332A\004name\022\245\001\n\031ResetNv"
  "meRemoteController\0224.opi_api.storage.v1."
  "ResetNvmeRemoteControllerRequest\032\026.googl"
  "e.protobuf.Empty\":\202\323\344\223\002-\"(/v1/{name=Nvme"
  "RemoteControllers/*}:reset:\001*\332A\004name\022\301\001\n"
  "\031StatsNvmeRemoteController\0224.opi_api.sto"
  "rage.v1.StatsNvmeRemoteControllerRequest"
  "\0325.opi_api.storage.v1.StatsNvmeRemoteCon"
  "trollerResponse\"7\202\323\344\223\002*\022(/v1/{name=NvmeR"
  "emoteControllers/*}:stats\332A\004name\022\257\001\n\030Lis"
  "tNvmeRemoteNamespaces\0223.opi_api.storage."
  "v1.ListNvmeRemoteNamespacesRequest\0324.opi"
  "_api.storage.v1.ListNvmeRemoteNamespaces"
  "Response\"(\202\323\344\223\002\031\022\027/v1/{parent=subsystems"
  "}\332A\006parent\022\246\001\n\026GetNvmeRemoteNamespace\0221."
  "opi_api.storage.v1.GetNvmeRemoteNamespac"
  "eRequest\032\'.opi_api.storage.v1.NvmeRemote"
  "Namespace\"0\202\323\344\223\002#\022!/v1/{name=NvmeRemoteN"
  "amespaces/*}\332A\004name\022\222\001\n\016CreateNvmePath\022)"
  ".opi_api.storage.v1.CreateNvmePathReques"
  "t\032\034.opi_api.storage.v1.NvmePath\"7\202\323\344\223\002\030\""
  "\013/v1/volumes:\tnvme_path\332A\026nvme_path,nvme"
  "_path_id\022z\n\016DeleteNvmePath\022).opi_api.sto"
  "rage.v1.DeleteNvmePathRequest\032\026.google.p"
  "rotobuf.Empty\"%\202\323\344\223\002\030*\026/v1/{name=NvmePat"
  "hs/*}\332A\004name\022\245\001\n\016UpdateNvmePath\022).opi_ap"
  "i.storage.v1.UpdateNvmePathRequest\032\034.opi"
  "_api.storage.v1.NvmePath\"J\202\323\344\223\002,2\037/v1/{n"
  "vme_path.name=subsystems}:\tnvme_path\332A\025n"
  "vme_path,update_mask\022\216\001\n\rListNvmePaths\022("
  ".opi_api.storage.v1.ListNvmePathsRequest"
  "\032).opi_api.storage.v1.ListNvmePathsRespo"
  "nse\"(\202\323\344\223\002\031\022\027/v1/{parent=subsystems}\332A\006p"
  "arent\022z\n\013GetNvmePath\022&.opi_api.storage.v"
  "1.GetNvmePathRequest\032\034.opi_api.storage.v"
  "1.NvmePath\"%\202\323\344\223\002\030\022\026/v1/{name=NvmePaths/"
  "*}\332A\004name\022\221\001\n\rStatsNvmePath\022(.opi_api.st"
  "orage.v1.StatsNvmePathRequest\032).opi_api."
  "storage.v1.StatsNvmePathResponse\"+\202\323\344\223\002\036"
  "\022\034/v1/{name=NvmePaths/*}:stats\332A\004nameBb\n"
  "\022opi_api.storage.v1B\023BackendNvmeTcpProto"
  "P\001Z5github.com/opiproject/opi-api/storag"
  "e/v1alpha1/gen/gob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_backend_5fnvme_5ftcp_2eproto_deps[8] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2fclient_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ffield_5fmask_2eproto,
  &::descriptor_table_opicommon_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::_pbi::once_flag descriptor_table_backend_5fnvme_5ftcp_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_backend_5fnvme_5ftcp_2eproto = {
    false, false, 7025, descriptor_table_protodef_backend_5fnvme_5ftcp_2eproto,
    "backend_nvme_tcp.proto",
    &descriptor_table_backend_5fnvme_5ftcp_2eproto_once, descriptor_table_backend_5fnvme_5ftcp_2eproto_deps, 8, 23,
    schemas, file_default_instances, TableStruct_backend_5fnvme_5ftcp_2eproto::offsets,
    file_level_metadata_backend_5fnvme_5ftcp_2eproto, file_level_enum_descriptors_backend_5fnvme_5ftcp_2eproto,
    file_level_service_descriptors_backend_5fnvme_5ftcp_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_backend_5fnvme_5ftcp_2eproto_getter() {
  return &descriptor_table_backend_5fnvme_5ftcp_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_backend_5fnvme_5ftcp_2eproto(&descriptor_table_backend_5fnvme_5ftcp_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeTransportType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_backend_5fnvme_5ftcp_2eproto);
  return file_level_enum_descriptors_backend_5fnvme_5ftcp_2eproto[0];
}
bool NvmeTransportType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeAddressFamily_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_backend_5fnvme_5ftcp_2eproto);
  return file_level_enum_descriptors_backend_5fnvme_5ftcp_2eproto[1];
}
bool NvmeAddressFamily_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeMultipath_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_backend_5fnvme_5ftcp_2eproto);
  return file_level_enum_descriptors_backend_5fnvme_5ftcp_2eproto[2];
}
bool NvmeMultipath_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NvmeRemoteController::_Internal {
 public:
};

NvmeRemoteController::NvmeRemoteController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeRemoteController)
}
NvmeRemoteController::NvmeRemoteController(const NvmeRemoteController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeRemoteController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.psk_){}
    , decltype(_impl_.io_queues_count_){}
    , decltype(_impl_.queue_size_){}
    , decltype(_impl_.multipath_){}
    , decltype(_impl_.hdgst_){}
    , decltype(_impl_.ddgst_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.psk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.psk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_psk().empty()) {
    _this->_impl_.psk_.Set(from._internal_psk(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.io_queues_count_, &from._impl_.io_queues_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ddgst_) -
    reinterpret_cast<char*>(&_impl_.io_queues_count_)) + sizeof(_impl_.ddgst_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeRemoteController)
}

inline void NvmeRemoteController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.psk_){}
    , decltype(_impl_.io_queues_count_){int64_t{0}}
    , decltype(_impl_.queue_size_){int64_t{0}}
    , decltype(_impl_.multipath_){0}
    , decltype(_impl_.hdgst_){false}
    , decltype(_impl_.ddgst_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.psk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.psk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeRemoteController::~NvmeRemoteController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeRemoteController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeRemoteController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.psk_.Destroy();
}

void NvmeRemoteController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeRemoteController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeRemoteController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.psk_.ClearToEmpty();
  ::memset(&_impl_.io_queues_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ddgst_) -
      reinterpret_cast<char*>(&_impl_.io_queues_count_)) + sizeof(_impl_.ddgst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeRemoteController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteController.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_multipath(static_cast<::opi_api::storage::v1::NvmeMultipath>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.io_queues_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hdgst = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.hdgst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ddgst = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.ddgst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes psk = 7 [(.google.api.field_behavior) = OPTIONAL];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_psk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeRemoteController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeRemoteController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteController.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_multipath() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_multipath(), target);
  }

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_io_queues_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_io_queues_count(), target);
  }

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_queue_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_queue_size(), target);
  }

  // bool hdgst = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_hdgst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_hdgst(), target);
  }

  // bool ddgst = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_ddgst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_ddgst(), target);
  }

  // bytes psk = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_psk().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_psk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeRemoteController)
  return target;
}

size_t NvmeRemoteController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeRemoteController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bytes psk = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_psk().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_psk());
  }

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_io_queues_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_io_queues_count());
  }

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_queue_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_queue_size());
  }

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_multipath() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_multipath());
  }

  // bool hdgst = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_hdgst() != 0) {
    total_size += 1 + 1;
  }

  // bool ddgst = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_ddgst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeRemoteController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeRemoteController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeRemoteController::GetClassData() const { return &_class_data_; }


void NvmeRemoteController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeRemoteController*>(&to_msg);
  auto& from = static_cast<const NvmeRemoteController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeRemoteController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_psk().empty()) {
    _this->_internal_set_psk(from._internal_psk());
  }
  if (from._internal_io_queues_count() != 0) {
    _this->_internal_set_io_queues_count(from._internal_io_queues_count());
  }
  if (from._internal_queue_size() != 0) {
    _this->_internal_set_queue_size(from._internal_queue_size());
  }
  if (from._internal_multipath() != 0) {
    _this->_internal_set_multipath(from._internal_multipath());
  }
  if (from._internal_hdgst() != 0) {
    _this->_internal_set_hdgst(from._internal_hdgst());
  }
  if (from._internal_ddgst() != 0) {
    _this->_internal_set_ddgst(from._internal_ddgst());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeRemoteController::CopyFrom(const NvmeRemoteController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeRemoteController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeRemoteController::IsInitialized() const {
  return true;
}

void NvmeRemoteController::InternalSwap(NvmeRemoteController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.psk_, lhs_arena,
      &other->_impl_.psk_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeRemoteController, _impl_.ddgst_)
      + sizeof(NvmeRemoteController::_impl_.ddgst_)
      - PROTOBUF_FIELD_OFFSET(NvmeRemoteController, _impl_.io_queues_count_)>(
          reinterpret_cast<char*>(&_impl_.io_queues_count_),
          reinterpret_cast<char*>(&other->_impl_.io_queues_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeRemoteController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[0]);
}

// ===================================================================

class NvmePath::_Internal {
 public:
};

NvmePath::NvmePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmePath)
}
NvmePath::NvmePath(const NvmePath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmePath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.traddr_){}
    , decltype(_impl_.subnqn_){}
    , decltype(_impl_.source_traddr_){}
    , decltype(_impl_.hostnqn_){}
    , decltype(_impl_.trtype_){}
    , decltype(_impl_.adrfam_){}
    , decltype(_impl_.trsvcid_){}
    , decltype(_impl_.source_trsvcid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_controller_name_ref().empty()) {
    _this->_impl_.controller_name_ref_.Set(from._internal_controller_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_traddr().empty()) {
    _this->_impl_.traddr_.Set(from._internal_traddr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.subnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subnqn().empty()) {
    _this->_impl_.subnqn_.Set(from._internal_subnqn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_traddr().empty()) {
    _this->_impl_.source_traddr_.Set(from._internal_source_traddr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hostnqn().empty()) {
    _this->_impl_.hostnqn_.Set(from._internal_hostnqn(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.trtype_, &from._impl_.trtype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.source_trsvcid_) -
    reinterpret_cast<char*>(&_impl_.trtype_)) + sizeof(_impl_.source_trsvcid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmePath)
}

inline void NvmePath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.traddr_){}
    , decltype(_impl_.subnqn_){}
    , decltype(_impl_.source_traddr_){}
    , decltype(_impl_.hostnqn_){}
    , decltype(_impl_.trtype_){0}
    , decltype(_impl_.adrfam_){0}
    , decltype(_impl_.trsvcid_){int64_t{0}}
    , decltype(_impl_.source_trsvcid_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmePath::~NvmePath() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmePath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmePath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.controller_name_ref_.Destroy();
  _impl_.traddr_.Destroy();
  _impl_.subnqn_.Destroy();
  _impl_.source_traddr_.Destroy();
  _impl_.hostnqn_.Destroy();
}

void NvmePath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmePath::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmePath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.controller_name_ref_.ClearToEmpty();
  _impl_.traddr_.ClearToEmpty();
  _impl_.subnqn_.ClearToEmpty();
  _impl_.source_traddr_.ClearToEmpty();
  _impl_.hostnqn_.ClearToEmpty();
  ::memset(&_impl_.trtype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.source_trsvcid_) -
      reinterpret_cast<char*>(&_impl_.trtype_)) + sizeof(_impl_.source_trsvcid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmePath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.name"));
        } else
          goto handle_unusual;
        continue;
      // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.controller_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_trtype(static_cast<::opi_api::storage::v1::NvmeTransportType>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeAddressFamily adrfam = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_adrfam(static_cast<::opi_api::storage::v1::NvmeAddressFamily>(val));
        } else
          goto handle_unusual;
        continue;
      // string traddr = 5 [(.google.api.field_behavior) = REQUIRED];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_traddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.traddr"));
        } else
          goto handle_unusual;
        continue;
      // int64 trsvcid = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.trsvcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string subnqn = 7 [(.google.api.field_behavior) = OPTIONAL];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_subnqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.subnqn"));
        } else
          goto handle_unusual;
        continue;
      // string source_traddr = 8 [(.google.api.field_behavior) = OPTIONAL];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_source_traddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.source_traddr"));
        } else
          goto handle_unusual;
        continue;
      // int64 source_trsvcid = 9 [(.google.api.field_behavior) = OPTIONAL];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.source_trsvcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hostnqn = 10 [(.google.api.field_behavior) = OPTIONAL];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_hostnqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.hostnqn"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmePath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmePath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_controller_name_ref().data(), static_cast<int>(this->_internal_controller_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.controller_name_ref");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_name_ref(), target);
  }

  // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_trtype(), target);
  }

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_adrfam() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_adrfam(), target);
  }

  // string traddr = 5 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_traddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_traddr().data(), static_cast<int>(this->_internal_traddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.traddr");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_traddr(), target);
  }

  // int64 trsvcid = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_trsvcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_trsvcid(), target);
  }

  // string subnqn = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_subnqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subnqn().data(), static_cast<int>(this->_internal_subnqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.subnqn");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_subnqn(), target);
  }

  // string source_traddr = 8 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_source_traddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source_traddr().data(), static_cast<int>(this->_internal_source_traddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.source_traddr");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_source_traddr(), target);
  }

  // int64 source_trsvcid = 9 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_source_trsvcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_source_trsvcid(), target);
  }

  // string hostnqn = 10 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_hostnqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hostnqn().data(), static_cast<int>(this->_internal_hostnqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.hostnqn");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_hostnqn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmePath)
  return target;
}

size_t NvmePath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmePath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_controller_name_ref());
  }

  // string traddr = 5 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_traddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_traddr());
  }

  // string subnqn = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_subnqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subnqn());
  }

  // string source_traddr = 8 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_source_traddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source_traddr());
  }

  // string hostnqn = 10 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_hostnqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostnqn());
  }

  // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_trtype());
  }

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_adrfam() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_adrfam());
  }

  // int64 trsvcid = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_trsvcid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_trsvcid());
  }

  // int64 source_trsvcid = 9 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_source_trsvcid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_source_trsvcid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmePath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmePath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmePath::GetClassData() const { return &_class_data_; }


void NvmePath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmePath*>(&to_msg);
  auto& from = static_cast<const NvmePath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmePath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_controller_name_ref().empty()) {
    _this->_internal_set_controller_name_ref(from._internal_controller_name_ref());
  }
  if (!from._internal_traddr().empty()) {
    _this->_internal_set_traddr(from._internal_traddr());
  }
  if (!from._internal_subnqn().empty()) {
    _this->_internal_set_subnqn(from._internal_subnqn());
  }
  if (!from._internal_source_traddr().empty()) {
    _this->_internal_set_source_traddr(from._internal_source_traddr());
  }
  if (!from._internal_hostnqn().empty()) {
    _this->_internal_set_hostnqn(from._internal_hostnqn());
  }
  if (from._internal_trtype() != 0) {
    _this->_internal_set_trtype(from._internal_trtype());
  }
  if (from._internal_adrfam() != 0) {
    _this->_internal_set_adrfam(from._internal_adrfam());
  }
  if (from._internal_trsvcid() != 0) {
    _this->_internal_set_trsvcid(from._internal_trsvcid());
  }
  if (from._internal_source_trsvcid() != 0) {
    _this->_internal_set_source_trsvcid(from._internal_source_trsvcid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmePath::CopyFrom(const NvmePath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmePath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmePath::IsInitialized() const {
  return true;
}

void NvmePath::InternalSwap(NvmePath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.controller_name_ref_, lhs_arena,
      &other->_impl_.controller_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.traddr_, lhs_arena,
      &other->_impl_.traddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.subnqn_, lhs_arena,
      &other->_impl_.subnqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_traddr_, lhs_arena,
      &other->_impl_.source_traddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostnqn_, lhs_arena,
      &other->_impl_.hostnqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmePath, _impl_.source_trsvcid_)
      + sizeof(NvmePath::_impl_.source_trsvcid_)
      - PROTOBUF_FIELD_OFFSET(NvmePath, _impl_.trtype_)>(
          reinterpret_cast<char*>(&_impl_.trtype_),
          reinterpret_cast<char*>(&other->_impl_.trtype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmePath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[1]);
}

// ===================================================================

class NvmeRemoteNamespace::_Internal {
 public:
  static const ::opi_api::common::v1::Uuid& uuid(const NvmeRemoteNamespace* msg);
};

const ::opi_api::common::v1::Uuid&
NvmeRemoteNamespace::_Internal::uuid(const NvmeRemoteNamespace* msg) {
  return *msg->_impl_.uuid_;
}
void NvmeRemoteNamespace::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
}
NvmeRemoteNamespace::NvmeRemoteNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeRemoteNamespace)
}
NvmeRemoteNamespace::NvmeRemoteNamespace(const NvmeRemoteNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeRemoteNamespace* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.nguid_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){}
    , decltype(_impl_.nsid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_controller_name_ref().empty()) {
    _this->_impl_.controller_name_ref_.Set(from._internal_controller_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    _this->_impl_.nguid_.Set(from._internal_nguid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::opi_api::common::v1::Uuid(*from._impl_.uuid_);
  }
  ::memcpy(&_impl_.eui64_, &from._impl_.eui64_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nsid_) -
    reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.nsid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeRemoteNamespace)
}

inline void NvmeRemoteNamespace::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.nguid_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){int64_t{0}}
    , decltype(_impl_.nsid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeRemoteNamespace::~NvmeRemoteNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeRemoteNamespace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeRemoteNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.controller_name_ref_.Destroy();
  _impl_.nguid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void NvmeRemoteNamespace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeRemoteNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeRemoteNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.controller_name_ref_.ClearToEmpty();
  _impl_.nguid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
  ::memset(&_impl_.eui64_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nsid_) -
      reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.nsid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeRemoteNamespace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.name"));
        } else
          goto handle_unusual;
        continue;
      // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nguid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.nguid"));
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeRemoteNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeRemoteNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_controller_name_ref().data(), static_cast<int>(this->_internal_controller_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_name_ref(), target);
  }

  // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_nsid(), target);
  }

  // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.nguid");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nguid(), target);
  }

  // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_uuid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeRemoteNamespace)
  return target;
}

size_t NvmeRemoteNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeRemoteNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_controller_name_ref());
  }

  // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_);
  }

  // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_eui64() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_nsid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nsid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeRemoteNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeRemoteNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeRemoteNamespace::GetClassData() const { return &_class_data_; }


void NvmeRemoteNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeRemoteNamespace*>(&to_msg);
  auto& from = static_cast<const NvmeRemoteNamespace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeRemoteNamespace)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_controller_name_ref().empty()) {
    _this->_internal_set_controller_name_ref(from._internal_controller_name_ref());
  }
  if (!from._internal_nguid().empty()) {
    _this->_internal_set_nguid(from._internal_nguid());
  }
  if (from._internal_has_uuid()) {
    _this->_internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(
        from._internal_uuid());
  }
  if (from._internal_eui64() != 0) {
    _this->_internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_nsid() != 0) {
    _this->_internal_set_nsid(from._internal_nsid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeRemoteNamespace::CopyFrom(const NvmeRemoteNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeRemoteNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeRemoteNamespace::IsInitialized() const {
  return true;
}

void NvmeRemoteNamespace::InternalSwap(NvmeRemoteNamespace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.controller_name_ref_, lhs_arena,
      &other->_impl_.controller_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nguid_, lhs_arena,
      &other->_impl_.nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeRemoteNamespace, _impl_.nsid_)
      + sizeof(NvmeRemoteNamespace::_impl_.nsid_)
      - PROTOBUF_FIELD_OFFSET(NvmeRemoteNamespace, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeRemoteNamespace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[2]);
}

// ===================================================================

class CreateNvmeRemoteControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller(const CreateNvmeRemoteControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeRemoteController&
CreateNvmeRemoteControllerRequest::_Internal::nvme_remote_controller(const CreateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.nvme_remote_controller_;
}
CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
}
CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(const CreateNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_id_){}
    , decltype(_impl_.nvme_remote_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nvme_remote_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_remote_controller_id().empty()) {
    _this->_impl_.nvme_remote_controller_id_.Set(from._internal_nvme_remote_controller_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_remote_controller()) {
    _this->_impl_.nvme_remote_controller_ = new ::opi_api::storage::v1::NvmeRemoteController(*from._impl_.nvme_remote_controller_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
}

inline void CreateNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_id_){}
    , decltype(_impl_.nvme_remote_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nvme_remote_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmeRemoteControllerRequest::~CreateNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_controller_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_remote_controller_;
}

void CreateNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_controller_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_remote_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_remote_controller_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_remote_controller(this),
        _Internal::nvme_remote_controller(this).GetCachedSize(), target, stream);
  }

  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_remote_controller_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_remote_controller_id().data(), static_cast<int>(this->_internal_nvme_remote_controller_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_remote_controller_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  return target;
}

size_t CreateNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_remote_controller_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_remote_controller_id());
  }

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_remote_controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void CreateNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_remote_controller_id().empty()) {
    _this->_internal_set_nvme_remote_controller_id(from._internal_nvme_remote_controller_id());
  }
  if (from._internal_has_nvme_remote_controller()) {
    _this->_internal_mutable_nvme_remote_controller()->::opi_api::storage::v1::NvmeRemoteController::MergeFrom(
        from._internal_nvme_remote_controller());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeRemoteControllerRequest::CopyFrom(const CreateNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void CreateNvmeRemoteControllerRequest::InternalSwap(CreateNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_remote_controller_id_, lhs_arena,
      &other->_impl_.nvme_remote_controller_id_, rhs_arena
  );
  swap(_impl_.nvme_remote_controller_, other->_impl_.nvme_remote_controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[3]);
}

// ===================================================================

class DeleteNvmeRemoteControllerRequest::_Internal {
 public:
};

DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
}
DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(const DeleteNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
}

inline void DeleteNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmeRemoteControllerRequest::~DeleteNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  return target;
}

size_t DeleteNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeRemoteControllerRequest::CopyFrom(const DeleteNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeRemoteControllerRequest::InternalSwap(DeleteNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[4]);
}

// ===================================================================

class UpdateNvmeRemoteControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller(const UpdateNvmeRemoteControllerRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeRemoteControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeRemoteController&
UpdateNvmeRemoteControllerRequest::_Internal::nvme_remote_controller(const UpdateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.nvme_remote_controller_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeRemoteControllerRequest::_Internal::update_mask(const UpdateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmeRemoteControllerRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
}
UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(const UpdateNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_remote_controller()) {
    _this->_impl_.nvme_remote_controller_ = new ::opi_api::storage::v1::NvmeRemoteController(*from._impl_.nvme_remote_controller_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
}

inline void UpdateNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmeRemoteControllerRequest::~UpdateNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_remote_controller_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_remote_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_remote_controller(this),
        _Internal::nvme_remote_controller(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  return target;
}

size_t UpdateNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_remote_controller_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_remote_controller()) {
    _this->_internal_mutable_nvme_remote_controller()->::opi_api::storage::v1::NvmeRemoteController::MergeFrom(
        from._internal_nvme_remote_controller());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeRemoteControllerRequest::CopyFrom(const UpdateNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeRemoteControllerRequest::InternalSwap(UpdateNvmeRemoteControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeRemoteControllerRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmeRemoteControllerRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_)>(
          reinterpret_cast<char*>(&_impl_.nvme_remote_controller_),
          reinterpret_cast<char*>(&other->_impl_.nvme_remote_controller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[5]);
}

// ===================================================================

class ListNvmeRemoteControllersRequest::_Internal {
 public:
};

ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
}
ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(const ListNvmeRemoteControllersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteControllersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
}

inline void ListNvmeRemoteControllersRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteControllersRequest::~ListNvmeRemoteControllersRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteControllersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeRemoteControllersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteControllersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteControllersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteControllersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  return target;
}

size_t ListNvmeRemoteControllersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteControllersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteControllersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteControllersRequest::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteControllersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteControllersRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteControllersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteControllersRequest::CopyFrom(const ListNvmeRemoteControllersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteControllersRequest::IsInitialized() const {
  return true;
}

void ListNvmeRemoteControllersRequest::InternalSwap(ListNvmeRemoteControllersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteControllersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[6]);
}

// ===================================================================

class ListNvmeRemoteControllersResponse::_Internal {
 public:
};

ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
}
ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(const ListNvmeRemoteControllersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteControllersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controllers_){from._impl_.nvme_remote_controllers_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
}

inline void ListNvmeRemoteControllersResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controllers_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteControllersResponse::~ListNvmeRemoteControllersResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteControllersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_controllers_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeRemoteControllersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteControllersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_controllers_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteControllersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_remote_controllers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteControllersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_remote_controllers_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_remote_controllers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  return target;
}

size_t ListNvmeRemoteControllersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  total_size += 1UL * this->_internal_nvme_remote_controllers_size();
  for (const auto& msg : this->_impl_.nvme_remote_controllers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteControllersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteControllersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteControllersResponse::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteControllersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteControllersResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteControllersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_remote_controllers_.MergeFrom(from._impl_.nvme_remote_controllers_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteControllersResponse::CopyFrom(const ListNvmeRemoteControllersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteControllersResponse::IsInitialized() const {
  return true;
}

void ListNvmeRemoteControllersResponse::InternalSwap(ListNvmeRemoteControllersResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_remote_controllers_.InternalSwap(&other->_impl_.nvme_remote_controllers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteControllersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[7]);
}

// ===================================================================

class GetNvmeRemoteControllerRequest::_Internal {
 public:
};

GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
}
GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(const GetNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
}

inline void GetNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeRemoteControllerRequest::~GetNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  return target;
}

size_t GetNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void GetNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeRemoteControllerRequest::CopyFrom(const GetNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void GetNvmeRemoteControllerRequest::InternalSwap(GetNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[8]);
}

// ===================================================================

class ResetNvmeRemoteControllerRequest::_Internal {
 public:
};

ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
}
ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(const ResetNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResetNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
}

inline void ResetNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResetNvmeRemoteControllerRequest::~ResetNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ResetNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResetNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResetNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  return target;
}

size_t ResetNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResetNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResetNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResetNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void ResetNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResetNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const ResetNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResetNvmeRemoteControllerRequest::CopyFrom(const ResetNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void ResetNvmeRemoteControllerRequest::InternalSwap(ResetNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ResetNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[9]);
}

// ===================================================================

class StatsNvmeRemoteControllerRequest::_Internal {
 public:
};

StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
}
StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(const StatsNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
}

inline void StatsNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeRemoteControllerRequest::~StatsNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  return target;
}

size_t StatsNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void StatsNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeRemoteControllerRequest::CopyFrom(const StatsNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void StatsNvmeRemoteControllerRequest::InternalSwap(StatsNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[10]);
}

// ===================================================================

class StatsNvmeRemoteControllerResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeRemoteControllerResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeRemoteControllerResponse::_Internal::stats(const StatsNvmeRemoteControllerResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmeRemoteControllerResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
}
StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(const StatsNvmeRemoteControllerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeRemoteControllerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
}

inline void StatsNvmeRemoteControllerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmeRemoteControllerResponse::~StatsNvmeRemoteControllerResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeRemoteControllerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmeRemoteControllerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeRemoteControllerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeRemoteControllerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeRemoteControllerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  return target;
}

size_t StatsNvmeRemoteControllerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeRemoteControllerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeRemoteControllerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeRemoteControllerResponse::GetClassData() const { return &_class_data_; }


void StatsNvmeRemoteControllerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeRemoteControllerResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmeRemoteControllerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeRemoteControllerResponse::CopyFrom(const StatsNvmeRemoteControllerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeRemoteControllerResponse::IsInitialized() const {
  return true;
}

void StatsNvmeRemoteControllerResponse::InternalSwap(StatsNvmeRemoteControllerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeRemoteControllerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[11]);
}

// ===================================================================

class ListNvmeRemoteNamespacesRequest::_Internal {
 public:
};

ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
}
ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(const ListNvmeRemoteNamespacesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteNamespacesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
}

inline void ListNvmeRemoteNamespacesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteNamespacesRequest::~ListNvmeRemoteNamespacesRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteNamespacesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeRemoteNamespacesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteNamespacesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteNamespacesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteNamespacesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  return target;
}

size_t ListNvmeRemoteNamespacesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteNamespacesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteNamespacesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteNamespacesRequest::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteNamespacesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteNamespacesRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteNamespacesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteNamespacesRequest::CopyFrom(const ListNvmeRemoteNamespacesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteNamespacesRequest::IsInitialized() const {
  return true;
}

void ListNvmeRemoteNamespacesRequest::InternalSwap(ListNvmeRemoteNamespacesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteNamespacesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[12]);
}

// ===================================================================

class ListNvmeRemoteNamespacesResponse::_Internal {
 public:
};

ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
}
ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(const ListNvmeRemoteNamespacesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteNamespacesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_namespaces_){from._impl_.nvme_remote_namespaces_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
}

inline void ListNvmeRemoteNamespacesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_namespaces_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteNamespacesResponse::~ListNvmeRemoteNamespacesResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteNamespacesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_namespaces_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeRemoteNamespacesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteNamespacesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_namespaces_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteNamespacesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_remote_namespaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteNamespacesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_remote_namespaces_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_remote_namespaces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  return target;
}

size_t ListNvmeRemoteNamespacesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  total_size += 1UL * this->_internal_nvme_remote_namespaces_size();
  for (const auto& msg : this->_impl_.nvme_remote_namespaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteNamespacesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteNamespacesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteNamespacesResponse::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteNamespacesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteNamespacesResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteNamespacesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_remote_namespaces_.MergeFrom(from._impl_.nvme_remote_namespaces_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteNamespacesResponse::CopyFrom(const ListNvmeRemoteNamespacesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteNamespacesResponse::IsInitialized() const {
  return true;
}

void ListNvmeRemoteNamespacesResponse::InternalSwap(ListNvmeRemoteNamespacesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_remote_namespaces_.InternalSwap(&other->_impl_.nvme_remote_namespaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteNamespacesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[13]);
}

// ===================================================================

class GetNvmeRemoteNamespaceRequest::_Internal {
 public:
};

GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
}
GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(const GetNvmeRemoteNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeRemoteNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
}

inline void GetNvmeRemoteNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeRemoteNamespaceRequest::~GetNvmeRemoteNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeRemoteNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeRemoteNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeRemoteNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeRemoteNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeRemoteNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  return target;
}

size_t GetNvmeRemoteNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeRemoteNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeRemoteNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeRemoteNamespaceRequest::GetClassData() const { return &_class_data_; }


void GetNvmeRemoteNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeRemoteNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeRemoteNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeRemoteNamespaceRequest::CopyFrom(const GetNvmeRemoteNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeRemoteNamespaceRequest::IsInitialized() const {
  return true;
}

void GetNvmeRemoteNamespaceRequest::InternalSwap(GetNvmeRemoteNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeRemoteNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[14]);
}

// ===================================================================

class CreateNvmePathRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmePath& nvme_path(const CreateNvmePathRequest* msg);
};

const ::opi_api::storage::v1::NvmePath&
CreateNvmePathRequest::_Internal::nvme_path(const CreateNvmePathRequest* msg) {
  return *msg->_impl_.nvme_path_;
}
CreateNvmePathRequest::CreateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmePathRequest)
}
CreateNvmePathRequest::CreateNvmePathRequest(const CreateNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_id_){}
    , decltype(_impl_.nvme_path_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nvme_path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_path_id().empty()) {
    _this->_impl_.nvme_path_id_.Set(from._internal_nvme_path_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_path()) {
    _this->_impl_.nvme_path_ = new ::opi_api::storage::v1::NvmePath(*from._impl_.nvme_path_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmePathRequest)
}

inline void CreateNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_id_){}
    , decltype(_impl_.nvme_path_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nvme_path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmePathRequest::~CreateNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_path_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_path_;
}

void CreateNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_path_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_path_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_path(this),
        _Internal::nvme_path(this).GetCachedSize(), target, stream);
  }

  // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_path_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_path_id().data(), static_cast<int>(this->_internal_nvme_path_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_path_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmePathRequest)
  return target;
}

size_t CreateNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_path_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_path_id());
  }

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_path_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmePathRequest::GetClassData() const { return &_class_data_; }


void CreateNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_path_id().empty()) {
    _this->_internal_set_nvme_path_id(from._internal_nvme_path_id());
  }
  if (from._internal_has_nvme_path()) {
    _this->_internal_mutable_nvme_path()->::opi_api::storage::v1::NvmePath::MergeFrom(
        from._internal_nvme_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmePathRequest::CopyFrom(const CreateNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmePathRequest::IsInitialized() const {
  return true;
}

void CreateNvmePathRequest::InternalSwap(CreateNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_path_id_, lhs_arena,
      &other->_impl_.nvme_path_id_, rhs_arena
  );
  swap(_impl_.nvme_path_, other->_impl_.nvme_path_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[15]);
}

// ===================================================================

class DeleteNvmePathRequest::_Internal {
 public:
};

DeleteNvmePathRequest::DeleteNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmePathRequest)
}
DeleteNvmePathRequest::DeleteNvmePathRequest(const DeleteNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmePathRequest)
}

inline void DeleteNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmePathRequest::~DeleteNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmePathRequest)
  return target;
}

size_t DeleteNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmePathRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmePathRequest::CopyFrom(const DeleteNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmePathRequest::IsInitialized() const {
  return true;
}

void DeleteNvmePathRequest::InternalSwap(DeleteNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[16]);
}

// ===================================================================

class UpdateNvmePathRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmePath& nvme_path(const UpdateNvmePathRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmePathRequest* msg);
};

const ::opi_api::storage::v1::NvmePath&
UpdateNvmePathRequest::_Internal::nvme_path(const UpdateNvmePathRequest* msg) {
  return *msg->_impl_.nvme_path_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmePathRequest::_Internal::update_mask(const UpdateNvmePathRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmePathRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmePathRequest::UpdateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmePathRequest)
}
UpdateNvmePathRequest::UpdateNvmePathRequest(const UpdateNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_path()) {
    _this->_impl_.nvme_path_ = new ::opi_api::storage::v1::NvmePath(*from._impl_.nvme_path_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmePathRequest)
}

inline void UpdateNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmePathRequest::~UpdateNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_path_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_path(this),
        _Internal::nvme_path(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmePathRequest)
  return target;
}

size_t UpdateNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_path_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmePathRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_path()) {
    _this->_internal_mutable_nvme_path()->::opi_api::storage::v1::NvmePath::MergeFrom(
        from._internal_nvme_path());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmePathRequest::CopyFrom(const UpdateNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmePathRequest::IsInitialized() const {
  return true;
}

void UpdateNvmePathRequest::InternalSwap(UpdateNvmePathRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmePathRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmePathRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmePathRequest, _impl_.nvme_path_)>(
          reinterpret_cast<char*>(&_impl_.nvme_path_),
          reinterpret_cast<char*>(&other->_impl_.nvme_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[17]);
}

// ===================================================================

class ListNvmePathsRequest::_Internal {
 public:
};

ListNvmePathsRequest::ListNvmePathsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmePathsRequest)
}
ListNvmePathsRequest::ListNvmePathsRequest(const ListNvmePathsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmePathsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmePathsRequest)
}

inline void ListNvmePathsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmePathsRequest::~ListNvmePathsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmePathsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmePathsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmePathsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmePathsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmePathsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmePathsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmePathsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmePathsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmePathsRequest)
  return target;
}

size_t ListNvmePathsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmePathsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmePathsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmePathsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmePathsRequest::GetClassData() const { return &_class_data_; }


void ListNvmePathsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmePathsRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmePathsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmePathsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmePathsRequest::CopyFrom(const ListNvmePathsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmePathsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmePathsRequest::IsInitialized() const {
  return true;
}

void ListNvmePathsRequest::InternalSwap(ListNvmePathsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmePathsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[18]);
}

// ===================================================================

class ListNvmePathsResponse::_Internal {
 public:
};

ListNvmePathsResponse::ListNvmePathsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmePathsResponse)
}
ListNvmePathsResponse::ListNvmePathsResponse(const ListNvmePathsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmePathsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_paths_){from._impl_.nvme_paths_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmePathsResponse)
}

inline void ListNvmePathsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_paths_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmePathsResponse::~ListNvmePathsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmePathsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmePathsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_paths_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmePathsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmePathsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmePathsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_paths_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmePathsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_paths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmePathsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmePathsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_paths_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_paths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmePathsResponse)
  return target;
}

size_t ListNvmePathsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmePathsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  total_size += 1UL * this->_internal_nvme_paths_size();
  for (const auto& msg : this->_impl_.nvme_paths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmePathsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmePathsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmePathsResponse::GetClassData() const { return &_class_data_; }


void ListNvmePathsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmePathsResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmePathsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmePathsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_paths_.MergeFrom(from._impl_.nvme_paths_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmePathsResponse::CopyFrom(const ListNvmePathsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmePathsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmePathsResponse::IsInitialized() const {
  return true;
}

void ListNvmePathsResponse::InternalSwap(ListNvmePathsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_paths_.InternalSwap(&other->_impl_.nvme_paths_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmePathsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[19]);
}

// ===================================================================

class GetNvmePathRequest::_Internal {
 public:
};

GetNvmePathRequest::GetNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmePathRequest)
}
GetNvmePathRequest::GetNvmePathRequest(const GetNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmePathRequest)
}

inline void GetNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmePathRequest::~GetNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmePathRequest)
  return target;
}

size_t GetNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmePathRequest::GetClassData() const { return &_class_data_; }


void GetNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmePathRequest::CopyFrom(const GetNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmePathRequest::IsInitialized() const {
  return true;
}

void GetNvmePathRequest::InternalSwap(GetNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[20]);
}

// ===================================================================

class StatsNvmePathRequest::_Internal {
 public:
};

StatsNvmePathRequest::StatsNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmePathRequest)
}
StatsNvmePathRequest::StatsNvmePathRequest(const StatsNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmePathRequest)
}

inline void StatsNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmePathRequest::~StatsNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmePathRequest)
  return target;
}

size_t StatsNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmePathRequest::GetClassData() const { return &_class_data_; }


void StatsNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmePathRequest::CopyFrom(const StatsNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmePathRequest::IsInitialized() const {
  return true;
}

void StatsNvmePathRequest::InternalSwap(StatsNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[21]);
}

// ===================================================================

class StatsNvmePathResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmePathResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmePathResponse::_Internal::stats(const StatsNvmePathResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmePathResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmePathResponse::StatsNvmePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmePathResponse)
}
StatsNvmePathResponse::StatsNvmePathResponse(const StatsNvmePathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmePathResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmePathResponse)
}

inline void StatsNvmePathResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmePathResponse::~StatsNvmePathResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmePathResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmePathResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmePathResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmePathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmePathResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmePathResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmePathResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmePathResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmePathResponse)
  return target;
}

size_t StatsNvmePathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmePathResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmePathResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmePathResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmePathResponse::GetClassData() const { return &_class_data_; }


void StatsNvmePathResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmePathResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmePathResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmePathResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmePathResponse::CopyFrom(const StatsNvmePathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmePathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmePathResponse::IsInitialized() const {
  return true;
}

void StatsNvmePathResponse::InternalSwap(StatsNvmePathResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmePathResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_5ftcp_2eproto_getter, &descriptor_table_backend_5fnvme_5ftcp_2eproto_once,
      file_level_metadata_backend_5fnvme_5ftcp_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeRemoteController*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeRemoteController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeRemoteController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmePath*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmePath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmePath >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeRemoteNamespace*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeRemoteNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeRemoteNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteControllersRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteControllersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteControllersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteControllersResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteControllersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteControllersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmePathsRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmePathsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmePathsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmePathsResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmePathsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmePathsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmePathResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmePathResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmePathResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
