// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "opicommon.pb.h"
#include "object_key.pb.h"
#include "uuid.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frontend_5fnvme_5fpcie_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frontend_5fnvme_5fpcie_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class CreateNVMeControllerRequest;
struct CreateNVMeControllerRequestDefaultTypeInternal;
extern CreateNVMeControllerRequestDefaultTypeInternal _CreateNVMeControllerRequest_default_instance_;
class CreateNVMeNamespaceRequest;
struct CreateNVMeNamespaceRequestDefaultTypeInternal;
extern CreateNVMeNamespaceRequestDefaultTypeInternal _CreateNVMeNamespaceRequest_default_instance_;
class CreateNVMeSubsystemRequest;
struct CreateNVMeSubsystemRequestDefaultTypeInternal;
extern CreateNVMeSubsystemRequestDefaultTypeInternal _CreateNVMeSubsystemRequest_default_instance_;
class DeleteNVMeControllerRequest;
struct DeleteNVMeControllerRequestDefaultTypeInternal;
extern DeleteNVMeControllerRequestDefaultTypeInternal _DeleteNVMeControllerRequest_default_instance_;
class DeleteNVMeNamespaceRequest;
struct DeleteNVMeNamespaceRequestDefaultTypeInternal;
extern DeleteNVMeNamespaceRequestDefaultTypeInternal _DeleteNVMeNamespaceRequest_default_instance_;
class DeleteNVMeSubsystemRequest;
struct DeleteNVMeSubsystemRequestDefaultTypeInternal;
extern DeleteNVMeSubsystemRequestDefaultTypeInternal _DeleteNVMeSubsystemRequest_default_instance_;
class GetNVMeControllerRequest;
struct GetNVMeControllerRequestDefaultTypeInternal;
extern GetNVMeControllerRequestDefaultTypeInternal _GetNVMeControllerRequest_default_instance_;
class GetNVMeNamespaceRequest;
struct GetNVMeNamespaceRequestDefaultTypeInternal;
extern GetNVMeNamespaceRequestDefaultTypeInternal _GetNVMeNamespaceRequest_default_instance_;
class GetNVMeSubsystemRequest;
struct GetNVMeSubsystemRequestDefaultTypeInternal;
extern GetNVMeSubsystemRequestDefaultTypeInternal _GetNVMeSubsystemRequest_default_instance_;
class ListNVMeControllerRequest;
struct ListNVMeControllerRequestDefaultTypeInternal;
extern ListNVMeControllerRequestDefaultTypeInternal _ListNVMeControllerRequest_default_instance_;
class ListNVMeControllerResponse;
struct ListNVMeControllerResponseDefaultTypeInternal;
extern ListNVMeControllerResponseDefaultTypeInternal _ListNVMeControllerResponse_default_instance_;
class ListNVMeNamespaceRequest;
struct ListNVMeNamespaceRequestDefaultTypeInternal;
extern ListNVMeNamespaceRequestDefaultTypeInternal _ListNVMeNamespaceRequest_default_instance_;
class ListNVMeNamespaceResponse;
struct ListNVMeNamespaceResponseDefaultTypeInternal;
extern ListNVMeNamespaceResponseDefaultTypeInternal _ListNVMeNamespaceResponse_default_instance_;
class ListNVMeSubsystemRequest;
struct ListNVMeSubsystemRequestDefaultTypeInternal;
extern ListNVMeSubsystemRequestDefaultTypeInternal _ListNVMeSubsystemRequest_default_instance_;
class ListNVMeSubsystemResponse;
struct ListNVMeSubsystemResponseDefaultTypeInternal;
extern ListNVMeSubsystemResponseDefaultTypeInternal _ListNVMeSubsystemResponse_default_instance_;
class NVMeController;
struct NVMeControllerDefaultTypeInternal;
extern NVMeControllerDefaultTypeInternal _NVMeController_default_instance_;
class NVMeControllerSpec;
struct NVMeControllerSpecDefaultTypeInternal;
extern NVMeControllerSpecDefaultTypeInternal _NVMeControllerSpec_default_instance_;
class NVMeControllerStatsRequest;
struct NVMeControllerStatsRequestDefaultTypeInternal;
extern NVMeControllerStatsRequestDefaultTypeInternal _NVMeControllerStatsRequest_default_instance_;
class NVMeControllerStatsResponse;
struct NVMeControllerStatsResponseDefaultTypeInternal;
extern NVMeControllerStatsResponseDefaultTypeInternal _NVMeControllerStatsResponse_default_instance_;
class NVMeControllerStatus;
struct NVMeControllerStatusDefaultTypeInternal;
extern NVMeControllerStatusDefaultTypeInternal _NVMeControllerStatus_default_instance_;
class NVMeNamespace;
struct NVMeNamespaceDefaultTypeInternal;
extern NVMeNamespaceDefaultTypeInternal _NVMeNamespace_default_instance_;
class NVMeNamespaceSpec;
struct NVMeNamespaceSpecDefaultTypeInternal;
extern NVMeNamespaceSpecDefaultTypeInternal _NVMeNamespaceSpec_default_instance_;
class NVMeNamespaceStatsRequest;
struct NVMeNamespaceStatsRequestDefaultTypeInternal;
extern NVMeNamespaceStatsRequestDefaultTypeInternal _NVMeNamespaceStatsRequest_default_instance_;
class NVMeNamespaceStatsResponse;
struct NVMeNamespaceStatsResponseDefaultTypeInternal;
extern NVMeNamespaceStatsResponseDefaultTypeInternal _NVMeNamespaceStatsResponse_default_instance_;
class NVMeNamespaceStatus;
struct NVMeNamespaceStatusDefaultTypeInternal;
extern NVMeNamespaceStatusDefaultTypeInternal _NVMeNamespaceStatus_default_instance_;
class NVMeSubsystem;
struct NVMeSubsystemDefaultTypeInternal;
extern NVMeSubsystemDefaultTypeInternal _NVMeSubsystem_default_instance_;
class NVMeSubsystemSpec;
struct NVMeSubsystemSpecDefaultTypeInternal;
extern NVMeSubsystemSpecDefaultTypeInternal _NVMeSubsystemSpec_default_instance_;
class NVMeSubsystemStatsRequest;
struct NVMeSubsystemStatsRequestDefaultTypeInternal;
extern NVMeSubsystemStatsRequestDefaultTypeInternal _NVMeSubsystemStatsRequest_default_instance_;
class NVMeSubsystemStatsResponse;
struct NVMeSubsystemStatsResponseDefaultTypeInternal;
extern NVMeSubsystemStatsResponseDefaultTypeInternal _NVMeSubsystemStatsResponse_default_instance_;
class NVMeSubsystemStatus;
struct NVMeSubsystemStatusDefaultTypeInternal;
extern NVMeSubsystemStatusDefaultTypeInternal _NVMeSubsystemStatus_default_instance_;
class UpdateNVMeControllerRequest;
struct UpdateNVMeControllerRequestDefaultTypeInternal;
extern UpdateNVMeControllerRequestDefaultTypeInternal _UpdateNVMeControllerRequest_default_instance_;
class UpdateNVMeNamespaceRequest;
struct UpdateNVMeNamespaceRequestDefaultTypeInternal;
extern UpdateNVMeNamespaceRequestDefaultTypeInternal _UpdateNVMeNamespaceRequest_default_instance_;
class UpdateNVMeSubsystemRequest;
struct UpdateNVMeSubsystemRequestDefaultTypeInternal;
extern UpdateNVMeSubsystemRequestDefaultTypeInternal _UpdateNVMeSubsystemRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::CreateNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeControllerResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeControllerResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeNamespaceResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeNamespaceResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeSubsystemResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeSubsystemResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeController* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerSpec>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatus>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespace* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceSpec>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatus>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystem* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemSpec>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatus>(Arena*);
template<> ::opi_api::storage::v1::UpdateNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNVMeSubsystemRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

enum NVMeNamespacePciState : int {
  NV_ME_NAMESPACE_PCI_STATE_UNSPECIFIED = 0,
  NVME_NAMESPACE_PCI_STATE_DISABLED = 1,
  NVME_NAMESPACE_PCI_STATE_ENABLED = 2,
  NVME_NAMESPACE_PCI_STATE_DELETING = 3,
  NVMeNamespacePciState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NVMeNamespacePciState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NVMeNamespacePciState_IsValid(int value);
constexpr NVMeNamespacePciState NVMeNamespacePciState_MIN = NV_ME_NAMESPACE_PCI_STATE_UNSPECIFIED;
constexpr NVMeNamespacePciState NVMeNamespacePciState_MAX = NVME_NAMESPACE_PCI_STATE_DELETING;
constexpr int NVMeNamespacePciState_ARRAYSIZE = NVMeNamespacePciState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciState_descriptor();
template<typename T>
inline const std::string& NVMeNamespacePciState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NVMeNamespacePciState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NVMeNamespacePciState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NVMeNamespacePciState_descriptor(), enum_t_value);
}
inline bool NVMeNamespacePciState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NVMeNamespacePciState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NVMeNamespacePciState>(
    NVMeNamespacePciState_descriptor(), name, value);
}
enum NVMeNamespacePciOperState : int {
  NV_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED = 0,
  NVME_NAMESPACE_PCI_OPER_STATE_ONLINE = 1,
  NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE = 2,
  NVMeNamespacePciOperState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NVMeNamespacePciOperState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NVMeNamespacePciOperState_IsValid(int value);
constexpr NVMeNamespacePciOperState NVMeNamespacePciOperState_MIN = NV_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED;
constexpr NVMeNamespacePciOperState NVMeNamespacePciOperState_MAX = NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE;
constexpr int NVMeNamespacePciOperState_ARRAYSIZE = NVMeNamespacePciOperState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciOperState_descriptor();
template<typename T>
inline const std::string& NVMeNamespacePciOperState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NVMeNamespacePciOperState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NVMeNamespacePciOperState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NVMeNamespacePciOperState_descriptor(), enum_t_value);
}
inline bool NVMeNamespacePciOperState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NVMeNamespacePciOperState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NVMeNamespacePciOperState>(
    NVMeNamespacePciOperState_descriptor(), name, value);
}
// ===================================================================

class NVMeSubsystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystem) */ {
 public:
  inline NVMeSubsystem() : NVMeSubsystem(nullptr) {}
  ~NVMeSubsystem() override;
  explicit constexpr NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystem(const NVMeSubsystem& from);
  NVMeSubsystem(NVMeSubsystem&& from) noexcept
    : NVMeSubsystem() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystem& operator=(const NVMeSubsystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystem& operator=(NVMeSubsystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystem* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystem*>(
               &_NVMeSubsystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NVMeSubsystem& a, NVMeSubsystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystem";
  }
  protected:
  explicit NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NVMeSubsystemSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystemSpec* release_spec();
  ::opi_api::storage::v1::NVMeSubsystemSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NVMeSubsystemSpec* spec);
  private:
  const ::opi_api::storage::v1::NVMeSubsystemSpec& _internal_spec() const;
  ::opi_api::storage::v1::NVMeSubsystemSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NVMeSubsystemSpec* spec);
  ::opi_api::storage::v1::NVMeSubsystemSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NVMeSubsystemStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystemStatus* release_status();
  ::opi_api::storage::v1::NVMeSubsystemStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NVMeSubsystemStatus* status);
  private:
  const ::opi_api::storage::v1::NVMeSubsystemStatus& _internal_status() const;
  ::opi_api::storage::v1::NVMeSubsystemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NVMeSubsystemStatus* status);
  ::opi_api::storage::v1::NVMeSubsystemStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystemSpec* spec_;
  ::opi_api::storage::v1::NVMeSubsystemStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemSpec) */ {
 public:
  inline NVMeSubsystemSpec() : NVMeSubsystemSpec(nullptr) {}
  ~NVMeSubsystemSpec() override;
  explicit constexpr NVMeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemSpec(const NVMeSubsystemSpec& from);
  NVMeSubsystemSpec(NVMeSubsystemSpec&& from) noexcept
    : NVMeSubsystemSpec() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemSpec& operator=(const NVMeSubsystemSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemSpec& operator=(NVMeSubsystemSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemSpec* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemSpec*>(
               &_NVMeSubsystemSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NVMeSubsystemSpec& a, NVMeSubsystemSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemSpec";
  }
  protected:
  explicit NVMeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNqnFieldNumber = 2,
    kSerialNumberFieldNumber = 3,
    kModelNumberFieldNumber = 4,
    kIdFieldNumber = 1,
    kMaxNamespacesFieldNumber = 5,
  };
  // string nqn = 2;
  void clear_nqn();
  const std::string& nqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nqn();
  PROTOBUF_NODISCARD std::string* release_nqn();
  void set_allocated_nqn(std::string* nqn);
  private:
  const std::string& _internal_nqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nqn(const std::string& value);
  std::string* _internal_mutable_nqn();
  public:

  // string serial_number = 3;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string model_number = 4;
  void clear_model_number();
  const std::string& model_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_number();
  PROTOBUF_NODISCARD std::string* release_model_number();
  void set_allocated_model_number(std::string* model_number);
  private:
  const std::string& _internal_model_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_number(const std::string& value);
  std::string* _internal_mutable_model_number();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // int64 max_namespaces = 5;
  void clear_max_namespaces();
  int64_t max_namespaces() const;
  void set_max_namespaces(int64_t value);
  private:
  int64_t _internal_max_namespaces() const;
  void _internal_set_max_namespaces(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nqn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_number_;
  ::opi_api::common::v1::ObjectKey* id_;
  int64_t max_namespaces_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatus) */ {
 public:
  inline NVMeSubsystemStatus() : NVMeSubsystemStatus(nullptr) {}
  ~NVMeSubsystemStatus() override;
  explicit constexpr NVMeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatus(const NVMeSubsystemStatus& from);
  NVMeSubsystemStatus(NVMeSubsystemStatus&& from) noexcept
    : NVMeSubsystemStatus() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatus& operator=(const NVMeSubsystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatus& operator=(NVMeSubsystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatus* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatus*>(
               &_NVMeSubsystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NVMeSubsystemStatus& a, NVMeSubsystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatus";
  }
  protected:
  explicit NVMeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareRevisionFieldNumber = 1,
    kFruGuidFieldNumber = 2,
  };
  // string firmware_revision = 1;
  void clear_firmware_revision();
  const std::string& firmware_revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_revision();
  PROTOBUF_NODISCARD std::string* release_firmware_revision();
  void set_allocated_firmware_revision(std::string* firmware_revision);
  private:
  const std::string& _internal_firmware_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_revision(const std::string& value);
  std::string* _internal_mutable_firmware_revision();
  public:

  // bytes fru_guid = 2;
  void clear_fru_guid();
  const std::string& fru_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fru_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fru_guid();
  PROTOBUF_NODISCARD std::string* release_fru_guid();
  void set_allocated_fru_guid(std::string* fru_guid);
  private:
  const std::string& _internal_fru_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fru_guid(const std::string& value);
  std::string* _internal_mutable_fru_guid();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fru_guid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeController) */ {
 public:
  inline NVMeController() : NVMeController(nullptr) {}
  ~NVMeController() override;
  explicit constexpr NVMeController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeController(const NVMeController& from);
  NVMeController(NVMeController&& from) noexcept
    : NVMeController() {
    *this = ::std::move(from);
  }

  inline NVMeController& operator=(const NVMeController& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeController& operator=(NVMeController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeController& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeController* internal_default_instance() {
    return reinterpret_cast<const NVMeController*>(
               &_NVMeController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NVMeController& a, NVMeController& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeController& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeController";
  }
  protected:
  explicit NVMeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NVMeControllerSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeControllerSpec* release_spec();
  ::opi_api::storage::v1::NVMeControllerSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NVMeControllerSpec* spec);
  private:
  const ::opi_api::storage::v1::NVMeControllerSpec& _internal_spec() const;
  ::opi_api::storage::v1::NVMeControllerSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NVMeControllerSpec* spec);
  ::opi_api::storage::v1::NVMeControllerSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NVMeControllerStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NVMeControllerStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeControllerStatus* release_status();
  ::opi_api::storage::v1::NVMeControllerStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NVMeControllerStatus* status);
  private:
  const ::opi_api::storage::v1::NVMeControllerStatus& _internal_status() const;
  ::opi_api::storage::v1::NVMeControllerStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NVMeControllerStatus* status);
  ::opi_api::storage::v1::NVMeControllerStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeControllerSpec* spec_;
  ::opi_api::storage::v1::NVMeControllerStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerSpec) */ {
 public:
  inline NVMeControllerSpec() : NVMeControllerSpec(nullptr) {}
  ~NVMeControllerSpec() override;
  explicit constexpr NVMeControllerSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerSpec(const NVMeControllerSpec& from);
  NVMeControllerSpec(NVMeControllerSpec&& from) noexcept
    : NVMeControllerSpec() {
    *this = ::std::move(from);
  }

  inline NVMeControllerSpec& operator=(const NVMeControllerSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerSpec& operator=(NVMeControllerSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerSpec* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerSpec*>(
               &_NVMeControllerSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NVMeControllerSpec& a, NVMeControllerSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerSpec";
  }
  protected:
  explicit NVMeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSubsystemIdFieldNumber = 3,
    kPcieIdFieldNumber = 4,
    kNvmeControllerIdFieldNumber = 2,
    kMaxNsqFieldNumber = 5,
    kMaxNcqFieldNumber = 6,
    kSqesFieldNumber = 7,
    kCqesFieldNumber = 8,
    kMaxNamespacesFieldNumber = 9,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
  bool has_pcie_id() const;
  private:
  bool _internal_has_pcie_id() const;
  public:
  void clear_pcie_id();
  const ::opi_api::storage::v1::PciEndpoint& pcie_id() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::PciEndpoint* release_pcie_id();
  ::opi_api::storage::v1::PciEndpoint* mutable_pcie_id();
  void set_allocated_pcie_id(::opi_api::storage::v1::PciEndpoint* pcie_id);
  private:
  const ::opi_api::storage::v1::PciEndpoint& _internal_pcie_id() const;
  ::opi_api::storage::v1::PciEndpoint* _internal_mutable_pcie_id();
  public:
  void unsafe_arena_set_allocated_pcie_id(
      ::opi_api::storage::v1::PciEndpoint* pcie_id);
  ::opi_api::storage::v1::PciEndpoint* unsafe_arena_release_pcie_id();

  // int32 nvme_controller_id = 2;
  void clear_nvme_controller_id();
  int32_t nvme_controller_id() const;
  void set_nvme_controller_id(int32_t value);
  private:
  int32_t _internal_nvme_controller_id() const;
  void _internal_set_nvme_controller_id(int32_t value);
  public:

  // int32 max_nsq = 5;
  void clear_max_nsq();
  int32_t max_nsq() const;
  void set_max_nsq(int32_t value);
  private:
  int32_t _internal_max_nsq() const;
  void _internal_set_max_nsq(int32_t value);
  public:

  // int32 max_ncq = 6;
  void clear_max_ncq();
  int32_t max_ncq() const;
  void set_max_ncq(int32_t value);
  private:
  int32_t _internal_max_ncq() const;
  void _internal_set_max_ncq(int32_t value);
  public:

  // int32 sqes = 7;
  void clear_sqes();
  int32_t sqes() const;
  void set_sqes(int32_t value);
  private:
  int32_t _internal_sqes() const;
  void _internal_set_sqes(int32_t value);
  public:

  // int32 cqes = 8;
  void clear_cqes();
  int32_t cqes() const;
  void set_cqes(int32_t value);
  private:
  int32_t _internal_cqes() const;
  void _internal_set_cqes(int32_t value);
  public:

  // int32 max_namespaces = 9;
  void clear_max_namespaces();
  int32_t max_namespaces() const;
  void set_max_namespaces(int32_t value);
  private:
  int32_t _internal_max_namespaces() const;
  void _internal_set_max_namespaces(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::storage::v1::PciEndpoint* pcie_id_;
  int32_t nvme_controller_id_;
  int32_t max_nsq_;
  int32_t max_ncq_;
  int32_t sqes_;
  int32_t cqes_;
  int32_t max_namespaces_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatus) */ {
 public:
  inline NVMeControllerStatus() : NVMeControllerStatus(nullptr) {}
  ~NVMeControllerStatus() override;
  explicit constexpr NVMeControllerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatus(const NVMeControllerStatus& from);
  NVMeControllerStatus(NVMeControllerStatus&& from) noexcept
    : NVMeControllerStatus() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatus& operator=(const NVMeControllerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatus& operator=(NVMeControllerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatus* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatus*>(
               &_NVMeControllerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NVMeControllerStatus& a, NVMeControllerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatus";
  }
  protected:
  explicit NVMeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveFieldNumber = 1,
  };
  // bool active = 1;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespace) */ {
 public:
  inline NVMeNamespace() : NVMeNamespace(nullptr) {}
  ~NVMeNamespace() override;
  explicit constexpr NVMeNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespace(const NVMeNamespace& from);
  NVMeNamespace(NVMeNamespace&& from) noexcept
    : NVMeNamespace() {
    *this = ::std::move(from);
  }

  inline NVMeNamespace& operator=(const NVMeNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespace& operator=(NVMeNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespace* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespace*>(
               &_NVMeNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NVMeNamespace& a, NVMeNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespace";
  }
  protected:
  explicit NVMeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NVMeNamespaceSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespaceSpec* release_spec();
  ::opi_api::storage::v1::NVMeNamespaceSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NVMeNamespaceSpec* spec);
  private:
  const ::opi_api::storage::v1::NVMeNamespaceSpec& _internal_spec() const;
  ::opi_api::storage::v1::NVMeNamespaceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NVMeNamespaceSpec* spec);
  ::opi_api::storage::v1::NVMeNamespaceSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NVMeNamespaceStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespaceStatus* release_status();
  ::opi_api::storage::v1::NVMeNamespaceStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NVMeNamespaceStatus* status);
  private:
  const ::opi_api::storage::v1::NVMeNamespaceStatus& _internal_status() const;
  ::opi_api::storage::v1::NVMeNamespaceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NVMeNamespaceStatus* status);
  ::opi_api::storage::v1::NVMeNamespaceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespaceSpec* spec_;
  ::opi_api::storage::v1::NVMeNamespaceStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceSpec) */ {
 public:
  inline NVMeNamespaceSpec() : NVMeNamespaceSpec(nullptr) {}
  ~NVMeNamespaceSpec() override;
  explicit constexpr NVMeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceSpec(const NVMeNamespaceSpec& from);
  NVMeNamespaceSpec(NVMeNamespaceSpec&& from) noexcept
    : NVMeNamespaceSpec() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceSpec& operator=(const NVMeNamespaceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceSpec& operator=(NVMeNamespaceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceSpec* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceSpec*>(
               &_NVMeNamespaceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NVMeNamespaceSpec& a, NVMeNamespaceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceSpec";
  }
  protected:
  explicit NVMeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNguidFieldNumber = 7,
    kIdFieldNumber = 1,
    kSubsystemIdFieldNumber = 2,
    kControllerIdFieldNumber = 3,
    kUuidFieldNumber = 9,
    kVolumeIdFieldNumber = 10,
    kBlockSizeFieldNumber = 5,
    kBlocksCountFieldNumber = 6,
    kHostNsidFieldNumber = 4,
    kOptimalWriteSizeFieldNumber = 11,
    kEui64FieldNumber = 8,
    kPrefWriteGranularityFieldNumber = 12,
  };
  // string nguid = 7;
  void clear_nguid();
  const std::string& nguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nguid();
  PROTOBUF_NODISCARD std::string* release_nguid();
  void set_allocated_nguid(std::string* nguid);
  private:
  const std::string& _internal_nguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nguid(const std::string& value);
  std::string* _internal_mutable_nguid();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // .opi_api.common.v1.Uuid uuid = 9;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::opi_api::common::v1::Uuid& uuid() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::Uuid* release_uuid();
  ::opi_api::common::v1::Uuid* mutable_uuid();
  void set_allocated_uuid(::opi_api::common::v1::Uuid* uuid);
  private:
  const ::opi_api::common::v1::Uuid& _internal_uuid() const;
  ::opi_api::common::v1::Uuid* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::opi_api::common::v1::Uuid* uuid);
  ::opi_api::common::v1::Uuid* unsafe_arena_release_uuid();

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  bool has_volume_id() const;
  private:
  bool _internal_has_volume_id() const;
  public:
  void clear_volume_id();
  const ::opi_api::common::v1::ObjectKey& volume_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_volume_id();
  ::opi_api::common::v1::ObjectKey* mutable_volume_id();
  void set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_volume_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_volume_id();
  public:
  void unsafe_arena_set_allocated_volume_id(
      ::opi_api::common::v1::ObjectKey* volume_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_volume_id();

  // int64 block_size = 5;
  void clear_block_size();
  int64_t block_size() const;
  void set_block_size(int64_t value);
  private:
  int64_t _internal_block_size() const;
  void _internal_set_block_size(int64_t value);
  public:

  // int64 blocks_count = 6;
  void clear_blocks_count();
  int64_t blocks_count() const;
  void set_blocks_count(int64_t value);
  private:
  int64_t _internal_blocks_count() const;
  void _internal_set_blocks_count(int64_t value);
  public:

  // int32 host_nsid = 4;
  void clear_host_nsid();
  int32_t host_nsid() const;
  void set_host_nsid(int32_t value);
  private:
  int32_t _internal_host_nsid() const;
  void _internal_set_host_nsid(int32_t value);
  public:

  // int32 optimal_write_size = 11;
  void clear_optimal_write_size();
  int32_t optimal_write_size() const;
  void set_optimal_write_size(int32_t value);
  private:
  int32_t _internal_optimal_write_size() const;
  void _internal_set_optimal_write_size(int32_t value);
  public:

  // int64 eui64 = 8;
  void clear_eui64();
  int64_t eui64() const;
  void set_eui64(int64_t value);
  private:
  int64_t _internal_eui64() const;
  void _internal_set_eui64(int64_t value);
  public:

  // int32 pref_write_granularity = 12;
  void clear_pref_write_granularity();
  int32_t pref_write_granularity() const;
  void set_pref_write_granularity(int32_t value);
  private:
  int32_t _internal_pref_write_granularity() const;
  void _internal_set_pref_write_granularity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nguid_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  ::opi_api::common::v1::Uuid* uuid_;
  ::opi_api::common::v1::ObjectKey* volume_id_;
  int64_t block_size_;
  int64_t blocks_count_;
  int32_t host_nsid_;
  int32_t optimal_write_size_;
  int64_t eui64_;
  int32_t pref_write_granularity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatus) */ {
 public:
  inline NVMeNamespaceStatus() : NVMeNamespaceStatus(nullptr) {}
  ~NVMeNamespaceStatus() override;
  explicit constexpr NVMeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatus(const NVMeNamespaceStatus& from);
  NVMeNamespaceStatus(NVMeNamespaceStatus&& from) noexcept
    : NVMeNamespaceStatus() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatus& operator=(const NVMeNamespaceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatus& operator=(NVMeNamespaceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatus* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatus*>(
               &_NVMeNamespaceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NVMeNamespaceStatus& a, NVMeNamespaceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatus";
  }
  protected:
  explicit NVMeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPciStateFieldNumber = 1,
    kPciOperStateFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
  void clear_pci_state();
  ::opi_api::storage::v1::NVMeNamespacePciState pci_state() const;
  void set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value);
  private:
  ::opi_api::storage::v1::NVMeNamespacePciState _internal_pci_state() const;
  void _internal_set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value);
  public:

  // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
  void clear_pci_oper_state();
  ::opi_api::storage::v1::NVMeNamespacePciOperState pci_oper_state() const;
  void set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value);
  private:
  ::opi_api::storage::v1::NVMeNamespacePciOperState _internal_pci_oper_state() const;
  void _internal_set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int pci_state_;
  int pci_oper_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class CreateNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNVMeSubsystemRequest) */ {
 public:
  inline CreateNVMeSubsystemRequest() : CreateNVMeSubsystemRequest(nullptr) {}
  ~CreateNVMeSubsystemRequest() override;
  explicit constexpr CreateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNVMeSubsystemRequest(const CreateNVMeSubsystemRequest& from);
  CreateNVMeSubsystemRequest(CreateNVMeSubsystemRequest&& from) noexcept
    : CreateNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline CreateNVMeSubsystemRequest& operator=(const CreateNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNVMeSubsystemRequest& operator=(CreateNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNVMeSubsystemRequest*>(
               &_CreateNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateNVMeSubsystemRequest& a, CreateNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNVMeSubsystemRequest";
  }
  protected:
  explicit CreateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  bool has_subsystem() const;
  private:
  bool _internal_has_subsystem() const;
  public:
  void clear_subsystem();
  const ::opi_api::storage::v1::NVMeSubsystem& subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystem* release_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_subsystem();
  void set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem);
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_subsystem() const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_mutable_subsystem();
  public:
  void unsafe_arena_set_allocated_subsystem(
      ::opi_api::storage::v1::NVMeSubsystem* subsystem);
  ::opi_api::storage::v1::NVMeSubsystem* unsafe_arena_release_subsystem();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystem* subsystem_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class DeleteNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNVMeSubsystemRequest) */ {
 public:
  inline DeleteNVMeSubsystemRequest() : DeleteNVMeSubsystemRequest(nullptr) {}
  ~DeleteNVMeSubsystemRequest() override;
  explicit constexpr DeleteNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNVMeSubsystemRequest(const DeleteNVMeSubsystemRequest& from);
  DeleteNVMeSubsystemRequest(DeleteNVMeSubsystemRequest&& from) noexcept
    : DeleteNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNVMeSubsystemRequest& operator=(const DeleteNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNVMeSubsystemRequest& operator=(DeleteNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNVMeSubsystemRequest*>(
               &_DeleteNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteNVMeSubsystemRequest& a, DeleteNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNVMeSubsystemRequest";
  }
  protected:
  explicit DeleteNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class UpdateNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNVMeSubsystemRequest) */ {
 public:
  inline UpdateNVMeSubsystemRequest() : UpdateNVMeSubsystemRequest(nullptr) {}
  ~UpdateNVMeSubsystemRequest() override;
  explicit constexpr UpdateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNVMeSubsystemRequest(const UpdateNVMeSubsystemRequest& from);
  UpdateNVMeSubsystemRequest(UpdateNVMeSubsystemRequest&& from) noexcept
    : UpdateNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNVMeSubsystemRequest& operator=(const UpdateNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNVMeSubsystemRequest& operator=(UpdateNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNVMeSubsystemRequest*>(
               &_UpdateNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateNVMeSubsystemRequest& a, UpdateNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNVMeSubsystemRequest";
  }
  protected:
  explicit UpdateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  bool has_subsystem() const;
  private:
  bool _internal_has_subsystem() const;
  public:
  void clear_subsystem();
  const ::opi_api::storage::v1::NVMeSubsystem& subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystem* release_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_subsystem();
  void set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem);
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_subsystem() const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_mutable_subsystem();
  public:
  void unsafe_arena_set_allocated_subsystem(
      ::opi_api::storage::v1::NVMeSubsystem* subsystem);
  ::opi_api::storage::v1::NVMeSubsystem* unsafe_arena_release_subsystem();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystem* subsystem_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeSubsystemRequest) */ {
 public:
  inline ListNVMeSubsystemRequest() : ListNVMeSubsystemRequest(nullptr) {}
  ~ListNVMeSubsystemRequest() override;
  explicit constexpr ListNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeSubsystemRequest(const ListNVMeSubsystemRequest& from);
  ListNVMeSubsystemRequest(ListNVMeSubsystemRequest&& from) noexcept
    : ListNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline ListNVMeSubsystemRequest& operator=(const ListNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeSubsystemRequest& operator=(ListNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const ListNVMeSubsystemRequest*>(
               &_ListNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListNVMeSubsystemRequest& a, ListNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeSubsystemRequest";
  }
  protected:
  explicit ListNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 1;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeSubsystemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeSubsystemResponse) */ {
 public:
  inline ListNVMeSubsystemResponse() : ListNVMeSubsystemResponse(nullptr) {}
  ~ListNVMeSubsystemResponse() override;
  explicit constexpr ListNVMeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeSubsystemResponse(const ListNVMeSubsystemResponse& from);
  ListNVMeSubsystemResponse(ListNVMeSubsystemResponse&& from) noexcept
    : ListNVMeSubsystemResponse() {
    *this = ::std::move(from);
  }

  inline ListNVMeSubsystemResponse& operator=(const ListNVMeSubsystemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeSubsystemResponse& operator=(ListNVMeSubsystemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeSubsystemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeSubsystemResponse* internal_default_instance() {
    return reinterpret_cast<const ListNVMeSubsystemResponse*>(
               &_ListNVMeSubsystemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListNVMeSubsystemResponse& a, ListNVMeSubsystemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeSubsystemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeSubsystemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeSubsystemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeSubsystemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeSubsystemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeSubsystemResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeSubsystemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeSubsystemResponse";
  }
  protected:
  explicit ListNVMeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NVMeSubsystem subsystems = 1;
  int subsystems_size() const;
  private:
  int _internal_subsystems_size() const;
  public:
  void clear_subsystems();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_subsystems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >*
      mutable_subsystems();
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_subsystems(int index) const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_add_subsystems();
  public:
  const ::opi_api::storage::v1::NVMeSubsystem& subsystems(int index) const;
  ::opi_api::storage::v1::NVMeSubsystem* add_subsystems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >&
      subsystems() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeSubsystemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem > subsystems_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class GetNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNVMeSubsystemRequest) */ {
 public:
  inline GetNVMeSubsystemRequest() : GetNVMeSubsystemRequest(nullptr) {}
  ~GetNVMeSubsystemRequest() override;
  explicit constexpr GetNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNVMeSubsystemRequest(const GetNVMeSubsystemRequest& from);
  GetNVMeSubsystemRequest(GetNVMeSubsystemRequest&& from) noexcept
    : GetNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline GetNVMeSubsystemRequest& operator=(const GetNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNVMeSubsystemRequest& operator=(GetNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const GetNVMeSubsystemRequest*>(
               &_GetNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetNVMeSubsystemRequest& a, GetNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNVMeSubsystemRequest";
  }
  protected:
  explicit GetNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatsRequest) */ {
 public:
  inline NVMeSubsystemStatsRequest() : NVMeSubsystemStatsRequest(nullptr) {}
  ~NVMeSubsystemStatsRequest() override;
  explicit constexpr NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatsRequest(const NVMeSubsystemStatsRequest& from);
  NVMeSubsystemStatsRequest(NVMeSubsystemStatsRequest&& from) noexcept
    : NVMeSubsystemStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatsRequest& operator=(const NVMeSubsystemStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatsRequest& operator=(NVMeSubsystemStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatsRequest*>(
               &_NVMeSubsystemStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NVMeSubsystemStatsRequest& a, NVMeSubsystemStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatsRequest";
  }
  protected:
  explicit NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatsResponse) */ {
 public:
  inline NVMeSubsystemStatsResponse() : NVMeSubsystemStatsResponse(nullptr) {}
  ~NVMeSubsystemStatsResponse() override;
  explicit constexpr NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatsResponse(const NVMeSubsystemStatsResponse& from);
  NVMeSubsystemStatsResponse(NVMeSubsystemStatsResponse&& from) noexcept
    : NVMeSubsystemStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatsResponse& operator=(const NVMeSubsystemStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatsResponse& operator=(NVMeSubsystemStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatsResponse*>(
               &_NVMeSubsystemStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NVMeSubsystemStatsResponse& a, NVMeSubsystemStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatsResponse";
  }
  protected:
  explicit NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // string stats = 1;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class CreateNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNVMeControllerRequest) */ {
 public:
  inline CreateNVMeControllerRequest() : CreateNVMeControllerRequest(nullptr) {}
  ~CreateNVMeControllerRequest() override;
  explicit constexpr CreateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNVMeControllerRequest(const CreateNVMeControllerRequest& from);
  CreateNVMeControllerRequest(CreateNVMeControllerRequest&& from) noexcept
    : CreateNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline CreateNVMeControllerRequest& operator=(const CreateNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNVMeControllerRequest& operator=(CreateNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNVMeControllerRequest*>(
               &_CreateNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateNVMeControllerRequest& a, CreateNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNVMeControllerRequest";
  }
  protected:
  explicit CreateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeController controller = 1;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::opi_api::storage::v1::NVMeController& controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeController* release_controller();
  ::opi_api::storage::v1::NVMeController* mutable_controller();
  void set_allocated_controller(::opi_api::storage::v1::NVMeController* controller);
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_controller() const;
  ::opi_api::storage::v1::NVMeController* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::opi_api::storage::v1::NVMeController* controller);
  ::opi_api::storage::v1::NVMeController* unsafe_arena_release_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeController* controller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class DeleteNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNVMeControllerRequest) */ {
 public:
  inline DeleteNVMeControllerRequest() : DeleteNVMeControllerRequest(nullptr) {}
  ~DeleteNVMeControllerRequest() override;
  explicit constexpr DeleteNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNVMeControllerRequest(const DeleteNVMeControllerRequest& from);
  DeleteNVMeControllerRequest(DeleteNVMeControllerRequest&& from) noexcept
    : DeleteNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNVMeControllerRequest& operator=(const DeleteNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNVMeControllerRequest& operator=(DeleteNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNVMeControllerRequest*>(
               &_DeleteNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteNVMeControllerRequest& a, DeleteNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNVMeControllerRequest";
  }
  protected:
  explicit DeleteNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey controller_id = 1;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class UpdateNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNVMeControllerRequest) */ {
 public:
  inline UpdateNVMeControllerRequest() : UpdateNVMeControllerRequest(nullptr) {}
  ~UpdateNVMeControllerRequest() override;
  explicit constexpr UpdateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNVMeControllerRequest(const UpdateNVMeControllerRequest& from);
  UpdateNVMeControllerRequest(UpdateNVMeControllerRequest&& from) noexcept
    : UpdateNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNVMeControllerRequest& operator=(const UpdateNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNVMeControllerRequest& operator=(UpdateNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNVMeControllerRequest*>(
               &_UpdateNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateNVMeControllerRequest& a, UpdateNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNVMeControllerRequest";
  }
  protected:
  explicit UpdateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeController controller = 1;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::opi_api::storage::v1::NVMeController& controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeController* release_controller();
  ::opi_api::storage::v1::NVMeController* mutable_controller();
  void set_allocated_controller(::opi_api::storage::v1::NVMeController* controller);
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_controller() const;
  ::opi_api::storage::v1::NVMeController* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::opi_api::storage::v1::NVMeController* controller);
  ::opi_api::storage::v1::NVMeController* unsafe_arena_release_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeController* controller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeControllerRequest) */ {
 public:
  inline ListNVMeControllerRequest() : ListNVMeControllerRequest(nullptr) {}
  ~ListNVMeControllerRequest() override;
  explicit constexpr ListNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeControllerRequest(const ListNVMeControllerRequest& from);
  ListNVMeControllerRequest(ListNVMeControllerRequest&& from) noexcept
    : ListNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline ListNVMeControllerRequest& operator=(const ListNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeControllerRequest& operator=(ListNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const ListNVMeControllerRequest*>(
               &_ListNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListNVMeControllerRequest& a, ListNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeControllerRequest";
  }
  protected:
  explicit ListNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 3,
    kSubsystemIdFieldNumber = 1,
    kPageSizeFieldNumber = 2,
  };
  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeControllerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeControllerResponse) */ {
 public:
  inline ListNVMeControllerResponse() : ListNVMeControllerResponse(nullptr) {}
  ~ListNVMeControllerResponse() override;
  explicit constexpr ListNVMeControllerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeControllerResponse(const ListNVMeControllerResponse& from);
  ListNVMeControllerResponse(ListNVMeControllerResponse&& from) noexcept
    : ListNVMeControllerResponse() {
    *this = ::std::move(from);
  }

  inline ListNVMeControllerResponse& operator=(const ListNVMeControllerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeControllerResponse& operator=(ListNVMeControllerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeControllerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeControllerResponse* internal_default_instance() {
    return reinterpret_cast<const ListNVMeControllerResponse*>(
               &_ListNVMeControllerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListNVMeControllerResponse& a, ListNVMeControllerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeControllerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeControllerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeControllerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeControllerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeControllerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeControllerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeControllerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeControllerResponse";
  }
  protected:
  explicit ListNVMeControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllersFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NVMeController controllers = 1;
  int controllers_size() const;
  private:
  int _internal_controllers_size() const;
  public:
  void clear_controllers();
  ::opi_api::storage::v1::NVMeController* mutable_controllers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >*
      mutable_controllers();
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_controllers(int index) const;
  ::opi_api::storage::v1::NVMeController* _internal_add_controllers();
  public:
  const ::opi_api::storage::v1::NVMeController& controllers(int index) const;
  ::opi_api::storage::v1::NVMeController* add_controllers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >&
      controllers() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeControllerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController > controllers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class GetNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNVMeControllerRequest) */ {
 public:
  inline GetNVMeControllerRequest() : GetNVMeControllerRequest(nullptr) {}
  ~GetNVMeControllerRequest() override;
  explicit constexpr GetNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNVMeControllerRequest(const GetNVMeControllerRequest& from);
  GetNVMeControllerRequest(GetNVMeControllerRequest&& from) noexcept
    : GetNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline GetNVMeControllerRequest& operator=(const GetNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNVMeControllerRequest& operator=(GetNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const GetNVMeControllerRequest*>(
               &_GetNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetNVMeControllerRequest& a, GetNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNVMeControllerRequest";
  }
  protected:
  explicit GetNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey controller_id = 1;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatsRequest) */ {
 public:
  inline NVMeControllerStatsRequest() : NVMeControllerStatsRequest(nullptr) {}
  ~NVMeControllerStatsRequest() override;
  explicit constexpr NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatsRequest(const NVMeControllerStatsRequest& from);
  NVMeControllerStatsRequest(NVMeControllerStatsRequest&& from) noexcept
    : NVMeControllerStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatsRequest& operator=(const NVMeControllerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatsRequest& operator=(NVMeControllerStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatsRequest*>(
               &_NVMeControllerStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NVMeControllerStatsRequest& a, NVMeControllerStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatsRequest";
  }
  protected:
  explicit NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatsResponse) */ {
 public:
  inline NVMeControllerStatsResponse() : NVMeControllerStatsResponse(nullptr) {}
  ~NVMeControllerStatsResponse() override;
  explicit constexpr NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatsResponse(const NVMeControllerStatsResponse& from);
  NVMeControllerStatsResponse(NVMeControllerStatsResponse&& from) noexcept
    : NVMeControllerStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatsResponse& operator=(const NVMeControllerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatsResponse& operator=(NVMeControllerStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatsResponse*>(
               &_NVMeControllerStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(NVMeControllerStatsResponse& a, NVMeControllerStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatsResponse";
  }
  protected:
  explicit NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string stats = 2;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class CreateNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNVMeNamespaceRequest) */ {
 public:
  inline CreateNVMeNamespaceRequest() : CreateNVMeNamespaceRequest(nullptr) {}
  ~CreateNVMeNamespaceRequest() override;
  explicit constexpr CreateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNVMeNamespaceRequest(const CreateNVMeNamespaceRequest& from);
  CreateNVMeNamespaceRequest(CreateNVMeNamespaceRequest&& from) noexcept
    : CreateNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline CreateNVMeNamespaceRequest& operator=(const CreateNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNVMeNamespaceRequest& operator=(CreateNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNVMeNamespaceRequest*>(
               &_CreateNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateNVMeNamespaceRequest& a, CreateNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNVMeNamespaceRequest";
  }
  protected:
  explicit CreateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::opi_api::storage::v1::NVMeNamespace& namespace_() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespace* release_namespace_();
  ::opi_api::storage::v1::NVMeNamespace* mutable_namespace_();
  void set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_);
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_namespace_() const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::opi_api::storage::v1::NVMeNamespace* namespace_);
  ::opi_api::storage::v1::NVMeNamespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class DeleteNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNVMeNamespaceRequest) */ {
 public:
  inline DeleteNVMeNamespaceRequest() : DeleteNVMeNamespaceRequest(nullptr) {}
  ~DeleteNVMeNamespaceRequest() override;
  explicit constexpr DeleteNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNVMeNamespaceRequest(const DeleteNVMeNamespaceRequest& from);
  DeleteNVMeNamespaceRequest(DeleteNVMeNamespaceRequest&& from) noexcept
    : DeleteNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNVMeNamespaceRequest& operator=(const DeleteNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNVMeNamespaceRequest& operator=(DeleteNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNVMeNamespaceRequest*>(
               &_DeleteNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DeleteNVMeNamespaceRequest& a, DeleteNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNVMeNamespaceRequest";
  }
  protected:
  explicit DeleteNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class UpdateNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNVMeNamespaceRequest) */ {
 public:
  inline UpdateNVMeNamespaceRequest() : UpdateNVMeNamespaceRequest(nullptr) {}
  ~UpdateNVMeNamespaceRequest() override;
  explicit constexpr UpdateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNVMeNamespaceRequest(const UpdateNVMeNamespaceRequest& from);
  UpdateNVMeNamespaceRequest(UpdateNVMeNamespaceRequest&& from) noexcept
    : UpdateNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNVMeNamespaceRequest& operator=(const UpdateNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNVMeNamespaceRequest& operator=(UpdateNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNVMeNamespaceRequest*>(
               &_UpdateNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateNVMeNamespaceRequest& a, UpdateNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNVMeNamespaceRequest";
  }
  protected:
  explicit UpdateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::opi_api::storage::v1::NVMeNamespace& namespace_() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespace* release_namespace_();
  ::opi_api::storage::v1::NVMeNamespace* mutable_namespace_();
  void set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_);
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_namespace_() const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::opi_api::storage::v1::NVMeNamespace* namespace_);
  ::opi_api::storage::v1::NVMeNamespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeNamespaceRequest) */ {
 public:
  inline ListNVMeNamespaceRequest() : ListNVMeNamespaceRequest(nullptr) {}
  ~ListNVMeNamespaceRequest() override;
  explicit constexpr ListNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeNamespaceRequest(const ListNVMeNamespaceRequest& from);
  ListNVMeNamespaceRequest(ListNVMeNamespaceRequest&& from) noexcept
    : ListNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline ListNVMeNamespaceRequest& operator=(const ListNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeNamespaceRequest& operator=(ListNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const ListNVMeNamespaceRequest*>(
               &_ListNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListNVMeNamespaceRequest& a, ListNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeNamespaceRequest";
  }
  protected:
  explicit ListNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 4,
    kSubsystemIdFieldNumber = 1,
    kControllerIdFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeNamespaceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeNamespaceResponse) */ {
 public:
  inline ListNVMeNamespaceResponse() : ListNVMeNamespaceResponse(nullptr) {}
  ~ListNVMeNamespaceResponse() override;
  explicit constexpr ListNVMeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeNamespaceResponse(const ListNVMeNamespaceResponse& from);
  ListNVMeNamespaceResponse(ListNVMeNamespaceResponse&& from) noexcept
    : ListNVMeNamespaceResponse() {
    *this = ::std::move(from);
  }

  inline ListNVMeNamespaceResponse& operator=(const ListNVMeNamespaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeNamespaceResponse& operator=(ListNVMeNamespaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeNamespaceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeNamespaceResponse* internal_default_instance() {
    return reinterpret_cast<const ListNVMeNamespaceResponse*>(
               &_ListNVMeNamespaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ListNVMeNamespaceResponse& a, ListNVMeNamespaceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeNamespaceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeNamespaceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeNamespaceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeNamespaceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeNamespaceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeNamespaceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeNamespaceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeNamespaceResponse";
  }
  protected:
  explicit ListNVMeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NVMeNamespace namespaces = 1;
  int namespaces_size() const;
  private:
  int _internal_namespaces_size() const;
  public:
  void clear_namespaces();
  ::opi_api::storage::v1::NVMeNamespace* mutable_namespaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >*
      mutable_namespaces();
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_namespaces(int index) const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_add_namespaces();
  public:
  const ::opi_api::storage::v1::NVMeNamespace& namespaces(int index) const;
  ::opi_api::storage::v1::NVMeNamespace* add_namespaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >&
      namespaces() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeNamespaceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace > namespaces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class GetNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNVMeNamespaceRequest) */ {
 public:
  inline GetNVMeNamespaceRequest() : GetNVMeNamespaceRequest(nullptr) {}
  ~GetNVMeNamespaceRequest() override;
  explicit constexpr GetNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNVMeNamespaceRequest(const GetNVMeNamespaceRequest& from);
  GetNVMeNamespaceRequest(GetNVMeNamespaceRequest&& from) noexcept
    : GetNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline GetNVMeNamespaceRequest& operator=(const GetNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNVMeNamespaceRequest& operator=(GetNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetNVMeNamespaceRequest*>(
               &_GetNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetNVMeNamespaceRequest& a, GetNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNVMeNamespaceRequest";
  }
  protected:
  explicit GetNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatsRequest) */ {
 public:
  inline NVMeNamespaceStatsRequest() : NVMeNamespaceStatsRequest(nullptr) {}
  ~NVMeNamespaceStatsRequest() override;
  explicit constexpr NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatsRequest(const NVMeNamespaceStatsRequest& from);
  NVMeNamespaceStatsRequest(NVMeNamespaceStatsRequest&& from) noexcept
    : NVMeNamespaceStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatsRequest& operator=(const NVMeNamespaceStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatsRequest& operator=(NVMeNamespaceStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatsRequest*>(
               &_NVMeNamespaceStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NVMeNamespaceStatsRequest& a, NVMeNamespaceStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatsRequest";
  }
  protected:
  explicit NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatsResponse) */ {
 public:
  inline NVMeNamespaceStatsResponse() : NVMeNamespaceStatsResponse(nullptr) {}
  ~NVMeNamespaceStatsResponse() override;
  explicit constexpr NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatsResponse(const NVMeNamespaceStatsResponse& from);
  NVMeNamespaceStatsResponse(NVMeNamespaceStatsResponse&& from) noexcept
    : NVMeNamespaceStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatsResponse& operator=(const NVMeNamespaceStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatsResponse& operator=(NVMeNamespaceStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatsResponse*>(
               &_NVMeNamespaceStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(NVMeNamespaceStatsResponse& a, NVMeNamespaceStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatsResponse";
  }
  protected:
  explicit NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string stats = 2;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NVMeSubsystem

// .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
inline bool NVMeSubsystem::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NVMeSubsystem::has_spec() const {
  return _internal_has_spec();
}
inline void NVMeSubsystem::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystemSpec& NVMeSubsystem::_internal_spec() const {
  const ::opi_api::storage::v1::NVMeSubsystemSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystemSpec&>(
      ::opi_api::storage::v1::_NVMeSubsystemSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystemSpec& NVMeSubsystem::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.spec)
  return _internal_spec();
}
inline void NVMeSubsystem::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NVMeSubsystemSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystem.spec)
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::release_spec() {
  
  ::opi_api::storage::v1::NVMeSubsystemSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.spec)
  
  ::opi_api::storage::v1::NVMeSubsystemSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::mutable_spec() {
  ::opi_api::storage::v1::NVMeSubsystemSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.spec)
  return _msg;
}
inline void NVMeSubsystem::set_allocated_spec(::opi_api::storage::v1::NVMeSubsystemSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystemSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.spec)
}

// .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
inline bool NVMeSubsystem::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NVMeSubsystem::has_status() const {
  return _internal_has_status();
}
inline void NVMeSubsystem::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystemStatus& NVMeSubsystem::_internal_status() const {
  const ::opi_api::storage::v1::NVMeSubsystemStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystemStatus&>(
      ::opi_api::storage::v1::_NVMeSubsystemStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystemStatus& NVMeSubsystem::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.status)
  return _internal_status();
}
inline void NVMeSubsystem::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NVMeSubsystemStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystem.status)
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::release_status() {
  
  ::opi_api::storage::v1::NVMeSubsystemStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.status)
  
  ::opi_api::storage::v1::NVMeSubsystemStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::mutable_status() {
  ::opi_api::storage::v1::NVMeSubsystemStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.status)
  return _msg;
}
inline void NVMeSubsystem::set_allocated_status(::opi_api::storage::v1::NVMeSubsystemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystemStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.status)
}

// -------------------------------------------------------------------

// NVMeSubsystemSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeSubsystemSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeSubsystemSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.id)
  return _internal_id();
}
inline void NVMeSubsystemSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.id)
  return _msg;
}
inline void NVMeSubsystemSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.id)
}

// string nqn = 2;
inline void NVMeSubsystemSpec::clear_nqn() {
  nqn_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemSpec::nqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
  return _internal_nqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemSpec::set_nqn(ArgT0&& arg0, ArgT... args) {
 
 nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
}
inline std::string* NVMeSubsystemSpec::mutable_nqn() {
  std::string* _s = _internal_mutable_nqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
  return _s;
}
inline const std::string& NVMeSubsystemSpec::_internal_nqn() const {
  return nqn_.Get();
}
inline void NVMeSubsystemSpec::_internal_set_nqn(const std::string& value) {
  
  nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::_internal_mutable_nqn() {
  
  return nqn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::release_nqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
  return nqn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemSpec::set_allocated_nqn(std::string* nqn) {
  if (nqn != nullptr) {
    
  } else {
    
  }
  nqn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nqn,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nqn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
}

// string serial_number = 3;
inline void NVMeSubsystemSpec::clear_serial_number() {
  serial_number_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemSpec::serial_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemSpec::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
}
inline std::string* NVMeSubsystemSpec::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
  return _s;
}
inline const std::string& NVMeSubsystemSpec::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void NVMeSubsystemSpec::_internal_set_serial_number(const std::string& value) {
  
  serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::_internal_mutable_serial_number() {
  
  return serial_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::release_serial_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
  return serial_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemSpec::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  serial_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
}

// string model_number = 4;
inline void NVMeSubsystemSpec::clear_model_number() {
  model_number_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemSpec::model_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
  return _internal_model_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemSpec::set_model_number(ArgT0&& arg0, ArgT... args) {
 
 model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
}
inline std::string* NVMeSubsystemSpec::mutable_model_number() {
  std::string* _s = _internal_mutable_model_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
  return _s;
}
inline const std::string& NVMeSubsystemSpec::_internal_model_number() const {
  return model_number_.Get();
}
inline void NVMeSubsystemSpec::_internal_set_model_number(const std::string& value) {
  
  model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::_internal_mutable_model_number() {
  
  return model_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::release_model_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
  return model_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemSpec::set_allocated_model_number(std::string* model_number) {
  if (model_number != nullptr) {
    
  } else {
    
  }
  model_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
}

// int64 max_namespaces = 5;
inline void NVMeSubsystemSpec::clear_max_namespaces() {
  max_namespaces_ = int64_t{0};
}
inline int64_t NVMeSubsystemSpec::_internal_max_namespaces() const {
  return max_namespaces_;
}
inline int64_t NVMeSubsystemSpec::max_namespaces() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.max_namespaces)
  return _internal_max_namespaces();
}
inline void NVMeSubsystemSpec::_internal_set_max_namespaces(int64_t value) {
  
  max_namespaces_ = value;
}
inline void NVMeSubsystemSpec::set_max_namespaces(int64_t value) {
  _internal_set_max_namespaces(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.max_namespaces)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatus

// string firmware_revision = 1;
inline void NVMeSubsystemStatus::clear_firmware_revision() {
  firmware_revision_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemStatus::firmware_revision() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
  return _internal_firmware_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemStatus::set_firmware_revision(ArgT0&& arg0, ArgT... args) {
 
 firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
}
inline std::string* NVMeSubsystemStatus::mutable_firmware_revision() {
  std::string* _s = _internal_mutable_firmware_revision();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
  return _s;
}
inline const std::string& NVMeSubsystemStatus::_internal_firmware_revision() const {
  return firmware_revision_.Get();
}
inline void NVMeSubsystemStatus::_internal_set_firmware_revision(const std::string& value) {
  
  firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::_internal_mutable_firmware_revision() {
  
  return firmware_revision_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
  return firmware_revision_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemStatus::set_allocated_firmware_revision(std::string* firmware_revision) {
  if (firmware_revision != nullptr) {
    
  } else {
    
  }
  firmware_revision_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), firmware_revision,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (firmware_revision_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
}

// bytes fru_guid = 2;
inline void NVMeSubsystemStatus::clear_fru_guid() {
  fru_guid_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemStatus::fru_guid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
  return _internal_fru_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemStatus::set_fru_guid(ArgT0&& arg0, ArgT... args) {
 
 fru_guid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
}
inline std::string* NVMeSubsystemStatus::mutable_fru_guid() {
  std::string* _s = _internal_mutable_fru_guid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
  return _s;
}
inline const std::string& NVMeSubsystemStatus::_internal_fru_guid() const {
  return fru_guid_.Get();
}
inline void NVMeSubsystemStatus::_internal_set_fru_guid(const std::string& value) {
  
  fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::_internal_mutable_fru_guid() {
  
  return fru_guid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::release_fru_guid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
  return fru_guid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemStatus::set_allocated_fru_guid(std::string* fru_guid) {
  if (fru_guid != nullptr) {
    
  } else {
    
  }
  fru_guid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fru_guid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fru_guid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
}

// -------------------------------------------------------------------

// NVMeController

// .opi_api.storage.v1.NVMeControllerSpec spec = 1;
inline bool NVMeController::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NVMeController::has_spec() const {
  return _internal_has_spec();
}
inline void NVMeController::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeControllerSpec& NVMeController::_internal_spec() const {
  const ::opi_api::storage::v1::NVMeControllerSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeControllerSpec&>(
      ::opi_api::storage::v1::_NVMeControllerSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeControllerSpec& NVMeController::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.spec)
  return _internal_spec();
}
inline void NVMeController::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NVMeControllerSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.spec)
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::release_spec() {
  
  ::opi_api::storage::v1::NVMeControllerSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.spec)
  
  ::opi_api::storage::v1::NVMeControllerSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::mutable_spec() {
  ::opi_api::storage::v1::NVMeControllerSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.spec)
  return _msg;
}
inline void NVMeController::set_allocated_spec(::opi_api::storage::v1::NVMeControllerSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeControllerSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.spec)
}

// .opi_api.storage.v1.NVMeControllerStatus status = 2;
inline bool NVMeController::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NVMeController::has_status() const {
  return _internal_has_status();
}
inline void NVMeController::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeControllerStatus& NVMeController::_internal_status() const {
  const ::opi_api::storage::v1::NVMeControllerStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeControllerStatus&>(
      ::opi_api::storage::v1::_NVMeControllerStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeControllerStatus& NVMeController::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.status)
  return _internal_status();
}
inline void NVMeController::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NVMeControllerStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.status)
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::release_status() {
  
  ::opi_api::storage::v1::NVMeControllerStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.status)
  
  ::opi_api::storage::v1::NVMeControllerStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::mutable_status() {
  ::opi_api::storage::v1::NVMeControllerStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.status)
  return _msg;
}
inline void NVMeController::set_allocated_status(::opi_api::storage::v1::NVMeControllerStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeControllerStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.status)
}

// -------------------------------------------------------------------

// NVMeControllerSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.id)
  return _internal_id();
}
inline void NVMeControllerSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerSpec.id)
  return _msg;
}
inline void NVMeControllerSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerSpec.id)
}

// int32 nvme_controller_id = 2;
inline void NVMeControllerSpec::clear_nvme_controller_id() {
  nvme_controller_id_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_nvme_controller_id() const {
  return nvme_controller_id_;
}
inline int32_t NVMeControllerSpec::nvme_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.nvme_controller_id)
  return _internal_nvme_controller_id();
}
inline void NVMeControllerSpec::_internal_set_nvme_controller_id(int32_t value) {
  
  nvme_controller_id_ = value;
}
inline void NVMeControllerSpec::set_nvme_controller_id(int32_t value) {
  _internal_set_nvme_controller_id(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.nvme_controller_id)
}

// .opi_api.common.v1.ObjectKey subsystem_id = 3;
inline bool NVMeControllerSpec::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeControllerSpec::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeControllerSpec::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
  return _msg;
}
inline void NVMeControllerSpec::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
}

// .opi_api.storage.v1.PciEndpoint pcie_id = 4;
inline bool NVMeControllerSpec::_internal_has_pcie_id() const {
  return this != internal_default_instance() && pcie_id_ != nullptr;
}
inline bool NVMeControllerSpec::has_pcie_id() const {
  return _internal_has_pcie_id();
}
inline const ::opi_api::storage::v1::PciEndpoint& NVMeControllerSpec::_internal_pcie_id() const {
  const ::opi_api::storage::v1::PciEndpoint* p = pcie_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::PciEndpoint&>(
      ::opi_api::storage::v1::_PciEndpoint_default_instance_);
}
inline const ::opi_api::storage::v1::PciEndpoint& NVMeControllerSpec::pcie_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
  return _internal_pcie_id();
}
inline void NVMeControllerSpec::unsafe_arena_set_allocated_pcie_id(
    ::opi_api::storage::v1::PciEndpoint* pcie_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id_);
  }
  pcie_id_ = pcie_id;
  if (pcie_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::release_pcie_id() {
  
  ::opi_api::storage::v1::PciEndpoint* temp = pcie_id_;
  pcie_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::unsafe_arena_release_pcie_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
  
  ::opi_api::storage::v1::PciEndpoint* temp = pcie_id_;
  pcie_id_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::_internal_mutable_pcie_id() {
  
  if (pcie_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::PciEndpoint>(GetArenaForAllocation());
    pcie_id_ = p;
  }
  return pcie_id_;
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::mutable_pcie_id() {
  ::opi_api::storage::v1::PciEndpoint* _msg = _internal_mutable_pcie_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
  return _msg;
}
inline void NVMeControllerSpec::set_allocated_pcie_id(::opi_api::storage::v1::PciEndpoint* pcie_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id_);
  }
  if (pcie_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id));
    if (message_arena != submessage_arena) {
      pcie_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pcie_id, submessage_arena);
    }
    
  } else {
    
  }
  pcie_id_ = pcie_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
}

// int32 max_nsq = 5;
inline void NVMeControllerSpec::clear_max_nsq() {
  max_nsq_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_max_nsq() const {
  return max_nsq_;
}
inline int32_t NVMeControllerSpec::max_nsq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.max_nsq)
  return _internal_max_nsq();
}
inline void NVMeControllerSpec::_internal_set_max_nsq(int32_t value) {
  
  max_nsq_ = value;
}
inline void NVMeControllerSpec::set_max_nsq(int32_t value) {
  _internal_set_max_nsq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.max_nsq)
}

// int32 max_ncq = 6;
inline void NVMeControllerSpec::clear_max_ncq() {
  max_ncq_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_max_ncq() const {
  return max_ncq_;
}
inline int32_t NVMeControllerSpec::max_ncq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.max_ncq)
  return _internal_max_ncq();
}
inline void NVMeControllerSpec::_internal_set_max_ncq(int32_t value) {
  
  max_ncq_ = value;
}
inline void NVMeControllerSpec::set_max_ncq(int32_t value) {
  _internal_set_max_ncq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.max_ncq)
}

// int32 sqes = 7;
inline void NVMeControllerSpec::clear_sqes() {
  sqes_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_sqes() const {
  return sqes_;
}
inline int32_t NVMeControllerSpec::sqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.sqes)
  return _internal_sqes();
}
inline void NVMeControllerSpec::_internal_set_sqes(int32_t value) {
  
  sqes_ = value;
}
inline void NVMeControllerSpec::set_sqes(int32_t value) {
  _internal_set_sqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.sqes)
}

// int32 cqes = 8;
inline void NVMeControllerSpec::clear_cqes() {
  cqes_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_cqes() const {
  return cqes_;
}
inline int32_t NVMeControllerSpec::cqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.cqes)
  return _internal_cqes();
}
inline void NVMeControllerSpec::_internal_set_cqes(int32_t value) {
  
  cqes_ = value;
}
inline void NVMeControllerSpec::set_cqes(int32_t value) {
  _internal_set_cqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.cqes)
}

// int32 max_namespaces = 9;
inline void NVMeControllerSpec::clear_max_namespaces() {
  max_namespaces_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_max_namespaces() const {
  return max_namespaces_;
}
inline int32_t NVMeControllerSpec::max_namespaces() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.max_namespaces)
  return _internal_max_namespaces();
}
inline void NVMeControllerSpec::_internal_set_max_namespaces(int32_t value) {
  
  max_namespaces_ = value;
}
inline void NVMeControllerSpec::set_max_namespaces(int32_t value) {
  _internal_set_max_namespaces(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.max_namespaces)
}

// -------------------------------------------------------------------

// NVMeControllerStatus

// bool active = 1;
inline void NVMeControllerStatus::clear_active() {
  active_ = false;
}
inline bool NVMeControllerStatus::_internal_active() const {
  return active_;
}
inline bool NVMeControllerStatus::active() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatus.active)
  return _internal_active();
}
inline void NVMeControllerStatus::_internal_set_active(bool value) {
  
  active_ = value;
}
inline void NVMeControllerStatus::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerStatus.active)
}

// -------------------------------------------------------------------

// NVMeNamespace

// .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
inline bool NVMeNamespace::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NVMeNamespace::has_spec() const {
  return _internal_has_spec();
}
inline void NVMeNamespace::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespaceSpec& NVMeNamespace::_internal_spec() const {
  const ::opi_api::storage::v1::NVMeNamespaceSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespaceSpec&>(
      ::opi_api::storage::v1::_NVMeNamespaceSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespaceSpec& NVMeNamespace::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.spec)
  return _internal_spec();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NVMeNamespaceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.spec)
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::release_spec() {
  
  ::opi_api::storage::v1::NVMeNamespaceSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.spec)
  
  ::opi_api::storage::v1::NVMeNamespaceSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::mutable_spec() {
  ::opi_api::storage::v1::NVMeNamespaceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.spec)
  return _msg;
}
inline void NVMeNamespace::set_allocated_spec(::opi_api::storage::v1::NVMeNamespaceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespaceSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.spec)
}

// .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
inline bool NVMeNamespace::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NVMeNamespace::has_status() const {
  return _internal_has_status();
}
inline void NVMeNamespace::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespaceStatus& NVMeNamespace::_internal_status() const {
  const ::opi_api::storage::v1::NVMeNamespaceStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespaceStatus&>(
      ::opi_api::storage::v1::_NVMeNamespaceStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespaceStatus& NVMeNamespace::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.status)
  return _internal_status();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NVMeNamespaceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.status)
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::release_status() {
  
  ::opi_api::storage::v1::NVMeNamespaceStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.status)
  
  ::opi_api::storage::v1::NVMeNamespaceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::mutable_status() {
  ::opi_api::storage::v1::NVMeNamespaceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.status)
  return _msg;
}
inline void NVMeNamespace::set_allocated_status(::opi_api::storage::v1::NVMeNamespaceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespaceStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.status)
}

// -------------------------------------------------------------------

// NVMeNamespaceSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeNamespaceSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.id)
  return _internal_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.id)
}

// .opi_api.common.v1.ObjectKey subsystem_id = 2;
inline bool NVMeNamespaceSpec::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
}

// .opi_api.common.v1.ObjectKey controller_id = 3;
inline bool NVMeNamespaceSpec::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.controller_id)
  return _internal_controller_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.controller_id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.controller_id)
}

// int32 host_nsid = 4;
inline void NVMeNamespaceSpec::clear_host_nsid() {
  host_nsid_ = 0;
}
inline int32_t NVMeNamespaceSpec::_internal_host_nsid() const {
  return host_nsid_;
}
inline int32_t NVMeNamespaceSpec::host_nsid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.host_nsid)
  return _internal_host_nsid();
}
inline void NVMeNamespaceSpec::_internal_set_host_nsid(int32_t value) {
  
  host_nsid_ = value;
}
inline void NVMeNamespaceSpec::set_host_nsid(int32_t value) {
  _internal_set_host_nsid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.host_nsid)
}

// int64 block_size = 5;
inline void NVMeNamespaceSpec::clear_block_size() {
  block_size_ = int64_t{0};
}
inline int64_t NVMeNamespaceSpec::_internal_block_size() const {
  return block_size_;
}
inline int64_t NVMeNamespaceSpec::block_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.block_size)
  return _internal_block_size();
}
inline void NVMeNamespaceSpec::_internal_set_block_size(int64_t value) {
  
  block_size_ = value;
}
inline void NVMeNamespaceSpec::set_block_size(int64_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.block_size)
}

// int64 blocks_count = 6;
inline void NVMeNamespaceSpec::clear_blocks_count() {
  blocks_count_ = int64_t{0};
}
inline int64_t NVMeNamespaceSpec::_internal_blocks_count() const {
  return blocks_count_;
}
inline int64_t NVMeNamespaceSpec::blocks_count() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.blocks_count)
  return _internal_blocks_count();
}
inline void NVMeNamespaceSpec::_internal_set_blocks_count(int64_t value) {
  
  blocks_count_ = value;
}
inline void NVMeNamespaceSpec::set_blocks_count(int64_t value) {
  _internal_set_blocks_count(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.blocks_count)
}

// string nguid = 7;
inline void NVMeNamespaceSpec::clear_nguid() {
  nguid_.ClearToEmpty();
}
inline const std::string& NVMeNamespaceSpec::nguid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
  return _internal_nguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeNamespaceSpec::set_nguid(ArgT0&& arg0, ArgT... args) {
 
 nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
}
inline std::string* NVMeNamespaceSpec::mutable_nguid() {
  std::string* _s = _internal_mutable_nguid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
  return _s;
}
inline const std::string& NVMeNamespaceSpec::_internal_nguid() const {
  return nguid_.Get();
}
inline void NVMeNamespaceSpec::_internal_set_nguid(const std::string& value) {
  
  nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceSpec::_internal_mutable_nguid() {
  
  return nguid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceSpec::release_nguid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
  return nguid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeNamespaceSpec::set_allocated_nguid(std::string* nguid) {
  if (nguid != nullptr) {
    
  } else {
    
  }
  nguid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nguid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nguid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
}

// int64 eui64 = 8;
inline void NVMeNamespaceSpec::clear_eui64() {
  eui64_ = int64_t{0};
}
inline int64_t NVMeNamespaceSpec::_internal_eui64() const {
  return eui64_;
}
inline int64_t NVMeNamespaceSpec::eui64() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.eui64)
  return _internal_eui64();
}
inline void NVMeNamespaceSpec::_internal_set_eui64(int64_t value) {
  
  eui64_ = value;
}
inline void NVMeNamespaceSpec::set_eui64(int64_t value) {
  _internal_set_eui64(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.eui64)
}

// .opi_api.common.v1.Uuid uuid = 9;
inline bool NVMeNamespaceSpec::_internal_has_uuid() const {
  return this != internal_default_instance() && uuid_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_uuid() const {
  return _internal_has_uuid();
}
inline const ::opi_api::common::v1::Uuid& NVMeNamespaceSpec::_internal_uuid() const {
  const ::opi_api::common::v1::Uuid* p = uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::Uuid&>(
      ::opi_api::common::v1::_Uuid_default_instance_);
}
inline const ::opi_api::common::v1::Uuid& NVMeNamespaceSpec::uuid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
  return _internal_uuid();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_uuid(
    ::opi_api::common::v1::Uuid* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  uuid_ = uuid;
  if (uuid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::release_uuid() {
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::_internal_mutable_uuid() {
  
  if (uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::Uuid>(GetArenaForAllocation());
    uuid_ = p;
  }
  return uuid_;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::mutable_uuid() {
  ::opi_api::common::v1::Uuid* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_uuid(::opi_api::common::v1::Uuid* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid));
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    
  } else {
    
  }
  uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
}

// .opi_api.common.v1.ObjectKey volume_id = 10;
inline bool NVMeNamespaceSpec::_internal_has_volume_id() const {
  return this != internal_default_instance() && volume_id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_volume_id() const {
  return _internal_has_volume_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_volume_id() const {
  const ::opi_api::common::v1::ObjectKey* p = volume_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::volume_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
  return _internal_volume_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_volume_id(
    ::opi_api::common::v1::ObjectKey* volume_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  volume_id_ = volume_id;
  if (volume_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_volume_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_volume_id() {
  
  if (volume_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    volume_id_ = p;
  }
  return volume_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_volume_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  if (volume_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id));
    if (message_arena != submessage_arena) {
      volume_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_id, submessage_arena);
    }
    
  } else {
    
  }
  volume_id_ = volume_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
}

// int32 optimal_write_size = 11;
inline void NVMeNamespaceSpec::clear_optimal_write_size() {
  optimal_write_size_ = 0;
}
inline int32_t NVMeNamespaceSpec::_internal_optimal_write_size() const {
  return optimal_write_size_;
}
inline int32_t NVMeNamespaceSpec::optimal_write_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.optimal_write_size)
  return _internal_optimal_write_size();
}
inline void NVMeNamespaceSpec::_internal_set_optimal_write_size(int32_t value) {
  
  optimal_write_size_ = value;
}
inline void NVMeNamespaceSpec::set_optimal_write_size(int32_t value) {
  _internal_set_optimal_write_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.optimal_write_size)
}

// int32 pref_write_granularity = 12;
inline void NVMeNamespaceSpec::clear_pref_write_granularity() {
  pref_write_granularity_ = 0;
}
inline int32_t NVMeNamespaceSpec::_internal_pref_write_granularity() const {
  return pref_write_granularity_;
}
inline int32_t NVMeNamespaceSpec::pref_write_granularity() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.pref_write_granularity)
  return _internal_pref_write_granularity();
}
inline void NVMeNamespaceSpec::_internal_set_pref_write_granularity(int32_t value) {
  
  pref_write_granularity_ = value;
}
inline void NVMeNamespaceSpec::set_pref_write_granularity(int32_t value) {
  _internal_set_pref_write_granularity(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.pref_write_granularity)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatus

// .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
inline void NVMeNamespaceStatus::clear_pci_state() {
  pci_state_ = 0;
}
inline ::opi_api::storage::v1::NVMeNamespacePciState NVMeNamespaceStatus::_internal_pci_state() const {
  return static_cast< ::opi_api::storage::v1::NVMeNamespacePciState >(pci_state_);
}
inline ::opi_api::storage::v1::NVMeNamespacePciState NVMeNamespaceStatus::pci_state() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatus.pci_state)
  return _internal_pci_state();
}
inline void NVMeNamespaceStatus::_internal_set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value) {
  
  pci_state_ = value;
}
inline void NVMeNamespaceStatus::set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value) {
  _internal_set_pci_state(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceStatus.pci_state)
}

// .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
inline void NVMeNamespaceStatus::clear_pci_oper_state() {
  pci_oper_state_ = 0;
}
inline ::opi_api::storage::v1::NVMeNamespacePciOperState NVMeNamespaceStatus::_internal_pci_oper_state() const {
  return static_cast< ::opi_api::storage::v1::NVMeNamespacePciOperState >(pci_oper_state_);
}
inline ::opi_api::storage::v1::NVMeNamespacePciOperState NVMeNamespaceStatus::pci_oper_state() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatus.pci_oper_state)
  return _internal_pci_oper_state();
}
inline void NVMeNamespaceStatus::_internal_set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value) {
  
  pci_oper_state_ = value;
}
inline void NVMeNamespaceStatus::set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value) {
  _internal_set_pci_oper_state(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceStatus.pci_oper_state)
}

// -------------------------------------------------------------------

// CreateNVMeSubsystemRequest

// .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
inline bool CreateNVMeSubsystemRequest::_internal_has_subsystem() const {
  return this != internal_default_instance() && subsystem_ != nullptr;
}
inline bool CreateNVMeSubsystemRequest::has_subsystem() const {
  return _internal_has_subsystem();
}
inline void CreateNVMeSubsystemRequest::clear_subsystem() {
  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& CreateNVMeSubsystemRequest::_internal_subsystem() const {
  const ::opi_api::storage::v1::NVMeSubsystem* p = subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystem&>(
      ::opi_api::storage::v1::_NVMeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& CreateNVMeSubsystemRequest::subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeSubsystemRequest.subsystem)
  return _internal_subsystem();
}
inline void CreateNVMeSubsystemRequest::unsafe_arena_set_allocated_subsystem(
    ::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_);
  }
  subsystem_ = subsystem;
  if (subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNVMeSubsystemRequest.subsystem)
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::release_subsystem() {
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::unsafe_arena_release_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeSubsystemRequest.subsystem)
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::_internal_mutable_subsystem() {
  
  if (subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(GetArenaForAllocation());
    subsystem_ = p;
  }
  return subsystem_;
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::mutable_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _msg = _internal_mutable_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeSubsystemRequest.subsystem)
  return _msg;
}
inline void CreateNVMeSubsystemRequest::set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subsystem_;
  }
  if (subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystem>::GetOwningArena(subsystem);
    if (message_arena != submessage_arena) {
      subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_ = subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeSubsystemRequest.subsystem)
}

// -------------------------------------------------------------------

// DeleteNVMeSubsystemRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool DeleteNVMeSubsystemRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool DeleteNVMeSubsystemRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& DeleteNVMeSubsystemRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& DeleteNVMeSubsystemRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNVMeSubsystemRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void DeleteNVMeSubsystemRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.DeleteNVMeSubsystemRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeSubsystemRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeSubsystemRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNVMeSubsystemRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeSubsystemRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeSubsystemRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNVMeSubsystemRequest.subsystem_id)
  return _msg;
}
inline void DeleteNVMeSubsystemRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNVMeSubsystemRequest.subsystem_id)
}

// -------------------------------------------------------------------

// UpdateNVMeSubsystemRequest

// .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
inline bool UpdateNVMeSubsystemRequest::_internal_has_subsystem() const {
  return this != internal_default_instance() && subsystem_ != nullptr;
}
inline bool UpdateNVMeSubsystemRequest::has_subsystem() const {
  return _internal_has_subsystem();
}
inline void UpdateNVMeSubsystemRequest::clear_subsystem() {
  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& UpdateNVMeSubsystemRequest::_internal_subsystem() const {
  const ::opi_api::storage::v1::NVMeSubsystem* p = subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystem&>(
      ::opi_api::storage::v1::_NVMeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& UpdateNVMeSubsystemRequest::subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeSubsystemRequest.subsystem)
  return _internal_subsystem();
}
inline void UpdateNVMeSubsystemRequest::unsafe_arena_set_allocated_subsystem(
    ::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_);
  }
  subsystem_ = subsystem;
  if (subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeSubsystemRequest.subsystem)
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::release_subsystem() {
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::unsafe_arena_release_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeSubsystemRequest.subsystem)
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::_internal_mutable_subsystem() {
  
  if (subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(GetArenaForAllocation());
    subsystem_ = p;
  }
  return subsystem_;
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::mutable_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _msg = _internal_mutable_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeSubsystemRequest.subsystem)
  return _msg;
}
inline void UpdateNVMeSubsystemRequest::set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subsystem_;
  }
  if (subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystem>::GetOwningArena(subsystem);
    if (message_arena != submessage_arena) {
      subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_ = subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeSubsystemRequest.subsystem)
}

// -------------------------------------------------------------------

// ListNVMeSubsystemRequest

// int32 page_size = 1;
inline void ListNVMeSubsystemRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListNVMeSubsystemRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListNVMeSubsystemRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemRequest.page_size)
  return _internal_page_size();
}
inline void ListNVMeSubsystemRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListNVMeSubsystemRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemRequest.page_size)
}

// string page_token = 2;
inline void ListNVMeSubsystemRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeSubsystemRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeSubsystemRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemRequest.page_token)
}
inline std::string* ListNVMeSubsystemRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemRequest.page_token)
  return _s;
}
inline const std::string& ListNVMeSubsystemRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListNVMeSubsystemRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeSubsystemRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeSubsystemRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeSubsystemRequest.page_token)
}

// -------------------------------------------------------------------

// ListNVMeSubsystemResponse

// repeated .opi_api.storage.v1.NVMeSubsystem subsystems = 1;
inline int ListNVMeSubsystemResponse::_internal_subsystems_size() const {
  return subsystems_.size();
}
inline int ListNVMeSubsystemResponse::subsystems_size() const {
  return _internal_subsystems_size();
}
inline void ListNVMeSubsystemResponse::clear_subsystems() {
  subsystems_.Clear();
}
inline ::opi_api::storage::v1::NVMeSubsystem* ListNVMeSubsystemResponse::mutable_subsystems(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemResponse.subsystems)
  return subsystems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >*
ListNVMeSubsystemResponse::mutable_subsystems() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNVMeSubsystemResponse.subsystems)
  return &subsystems_;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& ListNVMeSubsystemResponse::_internal_subsystems(int index) const {
  return subsystems_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& ListNVMeSubsystemResponse::subsystems(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemResponse.subsystems)
  return _internal_subsystems(index);
}
inline ::opi_api::storage::v1::NVMeSubsystem* ListNVMeSubsystemResponse::_internal_add_subsystems() {
  return subsystems_.Add();
}
inline ::opi_api::storage::v1::NVMeSubsystem* ListNVMeSubsystemResponse::add_subsystems() {
  ::opi_api::storage::v1::NVMeSubsystem* _add = _internal_add_subsystems();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNVMeSubsystemResponse.subsystems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >&
ListNVMeSubsystemResponse::subsystems() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNVMeSubsystemResponse.subsystems)
  return subsystems_;
}

// string next_page_token = 2;
inline void ListNVMeSubsystemResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeSubsystemResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeSubsystemResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemResponse.next_page_token)
}
inline std::string* ListNVMeSubsystemResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemResponse.next_page_token)
  return _s;
}
inline const std::string& ListNVMeSubsystemResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListNVMeSubsystemResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeSubsystemResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeSubsystemResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeSubsystemResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNVMeSubsystemRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool GetNVMeSubsystemRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool GetNVMeSubsystemRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& GetNVMeSubsystemRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& GetNVMeSubsystemRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNVMeSubsystemRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void GetNVMeSubsystemRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.GetNVMeSubsystemRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeSubsystemRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeSubsystemRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNVMeSubsystemRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeSubsystemRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeSubsystemRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNVMeSubsystemRequest.subsystem_id)
  return _msg;
}
inline void GetNVMeSubsystemRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNVMeSubsystemRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatsRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeSubsystemStatsRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeSubsystemStatsRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemStatsRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemStatsRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeSubsystemStatsRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  return _msg;
}
inline void NVMeSubsystemStatsRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatsResponse

// string stats = 1;
inline void NVMeSubsystemStatsResponse::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemStatsResponse::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
}
inline std::string* NVMeSubsystemStatsResponse::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return _s;
}
inline const std::string& NVMeSubsystemStatsResponse::_internal_stats() const {
  return stats_.Get();
}
inline void NVMeSubsystemStatsResponse::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatsResponse::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemStatsResponse::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
}

// -------------------------------------------------------------------

// CreateNVMeControllerRequest

// .opi_api.storage.v1.NVMeController controller = 1;
inline bool CreateNVMeControllerRequest::_internal_has_controller() const {
  return this != internal_default_instance() && controller_ != nullptr;
}
inline bool CreateNVMeControllerRequest::has_controller() const {
  return _internal_has_controller();
}
inline void CreateNVMeControllerRequest::clear_controller() {
  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeController& CreateNVMeControllerRequest::_internal_controller() const {
  const ::opi_api::storage::v1::NVMeController* p = controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeController&>(
      ::opi_api::storage::v1::_NVMeController_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeController& CreateNVMeControllerRequest::controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeControllerRequest.controller)
  return _internal_controller();
}
inline void CreateNVMeControllerRequest::unsafe_arena_set_allocated_controller(
    ::opi_api::storage::v1::NVMeController* controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNVMeControllerRequest.controller)
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::release_controller() {
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeControllerRequest.controller)
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::_internal_mutable_controller() {
  
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(GetArenaForAllocation());
    controller_ = p;
  }
  return controller_;
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::mutable_controller() {
  ::opi_api::storage::v1::NVMeController* _msg = _internal_mutable_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeControllerRequest.controller)
  return _msg;
}
inline void CreateNVMeControllerRequest::set_allocated_controller(::opi_api::storage::v1::NVMeController* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeController>::GetOwningArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeControllerRequest.controller)
}

// -------------------------------------------------------------------

// DeleteNVMeControllerRequest

// .opi_api.common.v1.ObjectKey controller_id = 1;
inline bool DeleteNVMeControllerRequest::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool DeleteNVMeControllerRequest::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& DeleteNVMeControllerRequest::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& DeleteNVMeControllerRequest::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNVMeControllerRequest.controller_id)
  return _internal_controller_id();
}
inline void DeleteNVMeControllerRequest::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.DeleteNVMeControllerRequest.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeControllerRequest::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeControllerRequest::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNVMeControllerRequest.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeControllerRequest::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeControllerRequest::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNVMeControllerRequest.controller_id)
  return _msg;
}
inline void DeleteNVMeControllerRequest::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNVMeControllerRequest.controller_id)
}

// -------------------------------------------------------------------

// UpdateNVMeControllerRequest

// .opi_api.storage.v1.NVMeController controller = 1;
inline bool UpdateNVMeControllerRequest::_internal_has_controller() const {
  return this != internal_default_instance() && controller_ != nullptr;
}
inline bool UpdateNVMeControllerRequest::has_controller() const {
  return _internal_has_controller();
}
inline void UpdateNVMeControllerRequest::clear_controller() {
  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeController& UpdateNVMeControllerRequest::_internal_controller() const {
  const ::opi_api::storage::v1::NVMeController* p = controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeController&>(
      ::opi_api::storage::v1::_NVMeController_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeController& UpdateNVMeControllerRequest::controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeControllerRequest.controller)
  return _internal_controller();
}
inline void UpdateNVMeControllerRequest::unsafe_arena_set_allocated_controller(
    ::opi_api::storage::v1::NVMeController* controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeControllerRequest.controller)
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::release_controller() {
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeControllerRequest.controller)
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::_internal_mutable_controller() {
  
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(GetArenaForAllocation());
    controller_ = p;
  }
  return controller_;
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::mutable_controller() {
  ::opi_api::storage::v1::NVMeController* _msg = _internal_mutable_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeControllerRequest.controller)
  return _msg;
}
inline void UpdateNVMeControllerRequest::set_allocated_controller(::opi_api::storage::v1::NVMeController* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeController>::GetOwningArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeControllerRequest.controller)
}

// -------------------------------------------------------------------

// ListNVMeControllerRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool ListNVMeControllerRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool ListNVMeControllerRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& ListNVMeControllerRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& ListNVMeControllerRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllerRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void ListNVMeControllerRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.ListNVMeControllerRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeControllerRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeControllerRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeControllerRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeControllerRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeControllerRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllerRequest.subsystem_id)
  return _msg;
}
inline void ListNVMeControllerRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeControllerRequest.subsystem_id)
}

// int32 page_size = 2;
inline void ListNVMeControllerRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListNVMeControllerRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListNVMeControllerRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllerRequest.page_size)
  return _internal_page_size();
}
inline void ListNVMeControllerRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListNVMeControllerRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllerRequest.page_size)
}

// string page_token = 3;
inline void ListNVMeControllerRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeControllerRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllerRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeControllerRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllerRequest.page_token)
}
inline std::string* ListNVMeControllerRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllerRequest.page_token)
  return _s;
}
inline const std::string& ListNVMeControllerRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListNVMeControllerRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeControllerRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeControllerRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeControllerRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeControllerRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeControllerRequest.page_token)
}

// -------------------------------------------------------------------

// ListNVMeControllerResponse

// repeated .opi_api.storage.v1.NVMeController controllers = 1;
inline int ListNVMeControllerResponse::_internal_controllers_size() const {
  return controllers_.size();
}
inline int ListNVMeControllerResponse::controllers_size() const {
  return _internal_controllers_size();
}
inline void ListNVMeControllerResponse::clear_controllers() {
  controllers_.Clear();
}
inline ::opi_api::storage::v1::NVMeController* ListNVMeControllerResponse::mutable_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllerResponse.controllers)
  return controllers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >*
ListNVMeControllerResponse::mutable_controllers() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNVMeControllerResponse.controllers)
  return &controllers_;
}
inline const ::opi_api::storage::v1::NVMeController& ListNVMeControllerResponse::_internal_controllers(int index) const {
  return controllers_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeController& ListNVMeControllerResponse::controllers(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllerResponse.controllers)
  return _internal_controllers(index);
}
inline ::opi_api::storage::v1::NVMeController* ListNVMeControllerResponse::_internal_add_controllers() {
  return controllers_.Add();
}
inline ::opi_api::storage::v1::NVMeController* ListNVMeControllerResponse::add_controllers() {
  ::opi_api::storage::v1::NVMeController* _add = _internal_add_controllers();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNVMeControllerResponse.controllers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >&
ListNVMeControllerResponse::controllers() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNVMeControllerResponse.controllers)
  return controllers_;
}

// string next_page_token = 2;
inline void ListNVMeControllerResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeControllerResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllerResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeControllerResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllerResponse.next_page_token)
}
inline std::string* ListNVMeControllerResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllerResponse.next_page_token)
  return _s;
}
inline const std::string& ListNVMeControllerResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListNVMeControllerResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeControllerResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeControllerResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeControllerResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeControllerResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeControllerResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNVMeControllerRequest

// .opi_api.common.v1.ObjectKey controller_id = 1;
inline bool GetNVMeControllerRequest::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool GetNVMeControllerRequest::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& GetNVMeControllerRequest::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& GetNVMeControllerRequest::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNVMeControllerRequest.controller_id)
  return _internal_controller_id();
}
inline void GetNVMeControllerRequest::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.GetNVMeControllerRequest.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeControllerRequest::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeControllerRequest::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNVMeControllerRequest.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeControllerRequest::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeControllerRequest::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNVMeControllerRequest.controller_id)
  return _msg;
}
inline void GetNVMeControllerRequest::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNVMeControllerRequest.controller_id)
}

// -------------------------------------------------------------------

// NVMeControllerStatsRequest

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerStatsRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerStatsRequest::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsRequest::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsRequest::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  return _internal_id();
}
inline void NVMeControllerStatsRequest::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsRequest.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  return _msg;
}
inline void NVMeControllerStatsRequest::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsRequest.id)
}

// -------------------------------------------------------------------

// NVMeControllerStatsResponse

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerStatsResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerStatsResponse::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsResponse::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsResponse::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  return _internal_id();
}
inline void NVMeControllerStatsResponse::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  return _msg;
}
inline void NVMeControllerStatsResponse::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.id)
}

// string stats = 2;
inline void NVMeControllerStatsResponse::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& NVMeControllerStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeControllerStatsResponse::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
}
inline std::string* NVMeControllerStatsResponse::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return _s;
}
inline const std::string& NVMeControllerStatsResponse::_internal_stats() const {
  return stats_.Get();
}
inline void NVMeControllerStatsResponse::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeControllerStatsResponse::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeControllerStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeControllerStatsResponse::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
}

// -------------------------------------------------------------------

// CreateNVMeNamespaceRequest

// .opi_api.storage.v1.NVMeNamespace namespace = 1;
inline bool CreateNVMeNamespaceRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool CreateNVMeNamespaceRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void CreateNVMeNamespaceRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespace& CreateNVMeNamespaceRequest::_internal_namespace_() const {
  const ::opi_api::storage::v1::NVMeNamespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespace&>(
      ::opi_api::storage::v1::_NVMeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespace& CreateNVMeNamespaceRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeNamespaceRequest.namespace)
  return _internal_namespace_();
}
inline void CreateNVMeNamespaceRequest::unsafe_arena_set_allocated_namespace_(
    ::opi_api::storage::v1::NVMeNamespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNVMeNamespaceRequest.namespace)
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::release_namespace_() {
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeNamespaceRequest.namespace)
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::mutable_namespace_() {
  ::opi_api::storage::v1::NVMeNamespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeNamespaceRequest.namespace)
  return _msg;
}
inline void CreateNVMeNamespaceRequest::set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeNamespaceRequest.namespace)
}

// -------------------------------------------------------------------

// DeleteNVMeNamespaceRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool DeleteNVMeNamespaceRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool DeleteNVMeNamespaceRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& DeleteNVMeNamespaceRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& DeleteNVMeNamespaceRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNVMeNamespaceRequest.namespace_id)
  return _internal_namespace_id();
}
inline void DeleteNVMeNamespaceRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.DeleteNVMeNamespaceRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeNamespaceRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeNamespaceRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNVMeNamespaceRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeNamespaceRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* DeleteNVMeNamespaceRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNVMeNamespaceRequest.namespace_id)
  return _msg;
}
inline void DeleteNVMeNamespaceRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNVMeNamespaceRequest.namespace_id)
}

// -------------------------------------------------------------------

// UpdateNVMeNamespaceRequest

// .opi_api.storage.v1.NVMeNamespace namespace = 1;
inline bool UpdateNVMeNamespaceRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool UpdateNVMeNamespaceRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void UpdateNVMeNamespaceRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespace& UpdateNVMeNamespaceRequest::_internal_namespace_() const {
  const ::opi_api::storage::v1::NVMeNamespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespace&>(
      ::opi_api::storage::v1::_NVMeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespace& UpdateNVMeNamespaceRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeNamespaceRequest.namespace)
  return _internal_namespace_();
}
inline void UpdateNVMeNamespaceRequest::unsafe_arena_set_allocated_namespace_(
    ::opi_api::storage::v1::NVMeNamespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeNamespaceRequest.namespace)
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::release_namespace_() {
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeNamespaceRequest.namespace)
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::mutable_namespace_() {
  ::opi_api::storage::v1::NVMeNamespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeNamespaceRequest.namespace)
  return _msg;
}
inline void UpdateNVMeNamespaceRequest::set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeNamespaceRequest.namespace)
}

// -------------------------------------------------------------------

// ListNVMeNamespaceRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool ListNVMeNamespaceRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool ListNVMeNamespaceRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& ListNVMeNamespaceRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& ListNVMeNamespaceRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespaceRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void ListNVMeNamespaceRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.ListNVMeNamespaceRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespaceRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespaceRequest.subsystem_id)
  return _msg;
}
inline void ListNVMeNamespaceRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespaceRequest.subsystem_id)
}

// .opi_api.common.v1.ObjectKey controller_id = 2;
inline bool ListNVMeNamespaceRequest::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool ListNVMeNamespaceRequest::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& ListNVMeNamespaceRequest::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& ListNVMeNamespaceRequest::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespaceRequest.controller_id)
  return _internal_controller_id();
}
inline void ListNVMeNamespaceRequest::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.ListNVMeNamespaceRequest.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespaceRequest.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* ListNVMeNamespaceRequest::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespaceRequest.controller_id)
  return _msg;
}
inline void ListNVMeNamespaceRequest::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespaceRequest.controller_id)
}

// int32 page_size = 3;
inline void ListNVMeNamespaceRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListNVMeNamespaceRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListNVMeNamespaceRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespaceRequest.page_size)
  return _internal_page_size();
}
inline void ListNVMeNamespaceRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListNVMeNamespaceRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespaceRequest.page_size)
}

// string page_token = 4;
inline void ListNVMeNamespaceRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeNamespaceRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespaceRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeNamespaceRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespaceRequest.page_token)
}
inline std::string* ListNVMeNamespaceRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespaceRequest.page_token)
  return _s;
}
inline const std::string& ListNVMeNamespaceRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListNVMeNamespaceRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespaceRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespaceRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespaceRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeNamespaceRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespaceRequest.page_token)
}

// -------------------------------------------------------------------

// ListNVMeNamespaceResponse

// repeated .opi_api.storage.v1.NVMeNamespace namespaces = 1;
inline int ListNVMeNamespaceResponse::_internal_namespaces_size() const {
  return namespaces_.size();
}
inline int ListNVMeNamespaceResponse::namespaces_size() const {
  return _internal_namespaces_size();
}
inline void ListNVMeNamespaceResponse::clear_namespaces() {
  namespaces_.Clear();
}
inline ::opi_api::storage::v1::NVMeNamespace* ListNVMeNamespaceResponse::mutable_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespaceResponse.namespaces)
  return namespaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >*
ListNVMeNamespaceResponse::mutable_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNVMeNamespaceResponse.namespaces)
  return &namespaces_;
}
inline const ::opi_api::storage::v1::NVMeNamespace& ListNVMeNamespaceResponse::_internal_namespaces(int index) const {
  return namespaces_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeNamespace& ListNVMeNamespaceResponse::namespaces(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespaceResponse.namespaces)
  return _internal_namespaces(index);
}
inline ::opi_api::storage::v1::NVMeNamespace* ListNVMeNamespaceResponse::_internal_add_namespaces() {
  return namespaces_.Add();
}
inline ::opi_api::storage::v1::NVMeNamespace* ListNVMeNamespaceResponse::add_namespaces() {
  ::opi_api::storage::v1::NVMeNamespace* _add = _internal_add_namespaces();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNVMeNamespaceResponse.namespaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >&
ListNVMeNamespaceResponse::namespaces() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNVMeNamespaceResponse.namespaces)
  return namespaces_;
}

// string next_page_token = 2;
inline void ListNVMeNamespaceResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeNamespaceResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespaceResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeNamespaceResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespaceResponse.next_page_token)
}
inline std::string* ListNVMeNamespaceResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespaceResponse.next_page_token)
  return _s;
}
inline const std::string& ListNVMeNamespaceResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListNVMeNamespaceResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespaceResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespaceResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespaceResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeNamespaceResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespaceResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNVMeNamespaceRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool GetNVMeNamespaceRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool GetNVMeNamespaceRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& GetNVMeNamespaceRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& GetNVMeNamespaceRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNVMeNamespaceRequest.namespace_id)
  return _internal_namespace_id();
}
inline void GetNVMeNamespaceRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.GetNVMeNamespaceRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeNamespaceRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeNamespaceRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNVMeNamespaceRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeNamespaceRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* GetNVMeNamespaceRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNVMeNamespaceRequest.namespace_id)
  return _msg;
}
inline void GetNVMeNamespaceRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNVMeNamespaceRequest.namespace_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatsRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool NVMeNamespaceStatsRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool NVMeNamespaceStatsRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  return _internal_namespace_id();
}
inline void NVMeNamespaceStatsRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  return _msg;
}
inline void NVMeNamespaceStatsRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatsResponse

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeNamespaceStatsResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeNamespaceStatsResponse::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsResponse::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsResponse::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  return _internal_id();
}
inline void NVMeNamespaceStatsResponse::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  return _msg;
}
inline void NVMeNamespaceStatsResponse::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
}

// string stats = 2;
inline void NVMeNamespaceStatsResponse::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& NVMeNamespaceStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeNamespaceStatsResponse::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
}
inline std::string* NVMeNamespaceStatsResponse::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return _s;
}
inline const std::string& NVMeNamespaceStatsResponse::_internal_stats() const {
  return stats_.Get();
}
inline void NVMeNamespaceStatsResponse::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceStatsResponse::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeNamespaceStatsResponse::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::storage::v1::NVMeNamespacePciState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NVMeNamespacePciState>() {
  return ::opi_api::storage::v1::NVMeNamespacePciState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::storage::v1::NVMeNamespacePciOperState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NVMeNamespacePciOperState>() {
  return ::opi_api::storage::v1::NVMeNamespacePciOperState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto
