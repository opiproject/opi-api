// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "object_key.pb.h"
#include "uuid.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frontend_5fnvme_5fpcie_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frontend_5fnvme_5fpcie_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class NVMeController;
struct NVMeControllerDefaultTypeInternal;
extern NVMeControllerDefaultTypeInternal _NVMeController_default_instance_;
class NVMeControllerCreateRequest;
struct NVMeControllerCreateRequestDefaultTypeInternal;
extern NVMeControllerCreateRequestDefaultTypeInternal _NVMeControllerCreateRequest_default_instance_;
class NVMeControllerDeleteRequest;
struct NVMeControllerDeleteRequestDefaultTypeInternal;
extern NVMeControllerDeleteRequestDefaultTypeInternal _NVMeControllerDeleteRequest_default_instance_;
class NVMeControllerGetRequest;
struct NVMeControllerGetRequestDefaultTypeInternal;
extern NVMeControllerGetRequestDefaultTypeInternal _NVMeControllerGetRequest_default_instance_;
class NVMeControllerListRequest;
struct NVMeControllerListRequestDefaultTypeInternal;
extern NVMeControllerListRequestDefaultTypeInternal _NVMeControllerListRequest_default_instance_;
class NVMeControllerListResponse;
struct NVMeControllerListResponseDefaultTypeInternal;
extern NVMeControllerListResponseDefaultTypeInternal _NVMeControllerListResponse_default_instance_;
class NVMeControllerStatsRequest;
struct NVMeControllerStatsRequestDefaultTypeInternal;
extern NVMeControllerStatsRequestDefaultTypeInternal _NVMeControllerStatsRequest_default_instance_;
class NVMeControllerStatsResponse;
struct NVMeControllerStatsResponseDefaultTypeInternal;
extern NVMeControllerStatsResponseDefaultTypeInternal _NVMeControllerStatsResponse_default_instance_;
class NVMeControllerUpdateRequest;
struct NVMeControllerUpdateRequestDefaultTypeInternal;
extern NVMeControllerUpdateRequestDefaultTypeInternal _NVMeControllerUpdateRequest_default_instance_;
class NVMeNamespace;
struct NVMeNamespaceDefaultTypeInternal;
extern NVMeNamespaceDefaultTypeInternal _NVMeNamespace_default_instance_;
class NVMeNamespaceCreateRequest;
struct NVMeNamespaceCreateRequestDefaultTypeInternal;
extern NVMeNamespaceCreateRequestDefaultTypeInternal _NVMeNamespaceCreateRequest_default_instance_;
class NVMeNamespaceDeleteRequest;
struct NVMeNamespaceDeleteRequestDefaultTypeInternal;
extern NVMeNamespaceDeleteRequestDefaultTypeInternal _NVMeNamespaceDeleteRequest_default_instance_;
class NVMeNamespaceGetRequest;
struct NVMeNamespaceGetRequestDefaultTypeInternal;
extern NVMeNamespaceGetRequestDefaultTypeInternal _NVMeNamespaceGetRequest_default_instance_;
class NVMeNamespaceListRequest;
struct NVMeNamespaceListRequestDefaultTypeInternal;
extern NVMeNamespaceListRequestDefaultTypeInternal _NVMeNamespaceListRequest_default_instance_;
class NVMeNamespaceListResponse;
struct NVMeNamespaceListResponseDefaultTypeInternal;
extern NVMeNamespaceListResponseDefaultTypeInternal _NVMeNamespaceListResponse_default_instance_;
class NVMeNamespaceStatsRequest;
struct NVMeNamespaceStatsRequestDefaultTypeInternal;
extern NVMeNamespaceStatsRequestDefaultTypeInternal _NVMeNamespaceStatsRequest_default_instance_;
class NVMeNamespaceStatsResponse;
struct NVMeNamespaceStatsResponseDefaultTypeInternal;
extern NVMeNamespaceStatsResponseDefaultTypeInternal _NVMeNamespaceStatsResponse_default_instance_;
class NVMeNamespaceUpdateRequest;
struct NVMeNamespaceUpdateRequestDefaultTypeInternal;
extern NVMeNamespaceUpdateRequestDefaultTypeInternal _NVMeNamespaceUpdateRequest_default_instance_;
class NVMeSubsystem;
struct NVMeSubsystemDefaultTypeInternal;
extern NVMeSubsystemDefaultTypeInternal _NVMeSubsystem_default_instance_;
class NVMeSubsystemCreateRequest;
struct NVMeSubsystemCreateRequestDefaultTypeInternal;
extern NVMeSubsystemCreateRequestDefaultTypeInternal _NVMeSubsystemCreateRequest_default_instance_;
class NVMeSubsystemDeleteRequest;
struct NVMeSubsystemDeleteRequestDefaultTypeInternal;
extern NVMeSubsystemDeleteRequestDefaultTypeInternal _NVMeSubsystemDeleteRequest_default_instance_;
class NVMeSubsystemGetRequest;
struct NVMeSubsystemGetRequestDefaultTypeInternal;
extern NVMeSubsystemGetRequestDefaultTypeInternal _NVMeSubsystemGetRequest_default_instance_;
class NVMeSubsystemListRequest;
struct NVMeSubsystemListRequestDefaultTypeInternal;
extern NVMeSubsystemListRequestDefaultTypeInternal _NVMeSubsystemListRequest_default_instance_;
class NVMeSubsystemListResponse;
struct NVMeSubsystemListResponseDefaultTypeInternal;
extern NVMeSubsystemListResponseDefaultTypeInternal _NVMeSubsystemListResponse_default_instance_;
class NVMeSubsystemStatsRequest;
struct NVMeSubsystemStatsRequestDefaultTypeInternal;
extern NVMeSubsystemStatsRequestDefaultTypeInternal _NVMeSubsystemStatsRequest_default_instance_;
class NVMeSubsystemStatsResponse;
struct NVMeSubsystemStatsResponseDefaultTypeInternal;
extern NVMeSubsystemStatsResponseDefaultTypeInternal _NVMeSubsystemStatsResponse_default_instance_;
class NVMeSubsystemUpdateRequest;
struct NVMeSubsystemUpdateRequestDefaultTypeInternal;
extern NVMeSubsystemUpdateRequestDefaultTypeInternal _NVMeSubsystemUpdateRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::NVMeController* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerCreateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerCreateRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerDeleteRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerDeleteRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerGetRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerGetRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerListRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerListRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerListResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerListResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerUpdateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerUpdateRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespace* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceCreateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceCreateRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceDeleteRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceDeleteRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceGetRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceGetRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceListRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceListRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceListResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceListResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceUpdateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceUpdateRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystem* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemCreateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemCreateRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemDeleteRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemDeleteRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemGetRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemGetRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemListRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemListRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemListResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemListResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemUpdateRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemUpdateRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

// ===================================================================

class NVMeSubsystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystem) */ {
 public:
  inline NVMeSubsystem() : NVMeSubsystem(nullptr) {}
  ~NVMeSubsystem() override;
  explicit constexpr NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystem(const NVMeSubsystem& from);
  NVMeSubsystem(NVMeSubsystem&& from) noexcept
    : NVMeSubsystem() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystem& operator=(const NVMeSubsystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystem& operator=(NVMeSubsystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystem* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystem*>(
               &_NVMeSubsystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NVMeSubsystem& a, NVMeSubsystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystem";
  }
  protected:
  explicit NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNqnFieldNumber = 2,
    kSerialNumberFieldNumber = 3,
    kModelNumberFieldNumber = 4,
    kFirmwareRevisionFieldNumber = 6,
    kFruGuidFieldNumber = 7,
    kIdFieldNumber = 1,
    kMaxNsFieldNumber = 5,
  };
  // string nqn = 2;
  void clear_nqn();
  const std::string& nqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nqn();
  PROTOBUF_NODISCARD std::string* release_nqn();
  void set_allocated_nqn(std::string* nqn);
  private:
  const std::string& _internal_nqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nqn(const std::string& value);
  std::string* _internal_mutable_nqn();
  public:

  // string serial_number = 3;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string model_number = 4;
  void clear_model_number();
  const std::string& model_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_number();
  PROTOBUF_NODISCARD std::string* release_model_number();
  void set_allocated_model_number(std::string* model_number);
  private:
  const std::string& _internal_model_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_number(const std::string& value);
  std::string* _internal_mutable_model_number();
  public:

  // string firmware_revision = 6;
  void clear_firmware_revision();
  const std::string& firmware_revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_revision();
  PROTOBUF_NODISCARD std::string* release_firmware_revision();
  void set_allocated_firmware_revision(std::string* firmware_revision);
  private:
  const std::string& _internal_firmware_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_revision(const std::string& value);
  std::string* _internal_mutable_firmware_revision();
  public:

  // bytes fru_guid = 7;
  void clear_fru_guid();
  const std::string& fru_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fru_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fru_guid();
  PROTOBUF_NODISCARD std::string* release_fru_guid();
  void set_allocated_fru_guid(std::string* fru_guid);
  private:
  const std::string& _internal_fru_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fru_guid(const std::string& value);
  std::string* _internal_mutable_fru_guid();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // int64 max_ns = 5;
  void clear_max_ns();
  int64_t max_ns() const;
  void set_max_ns(int64_t value);
  private:
  int64_t _internal_max_ns() const;
  void _internal_set_max_ns(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nqn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fru_guid_;
  ::opi_api::common::v1::ObjectKey* id_;
  int64_t max_ns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeController) */ {
 public:
  inline NVMeController() : NVMeController(nullptr) {}
  ~NVMeController() override;
  explicit constexpr NVMeController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeController(const NVMeController& from);
  NVMeController(NVMeController&& from) noexcept
    : NVMeController() {
    *this = ::std::move(from);
  }

  inline NVMeController& operator=(const NVMeController& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeController& operator=(NVMeController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeController& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeController* internal_default_instance() {
    return reinterpret_cast<const NVMeController*>(
               &_NVMeController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NVMeController& a, NVMeController& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeController& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeController";
  }
  protected:
  explicit NVMeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSubsystemIdFieldNumber = 3,
    kPcieIdFieldNumber = 4,
    kNvmeControllerIdFieldNumber = 2,
    kMaxNsqFieldNumber = 5,
    kMaxNcqFieldNumber = 6,
    kSqesFieldNumber = 7,
    kCqesFieldNumber = 8,
    kMaxNsFieldNumber = 9,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.storage.v1.NvmeControllerPciId pcie_id = 4;
  bool has_pcie_id() const;
  private:
  bool _internal_has_pcie_id() const;
  public:
  void clear_pcie_id();
  const ::opi_api::storage::v1::NvmeControllerPciId& pcie_id() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeControllerPciId* release_pcie_id();
  ::opi_api::storage::v1::NvmeControllerPciId* mutable_pcie_id();
  void set_allocated_pcie_id(::opi_api::storage::v1::NvmeControllerPciId* pcie_id);
  private:
  const ::opi_api::storage::v1::NvmeControllerPciId& _internal_pcie_id() const;
  ::opi_api::storage::v1::NvmeControllerPciId* _internal_mutable_pcie_id();
  public:
  void unsafe_arena_set_allocated_pcie_id(
      ::opi_api::storage::v1::NvmeControllerPciId* pcie_id);
  ::opi_api::storage::v1::NvmeControllerPciId* unsafe_arena_release_pcie_id();

  // uint32 nvme_controller_id = 2;
  void clear_nvme_controller_id();
  uint32_t nvme_controller_id() const;
  void set_nvme_controller_id(uint32_t value);
  private:
  uint32_t _internal_nvme_controller_id() const;
  void _internal_set_nvme_controller_id(uint32_t value);
  public:

  // uint32 max_nsq = 5;
  void clear_max_nsq();
  uint32_t max_nsq() const;
  void set_max_nsq(uint32_t value);
  private:
  uint32_t _internal_max_nsq() const;
  void _internal_set_max_nsq(uint32_t value);
  public:

  // uint32 max_ncq = 6;
  void clear_max_ncq();
  uint32_t max_ncq() const;
  void set_max_ncq(uint32_t value);
  private:
  uint32_t _internal_max_ncq() const;
  void _internal_set_max_ncq(uint32_t value);
  public:

  // uint32 sqes = 7;
  void clear_sqes();
  uint32_t sqes() const;
  void set_sqes(uint32_t value);
  private:
  uint32_t _internal_sqes() const;
  void _internal_set_sqes(uint32_t value);
  public:

  // uint32 cqes = 8;
  void clear_cqes();
  uint32_t cqes() const;
  void set_cqes(uint32_t value);
  private:
  uint32_t _internal_cqes() const;
  void _internal_set_cqes(uint32_t value);
  public:

  // uint32 max_ns = 9;
  void clear_max_ns();
  uint32_t max_ns() const;
  void set_max_ns(uint32_t value);
  private:
  uint32_t _internal_max_ns() const;
  void _internal_set_max_ns(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::storage::v1::NvmeControllerPciId* pcie_id_;
  uint32_t nvme_controller_id_;
  uint32_t max_nsq_;
  uint32_t max_ncq_;
  uint32_t sqes_;
  uint32_t cqes_;
  uint32_t max_ns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespace) */ {
 public:
  inline NVMeNamespace() : NVMeNamespace(nullptr) {}
  ~NVMeNamespace() override;
  explicit constexpr NVMeNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespace(const NVMeNamespace& from);
  NVMeNamespace(NVMeNamespace&& from) noexcept
    : NVMeNamespace() {
    *this = ::std::move(from);
  }

  inline NVMeNamespace& operator=(const NVMeNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespace& operator=(NVMeNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespace* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespace*>(
               &_NVMeNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NVMeNamespace& a, NVMeNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespace";
  }
  protected:
  explicit NVMeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNguidFieldNumber = 7,
    kIdFieldNumber = 1,
    kSubsystemIdFieldNumber = 2,
    kControllerIdFieldNumber = 3,
    kUuidFieldNumber = 9,
    kVolumeIdFieldNumber = 10,
    kBlockSizeFieldNumber = 5,
    kNumBlocksFieldNumber = 6,
    kHostNsidFieldNumber = 4,
    kOptimalWriteSizeFieldNumber = 11,
    kEui64FieldNumber = 8,
    kPrefWriteGranularityFieldNumber = 12,
  };
  // string nguid = 7;
  void clear_nguid();
  const std::string& nguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nguid();
  PROTOBUF_NODISCARD std::string* release_nguid();
  void set_allocated_nguid(std::string* nguid);
  private:
  const std::string& _internal_nguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nguid(const std::string& value);
  std::string* _internal_mutable_nguid();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // .opi_api.common.v1.Uuid uuid = 9;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::opi_api::common::v1::Uuid& uuid() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::Uuid* release_uuid();
  ::opi_api::common::v1::Uuid* mutable_uuid();
  void set_allocated_uuid(::opi_api::common::v1::Uuid* uuid);
  private:
  const ::opi_api::common::v1::Uuid& _internal_uuid() const;
  ::opi_api::common::v1::Uuid* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::opi_api::common::v1::Uuid* uuid);
  ::opi_api::common::v1::Uuid* unsafe_arena_release_uuid();

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  bool has_volume_id() const;
  private:
  bool _internal_has_volume_id() const;
  public:
  void clear_volume_id();
  const ::opi_api::common::v1::ObjectKey& volume_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_volume_id();
  ::opi_api::common::v1::ObjectKey* mutable_volume_id();
  void set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_volume_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_volume_id();
  public:
  void unsafe_arena_set_allocated_volume_id(
      ::opi_api::common::v1::ObjectKey* volume_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_volume_id();

  // int64 block_size = 5;
  void clear_block_size();
  int64_t block_size() const;
  void set_block_size(int64_t value);
  private:
  int64_t _internal_block_size() const;
  void _internal_set_block_size(int64_t value);
  public:

  // int64 num_blocks = 6;
  void clear_num_blocks();
  int64_t num_blocks() const;
  void set_num_blocks(int64_t value);
  private:
  int64_t _internal_num_blocks() const;
  void _internal_set_num_blocks(int64_t value);
  public:

  // uint32 host_nsid = 4;
  void clear_host_nsid();
  uint32_t host_nsid() const;
  void set_host_nsid(uint32_t value);
  private:
  uint32_t _internal_host_nsid() const;
  void _internal_set_host_nsid(uint32_t value);
  public:

  // uint32 optimal_write_size = 11;
  void clear_optimal_write_size();
  uint32_t optimal_write_size() const;
  void set_optimal_write_size(uint32_t value);
  private:
  uint32_t _internal_optimal_write_size() const;
  void _internal_set_optimal_write_size(uint32_t value);
  public:

  // fixed64 eui64 = 8;
  void clear_eui64();
  uint64_t eui64() const;
  void set_eui64(uint64_t value);
  private:
  uint64_t _internal_eui64() const;
  void _internal_set_eui64(uint64_t value);
  public:

  // uint32 pref_write_granularity = 12;
  void clear_pref_write_granularity();
  uint32_t pref_write_granularity() const;
  void set_pref_write_granularity(uint32_t value);
  private:
  uint32_t _internal_pref_write_granularity() const;
  void _internal_set_pref_write_granularity(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nguid_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  ::opi_api::common::v1::Uuid* uuid_;
  ::opi_api::common::v1::ObjectKey* volume_id_;
  int64_t block_size_;
  int64_t num_blocks_;
  uint32_t host_nsid_;
  uint32_t optimal_write_size_;
  uint64_t eui64_;
  uint32_t pref_write_granularity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemCreateRequest) */ {
 public:
  inline NVMeSubsystemCreateRequest() : NVMeSubsystemCreateRequest(nullptr) {}
  ~NVMeSubsystemCreateRequest() override;
  explicit constexpr NVMeSubsystemCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemCreateRequest(const NVMeSubsystemCreateRequest& from);
  NVMeSubsystemCreateRequest(NVMeSubsystemCreateRequest&& from) noexcept
    : NVMeSubsystemCreateRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemCreateRequest& operator=(const NVMeSubsystemCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemCreateRequest& operator=(NVMeSubsystemCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemCreateRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemCreateRequest*>(
               &_NVMeSubsystemCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NVMeSubsystemCreateRequest& a, NVMeSubsystemCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemCreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemCreateRequest";
  }
  protected:
  explicit NVMeSubsystemCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  bool has_subsystem() const;
  private:
  bool _internal_has_subsystem() const;
  public:
  void clear_subsystem();
  const ::opi_api::storage::v1::NVMeSubsystem& subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystem* release_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_subsystem();
  void set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem);
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_subsystem() const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_mutable_subsystem();
  public:
  void unsafe_arena_set_allocated_subsystem(
      ::opi_api::storage::v1::NVMeSubsystem* subsystem);
  ::opi_api::storage::v1::NVMeSubsystem* unsafe_arena_release_subsystem();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystem* subsystem_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemDeleteRequest) */ {
 public:
  inline NVMeSubsystemDeleteRequest() : NVMeSubsystemDeleteRequest(nullptr) {}
  ~NVMeSubsystemDeleteRequest() override;
  explicit constexpr NVMeSubsystemDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemDeleteRequest(const NVMeSubsystemDeleteRequest& from);
  NVMeSubsystemDeleteRequest(NVMeSubsystemDeleteRequest&& from) noexcept
    : NVMeSubsystemDeleteRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemDeleteRequest& operator=(const NVMeSubsystemDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemDeleteRequest& operator=(NVMeSubsystemDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemDeleteRequest*>(
               &_NVMeSubsystemDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NVMeSubsystemDeleteRequest& a, NVMeSubsystemDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemDeleteRequest";
  }
  protected:
  explicit NVMeSubsystemDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemUpdateRequest) */ {
 public:
  inline NVMeSubsystemUpdateRequest() : NVMeSubsystemUpdateRequest(nullptr) {}
  ~NVMeSubsystemUpdateRequest() override;
  explicit constexpr NVMeSubsystemUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemUpdateRequest(const NVMeSubsystemUpdateRequest& from);
  NVMeSubsystemUpdateRequest(NVMeSubsystemUpdateRequest&& from) noexcept
    : NVMeSubsystemUpdateRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemUpdateRequest& operator=(const NVMeSubsystemUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemUpdateRequest& operator=(NVMeSubsystemUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemUpdateRequest*>(
               &_NVMeSubsystemUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NVMeSubsystemUpdateRequest& a, NVMeSubsystemUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemUpdateRequest";
  }
  protected:
  explicit NVMeSubsystemUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  bool has_subsystem() const;
  private:
  bool _internal_has_subsystem() const;
  public:
  void clear_subsystem();
  const ::opi_api::storage::v1::NVMeSubsystem& subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystem* release_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_subsystem();
  void set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem);
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_subsystem() const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_mutable_subsystem();
  public:
  void unsafe_arena_set_allocated_subsystem(
      ::opi_api::storage::v1::NVMeSubsystem* subsystem);
  ::opi_api::storage::v1::NVMeSubsystem* unsafe_arena_release_subsystem();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystem* subsystem_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemListRequest) */ {
 public:
  inline NVMeSubsystemListRequest() : NVMeSubsystemListRequest(nullptr) {}
  explicit constexpr NVMeSubsystemListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemListRequest(const NVMeSubsystemListRequest& from);
  NVMeSubsystemListRequest(NVMeSubsystemListRequest&& from) noexcept
    : NVMeSubsystemListRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemListRequest& operator=(const NVMeSubsystemListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemListRequest& operator=(NVMeSubsystemListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemListRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemListRequest*>(
               &_NVMeSubsystemListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NVMeSubsystemListRequest& a, NVMeSubsystemListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NVMeSubsystemListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NVMeSubsystemListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemListRequest";
  }
  protected:
  explicit NVMeSubsystemListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemListResponse) */ {
 public:
  inline NVMeSubsystemListResponse() : NVMeSubsystemListResponse(nullptr) {}
  ~NVMeSubsystemListResponse() override;
  explicit constexpr NVMeSubsystemListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemListResponse(const NVMeSubsystemListResponse& from);
  NVMeSubsystemListResponse(NVMeSubsystemListResponse&& from) noexcept
    : NVMeSubsystemListResponse() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemListResponse& operator=(const NVMeSubsystemListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemListResponse& operator=(NVMeSubsystemListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemListResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemListResponse*>(
               &_NVMeSubsystemListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NVMeSubsystemListResponse& a, NVMeSubsystemListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemListResponse";
  }
  protected:
  explicit NVMeSubsystemListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemFieldNumber = 1,
  };
  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  int subsystem_size() const;
  private:
  int _internal_subsystem_size() const;
  public:
  void clear_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_subsystem(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >*
      mutable_subsystem();
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_subsystem(int index) const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_add_subsystem();
  public:
  const ::opi_api::storage::v1::NVMeSubsystem& subsystem(int index) const;
  ::opi_api::storage::v1::NVMeSubsystem* add_subsystem();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >&
      subsystem() const;

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem > subsystem_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemGetRequest) */ {
 public:
  inline NVMeSubsystemGetRequest() : NVMeSubsystemGetRequest(nullptr) {}
  ~NVMeSubsystemGetRequest() override;
  explicit constexpr NVMeSubsystemGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemGetRequest(const NVMeSubsystemGetRequest& from);
  NVMeSubsystemGetRequest(NVMeSubsystemGetRequest&& from) noexcept
    : NVMeSubsystemGetRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemGetRequest& operator=(const NVMeSubsystemGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemGetRequest& operator=(NVMeSubsystemGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemGetRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemGetRequest*>(
               &_NVMeSubsystemGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NVMeSubsystemGetRequest& a, NVMeSubsystemGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemGetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemGetRequest";
  }
  protected:
  explicit NVMeSubsystemGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatsRequest) */ {
 public:
  inline NVMeSubsystemStatsRequest() : NVMeSubsystemStatsRequest(nullptr) {}
  ~NVMeSubsystemStatsRequest() override;
  explicit constexpr NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatsRequest(const NVMeSubsystemStatsRequest& from);
  NVMeSubsystemStatsRequest(NVMeSubsystemStatsRequest&& from) noexcept
    : NVMeSubsystemStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatsRequest& operator=(const NVMeSubsystemStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatsRequest& operator=(NVMeSubsystemStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatsRequest*>(
               &_NVMeSubsystemStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NVMeSubsystemStatsRequest& a, NVMeSubsystemStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatsRequest";
  }
  protected:
  explicit NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatsResponse) */ {
 public:
  inline NVMeSubsystemStatsResponse() : NVMeSubsystemStatsResponse(nullptr) {}
  ~NVMeSubsystemStatsResponse() override;
  explicit constexpr NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatsResponse(const NVMeSubsystemStatsResponse& from);
  NVMeSubsystemStatsResponse(NVMeSubsystemStatsResponse&& from) noexcept
    : NVMeSubsystemStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatsResponse& operator=(const NVMeSubsystemStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatsResponse& operator=(NVMeSubsystemStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatsResponse*>(
               &_NVMeSubsystemStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NVMeSubsystemStatsResponse& a, NVMeSubsystemStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatsResponse";
  }
  protected:
  explicit NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // string stats = 1;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerCreateRequest) */ {
 public:
  inline NVMeControllerCreateRequest() : NVMeControllerCreateRequest(nullptr) {}
  ~NVMeControllerCreateRequest() override;
  explicit constexpr NVMeControllerCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerCreateRequest(const NVMeControllerCreateRequest& from);
  NVMeControllerCreateRequest(NVMeControllerCreateRequest&& from) noexcept
    : NVMeControllerCreateRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerCreateRequest& operator=(const NVMeControllerCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerCreateRequest& operator=(NVMeControllerCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerCreateRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerCreateRequest*>(
               &_NVMeControllerCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NVMeControllerCreateRequest& a, NVMeControllerCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerCreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerCreateRequest";
  }
  protected:
  explicit NVMeControllerCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeController controller = 1;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::opi_api::storage::v1::NVMeController& controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeController* release_controller();
  ::opi_api::storage::v1::NVMeController* mutable_controller();
  void set_allocated_controller(::opi_api::storage::v1::NVMeController* controller);
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_controller() const;
  ::opi_api::storage::v1::NVMeController* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::opi_api::storage::v1::NVMeController* controller);
  ::opi_api::storage::v1::NVMeController* unsafe_arena_release_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeController* controller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerDeleteRequest) */ {
 public:
  inline NVMeControllerDeleteRequest() : NVMeControllerDeleteRequest(nullptr) {}
  ~NVMeControllerDeleteRequest() override;
  explicit constexpr NVMeControllerDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerDeleteRequest(const NVMeControllerDeleteRequest& from);
  NVMeControllerDeleteRequest(NVMeControllerDeleteRequest&& from) noexcept
    : NVMeControllerDeleteRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerDeleteRequest& operator=(const NVMeControllerDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerDeleteRequest& operator=(NVMeControllerDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerDeleteRequest*>(
               &_NVMeControllerDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NVMeControllerDeleteRequest& a, NVMeControllerDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerDeleteRequest";
  }
  protected:
  explicit NVMeControllerDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey controller_id = 1;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerUpdateRequest) */ {
 public:
  inline NVMeControllerUpdateRequest() : NVMeControllerUpdateRequest(nullptr) {}
  ~NVMeControllerUpdateRequest() override;
  explicit constexpr NVMeControllerUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerUpdateRequest(const NVMeControllerUpdateRequest& from);
  NVMeControllerUpdateRequest(NVMeControllerUpdateRequest&& from) noexcept
    : NVMeControllerUpdateRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerUpdateRequest& operator=(const NVMeControllerUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerUpdateRequest& operator=(NVMeControllerUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerUpdateRequest*>(
               &_NVMeControllerUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NVMeControllerUpdateRequest& a, NVMeControllerUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerUpdateRequest";
  }
  protected:
  explicit NVMeControllerUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeController controller = 1;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::opi_api::storage::v1::NVMeController& controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeController* release_controller();
  ::opi_api::storage::v1::NVMeController* mutable_controller();
  void set_allocated_controller(::opi_api::storage::v1::NVMeController* controller);
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_controller() const;
  ::opi_api::storage::v1::NVMeController* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::opi_api::storage::v1::NVMeController* controller);
  ::opi_api::storage::v1::NVMeController* unsafe_arena_release_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeController* controller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerListRequest) */ {
 public:
  inline NVMeControllerListRequest() : NVMeControllerListRequest(nullptr) {}
  ~NVMeControllerListRequest() override;
  explicit constexpr NVMeControllerListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerListRequest(const NVMeControllerListRequest& from);
  NVMeControllerListRequest(NVMeControllerListRequest&& from) noexcept
    : NVMeControllerListRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerListRequest& operator=(const NVMeControllerListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerListRequest& operator=(NVMeControllerListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerListRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerListRequest*>(
               &_NVMeControllerListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NVMeControllerListRequest& a, NVMeControllerListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerListRequest";
  }
  protected:
  explicit NVMeControllerListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerListResponse) */ {
 public:
  inline NVMeControllerListResponse() : NVMeControllerListResponse(nullptr) {}
  ~NVMeControllerListResponse() override;
  explicit constexpr NVMeControllerListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerListResponse(const NVMeControllerListResponse& from);
  NVMeControllerListResponse(NVMeControllerListResponse&& from) noexcept
    : NVMeControllerListResponse() {
    *this = ::std::move(from);
  }

  inline NVMeControllerListResponse& operator=(const NVMeControllerListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerListResponse& operator=(NVMeControllerListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerListResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerListResponse*>(
               &_NVMeControllerListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NVMeControllerListResponse& a, NVMeControllerListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerListResponse";
  }
  protected:
  explicit NVMeControllerListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerFieldNumber = 1,
  };
  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  int controller_size() const;
  private:
  int _internal_controller_size() const;
  public:
  void clear_controller();
  ::opi_api::storage::v1::NVMeController* mutable_controller(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >*
      mutable_controller();
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_controller(int index) const;
  ::opi_api::storage::v1::NVMeController* _internal_add_controller();
  public:
  const ::opi_api::storage::v1::NVMeController& controller(int index) const;
  ::opi_api::storage::v1::NVMeController* add_controller();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >&
      controller() const;

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController > controller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerGetRequest) */ {
 public:
  inline NVMeControllerGetRequest() : NVMeControllerGetRequest(nullptr) {}
  ~NVMeControllerGetRequest() override;
  explicit constexpr NVMeControllerGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerGetRequest(const NVMeControllerGetRequest& from);
  NVMeControllerGetRequest(NVMeControllerGetRequest&& from) noexcept
    : NVMeControllerGetRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerGetRequest& operator=(const NVMeControllerGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerGetRequest& operator=(NVMeControllerGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerGetRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerGetRequest*>(
               &_NVMeControllerGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NVMeControllerGetRequest& a, NVMeControllerGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerGetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerGetRequest";
  }
  protected:
  explicit NVMeControllerGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey controller_id = 1;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatsRequest) */ {
 public:
  inline NVMeControllerStatsRequest() : NVMeControllerStatsRequest(nullptr) {}
  ~NVMeControllerStatsRequest() override;
  explicit constexpr NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatsRequest(const NVMeControllerStatsRequest& from);
  NVMeControllerStatsRequest(NVMeControllerStatsRequest&& from) noexcept
    : NVMeControllerStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatsRequest& operator=(const NVMeControllerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatsRequest& operator=(NVMeControllerStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatsRequest*>(
               &_NVMeControllerStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NVMeControllerStatsRequest& a, NVMeControllerStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatsRequest";
  }
  protected:
  explicit NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatsResponse) */ {
 public:
  inline NVMeControllerStatsResponse() : NVMeControllerStatsResponse(nullptr) {}
  ~NVMeControllerStatsResponse() override;
  explicit constexpr NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatsResponse(const NVMeControllerStatsResponse& from);
  NVMeControllerStatsResponse(NVMeControllerStatsResponse&& from) noexcept
    : NVMeControllerStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatsResponse& operator=(const NVMeControllerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatsResponse& operator=(NVMeControllerStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatsResponse*>(
               &_NVMeControllerStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NVMeControllerStatsResponse& a, NVMeControllerStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatsResponse";
  }
  protected:
  explicit NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string stats = 2;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceCreateRequest) */ {
 public:
  inline NVMeNamespaceCreateRequest() : NVMeNamespaceCreateRequest(nullptr) {}
  ~NVMeNamespaceCreateRequest() override;
  explicit constexpr NVMeNamespaceCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceCreateRequest(const NVMeNamespaceCreateRequest& from);
  NVMeNamespaceCreateRequest(NVMeNamespaceCreateRequest&& from) noexcept
    : NVMeNamespaceCreateRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceCreateRequest& operator=(const NVMeNamespaceCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceCreateRequest& operator=(NVMeNamespaceCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceCreateRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceCreateRequest*>(
               &_NVMeNamespaceCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(NVMeNamespaceCreateRequest& a, NVMeNamespaceCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceCreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceCreateRequest";
  }
  protected:
  explicit NVMeNamespaceCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::opi_api::storage::v1::NVMeNamespace& namespace_() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespace* release_namespace_();
  ::opi_api::storage::v1::NVMeNamespace* mutable_namespace_();
  void set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_);
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_namespace_() const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::opi_api::storage::v1::NVMeNamespace* namespace_);
  ::opi_api::storage::v1::NVMeNamespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceDeleteRequest) */ {
 public:
  inline NVMeNamespaceDeleteRequest() : NVMeNamespaceDeleteRequest(nullptr) {}
  ~NVMeNamespaceDeleteRequest() override;
  explicit constexpr NVMeNamespaceDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceDeleteRequest(const NVMeNamespaceDeleteRequest& from);
  NVMeNamespaceDeleteRequest(NVMeNamespaceDeleteRequest&& from) noexcept
    : NVMeNamespaceDeleteRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceDeleteRequest& operator=(const NVMeNamespaceDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceDeleteRequest& operator=(NVMeNamespaceDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceDeleteRequest*>(
               &_NVMeNamespaceDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(NVMeNamespaceDeleteRequest& a, NVMeNamespaceDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceDeleteRequest";
  }
  protected:
  explicit NVMeNamespaceDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceUpdateRequest) */ {
 public:
  inline NVMeNamespaceUpdateRequest() : NVMeNamespaceUpdateRequest(nullptr) {}
  ~NVMeNamespaceUpdateRequest() override;
  explicit constexpr NVMeNamespaceUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceUpdateRequest(const NVMeNamespaceUpdateRequest& from);
  NVMeNamespaceUpdateRequest(NVMeNamespaceUpdateRequest&& from) noexcept
    : NVMeNamespaceUpdateRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceUpdateRequest& operator=(const NVMeNamespaceUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceUpdateRequest& operator=(NVMeNamespaceUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceUpdateRequest*>(
               &_NVMeNamespaceUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NVMeNamespaceUpdateRequest& a, NVMeNamespaceUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceUpdateRequest";
  }
  protected:
  explicit NVMeNamespaceUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
  };
  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::opi_api::storage::v1::NVMeNamespace& namespace_() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespace* release_namespace_();
  ::opi_api::storage::v1::NVMeNamespace* mutable_namespace_();
  void set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_);
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_namespace_() const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::opi_api::storage::v1::NVMeNamespace* namespace_);
  ::opi_api::storage::v1::NVMeNamespace* unsafe_arena_release_namespace_();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespace* namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceListRequest) */ {
 public:
  inline NVMeNamespaceListRequest() : NVMeNamespaceListRequest(nullptr) {}
  ~NVMeNamespaceListRequest() override;
  explicit constexpr NVMeNamespaceListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceListRequest(const NVMeNamespaceListRequest& from);
  NVMeNamespaceListRequest(NVMeNamespaceListRequest&& from) noexcept
    : NVMeNamespaceListRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceListRequest& operator=(const NVMeNamespaceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceListRequest& operator=(NVMeNamespaceListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceListRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceListRequest*>(
               &_NVMeNamespaceListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(NVMeNamespaceListRequest& a, NVMeNamespaceListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceListRequest";
  }
  protected:
  explicit NVMeNamespaceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
    kControllerIdFieldNumber = 2,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  bool has_controller_id() const;
  private:
  bool _internal_has_controller_id() const;
  public:
  void clear_controller_id();
  const ::opi_api::common::v1::ObjectKey& controller_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_controller_id();
  ::opi_api::common::v1::ObjectKey* mutable_controller_id();
  void set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_controller_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_controller_id();
  public:
  void unsafe_arena_set_allocated_controller_id(
      ::opi_api::common::v1::ObjectKey* controller_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_controller_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::common::v1::ObjectKey* controller_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceListResponse) */ {
 public:
  inline NVMeNamespaceListResponse() : NVMeNamespaceListResponse(nullptr) {}
  ~NVMeNamespaceListResponse() override;
  explicit constexpr NVMeNamespaceListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceListResponse(const NVMeNamespaceListResponse& from);
  NVMeNamespaceListResponse(NVMeNamespaceListResponse&& from) noexcept
    : NVMeNamespaceListResponse() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceListResponse& operator=(const NVMeNamespaceListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceListResponse& operator=(NVMeNamespaceListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceListResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceListResponse*>(
               &_NVMeNamespaceListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NVMeNamespaceListResponse& a, NVMeNamespaceListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceListResponse";
  }
  protected:
  explicit NVMeNamespaceListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
  };
  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  int namespace__size() const;
  private:
  int _internal_namespace__size() const;
  public:
  void clear_namespace_();
  ::opi_api::storage::v1::NVMeNamespace* mutable_namespace_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >*
      mutable_namespace_();
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_namespace_(int index) const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_add_namespace_();
  public:
  const ::opi_api::storage::v1::NVMeNamespace& namespace_(int index) const;
  ::opi_api::storage::v1::NVMeNamespace* add_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >&
      namespace_() const;

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace > namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceGetRequest) */ {
 public:
  inline NVMeNamespaceGetRequest() : NVMeNamespaceGetRequest(nullptr) {}
  ~NVMeNamespaceGetRequest() override;
  explicit constexpr NVMeNamespaceGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceGetRequest(const NVMeNamespaceGetRequest& from);
  NVMeNamespaceGetRequest(NVMeNamespaceGetRequest&& from) noexcept
    : NVMeNamespaceGetRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceGetRequest& operator=(const NVMeNamespaceGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceGetRequest& operator=(NVMeNamespaceGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceGetRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceGetRequest*>(
               &_NVMeNamespaceGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(NVMeNamespaceGetRequest& a, NVMeNamespaceGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceGetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceGetRequest";
  }
  protected:
  explicit NVMeNamespaceGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatsRequest) */ {
 public:
  inline NVMeNamespaceStatsRequest() : NVMeNamespaceStatsRequest(nullptr) {}
  ~NVMeNamespaceStatsRequest() override;
  explicit constexpr NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatsRequest(const NVMeNamespaceStatsRequest& from);
  NVMeNamespaceStatsRequest(NVMeNamespaceStatsRequest&& from) noexcept
    : NVMeNamespaceStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatsRequest& operator=(const NVMeNamespaceStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatsRequest& operator=(NVMeNamespaceStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatsRequest*>(
               &_NVMeNamespaceStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(NVMeNamespaceStatsRequest& a, NVMeNamespaceStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatsRequest";
  }
  protected:
  explicit NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatsResponse) */ {
 public:
  inline NVMeNamespaceStatsResponse() : NVMeNamespaceStatsResponse(nullptr) {}
  ~NVMeNamespaceStatsResponse() override;
  explicit constexpr NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatsResponse(const NVMeNamespaceStatsResponse& from);
  NVMeNamespaceStatsResponse(NVMeNamespaceStatsResponse&& from) noexcept
    : NVMeNamespaceStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatsResponse& operator=(const NVMeNamespaceStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatsResponse& operator=(NVMeNamespaceStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatsResponse*>(
               &_NVMeNamespaceStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(NVMeNamespaceStatsResponse& a, NVMeNamespaceStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatsResponse";
  }
  protected:
  explicit NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string stats = 2;
  void clear_stats();
  const std::string& stats() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stats(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stats();
  PROTOBUF_NODISCARD std::string* release_stats();
  void set_allocated_stats(std::string* stats);
  private:
  const std::string& _internal_stats() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stats(const std::string& value);
  std::string* _internal_mutable_stats();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stats_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NVMeSubsystem

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeSubsystem::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeSubsystem::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystem::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystem::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.id)
  return _internal_id();
}
inline void NVMeSubsystem::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystem.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystem::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystem::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystem::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystem::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.id)
  return _msg;
}
inline void NVMeSubsystem::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.id)
}

// string nqn = 2;
inline void NVMeSubsystem::clear_nqn() {
  nqn_.ClearToEmpty();
}
inline const std::string& NVMeSubsystem::nqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.nqn)
  return _internal_nqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystem::set_nqn(ArgT0&& arg0, ArgT... args) {
 
 nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystem.nqn)
}
inline std::string* NVMeSubsystem::mutable_nqn() {
  std::string* _s = _internal_mutable_nqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.nqn)
  return _s;
}
inline const std::string& NVMeSubsystem::_internal_nqn() const {
  return nqn_.Get();
}
inline void NVMeSubsystem::_internal_set_nqn(const std::string& value) {
  
  nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::_internal_mutable_nqn() {
  
  return nqn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::release_nqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.nqn)
  return nqn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystem::set_allocated_nqn(std::string* nqn) {
  if (nqn != nullptr) {
    
  } else {
    
  }
  nqn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nqn,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nqn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.nqn)
}

// string serial_number = 3;
inline void NVMeSubsystem::clear_serial_number() {
  serial_number_.ClearToEmpty();
}
inline const std::string& NVMeSubsystem::serial_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystem::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystem.serial_number)
}
inline std::string* NVMeSubsystem::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.serial_number)
  return _s;
}
inline const std::string& NVMeSubsystem::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void NVMeSubsystem::_internal_set_serial_number(const std::string& value) {
  
  serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::_internal_mutable_serial_number() {
  
  return serial_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::release_serial_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.serial_number)
  return serial_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystem::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  serial_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.serial_number)
}

// string model_number = 4;
inline void NVMeSubsystem::clear_model_number() {
  model_number_.ClearToEmpty();
}
inline const std::string& NVMeSubsystem::model_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.model_number)
  return _internal_model_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystem::set_model_number(ArgT0&& arg0, ArgT... args) {
 
 model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystem.model_number)
}
inline std::string* NVMeSubsystem::mutable_model_number() {
  std::string* _s = _internal_mutable_model_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.model_number)
  return _s;
}
inline const std::string& NVMeSubsystem::_internal_model_number() const {
  return model_number_.Get();
}
inline void NVMeSubsystem::_internal_set_model_number(const std::string& value) {
  
  model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::_internal_mutable_model_number() {
  
  return model_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::release_model_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.model_number)
  return model_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystem::set_allocated_model_number(std::string* model_number) {
  if (model_number != nullptr) {
    
  } else {
    
  }
  model_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.model_number)
}

// int64 max_ns = 5;
inline void NVMeSubsystem::clear_max_ns() {
  max_ns_ = int64_t{0};
}
inline int64_t NVMeSubsystem::_internal_max_ns() const {
  return max_ns_;
}
inline int64_t NVMeSubsystem::max_ns() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.max_ns)
  return _internal_max_ns();
}
inline void NVMeSubsystem::_internal_set_max_ns(int64_t value) {
  
  max_ns_ = value;
}
inline void NVMeSubsystem::set_max_ns(int64_t value) {
  _internal_set_max_ns(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystem.max_ns)
}

// string firmware_revision = 6;
inline void NVMeSubsystem::clear_firmware_revision() {
  firmware_revision_.ClearToEmpty();
}
inline const std::string& NVMeSubsystem::firmware_revision() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.firmware_revision)
  return _internal_firmware_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystem::set_firmware_revision(ArgT0&& arg0, ArgT... args) {
 
 firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystem.firmware_revision)
}
inline std::string* NVMeSubsystem::mutable_firmware_revision() {
  std::string* _s = _internal_mutable_firmware_revision();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.firmware_revision)
  return _s;
}
inline const std::string& NVMeSubsystem::_internal_firmware_revision() const {
  return firmware_revision_.Get();
}
inline void NVMeSubsystem::_internal_set_firmware_revision(const std::string& value) {
  
  firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::_internal_mutable_firmware_revision() {
  
  return firmware_revision_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.firmware_revision)
  return firmware_revision_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystem::set_allocated_firmware_revision(std::string* firmware_revision) {
  if (firmware_revision != nullptr) {
    
  } else {
    
  }
  firmware_revision_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), firmware_revision,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (firmware_revision_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.firmware_revision)
}

// bytes fru_guid = 7;
inline void NVMeSubsystem::clear_fru_guid() {
  fru_guid_.ClearToEmpty();
}
inline const std::string& NVMeSubsystem::fru_guid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.fru_guid)
  return _internal_fru_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystem::set_fru_guid(ArgT0&& arg0, ArgT... args) {
 
 fru_guid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystem.fru_guid)
}
inline std::string* NVMeSubsystem::mutable_fru_guid() {
  std::string* _s = _internal_mutable_fru_guid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.fru_guid)
  return _s;
}
inline const std::string& NVMeSubsystem::_internal_fru_guid() const {
  return fru_guid_.Get();
}
inline void NVMeSubsystem::_internal_set_fru_guid(const std::string& value) {
  
  fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::_internal_mutable_fru_guid() {
  
  return fru_guid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystem::release_fru_guid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.fru_guid)
  return fru_guid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystem::set_allocated_fru_guid(std::string* fru_guid) {
  if (fru_guid != nullptr) {
    
  } else {
    
  }
  fru_guid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fru_guid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fru_guid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.fru_guid)
}

// -------------------------------------------------------------------

// NVMeController

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeController::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeController::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeController::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeController::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.id)
  return _internal_id();
}
inline void NVMeController::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.id)
  return _msg;
}
inline void NVMeController::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.id)
}

// uint32 nvme_controller_id = 2;
inline void NVMeController::clear_nvme_controller_id() {
  nvme_controller_id_ = 0u;
}
inline uint32_t NVMeController::_internal_nvme_controller_id() const {
  return nvme_controller_id_;
}
inline uint32_t NVMeController::nvme_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.nvme_controller_id)
  return _internal_nvme_controller_id();
}
inline void NVMeController::_internal_set_nvme_controller_id(uint32_t value) {
  
  nvme_controller_id_ = value;
}
inline void NVMeController::set_nvme_controller_id(uint32_t value) {
  _internal_set_nvme_controller_id(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeController.nvme_controller_id)
}

// .opi_api.common.v1.ObjectKey subsystem_id = 3;
inline bool NVMeController::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeController::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeController::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeController::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeController::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeController::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.subsystem_id)
  return _msg;
}
inline void NVMeController::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.subsystem_id)
}

// .opi_api.storage.v1.NvmeControllerPciId pcie_id = 4;
inline bool NVMeController::_internal_has_pcie_id() const {
  return this != internal_default_instance() && pcie_id_ != nullptr;
}
inline bool NVMeController::has_pcie_id() const {
  return _internal_has_pcie_id();
}
inline const ::opi_api::storage::v1::NvmeControllerPciId& NVMeController::_internal_pcie_id() const {
  const ::opi_api::storage::v1::NvmeControllerPciId* p = pcie_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeControllerPciId&>(
      ::opi_api::storage::v1::_NvmeControllerPciId_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeControllerPciId& NVMeController::pcie_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.pcie_id)
  return _internal_pcie_id();
}
inline void NVMeController::unsafe_arena_set_allocated_pcie_id(
    ::opi_api::storage::v1::NvmeControllerPciId* pcie_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id_);
  }
  pcie_id_ = pcie_id;
  if (pcie_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.pcie_id)
}
inline ::opi_api::storage::v1::NvmeControllerPciId* NVMeController::release_pcie_id() {
  
  ::opi_api::storage::v1::NvmeControllerPciId* temp = pcie_id_;
  pcie_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeControllerPciId* NVMeController::unsafe_arena_release_pcie_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.pcie_id)
  
  ::opi_api::storage::v1::NvmeControllerPciId* temp = pcie_id_;
  pcie_id_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeControllerPciId* NVMeController::_internal_mutable_pcie_id() {
  
  if (pcie_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeControllerPciId>(GetArenaForAllocation());
    pcie_id_ = p;
  }
  return pcie_id_;
}
inline ::opi_api::storage::v1::NvmeControllerPciId* NVMeController::mutable_pcie_id() {
  ::opi_api::storage::v1::NvmeControllerPciId* _msg = _internal_mutable_pcie_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.pcie_id)
  return _msg;
}
inline void NVMeController::set_allocated_pcie_id(::opi_api::storage::v1::NvmeControllerPciId* pcie_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id_);
  }
  if (pcie_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id));
    if (message_arena != submessage_arena) {
      pcie_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pcie_id, submessage_arena);
    }
    
  } else {
    
  }
  pcie_id_ = pcie_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.pcie_id)
}

// uint32 max_nsq = 5;
inline void NVMeController::clear_max_nsq() {
  max_nsq_ = 0u;
}
inline uint32_t NVMeController::_internal_max_nsq() const {
  return max_nsq_;
}
inline uint32_t NVMeController::max_nsq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.max_nsq)
  return _internal_max_nsq();
}
inline void NVMeController::_internal_set_max_nsq(uint32_t value) {
  
  max_nsq_ = value;
}
inline void NVMeController::set_max_nsq(uint32_t value) {
  _internal_set_max_nsq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeController.max_nsq)
}

// uint32 max_ncq = 6;
inline void NVMeController::clear_max_ncq() {
  max_ncq_ = 0u;
}
inline uint32_t NVMeController::_internal_max_ncq() const {
  return max_ncq_;
}
inline uint32_t NVMeController::max_ncq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.max_ncq)
  return _internal_max_ncq();
}
inline void NVMeController::_internal_set_max_ncq(uint32_t value) {
  
  max_ncq_ = value;
}
inline void NVMeController::set_max_ncq(uint32_t value) {
  _internal_set_max_ncq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeController.max_ncq)
}

// uint32 sqes = 7;
inline void NVMeController::clear_sqes() {
  sqes_ = 0u;
}
inline uint32_t NVMeController::_internal_sqes() const {
  return sqes_;
}
inline uint32_t NVMeController::sqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.sqes)
  return _internal_sqes();
}
inline void NVMeController::_internal_set_sqes(uint32_t value) {
  
  sqes_ = value;
}
inline void NVMeController::set_sqes(uint32_t value) {
  _internal_set_sqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeController.sqes)
}

// uint32 cqes = 8;
inline void NVMeController::clear_cqes() {
  cqes_ = 0u;
}
inline uint32_t NVMeController::_internal_cqes() const {
  return cqes_;
}
inline uint32_t NVMeController::cqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.cqes)
  return _internal_cqes();
}
inline void NVMeController::_internal_set_cqes(uint32_t value) {
  
  cqes_ = value;
}
inline void NVMeController::set_cqes(uint32_t value) {
  _internal_set_cqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeController.cqes)
}

// uint32 max_ns = 9;
inline void NVMeController::clear_max_ns() {
  max_ns_ = 0u;
}
inline uint32_t NVMeController::_internal_max_ns() const {
  return max_ns_;
}
inline uint32_t NVMeController::max_ns() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.max_ns)
  return _internal_max_ns();
}
inline void NVMeController::_internal_set_max_ns(uint32_t value) {
  
  max_ns_ = value;
}
inline void NVMeController::set_max_ns(uint32_t value) {
  _internal_set_max_ns(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeController.max_ns)
}

// -------------------------------------------------------------------

// NVMeNamespace

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeNamespace::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeNamespace::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.id)
  return _internal_id();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.id)
  return _msg;
}
inline void NVMeNamespace::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.id)
}

// .opi_api.common.v1.ObjectKey subsystem_id = 2;
inline bool NVMeNamespace::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeNamespace::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.subsystem_id)
  return _msg;
}
inline void NVMeNamespace::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.subsystem_id)
}

// .opi_api.common.v1.ObjectKey controller_id = 3;
inline bool NVMeNamespace::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool NVMeNamespace::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.controller_id)
  return _internal_controller_id();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.controller_id)
  return _msg;
}
inline void NVMeNamespace::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.controller_id)
}

// uint32 host_nsid = 4;
inline void NVMeNamespace::clear_host_nsid() {
  host_nsid_ = 0u;
}
inline uint32_t NVMeNamespace::_internal_host_nsid() const {
  return host_nsid_;
}
inline uint32_t NVMeNamespace::host_nsid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.host_nsid)
  return _internal_host_nsid();
}
inline void NVMeNamespace::_internal_set_host_nsid(uint32_t value) {
  
  host_nsid_ = value;
}
inline void NVMeNamespace::set_host_nsid(uint32_t value) {
  _internal_set_host_nsid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.host_nsid)
}

// int64 block_size = 5;
inline void NVMeNamespace::clear_block_size() {
  block_size_ = int64_t{0};
}
inline int64_t NVMeNamespace::_internal_block_size() const {
  return block_size_;
}
inline int64_t NVMeNamespace::block_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.block_size)
  return _internal_block_size();
}
inline void NVMeNamespace::_internal_set_block_size(int64_t value) {
  
  block_size_ = value;
}
inline void NVMeNamespace::set_block_size(int64_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.block_size)
}

// int64 num_blocks = 6;
inline void NVMeNamespace::clear_num_blocks() {
  num_blocks_ = int64_t{0};
}
inline int64_t NVMeNamespace::_internal_num_blocks() const {
  return num_blocks_;
}
inline int64_t NVMeNamespace::num_blocks() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.num_blocks)
  return _internal_num_blocks();
}
inline void NVMeNamespace::_internal_set_num_blocks(int64_t value) {
  
  num_blocks_ = value;
}
inline void NVMeNamespace::set_num_blocks(int64_t value) {
  _internal_set_num_blocks(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.num_blocks)
}

// string nguid = 7;
inline void NVMeNamespace::clear_nguid() {
  nguid_.ClearToEmpty();
}
inline const std::string& NVMeNamespace::nguid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.nguid)
  return _internal_nguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeNamespace::set_nguid(ArgT0&& arg0, ArgT... args) {
 
 nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.nguid)
}
inline std::string* NVMeNamespace::mutable_nguid() {
  std::string* _s = _internal_mutable_nguid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.nguid)
  return _s;
}
inline const std::string& NVMeNamespace::_internal_nguid() const {
  return nguid_.Get();
}
inline void NVMeNamespace::_internal_set_nguid(const std::string& value) {
  
  nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeNamespace::_internal_mutable_nguid() {
  
  return nguid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeNamespace::release_nguid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.nguid)
  return nguid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeNamespace::set_allocated_nguid(std::string* nguid) {
  if (nguid != nullptr) {
    
  } else {
    
  }
  nguid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nguid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nguid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.nguid)
}

// fixed64 eui64 = 8;
inline void NVMeNamespace::clear_eui64() {
  eui64_ = uint64_t{0u};
}
inline uint64_t NVMeNamespace::_internal_eui64() const {
  return eui64_;
}
inline uint64_t NVMeNamespace::eui64() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.eui64)
  return _internal_eui64();
}
inline void NVMeNamespace::_internal_set_eui64(uint64_t value) {
  
  eui64_ = value;
}
inline void NVMeNamespace::set_eui64(uint64_t value) {
  _internal_set_eui64(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.eui64)
}

// .opi_api.common.v1.Uuid uuid = 9;
inline bool NVMeNamespace::_internal_has_uuid() const {
  return this != internal_default_instance() && uuid_ != nullptr;
}
inline bool NVMeNamespace::has_uuid() const {
  return _internal_has_uuid();
}
inline const ::opi_api::common::v1::Uuid& NVMeNamespace::_internal_uuid() const {
  const ::opi_api::common::v1::Uuid* p = uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::Uuid&>(
      ::opi_api::common::v1::_Uuid_default_instance_);
}
inline const ::opi_api::common::v1::Uuid& NVMeNamespace::uuid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.uuid)
  return _internal_uuid();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_uuid(
    ::opi_api::common::v1::Uuid* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  uuid_ = uuid;
  if (uuid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.uuid)
}
inline ::opi_api::common::v1::Uuid* NVMeNamespace::release_uuid() {
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespace::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.uuid)
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespace::_internal_mutable_uuid() {
  
  if (uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::Uuid>(GetArenaForAllocation());
    uuid_ = p;
  }
  return uuid_;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespace::mutable_uuid() {
  ::opi_api::common::v1::Uuid* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.uuid)
  return _msg;
}
inline void NVMeNamespace::set_allocated_uuid(::opi_api::common::v1::Uuid* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid));
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    
  } else {
    
  }
  uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.uuid)
}

// .opi_api.common.v1.ObjectKey volume_id = 10;
inline bool NVMeNamespace::_internal_has_volume_id() const {
  return this != internal_default_instance() && volume_id_ != nullptr;
}
inline bool NVMeNamespace::has_volume_id() const {
  return _internal_has_volume_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::_internal_volume_id() const {
  const ::opi_api::common::v1::ObjectKey* p = volume_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespace::volume_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.volume_id)
  return _internal_volume_id();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_volume_id(
    ::opi_api::common::v1::ObjectKey* volume_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  volume_id_ = volume_id;
  if (volume_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.volume_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::release_volume_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.volume_id)
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::_internal_mutable_volume_id() {
  
  if (volume_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    volume_id_ = p;
  }
  return volume_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespace::mutable_volume_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.volume_id)
  return _msg;
}
inline void NVMeNamespace::set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  if (volume_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id));
    if (message_arena != submessage_arena) {
      volume_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_id, submessage_arena);
    }
    
  } else {
    
  }
  volume_id_ = volume_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.volume_id)
}

// uint32 optimal_write_size = 11;
inline void NVMeNamespace::clear_optimal_write_size() {
  optimal_write_size_ = 0u;
}
inline uint32_t NVMeNamespace::_internal_optimal_write_size() const {
  return optimal_write_size_;
}
inline uint32_t NVMeNamespace::optimal_write_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.optimal_write_size)
  return _internal_optimal_write_size();
}
inline void NVMeNamespace::_internal_set_optimal_write_size(uint32_t value) {
  
  optimal_write_size_ = value;
}
inline void NVMeNamespace::set_optimal_write_size(uint32_t value) {
  _internal_set_optimal_write_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.optimal_write_size)
}

// uint32 pref_write_granularity = 12;
inline void NVMeNamespace::clear_pref_write_granularity() {
  pref_write_granularity_ = 0u;
}
inline uint32_t NVMeNamespace::_internal_pref_write_granularity() const {
  return pref_write_granularity_;
}
inline uint32_t NVMeNamespace::pref_write_granularity() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.pref_write_granularity)
  return _internal_pref_write_granularity();
}
inline void NVMeNamespace::_internal_set_pref_write_granularity(uint32_t value) {
  
  pref_write_granularity_ = value;
}
inline void NVMeNamespace::set_pref_write_granularity(uint32_t value) {
  _internal_set_pref_write_granularity(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespace.pref_write_granularity)
}

// -------------------------------------------------------------------

// NVMeSubsystemCreateRequest

// .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
inline bool NVMeSubsystemCreateRequest::_internal_has_subsystem() const {
  return this != internal_default_instance() && subsystem_ != nullptr;
}
inline bool NVMeSubsystemCreateRequest::has_subsystem() const {
  return _internal_has_subsystem();
}
inline void NVMeSubsystemCreateRequest::clear_subsystem() {
  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& NVMeSubsystemCreateRequest::_internal_subsystem() const {
  const ::opi_api::storage::v1::NVMeSubsystem* p = subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystem&>(
      ::opi_api::storage::v1::_NVMeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& NVMeSubsystemCreateRequest::subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemCreateRequest.subsystem)
  return _internal_subsystem();
}
inline void NVMeSubsystemCreateRequest::unsafe_arena_set_allocated_subsystem(
    ::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_);
  }
  subsystem_ = subsystem;
  if (subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemCreateRequest.subsystem)
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemCreateRequest::release_subsystem() {
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemCreateRequest::unsafe_arena_release_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemCreateRequest.subsystem)
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemCreateRequest::_internal_mutable_subsystem() {
  
  if (subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(GetArenaForAllocation());
    subsystem_ = p;
  }
  return subsystem_;
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemCreateRequest::mutable_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _msg = _internal_mutable_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemCreateRequest.subsystem)
  return _msg;
}
inline void NVMeSubsystemCreateRequest::set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subsystem_;
  }
  if (subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystem>::GetOwningArena(subsystem);
    if (message_arena != submessage_arena) {
      subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_ = subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemCreateRequest.subsystem)
}

// -------------------------------------------------------------------

// NVMeSubsystemDeleteRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeSubsystemDeleteRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeSubsystemDeleteRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemDeleteRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemDeleteRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemDeleteRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeSubsystemDeleteRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemDeleteRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemDeleteRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemDeleteRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemDeleteRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemDeleteRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemDeleteRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemDeleteRequest.subsystem_id)
  return _msg;
}
inline void NVMeSubsystemDeleteRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemDeleteRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeSubsystemUpdateRequest

// .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
inline bool NVMeSubsystemUpdateRequest::_internal_has_subsystem() const {
  return this != internal_default_instance() && subsystem_ != nullptr;
}
inline bool NVMeSubsystemUpdateRequest::has_subsystem() const {
  return _internal_has_subsystem();
}
inline void NVMeSubsystemUpdateRequest::clear_subsystem() {
  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& NVMeSubsystemUpdateRequest::_internal_subsystem() const {
  const ::opi_api::storage::v1::NVMeSubsystem* p = subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystem&>(
      ::opi_api::storage::v1::_NVMeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& NVMeSubsystemUpdateRequest::subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemUpdateRequest.subsystem)
  return _internal_subsystem();
}
inline void NVMeSubsystemUpdateRequest::unsafe_arena_set_allocated_subsystem(
    ::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_);
  }
  subsystem_ = subsystem;
  if (subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemUpdateRequest.subsystem)
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemUpdateRequest::release_subsystem() {
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemUpdateRequest::unsafe_arena_release_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemUpdateRequest.subsystem)
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = subsystem_;
  subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemUpdateRequest::_internal_mutable_subsystem() {
  
  if (subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(GetArenaForAllocation());
    subsystem_ = p;
  }
  return subsystem_;
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemUpdateRequest::mutable_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _msg = _internal_mutable_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemUpdateRequest.subsystem)
  return _msg;
}
inline void NVMeSubsystemUpdateRequest::set_allocated_subsystem(::opi_api::storage::v1::NVMeSubsystem* subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subsystem_;
  }
  if (subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystem>::GetOwningArena(subsystem);
    if (message_arena != submessage_arena) {
      subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_ = subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemUpdateRequest.subsystem)
}

// -------------------------------------------------------------------

// NVMeSubsystemListRequest

// -------------------------------------------------------------------

// NVMeSubsystemListResponse

// repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
inline int NVMeSubsystemListResponse::_internal_subsystem_size() const {
  return subsystem_.size();
}
inline int NVMeSubsystemListResponse::subsystem_size() const {
  return _internal_subsystem_size();
}
inline void NVMeSubsystemListResponse::clear_subsystem() {
  subsystem_.Clear();
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemListResponse::mutable_subsystem(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemListResponse.subsystem)
  return subsystem_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >*
NVMeSubsystemListResponse::mutable_subsystem() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.NVMeSubsystemListResponse.subsystem)
  return &subsystem_;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& NVMeSubsystemListResponse::_internal_subsystem(int index) const {
  return subsystem_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& NVMeSubsystemListResponse::subsystem(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemListResponse.subsystem)
  return _internal_subsystem(index);
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemListResponse::_internal_add_subsystem() {
  return subsystem_.Add();
}
inline ::opi_api::storage::v1::NVMeSubsystem* NVMeSubsystemListResponse::add_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _add = _internal_add_subsystem();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.NVMeSubsystemListResponse.subsystem)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >&
NVMeSubsystemListResponse::subsystem() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.NVMeSubsystemListResponse.subsystem)
  return subsystem_;
}

// -------------------------------------------------------------------

// NVMeSubsystemGetRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeSubsystemGetRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeSubsystemGetRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemGetRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemGetRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemGetRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeSubsystemGetRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemGetRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemGetRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemGetRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemGetRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemGetRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemGetRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemGetRequest.subsystem_id)
  return _msg;
}
inline void NVMeSubsystemGetRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemGetRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatsRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeSubsystemStatsRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeSubsystemStatsRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemStatsRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemStatsRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeSubsystemStatsRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  return _msg;
}
inline void NVMeSubsystemStatsRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatsResponse

// string stats = 1;
inline void NVMeSubsystemStatsResponse::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemStatsResponse::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
}
inline std::string* NVMeSubsystemStatsResponse::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return _s;
}
inline const std::string& NVMeSubsystemStatsResponse::_internal_stats() const {
  return stats_.Get();
}
inline void NVMeSubsystemStatsResponse::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatsResponse::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemStatsResponse::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
}

// -------------------------------------------------------------------

// NVMeControllerCreateRequest

// .opi_api.storage.v1.NVMeController controller = 1;
inline bool NVMeControllerCreateRequest::_internal_has_controller() const {
  return this != internal_default_instance() && controller_ != nullptr;
}
inline bool NVMeControllerCreateRequest::has_controller() const {
  return _internal_has_controller();
}
inline void NVMeControllerCreateRequest::clear_controller() {
  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeController& NVMeControllerCreateRequest::_internal_controller() const {
  const ::opi_api::storage::v1::NVMeController* p = controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeController&>(
      ::opi_api::storage::v1::_NVMeController_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeController& NVMeControllerCreateRequest::controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerCreateRequest.controller)
  return _internal_controller();
}
inline void NVMeControllerCreateRequest::unsafe_arena_set_allocated_controller(
    ::opi_api::storage::v1::NVMeController* controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerCreateRequest.controller)
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerCreateRequest::release_controller() {
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerCreateRequest::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerCreateRequest.controller)
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerCreateRequest::_internal_mutable_controller() {
  
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(GetArenaForAllocation());
    controller_ = p;
  }
  return controller_;
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerCreateRequest::mutable_controller() {
  ::opi_api::storage::v1::NVMeController* _msg = _internal_mutable_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerCreateRequest.controller)
  return _msg;
}
inline void NVMeControllerCreateRequest::set_allocated_controller(::opi_api::storage::v1::NVMeController* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeController>::GetOwningArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerCreateRequest.controller)
}

// -------------------------------------------------------------------

// NVMeControllerDeleteRequest

// .opi_api.common.v1.ObjectKey controller_id = 1;
inline bool NVMeControllerDeleteRequest::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool NVMeControllerDeleteRequest::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerDeleteRequest::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerDeleteRequest::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerDeleteRequest.controller_id)
  return _internal_controller_id();
}
inline void NVMeControllerDeleteRequest::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerDeleteRequest.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerDeleteRequest::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerDeleteRequest::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerDeleteRequest.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerDeleteRequest::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerDeleteRequest::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerDeleteRequest.controller_id)
  return _msg;
}
inline void NVMeControllerDeleteRequest::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerDeleteRequest.controller_id)
}

// -------------------------------------------------------------------

// NVMeControllerUpdateRequest

// .opi_api.storage.v1.NVMeController controller = 1;
inline bool NVMeControllerUpdateRequest::_internal_has_controller() const {
  return this != internal_default_instance() && controller_ != nullptr;
}
inline bool NVMeControllerUpdateRequest::has_controller() const {
  return _internal_has_controller();
}
inline void NVMeControllerUpdateRequest::clear_controller() {
  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeController& NVMeControllerUpdateRequest::_internal_controller() const {
  const ::opi_api::storage::v1::NVMeController* p = controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeController&>(
      ::opi_api::storage::v1::_NVMeController_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeController& NVMeControllerUpdateRequest::controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerUpdateRequest.controller)
  return _internal_controller();
}
inline void NVMeControllerUpdateRequest::unsafe_arena_set_allocated_controller(
    ::opi_api::storage::v1::NVMeController* controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerUpdateRequest.controller)
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerUpdateRequest::release_controller() {
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerUpdateRequest::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerUpdateRequest.controller)
  
  ::opi_api::storage::v1::NVMeController* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerUpdateRequest::_internal_mutable_controller() {
  
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(GetArenaForAllocation());
    controller_ = p;
  }
  return controller_;
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerUpdateRequest::mutable_controller() {
  ::opi_api::storage::v1::NVMeController* _msg = _internal_mutable_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerUpdateRequest.controller)
  return _msg;
}
inline void NVMeControllerUpdateRequest::set_allocated_controller(::opi_api::storage::v1::NVMeController* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeController>::GetOwningArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerUpdateRequest.controller)
}

// -------------------------------------------------------------------

// NVMeControllerListRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeControllerListRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeControllerListRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerListRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerListRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerListRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeControllerListRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerListRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerListRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerListRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerListRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerListRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerListRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerListRequest.subsystem_id)
  return _msg;
}
inline void NVMeControllerListRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerListRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeControllerListResponse

// repeated .opi_api.storage.v1.NVMeController controller = 1;
inline int NVMeControllerListResponse::_internal_controller_size() const {
  return controller_.size();
}
inline int NVMeControllerListResponse::controller_size() const {
  return _internal_controller_size();
}
inline void NVMeControllerListResponse::clear_controller() {
  controller_.Clear();
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerListResponse::mutable_controller(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerListResponse.controller)
  return controller_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >*
NVMeControllerListResponse::mutable_controller() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.NVMeControllerListResponse.controller)
  return &controller_;
}
inline const ::opi_api::storage::v1::NVMeController& NVMeControllerListResponse::_internal_controller(int index) const {
  return controller_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeController& NVMeControllerListResponse::controller(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerListResponse.controller)
  return _internal_controller(index);
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerListResponse::_internal_add_controller() {
  return controller_.Add();
}
inline ::opi_api::storage::v1::NVMeController* NVMeControllerListResponse::add_controller() {
  ::opi_api::storage::v1::NVMeController* _add = _internal_add_controller();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.NVMeControllerListResponse.controller)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >&
NVMeControllerListResponse::controller() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.NVMeControllerListResponse.controller)
  return controller_;
}

// -------------------------------------------------------------------

// NVMeControllerGetRequest

// .opi_api.common.v1.ObjectKey controller_id = 1;
inline bool NVMeControllerGetRequest::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool NVMeControllerGetRequest::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerGetRequest::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerGetRequest::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerGetRequest.controller_id)
  return _internal_controller_id();
}
inline void NVMeControllerGetRequest::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerGetRequest.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerGetRequest::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerGetRequest::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerGetRequest.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerGetRequest::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerGetRequest::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerGetRequest.controller_id)
  return _msg;
}
inline void NVMeControllerGetRequest::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerGetRequest.controller_id)
}

// -------------------------------------------------------------------

// NVMeControllerStatsRequest

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerStatsRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerStatsRequest::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsRequest::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsRequest::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  return _internal_id();
}
inline void NVMeControllerStatsRequest::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsRequest.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  return _msg;
}
inline void NVMeControllerStatsRequest::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsRequest.id)
}

// -------------------------------------------------------------------

// NVMeControllerStatsResponse

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerStatsResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerStatsResponse::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsResponse::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsResponse::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  return _internal_id();
}
inline void NVMeControllerStatsResponse::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  return _msg;
}
inline void NVMeControllerStatsResponse::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.id)
}

// string stats = 2;
inline void NVMeControllerStatsResponse::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& NVMeControllerStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeControllerStatsResponse::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
}
inline std::string* NVMeControllerStatsResponse::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return _s;
}
inline const std::string& NVMeControllerStatsResponse::_internal_stats() const {
  return stats_.Get();
}
inline void NVMeControllerStatsResponse::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeControllerStatsResponse::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeControllerStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeControllerStatsResponse::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
}

// -------------------------------------------------------------------

// NVMeNamespaceCreateRequest

// .opi_api.storage.v1.NVMeNamespace namespace = 1;
inline bool NVMeNamespaceCreateRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool NVMeNamespaceCreateRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void NVMeNamespaceCreateRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespace& NVMeNamespaceCreateRequest::_internal_namespace_() const {
  const ::opi_api::storage::v1::NVMeNamespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespace&>(
      ::opi_api::storage::v1::_NVMeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespace& NVMeNamespaceCreateRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceCreateRequest.namespace)
  return _internal_namespace_();
}
inline void NVMeNamespaceCreateRequest::unsafe_arena_set_allocated_namespace_(
    ::opi_api::storage::v1::NVMeNamespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceCreateRequest.namespace)
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceCreateRequest::release_namespace_() {
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceCreateRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceCreateRequest.namespace)
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceCreateRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceCreateRequest::mutable_namespace_() {
  ::opi_api::storage::v1::NVMeNamespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceCreateRequest.namespace)
  return _msg;
}
inline void NVMeNamespaceCreateRequest::set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceCreateRequest.namespace)
}

// -------------------------------------------------------------------

// NVMeNamespaceDeleteRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool NVMeNamespaceDeleteRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool NVMeNamespaceDeleteRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceDeleteRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceDeleteRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceDeleteRequest.namespace_id)
  return _internal_namespace_id();
}
inline void NVMeNamespaceDeleteRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceDeleteRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceDeleteRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceDeleteRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceDeleteRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceDeleteRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceDeleteRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceDeleteRequest.namespace_id)
  return _msg;
}
inline void NVMeNamespaceDeleteRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceDeleteRequest.namespace_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceUpdateRequest

// .opi_api.storage.v1.NVMeNamespace namespace = 1;
inline bool NVMeNamespaceUpdateRequest::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool NVMeNamespaceUpdateRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void NVMeNamespaceUpdateRequest::clear_namespace_() {
  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespace& NVMeNamespaceUpdateRequest::_internal_namespace_() const {
  const ::opi_api::storage::v1::NVMeNamespace* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespace&>(
      ::opi_api::storage::v1::_NVMeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespace& NVMeNamespaceUpdateRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceUpdateRequest.namespace)
  return _internal_namespace_();
}
inline void NVMeNamespaceUpdateRequest::unsafe_arena_set_allocated_namespace_(
    ::opi_api::storage::v1::NVMeNamespace* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceUpdateRequest.namespace)
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceUpdateRequest::release_namespace_() {
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceUpdateRequest::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceUpdateRequest.namespace)
  
  ::opi_api::storage::v1::NVMeNamespace* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceUpdateRequest::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceUpdateRequest::mutable_namespace_() {
  ::opi_api::storage::v1::NVMeNamespace* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceUpdateRequest.namespace)
  return _msg;
}
inline void NVMeNamespaceUpdateRequest::set_allocated_namespace_(::opi_api::storage::v1::NVMeNamespace* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace__;
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespace>::GetOwningArena(namespace_);
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceUpdateRequest.namespace)
}

// -------------------------------------------------------------------

// NVMeNamespaceListRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeNamespaceListRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeNamespaceListRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceListRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceListRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceListRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeNamespaceListRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceListRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceListRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceListRequest.subsystem_id)
  return _msg;
}
inline void NVMeNamespaceListRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceListRequest.subsystem_id)
}

// .opi_api.common.v1.ObjectKey controller_id = 2;
inline bool NVMeNamespaceListRequest::_internal_has_controller_id() const {
  return this != internal_default_instance() && controller_id_ != nullptr;
}
inline bool NVMeNamespaceListRequest::has_controller_id() const {
  return _internal_has_controller_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceListRequest::_internal_controller_id() const {
  const ::opi_api::common::v1::ObjectKey* p = controller_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceListRequest::controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceListRequest.controller_id)
  return _internal_controller_id();
}
inline void NVMeNamespaceListRequest::unsafe_arena_set_allocated_controller_id(
    ::opi_api::common::v1::ObjectKey* controller_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  controller_id_ = controller_id;
  if (controller_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceListRequest.controller_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::release_controller_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::unsafe_arena_release_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceListRequest.controller_id)
  
  ::opi_api::common::v1::ObjectKey* temp = controller_id_;
  controller_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::_internal_mutable_controller_id() {
  
  if (controller_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    controller_id_ = p;
  }
  return controller_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceListRequest::mutable_controller_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceListRequest.controller_id)
  return _msg;
}
inline void NVMeNamespaceListRequest::set_allocated_controller_id(::opi_api::common::v1::ObjectKey* controller_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id_);
  }
  if (controller_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_id));
    if (message_arena != submessage_arena) {
      controller_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller_id, submessage_arena);
    }
    
  } else {
    
  }
  controller_id_ = controller_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceListRequest.controller_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceListResponse

// repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
inline int NVMeNamespaceListResponse::_internal_namespace__size() const {
  return namespace__.size();
}
inline int NVMeNamespaceListResponse::namespace__size() const {
  return _internal_namespace__size();
}
inline void NVMeNamespaceListResponse::clear_namespace_() {
  namespace__.Clear();
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceListResponse::mutable_namespace_(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceListResponse.namespace)
  return namespace__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >*
NVMeNamespaceListResponse::mutable_namespace_() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.NVMeNamespaceListResponse.namespace)
  return &namespace__;
}
inline const ::opi_api::storage::v1::NVMeNamespace& NVMeNamespaceListResponse::_internal_namespace_(int index) const {
  return namespace__.Get(index);
}
inline const ::opi_api::storage::v1::NVMeNamespace& NVMeNamespaceListResponse::namespace_(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceListResponse.namespace)
  return _internal_namespace_(index);
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceListResponse::_internal_add_namespace_() {
  return namespace__.Add();
}
inline ::opi_api::storage::v1::NVMeNamespace* NVMeNamespaceListResponse::add_namespace_() {
  ::opi_api::storage::v1::NVMeNamespace* _add = _internal_add_namespace_();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.NVMeNamespaceListResponse.namespace)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >&
NVMeNamespaceListResponse::namespace_() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.NVMeNamespaceListResponse.namespace)
  return namespace__;
}

// -------------------------------------------------------------------

// NVMeNamespaceGetRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool NVMeNamespaceGetRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool NVMeNamespaceGetRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceGetRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceGetRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceGetRequest.namespace_id)
  return _internal_namespace_id();
}
inline void NVMeNamespaceGetRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceGetRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceGetRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceGetRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceGetRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceGetRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceGetRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceGetRequest.namespace_id)
  return _msg;
}
inline void NVMeNamespaceGetRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceGetRequest.namespace_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatsRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool NVMeNamespaceStatsRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool NVMeNamespaceStatsRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  return _internal_namespace_id();
}
inline void NVMeNamespaceStatsRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  return _msg;
}
inline void NVMeNamespaceStatsRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatsResponse

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeNamespaceStatsResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeNamespaceStatsResponse::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsResponse::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsResponse::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  return _internal_id();
}
inline void NVMeNamespaceStatsResponse::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  return _msg;
}
inline void NVMeNamespaceStatsResponse::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
}

// string stats = 2;
inline void NVMeNamespaceStatsResponse::clear_stats() {
  stats_.ClearToEmpty();
}
inline const std::string& NVMeNamespaceStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return _internal_stats();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeNamespaceStatsResponse::set_stats(ArgT0&& arg0, ArgT... args) {
 
 stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
}
inline std::string* NVMeNamespaceStatsResponse::mutable_stats() {
  std::string* _s = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return _s;
}
inline const std::string& NVMeNamespaceStatsResponse::_internal_stats() const {
  return stats_.Get();
}
inline void NVMeNamespaceStatsResponse::_internal_set_stats(const std::string& value) {
  
  stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceStatsResponse::_internal_mutable_stats() {
  
  return stats_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return stats_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeNamespaceStatsResponse::set_allocated_stats(std::string* stats) {
  if (stats != nullptr) {
    
  } else {
    
  }
  stats_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stats,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stats_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto
