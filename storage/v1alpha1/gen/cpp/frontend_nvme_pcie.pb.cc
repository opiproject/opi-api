// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#include "frontend_nvme_pcie.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace opi_api {
namespace storage {
namespace v1 {
constexpr NVMeSubsystem::NVMeSubsystem(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spec_(nullptr)
  , status_(nullptr){}
struct NVMeSubsystemDefaultTypeInternal {
  constexpr NVMeSubsystemDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemDefaultTypeInternal() {}
  union {
    NVMeSubsystem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemDefaultTypeInternal _NVMeSubsystem_default_instance_;
constexpr NVMeSubsystemSpec::NVMeSubsystemSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nqn_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr)
  , max_namespaces_(int64_t{0}){}
struct NVMeSubsystemSpecDefaultTypeInternal {
  constexpr NVMeSubsystemSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemSpecDefaultTypeInternal() {}
  union {
    NVMeSubsystemSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemSpecDefaultTypeInternal _NVMeSubsystemSpec_default_instance_;
constexpr NVMeSubsystemStatus::NVMeSubsystemStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : firmware_revision_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fru_guid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct NVMeSubsystemStatusDefaultTypeInternal {
  constexpr NVMeSubsystemStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatusDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatusDefaultTypeInternal _NVMeSubsystemStatus_default_instance_;
constexpr NVMeController::NVMeController(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spec_(nullptr)
  , status_(nullptr){}
struct NVMeControllerDefaultTypeInternal {
  constexpr NVMeControllerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerDefaultTypeInternal() {}
  union {
    NVMeController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerDefaultTypeInternal _NVMeController_default_instance_;
constexpr NVMeControllerSpec::NVMeControllerSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr)
  , subsystem_id_(nullptr)
  , pcie_id_(nullptr)
  , nvme_controller_id_(0)
  , max_nsq_(0)
  , max_ncq_(0)
  , sqes_(0)
  , cqes_(0)
  , max_namespaces_(0){}
struct NVMeControllerSpecDefaultTypeInternal {
  constexpr NVMeControllerSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerSpecDefaultTypeInternal() {}
  union {
    NVMeControllerSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerSpecDefaultTypeInternal _NVMeControllerSpec_default_instance_;
constexpr NVMeControllerStatus::NVMeControllerStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : active_(false){}
struct NVMeControllerStatusDefaultTypeInternal {
  constexpr NVMeControllerStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatusDefaultTypeInternal() {}
  union {
    NVMeControllerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatusDefaultTypeInternal _NVMeControllerStatus_default_instance_;
constexpr NVMeNamespace::NVMeNamespace(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spec_(nullptr)
  , status_(nullptr){}
struct NVMeNamespaceDefaultTypeInternal {
  constexpr NVMeNamespaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceDefaultTypeInternal() {}
  union {
    NVMeNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceDefaultTypeInternal _NVMeNamespace_default_instance_;
constexpr NVMeNamespaceSpec::NVMeNamespaceSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nguid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr)
  , subsystem_id_(nullptr)
  , controller_id_(nullptr)
  , uuid_(nullptr)
  , volume_id_(nullptr)
  , block_size_(int64_t{0})
  , blocks_count_(int64_t{0})
  , host_nsid_(0)
  , optimal_write_size_(0)
  , eui64_(int64_t{0})
  , pref_write_granularity_(0){}
struct NVMeNamespaceSpecDefaultTypeInternal {
  constexpr NVMeNamespaceSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceSpecDefaultTypeInternal() {}
  union {
    NVMeNamespaceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceSpecDefaultTypeInternal _NVMeNamespaceSpec_default_instance_;
constexpr NVMeNamespaceStatus::NVMeNamespaceStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pci_state_(0)

  , pci_oper_state_(0)
{}
struct NVMeNamespaceStatusDefaultTypeInternal {
  constexpr NVMeNamespaceStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatusDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatusDefaultTypeInternal _NVMeNamespaceStatus_default_instance_;
constexpr NVMeSubsystemCreateRequest::NVMeSubsystemCreateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(nullptr){}
struct NVMeSubsystemCreateRequestDefaultTypeInternal {
  constexpr NVMeSubsystemCreateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemCreateRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemCreateRequestDefaultTypeInternal _NVMeSubsystemCreateRequest_default_instance_;
constexpr NVMeSubsystemDeleteRequest::NVMeSubsystemDeleteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemDeleteRequestDefaultTypeInternal {
  constexpr NVMeSubsystemDeleteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemDeleteRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemDeleteRequestDefaultTypeInternal _NVMeSubsystemDeleteRequest_default_instance_;
constexpr NVMeSubsystemUpdateRequest::NVMeSubsystemUpdateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(nullptr){}
struct NVMeSubsystemUpdateRequestDefaultTypeInternal {
  constexpr NVMeSubsystemUpdateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemUpdateRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemUpdateRequestDefaultTypeInternal _NVMeSubsystemUpdateRequest_default_instance_;
constexpr NVMeSubsystemListRequest::NVMeSubsystemListRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct NVMeSubsystemListRequestDefaultTypeInternal {
  constexpr NVMeSubsystemListRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemListRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemListRequestDefaultTypeInternal _NVMeSubsystemListRequest_default_instance_;
constexpr NVMeSubsystemListResponse::NVMeSubsystemListResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(){}
struct NVMeSubsystemListResponseDefaultTypeInternal {
  constexpr NVMeSubsystemListResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemListResponseDefaultTypeInternal() {}
  union {
    NVMeSubsystemListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemListResponseDefaultTypeInternal _NVMeSubsystemListResponse_default_instance_;
constexpr NVMeSubsystemGetRequest::NVMeSubsystemGetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemGetRequestDefaultTypeInternal {
  constexpr NVMeSubsystemGetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemGetRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemGetRequestDefaultTypeInternal _NVMeSubsystemGetRequest_default_instance_;
constexpr NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemStatsRequestDefaultTypeInternal {
  constexpr NVMeSubsystemStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatsRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatsRequestDefaultTypeInternal _NVMeSubsystemStatsRequest_default_instance_;
constexpr NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct NVMeSubsystemStatsResponseDefaultTypeInternal {
  constexpr NVMeSubsystemStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatsResponseDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatsResponseDefaultTypeInternal _NVMeSubsystemStatsResponse_default_instance_;
constexpr NVMeControllerCreateRequest::NVMeControllerCreateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(nullptr){}
struct NVMeControllerCreateRequestDefaultTypeInternal {
  constexpr NVMeControllerCreateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerCreateRequestDefaultTypeInternal() {}
  union {
    NVMeControllerCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerCreateRequestDefaultTypeInternal _NVMeControllerCreateRequest_default_instance_;
constexpr NVMeControllerDeleteRequest::NVMeControllerDeleteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_id_(nullptr){}
struct NVMeControllerDeleteRequestDefaultTypeInternal {
  constexpr NVMeControllerDeleteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerDeleteRequestDefaultTypeInternal() {}
  union {
    NVMeControllerDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerDeleteRequestDefaultTypeInternal _NVMeControllerDeleteRequest_default_instance_;
constexpr NVMeControllerUpdateRequest::NVMeControllerUpdateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(nullptr){}
struct NVMeControllerUpdateRequestDefaultTypeInternal {
  constexpr NVMeControllerUpdateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerUpdateRequestDefaultTypeInternal() {}
  union {
    NVMeControllerUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerUpdateRequestDefaultTypeInternal _NVMeControllerUpdateRequest_default_instance_;
constexpr NVMeControllerListRequest::NVMeControllerListRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeControllerListRequestDefaultTypeInternal {
  constexpr NVMeControllerListRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerListRequestDefaultTypeInternal() {}
  union {
    NVMeControllerListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerListRequestDefaultTypeInternal _NVMeControllerListRequest_default_instance_;
constexpr NVMeControllerListResponse::NVMeControllerListResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(){}
struct NVMeControllerListResponseDefaultTypeInternal {
  constexpr NVMeControllerListResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerListResponseDefaultTypeInternal() {}
  union {
    NVMeControllerListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerListResponseDefaultTypeInternal _NVMeControllerListResponse_default_instance_;
constexpr NVMeControllerGetRequest::NVMeControllerGetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_id_(nullptr){}
struct NVMeControllerGetRequestDefaultTypeInternal {
  constexpr NVMeControllerGetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerGetRequestDefaultTypeInternal() {}
  union {
    NVMeControllerGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerGetRequestDefaultTypeInternal _NVMeControllerGetRequest_default_instance_;
constexpr NVMeControllerStatsRequest::NVMeControllerStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr){}
struct NVMeControllerStatsRequestDefaultTypeInternal {
  constexpr NVMeControllerStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatsRequestDefaultTypeInternal() {}
  union {
    NVMeControllerStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatsRequestDefaultTypeInternal _NVMeControllerStatsRequest_default_instance_;
constexpr NVMeControllerStatsResponse::NVMeControllerStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr){}
struct NVMeControllerStatsResponseDefaultTypeInternal {
  constexpr NVMeControllerStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatsResponseDefaultTypeInternal() {}
  union {
    NVMeControllerStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatsResponseDefaultTypeInternal _NVMeControllerStatsResponse_default_instance_;
constexpr NVMeNamespaceCreateRequest::NVMeNamespaceCreateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(nullptr){}
struct NVMeNamespaceCreateRequestDefaultTypeInternal {
  constexpr NVMeNamespaceCreateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceCreateRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceCreateRequestDefaultTypeInternal _NVMeNamespaceCreateRequest_default_instance_;
constexpr NVMeNamespaceDeleteRequest::NVMeNamespaceDeleteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceDeleteRequestDefaultTypeInternal {
  constexpr NVMeNamespaceDeleteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceDeleteRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceDeleteRequestDefaultTypeInternal _NVMeNamespaceDeleteRequest_default_instance_;
constexpr NVMeNamespaceUpdateRequest::NVMeNamespaceUpdateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(nullptr){}
struct NVMeNamespaceUpdateRequestDefaultTypeInternal {
  constexpr NVMeNamespaceUpdateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceUpdateRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceUpdateRequestDefaultTypeInternal _NVMeNamespaceUpdateRequest_default_instance_;
constexpr NVMeNamespaceListRequest::NVMeNamespaceListRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr)
  , controller_id_(nullptr){}
struct NVMeNamespaceListRequestDefaultTypeInternal {
  constexpr NVMeNamespaceListRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceListRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceListRequestDefaultTypeInternal _NVMeNamespaceListRequest_default_instance_;
constexpr NVMeNamespaceListResponse::NVMeNamespaceListResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(){}
struct NVMeNamespaceListResponseDefaultTypeInternal {
  constexpr NVMeNamespaceListResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceListResponseDefaultTypeInternal() {}
  union {
    NVMeNamespaceListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceListResponseDefaultTypeInternal _NVMeNamespaceListResponse_default_instance_;
constexpr NVMeNamespaceGetRequest::NVMeNamespaceGetRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceGetRequestDefaultTypeInternal {
  constexpr NVMeNamespaceGetRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceGetRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceGetRequestDefaultTypeInternal _NVMeNamespaceGetRequest_default_instance_;
constexpr NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceStatsRequestDefaultTypeInternal {
  constexpr NVMeNamespaceStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatsRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatsRequestDefaultTypeInternal _NVMeNamespaceStatsRequest_default_instance_;
constexpr NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr){}
struct NVMeNamespaceStatsResponseDefaultTypeInternal {
  constexpr NVMeNamespaceStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatsResponseDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatsResponseDefaultTypeInternal _NVMeNamespaceStatsResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_frontend_5fnvme_5fpcie_2eproto[33];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto = nullptr;

const uint32_t TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, nqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, serial_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, model_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, max_namespaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatus, firmware_revision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatus, fru_guid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, nvme_controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, pcie_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, max_nsq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, max_ncq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, sqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, cqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, max_namespaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatus, active_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, host_nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, block_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, blocks_count_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, uuid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, volume_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, optimal_write_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, pref_write_granularity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatus, pci_state_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatus, pci_oper_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemCreateRequest, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemDeleteRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemUpdateRequest, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemListResponse, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemGetRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerCreateRequest, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerDeleteRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerUpdateRequest, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerListResponse, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerGetRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsRequest, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceCreateRequest, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceDeleteRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceUpdateRequest, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListRequest, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceListResponse, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceGetRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, stats_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystem)},
  { 8, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemSpec)},
  { 19, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatus)},
  { 27, -1, -1, sizeof(::opi_api::storage::v1::NVMeController)},
  { 35, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerSpec)},
  { 50, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatus)},
  { 57, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespace)},
  { 65, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceSpec)},
  { 83, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatus)},
  { 91, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemCreateRequest)},
  { 98, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemDeleteRequest)},
  { 105, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemUpdateRequest)},
  { 112, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemListRequest)},
  { 118, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemListResponse)},
  { 125, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemGetRequest)},
  { 132, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatsRequest)},
  { 139, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatsResponse)},
  { 146, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerCreateRequest)},
  { 153, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerDeleteRequest)},
  { 160, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerUpdateRequest)},
  { 167, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerListRequest)},
  { 174, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerListResponse)},
  { 181, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerGetRequest)},
  { 188, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatsRequest)},
  { 195, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatsResponse)},
  { 203, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceCreateRequest)},
  { 210, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceDeleteRequest)},
  { 217, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceUpdateRequest)},
  { 224, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceListRequest)},
  { 232, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceListResponse)},
  { 239, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceGetRequest)},
  { 246, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatsRequest)},
  { 253, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatsResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeController_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemCreateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemDeleteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemUpdateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemListRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemListResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemGetRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerCreateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerDeleteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerUpdateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerListRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerListResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerGetRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceCreateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceDeleteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceUpdateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceListRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceListResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceGetRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatsResponse_default_instance_),
};

const char descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030frontend_nvme_pcie.proto\022\022opi_api.stor"
  "age.v1\032\014common.proto\032\020object_key.proto\032\n"
  "uuid.proto\032\033google/protobuf/empty.proto\032"
  "\034google/api/annotations.proto\"}\n\rNVMeSub"
  "system\0223\n\004spec\030\001 \001(\0132%.opi_api.storage.v"
  "1.NVMeSubsystemSpec\0227\n\006status\030\002 \001(\0132\'.op"
  "i_api.storage.v1.NVMeSubsystemStatus\"\217\001\n"
  "\021NVMeSubsystemSpec\022(\n\002id\030\001 \001(\0132\034.opi_api"
  ".common.v1.ObjectKey\022\013\n\003nqn\030\002 \001(\t\022\025\n\rser"
  "ial_number\030\003 \001(\t\022\024\n\014model_number\030\004 \001(\t\022\026"
  "\n\016max_namespaces\030\005 \001(\003\"B\n\023NVMeSubsystemS"
  "tatus\022\031\n\021firmware_revision\030\001 \001(\t\022\020\n\010fru_"
  "guid\030\002 \001(\014\"\200\001\n\016NVMeController\0224\n\004spec\030\001 "
  "\001(\0132&.opi_api.storage.v1.NVMeControllerS"
  "pec\0228\n\006status\030\002 \001(\0132(.opi_api.storage.v1"
  ".NVMeControllerStatus\"\226\002\n\022NVMeController"
  "Spec\022(\n\002id\030\001 \001(\0132\034.opi_api.common.v1.Obj"
  "ectKey\022\032\n\022nvme_controller_id\030\002 \001(\005\0222\n\014su"
  "bsystem_id\030\003 \001(\0132\034.opi_api.common.v1.Obj"
  "ectKey\0220\n\007pcie_id\030\004 \001(\0132\037.opi_api.storag"
  "e.v1.PciEndpoint\022\017\n\007max_nsq\030\005 \001(\005\022\017\n\007max"
  "_ncq\030\006 \001(\005\022\014\n\004sqes\030\007 \001(\005\022\014\n\004cqes\030\010 \001(\005\022\026"
  "\n\016max_namespaces\030\t \001(\005\"&\n\024NVMeController"
  "Status\022\016\n\006active\030\001 \001(\010\"}\n\rNVMeNamespace\022"
  "3\n\004spec\030\001 \001(\0132%.opi_api.storage.v1.NVMeN"
  "amespaceSpec\0227\n\006status\030\002 \001(\0132\'.opi_api.s"
  "torage.v1.NVMeNamespaceStatus\"\225\003\n\021NVMeNa"
  "mespaceSpec\022(\n\002id\030\001 \001(\0132\034.opi_api.common"
  ".v1.ObjectKey\0222\n\014subsystem_id\030\002 \001(\0132\034.op"
  "i_api.common.v1.ObjectKey\0223\n\rcontroller_"
  "id\030\003 \001(\0132\034.opi_api.common.v1.ObjectKey\022\021"
  "\n\thost_nsid\030\004 \001(\005\022\022\n\nblock_size\030\005 \001(\003\022\024\n"
  "\014blocks_count\030\006 \001(\003\022\r\n\005nguid\030\007 \001(\t\022\r\n\005eu"
  "i64\030\010 \001(\003\022%\n\004uuid\030\t \001(\0132\027.opi_api.common"
  ".v1.Uuid\022/\n\tvolume_id\030\n \001(\0132\034.opi_api.co"
  "mmon.v1.ObjectKey\022\032\n\022optimal_write_size\030"
  "\013 \001(\005\022\036\n\026pref_write_granularity\030\014 \001(\005\"\232\001"
  "\n\023NVMeNamespaceStatus\022<\n\tpci_state\030\001 \001(\016"
  "2).opi_api.storage.v1.NVMeNamespacePciSt"
  "ate\022E\n\016pci_oper_state\030\002 \001(\0162-.opi_api.st"
  "orage.v1.NVMeNamespacePciOperState\"R\n\032NV"
  "MeSubsystemCreateRequest\0224\n\tsubsystem\030\001 "
  "\001(\0132!.opi_api.storage.v1.NVMeSubsystem\"P"
  "\n\032NVMeSubsystemDeleteRequest\0222\n\014subsyste"
  "m_id\030\001 \001(\0132\034.opi_api.common.v1.ObjectKey"
  "\"R\n\032NVMeSubsystemUpdateRequest\0224\n\tsubsys"
  "tem\030\001 \001(\0132!.opi_api.storage.v1.NVMeSubsy"
  "stem\"\032\n\030NVMeSubsystemListRequest\"Q\n\031NVMe"
  "SubsystemListResponse\0224\n\tsubsystem\030\001 \003(\013"
  "2!.opi_api.storage.v1.NVMeSubsystem\"M\n\027N"
  "VMeSubsystemGetRequest\0222\n\014subsystem_id\030\001"
  " \001(\0132\034.opi_api.common.v1.ObjectKey\"O\n\031NV"
  "MeSubsystemStatsRequest\0222\n\014subsystem_id\030"
  "\001 \001(\0132\034.opi_api.common.v1.ObjectKey\"+\n\032N"
  "VMeSubsystemStatsResponse\022\r\n\005stats\030\001 \001(\t"
  "\"U\n\033NVMeControllerCreateRequest\0226\n\ncontr"
  "oller\030\001 \001(\0132\".opi_api.storage.v1.NVMeCon"
  "troller\"R\n\033NVMeControllerDeleteRequest\0223"
  "\n\rcontroller_id\030\001 \001(\0132\034.opi_api.common.v"
  "1.ObjectKey\"U\n\033NVMeControllerUpdateReque"
  "st\0226\n\ncontroller\030\001 \001(\0132\".opi_api.storage"
  ".v1.NVMeController\"O\n\031NVMeControllerList"
  "Request\0222\n\014subsystem_id\030\001 \001(\0132\034.opi_api."
  "common.v1.ObjectKey\"T\n\032NVMeControllerLis"
  "tResponse\0226\n\ncontroller\030\001 \003(\0132\".opi_api."
  "storage.v1.NVMeController\"O\n\030NVMeControl"
  "lerGetRequest\0223\n\rcontroller_id\030\001 \001(\0132\034.o"
  "pi_api.common.v1.ObjectKey\"F\n\032NVMeContro"
  "llerStatsRequest\022(\n\002id\030\001 \001(\0132\034.opi_api.c"
  "ommon.v1.ObjectKey\"V\n\033NVMeControllerStat"
  "sResponse\022(\n\002id\030\001 \001(\0132\034.opi_api.common.v"
  "1.ObjectKey\022\r\n\005stats\030\002 \001(\t\"R\n\032NVMeNamesp"
  "aceCreateRequest\0224\n\tnamespace\030\001 \001(\0132!.op"
  "i_api.storage.v1.NVMeNamespace\"P\n\032NVMeNa"
  "mespaceDeleteRequest\0222\n\014namespace_id\030\001 \001"
  "(\0132\034.opi_api.common.v1.ObjectKey\"R\n\032NVMe"
  "NamespaceUpdateRequest\0224\n\tnamespace\030\001 \001("
  "\0132!.opi_api.storage.v1.NVMeNamespace\"\203\001\n"
  "\030NVMeNamespaceListRequest\0222\n\014subsystem_i"
  "d\030\001 \001(\0132\034.opi_api.common.v1.ObjectKey\0223\n"
  "\rcontroller_id\030\002 \001(\0132\034.opi_api.common.v1"
  ".ObjectKey\"Q\n\031NVMeNamespaceListResponse\022"
  "4\n\tnamespace\030\001 \003(\0132!.opi_api.storage.v1."
  "NVMeNamespace\"M\n\027NVMeNamespaceGetRequest"
  "\0222\n\014namespace_id\030\001 \001(\0132\034.opi_api.common."
  "v1.ObjectKey\"O\n\031NVMeNamespaceStatsReques"
  "t\0222\n\014namespace_id\030\001 \001(\0132\034.opi_api.common"
  ".v1.ObjectKey\"U\n\032NVMeNamespaceStatsRespo"
  "nse\022(\n\002id\030\001 \001(\0132\034.opi_api.common.v1.Obje"
  "ctKey\022\r\n\005stats\030\002 \001(\t*\266\001\n\025NVMeNamespacePc"
  "iState\022)\n%NV_ME_NAMESPACE_PCI_STATE_UNSP"
  "ECIFIED\020\000\022%\n!NVME_NAMESPACE_PCI_STATE_DI"
  "SABLED\020\001\022$\n NVME_NAMESPACE_PCI_STATE_ENA"
  "BLED\020\002\022%\n!NVME_NAMESPACE_PCI_STATE_DELET"
  "ING\020\003*\240\001\n\031NVMeNamespacePciOperState\022.\n*N"
  "V_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIE"
  "D\020\000\022(\n$NVME_NAMESPACE_PCI_OPER_STATE_ONL"
  "INE\020\001\022)\n%NVME_NAMESPACE_PCI_OPER_STATE_O"
  "FFLINE\020\0022\260\023\n\023FrontendNvmeService\022\213\001\n\023NVM"
  "eSubsystemCreate\022..opi_api.storage.v1.NV"
  "MeSubsystemCreateRequest\032!.opi_api.stora"
  "ge.v1.NVMeSubsystem\"!\202\323\344\223\002\033\"\016/v1/subsyst"
  "ems:\tsubsystem\022\201\001\n\023NVMeSubsystemDelete\022."
  ".opi_api.storage.v1.NVMeSubsystemDeleteR"
  "equest\032\026.google.protobuf.Empty\"\"\202\323\344\223\002\034*\032"
  "/v1/subsystems/{subsystem}\022\213\001\n\023NVMeSubsy"
  "stemUpdate\022..opi_api.storage.v1.NVMeSubs"
  "ystemUpdateRequest\032!.opi_api.storage.v1."
  "NVMeSubsystem\"!\202\323\344\223\002\0332\016/v1/subsystems:\ts"
  "ubsystem\022\210\001\n\021NVMeSubsystemList\022,.opi_api"
  ".storage.v1.NVMeSubsystemListRequest\032-.o"
  "pi_api.storage.v1.NVMeSubsystemListRespo"
  "nse\"\026\202\323\344\223\002\020\022\016/v1/subsystems\022\206\001\n\020NVMeSubs"
  "ystemGet\022+.opi_api.storage.v1.NVMeSubsys"
  "temGetRequest\032!.opi_api.storage.v1.NVMeS"
  "ubsystem\"\"\202\323\344\223\002\034\022\032/v1/subsystems/{subsys"
  "tem}\022u\n\022NVMeSubsystemStats\022-.opi_api.sto"
  "rage.v1.NVMeSubsystemStatsRequest\032..opi_"
  "api.storage.v1.NVMeSubsystemStatsRespons"
  "e\"\000\022\220\001\n\024NVMeControllerCreate\022/.opi_api.s"
  "torage.v1.NVMeControllerCreateRequest\032\"."
  "opi_api.storage.v1.NVMeController\"#\202\323\344\223\002"
  "\035\"\017/v1/controllers:\ncontroller\022\205\001\n\024NVMeC"
  "ontrollerDelete\022/.opi_api.storage.v1.NVM"
  "eControllerDeleteRequest\032\026.google.protob"
  "uf.Empty\"$\202\323\344\223\002\036*\034/v1/controllers/{contr"
  "oller}\022\220\001\n\024NVMeControllerUpdate\022/.opi_ap"
  "i.storage.v1.NVMeControllerUpdateRequest"
  "\032\".opi_api.storage.v1.NVMeController\"#\202\323"
  "\344\223\002\0352\017/v1/controllers:\ncontroller\022\214\001\n\022NV"
  "MeControllerList\022-.opi_api.storage.v1.NV"
  "MeControllerListRequest\032..opi_api.storag"
  "e.v1.NVMeControllerListResponse\"\027\202\323\344\223\002\021\022"
  "\017/v1/controllers\022\213\001\n\021NVMeControllerGet\022,"
  ".opi_api.storage.v1.NVMeControllerGetReq"
  "uest\032\".opi_api.storage.v1.NVMeController"
  "\"$\202\323\344\223\002\036\022\034/v1/controllers/{controller}\022x"
  "\n\023NVMeControllerStats\022..opi_api.storage."
  "v1.NVMeControllerStatsRequest\032/.opi_api."
  "storage.v1.NVMeControllerStatsResponse\"\000"
  "\022\213\001\n\023NVMeNamespaceCreate\022..opi_api.stora"
  "ge.v1.NVMeNamespaceCreateRequest\032!.opi_a"
  "pi.storage.v1.NVMeNamespace\"!\202\323\344\223\002\033\"\016/v1"
  "/namespaces:\tnamespace\022\201\001\n\023NVMeNamespace"
  "Delete\022..opi_api.storage.v1.NVMeNamespac"
  "eDeleteRequest\032\026.google.protobuf.Empty\"\""
  "\202\323\344\223\002\034*\032/v1/namespaces/{namespace}\022\213\001\n\023N"
  "VMeNamespaceUpdate\022..opi_api.storage.v1."
  "NVMeNamespaceUpdateRequest\032!.opi_api.sto"
  "rage.v1.NVMeNamespace\"!\202\323\344\223\002\0332\016/v1/names"
  "paces:\tnamespace\022\210\001\n\021NVMeNamespaceList\022,"
  ".opi_api.storage.v1.NVMeNamespaceListReq"
  "uest\032-.opi_api.storage.v1.NVMeNamespaceL"
  "istResponse\"\026\202\323\344\223\002\020\022\016/v1/namespaces\022\206\001\n\020"
  "NVMeNamespaceGet\022+.opi_api.storage.v1.NV"
  "MeNamespaceGetRequest\032!.opi_api.storage."
  "v1.NVMeNamespace\"\"\202\323\344\223\002\034\022\032/v1/namespaces"
  "/{namespace}\022u\n\022NVMeNamespaceStats\022-.opi"
  "_api.storage.v1.NVMeNamespaceStatsReques"
  "t\032..opi_api.storage.v1.NVMeNamespaceStat"
  "sResponse\"\000Bd\n\022opi_api.storage.v1B\025Front"
  "endNvmePcieProtoP\001Z5github.com/opiprojec"
  "t/opi-api/storage/v1alpha1/gen/gob\006proto"
  "3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps[5] = {
  &::descriptor_table_common_2eproto,
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_object_5fkey_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_frontend_5fnvme_5fpcie_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto = {
  false, false, 6521, descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto, "frontend_nvme_pcie.proto", 
  &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once, descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps, 5, 33,
  schemas, file_default_instances, TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets,
  file_level_metadata_frontend_5fnvme_5fpcie_2eproto, file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto, file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter() {
  return &descriptor_table_frontend_5fnvme_5fpcie_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_frontend_5fnvme_5fpcie_2eproto(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[0];
}
bool NVMeNamespacePciState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciOperState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[1];
}
bool NVMeNamespacePciOperState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NVMeSubsystem::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystemSpec& spec(const NVMeSubsystem* msg);
  static const ::opi_api::storage::v1::NVMeSubsystemStatus& status(const NVMeSubsystem* msg);
};

const ::opi_api::storage::v1::NVMeSubsystemSpec&
NVMeSubsystem::_Internal::spec(const NVMeSubsystem* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NVMeSubsystemStatus&
NVMeSubsystem::_Internal::status(const NVMeSubsystem* msg) {
  return *msg->status_;
}
NVMeSubsystem::NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystem)
}
NVMeSubsystem::NVMeSubsystem(const NVMeSubsystem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NVMeSubsystemSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NVMeSubsystemStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystem)
}

inline void NVMeSubsystem::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NVMeSubsystem::~NVMeSubsystem() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystem)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NVMeSubsystem::ArenaDtor(void* object) {
  NVMeSubsystem* _this = reinterpret_cast< NVMeSubsystem* >(object);
  (void)_this;
}
void NVMeSubsystem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystem::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystem)
  return target;
}

size_t NVMeSubsystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystem::GetClassData() const { return &_class_data_; }

void NVMeSubsystem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystem *>(to)->MergeFrom(
      static_cast<const NVMeSubsystem &>(from));
}


void NVMeSubsystem::MergeFrom(const NVMeSubsystem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NVMeSubsystemSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NVMeSubsystemStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystem::CopyFrom(const NVMeSubsystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystem::IsInitialized() const {
  return true;
}

void NVMeSubsystem::InternalSwap(NVMeSubsystem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeSubsystem, status_)
      + sizeof(NVMeSubsystem::status_)
      - PROTOBUF_FIELD_OFFSET(NVMeSubsystem, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystem::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[0]);
}

// ===================================================================

class NVMeSubsystemSpec::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeSubsystemSpec* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemSpec::_Internal::id(const NVMeSubsystemSpec* msg) {
  return *msg->id_;
}
void NVMeSubsystemSpec::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeSubsystemSpec::NVMeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemSpec)
}
NVMeSubsystemSpec::NVMeSubsystemSpec(const NVMeSubsystemSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nqn().empty()) {
    nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nqn(), 
      GetArenaForAllocation());
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial_number(), 
      GetArenaForAllocation());
  }
  model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_number().empty()) {
    model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_number(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  max_namespaces_ = from.max_namespaces_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemSpec)
}

inline void NVMeSubsystemSpec::SharedCtor() {
nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_namespaces_));
}

NVMeSubsystemSpec::~NVMeSubsystemSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nqn_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeSubsystemSpec::ArenaDtor(void* object) {
  NVMeSubsystemSpec* _this = reinterpret_cast< NVMeSubsystemSpec* >(object);
  (void)_this;
}
void NVMeSubsystemSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nqn_.ClearToEmpty();
  serial_number_.ClearToEmpty();
  model_number_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  max_namespaces_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nqn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nqn();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemSpec.nqn"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemSpec.serial_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_model_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemSpec.model_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_namespaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string nqn = 2;
  if (!this->_internal_nqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nqn().data(), static_cast<int>(this->_internal_nqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemSpec.nqn");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nqn(), target);
  }

  // string serial_number = 3;
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemSpec.serial_number");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_serial_number(), target);
  }

  // string model_number = 4;
  if (!this->_internal_model_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_number().data(), static_cast<int>(this->_internal_model_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemSpec.model_number");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_model_number(), target);
  }

  // int64 max_namespaces = 5;
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_max_namespaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemSpec)
  return target;
}

size_t NVMeSubsystemSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nqn = 2;
  if (!this->_internal_nqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nqn());
  }

  // string serial_number = 3;
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // string model_number = 4;
  if (!this->_internal_model_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_number());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // int64 max_namespaces = 5;
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemSpec::GetClassData() const { return &_class_data_; }

void NVMeSubsystemSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemSpec *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemSpec &>(from));
}


void NVMeSubsystemSpec::MergeFrom(const NVMeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nqn().empty()) {
    _internal_set_nqn(from._internal_nqn());
  }
  if (!from._internal_serial_number().empty()) {
    _internal_set_serial_number(from._internal_serial_number());
  }
  if (!from._internal_model_number().empty()) {
    _internal_set_model_number(from._internal_model_number());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_max_namespaces() != 0) {
    _internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemSpec::CopyFrom(const NVMeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemSpec::IsInitialized() const {
  return true;
}

void NVMeSubsystemSpec::InternalSwap(NVMeSubsystemSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nqn_, lhs_arena,
      &other->nqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_number_, lhs_arena,
      &other->serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_number_, lhs_arena,
      &other->model_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeSubsystemSpec, max_namespaces_)
      + sizeof(NVMeSubsystemSpec::max_namespaces_)
      - PROTOBUF_FIELD_OFFSET(NVMeSubsystemSpec, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[1]);
}

// ===================================================================

class NVMeSubsystemStatus::_Internal {
 public:
};

NVMeSubsystemStatus::NVMeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatus)
}
NVMeSubsystemStatus::NVMeSubsystemStatus(const NVMeSubsystemStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_revision().empty()) {
    firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_firmware_revision(), 
      GetArenaForAllocation());
  }
  fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fru_guid().empty()) {
    fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_fru_guid(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatus)
}

inline void NVMeSubsystemStatus::SharedCtor() {
firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NVMeSubsystemStatus::~NVMeSubsystemStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  firmware_revision_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fru_guid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NVMeSubsystemStatus::ArenaDtor(void* object) {
  NVMeSubsystemStatus* _this = reinterpret_cast< NVMeSubsystemStatus* >(object);
  (void)_this;
}
void NVMeSubsystemStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  firmware_revision_.ClearToEmpty();
  fru_guid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string firmware_revision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firmware_revision();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes fru_guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fru_guid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string firmware_revision = 1;
  if (!this->_internal_firmware_revision().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_revision().data(), static_cast<int>(this->_internal_firmware_revision().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firmware_revision(), target);
  }

  // bytes fru_guid = 2;
  if (!this->_internal_fru_guid().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fru_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatus)
  return target;
}

size_t NVMeSubsystemStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string firmware_revision = 1;
  if (!this->_internal_firmware_revision().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_revision());
  }

  // bytes fru_guid = 2;
  if (!this->_internal_fru_guid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fru_guid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatus::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatus *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatus &>(from));
}


void NVMeSubsystemStatus::MergeFrom(const NVMeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_firmware_revision().empty()) {
    _internal_set_firmware_revision(from._internal_firmware_revision());
  }
  if (!from._internal_fru_guid().empty()) {
    _internal_set_fru_guid(from._internal_fru_guid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatus::CopyFrom(const NVMeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatus::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatus::InternalSwap(NVMeSubsystemStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &firmware_revision_, lhs_arena,
      &other->firmware_revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &fru_guid_, lhs_arena,
      &other->fru_guid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[2]);
}

// ===================================================================

class NVMeController::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeControllerSpec& spec(const NVMeController* msg);
  static const ::opi_api::storage::v1::NVMeControllerStatus& status(const NVMeController* msg);
};

const ::opi_api::storage::v1::NVMeControllerSpec&
NVMeController::_Internal::spec(const NVMeController* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NVMeControllerStatus&
NVMeController::_Internal::status(const NVMeController* msg) {
  return *msg->status_;
}
NVMeController::NVMeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeController)
}
NVMeController::NVMeController(const NVMeController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NVMeControllerSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NVMeControllerStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeController)
}

inline void NVMeController::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NVMeController::~NVMeController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeController)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NVMeController::ArenaDtor(void* object) {
  NVMeController* _this = reinterpret_cast< NVMeController* >(object);
  (void)_this;
}
void NVMeController::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeController::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeController::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeControllerStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NVMeControllerStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeController)
  return target;
}

size_t NVMeController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NVMeControllerStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeController::GetClassData() const { return &_class_data_; }

void NVMeController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeController *>(to)->MergeFrom(
      static_cast<const NVMeController &>(from));
}


void NVMeController::MergeFrom(const NVMeController& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeController)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NVMeControllerSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NVMeControllerStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeController::CopyFrom(const NVMeController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeController::IsInitialized() const {
  return true;
}

void NVMeController::InternalSwap(NVMeController* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeController, status_)
      + sizeof(NVMeController::status_)
      - PROTOBUF_FIELD_OFFSET(NVMeController, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeController::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[3]);
}

// ===================================================================

class NVMeControllerSpec::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeControllerSpec* msg);
  static const ::opi_api::storage::v1::PciEndpoint& pcie_id(const NVMeControllerSpec* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerSpec::_Internal::id(const NVMeControllerSpec* msg) {
  return *msg->id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeControllerSpec::_Internal::subsystem_id(const NVMeControllerSpec* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::storage::v1::PciEndpoint&
NVMeControllerSpec::_Internal::pcie_id(const NVMeControllerSpec* msg) {
  return *msg->pcie_id_;
}
void NVMeControllerSpec::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void NVMeControllerSpec::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeControllerSpec::clear_pcie_id() {
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
}
NVMeControllerSpec::NVMeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerSpec)
}
NVMeControllerSpec::NVMeControllerSpec(const NVMeControllerSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_pcie_id()) {
    pcie_id_ = new ::opi_api::storage::v1::PciEndpoint(*from.pcie_id_);
  } else {
    pcie_id_ = nullptr;
  }
  ::memcpy(&nvme_controller_id_, &from.nvme_controller_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_namespaces_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerSpec)
}

inline void NVMeControllerSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_namespaces_));
}

NVMeControllerSpec::~NVMeControllerSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete pcie_id_;
}

void NVMeControllerSpec::ArenaDtor(void* object) {
  NVMeControllerSpec* _this = reinterpret_cast< NVMeControllerSpec* >(object);
  (void)_this;
}
void NVMeControllerSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
  ::memset(&nvme_controller_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_namespaces_) -
      reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_namespaces_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nvme_controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          nvme_controller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey subsystem_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pcie_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_nsq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_nsq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_ncq = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          max_ncq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sqes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          sqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 cqes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          cqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_namespaces = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // int32 nvme_controller_id = 2;
  if (this->_internal_nvme_controller_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_nvme_controller_id(), target);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
  if (this->_internal_has_pcie_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::pcie_id(this), target, stream);
  }

  // int32 max_nsq = 5;
  if (this->_internal_max_nsq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_max_nsq(), target);
  }

  // int32 max_ncq = 6;
  if (this->_internal_max_ncq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_max_ncq(), target);
  }

  // int32 sqes = 7;
  if (this->_internal_sqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_sqes(), target);
  }

  // int32 cqes = 8;
  if (this->_internal_cqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_cqes(), target);
  }

  // int32 max_namespaces = 9;
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_max_namespaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerSpec)
  return target;
}

size_t NVMeControllerSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
  if (this->_internal_has_pcie_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pcie_id_);
  }

  // int32 nvme_controller_id = 2;
  if (this->_internal_nvme_controller_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nvme_controller_id());
  }

  // int32 max_nsq = 5;
  if (this->_internal_max_nsq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_nsq());
  }

  // int32 max_ncq = 6;
  if (this->_internal_max_ncq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_ncq());
  }

  // int32 sqes = 7;
  if (this->_internal_sqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sqes());
  }

  // int32 cqes = 8;
  if (this->_internal_cqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cqes());
  }

  // int32 max_namespaces = 9;
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerSpec::GetClassData() const { return &_class_data_; }

void NVMeControllerSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerSpec *>(to)->MergeFrom(
      static_cast<const NVMeControllerSpec &>(from));
}


void NVMeControllerSpec::MergeFrom(const NVMeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_pcie_id()) {
    _internal_mutable_pcie_id()->::opi_api::storage::v1::PciEndpoint::MergeFrom(from._internal_pcie_id());
  }
  if (from._internal_nvme_controller_id() != 0) {
    _internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_max_nsq() != 0) {
    _internal_set_max_nsq(from._internal_max_nsq());
  }
  if (from._internal_max_ncq() != 0) {
    _internal_set_max_ncq(from._internal_max_ncq());
  }
  if (from._internal_sqes() != 0) {
    _internal_set_sqes(from._internal_sqes());
  }
  if (from._internal_cqes() != 0) {
    _internal_set_cqes(from._internal_cqes());
  }
  if (from._internal_max_namespaces() != 0) {
    _internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerSpec::CopyFrom(const NVMeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerSpec::IsInitialized() const {
  return true;
}

void NVMeControllerSpec::InternalSwap(NVMeControllerSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeControllerSpec, max_namespaces_)
      + sizeof(NVMeControllerSpec::max_namespaces_)
      - PROTOBUF_FIELD_OFFSET(NVMeControllerSpec, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[4]);
}

// ===================================================================

class NVMeControllerStatus::_Internal {
 public:
};

NVMeControllerStatus::NVMeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatus)
}
NVMeControllerStatus::NVMeControllerStatus(const NVMeControllerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  active_ = from.active_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatus)
}

inline void NVMeControllerStatus::SharedCtor() {
active_ = false;
}

NVMeControllerStatus::~NVMeControllerStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeControllerStatus::ArenaDtor(void* object) {
  NVMeControllerStatus* _this = reinterpret_cast< NVMeControllerStatus* >(object);
  (void)_this;
}
void NVMeControllerStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  active_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool active = 1;
  if (this->_internal_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatus)
  return target;
}

size_t NVMeControllerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool active = 1;
  if (this->_internal_active() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatus::GetClassData() const { return &_class_data_; }

void NVMeControllerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatus *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatus &>(from));
}


void NVMeControllerStatus::MergeFrom(const NVMeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_active() != 0) {
    _internal_set_active(from._internal_active());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatus::CopyFrom(const NVMeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatus::IsInitialized() const {
  return true;
}

void NVMeControllerStatus::InternalSwap(NVMeControllerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(active_, other->active_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[5]);
}

// ===================================================================

class NVMeNamespace::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespaceSpec& spec(const NVMeNamespace* msg);
  static const ::opi_api::storage::v1::NVMeNamespaceStatus& status(const NVMeNamespace* msg);
};

const ::opi_api::storage::v1::NVMeNamespaceSpec&
NVMeNamespace::_Internal::spec(const NVMeNamespace* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NVMeNamespaceStatus&
NVMeNamespace::_Internal::status(const NVMeNamespace* msg) {
  return *msg->status_;
}
NVMeNamespace::NVMeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespace)
}
NVMeNamespace::NVMeNamespace(const NVMeNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NVMeNamespaceSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NVMeNamespaceStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespace)
}

inline void NVMeNamespace::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NVMeNamespace::~NVMeNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespace)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NVMeNamespace::ArenaDtor(void* object) {
  NVMeNamespace* _this = reinterpret_cast< NVMeNamespace* >(object);
  (void)_this;
}
void NVMeNamespace::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespace)
  return target;
}

size_t NVMeNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespace::GetClassData() const { return &_class_data_; }

void NVMeNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespace *>(to)->MergeFrom(
      static_cast<const NVMeNamespace &>(from));
}


void NVMeNamespace::MergeFrom(const NVMeNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NVMeNamespaceSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NVMeNamespaceStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespace::CopyFrom(const NVMeNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespace::IsInitialized() const {
  return true;
}

void NVMeNamespace::InternalSwap(NVMeNamespace* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespace, status_)
      + sizeof(NVMeNamespace::status_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespace, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespace::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[6]);
}

// ===================================================================

class NVMeNamespaceSpec::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::Uuid& uuid(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& volume_id(const NVMeNamespaceSpec* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::id(const NVMeNamespaceSpec* msg) {
  return *msg->id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::subsystem_id(const NVMeNamespaceSpec* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::controller_id(const NVMeNamespaceSpec* msg) {
  return *msg->controller_id_;
}
const ::opi_api::common::v1::Uuid&
NVMeNamespaceSpec::_Internal::uuid(const NVMeNamespaceSpec* msg) {
  return *msg->uuid_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::volume_id(const NVMeNamespaceSpec* msg) {
  return *msg->volume_id_;
}
void NVMeNamespaceSpec::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void NVMeNamespaceSpec::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeNamespaceSpec::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
void NVMeNamespaceSpec::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
}
void NVMeNamespaceSpec::clear_volume_id() {
  if (GetArenaForAllocation() == nullptr && volume_id_ != nullptr) {
    delete volume_id_;
  }
  volume_id_ = nullptr;
}
NVMeNamespaceSpec::NVMeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceSpec)
}
NVMeNamespaceSpec::NVMeNamespaceSpec(const NVMeNamespaceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nguid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  if (from._internal_has_uuid()) {
    uuid_ = new ::opi_api::common::v1::Uuid(*from.uuid_);
  } else {
    uuid_ = nullptr;
  }
  if (from._internal_has_volume_id()) {
    volume_id_ = new ::opi_api::common::v1::ObjectKey(*from.volume_id_);
  } else {
    volume_id_ = nullptr;
  }
  ::memcpy(&block_size_, &from.block_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&pref_write_granularity_) -
    reinterpret_cast<char*>(&block_size_)) + sizeof(pref_write_granularity_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceSpec)
}

inline void NVMeNamespaceSpec::SharedCtor() {
nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pref_write_granularity_) -
    reinterpret_cast<char*>(&id_)) + sizeof(pref_write_granularity_));
}

NVMeNamespaceSpec::~NVMeNamespaceSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nguid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete controller_id_;
  if (this != internal_default_instance()) delete uuid_;
  if (this != internal_default_instance()) delete volume_id_;
}

void NVMeNamespaceSpec::ArenaDtor(void* object) {
  NVMeNamespaceSpec* _this = reinterpret_cast< NVMeNamespaceSpec* >(object);
  (void)_this;
}
void NVMeNamespaceSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nguid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
  if (GetArenaForAllocation() == nullptr && volume_id_ != nullptr) {
    delete volume_id_;
  }
  volume_id_ = nullptr;
  ::memset(&block_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pref_write_granularity_) -
      reinterpret_cast<char*>(&block_size_)) + sizeof(pref_write_granularity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey subsystem_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey controller_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 host_nsid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          host_nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 block_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 blocks_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          blocks_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_nguid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeNamespaceSpec.nguid"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey volume_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 optimal_write_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          optimal_write_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 pref_write_granularity = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          pref_write_granularity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::controller_id(this), target, stream);
  }

  // int32 host_nsid = 4;
  if (this->_internal_host_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_host_nsid(), target);
  }

  // int64 block_size = 5;
  if (this->_internal_block_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_block_size(), target);
  }

  // int64 blocks_count = 6;
  if (this->_internal_blocks_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_blocks_count(), target);
  }

  // string nguid = 7;
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeNamespaceSpec.nguid");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_nguid(), target);
  }

  // int64 eui64 = 8;
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 9;
  if (this->_internal_has_uuid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::uuid(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  if (this->_internal_has_volume_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::volume_id(this), target, stream);
  }

  // int32 optimal_write_size = 11;
  if (this->_internal_optimal_write_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_optimal_write_size(), target);
  }

  // int32 pref_write_granularity = 12;
  if (this->_internal_pref_write_granularity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_pref_write_granularity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceSpec)
  return target;
}

size_t NVMeNamespaceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nguid = 7;
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  // .opi_api.common.v1.Uuid uuid = 9;
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *uuid_);
  }

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  if (this->_internal_has_volume_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *volume_id_);
  }

  // int64 block_size = 5;
  if (this->_internal_block_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_block_size());
  }

  // int64 blocks_count = 6;
  if (this->_internal_blocks_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_blocks_count());
  }

  // int32 host_nsid = 4;
  if (this->_internal_host_nsid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_host_nsid());
  }

  // int32 optimal_write_size = 11;
  if (this->_internal_optimal_write_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_optimal_write_size());
  }

  // int64 eui64 = 8;
  if (this->_internal_eui64() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 pref_write_granularity = 12;
  if (this->_internal_pref_write_granularity() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_pref_write_granularity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceSpec::GetClassData() const { return &_class_data_; }

void NVMeNamespaceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceSpec *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceSpec &>(from));
}


void NVMeNamespaceSpec::MergeFrom(const NVMeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nguid().empty()) {
    _internal_set_nguid(from._internal_nguid());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  if (from._internal_has_uuid()) {
    _internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(from._internal_uuid());
  }
  if (from._internal_has_volume_id()) {
    _internal_mutable_volume_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_volume_id());
  }
  if (from._internal_block_size() != 0) {
    _internal_set_block_size(from._internal_block_size());
  }
  if (from._internal_blocks_count() != 0) {
    _internal_set_blocks_count(from._internal_blocks_count());
  }
  if (from._internal_host_nsid() != 0) {
    _internal_set_host_nsid(from._internal_host_nsid());
  }
  if (from._internal_optimal_write_size() != 0) {
    _internal_set_optimal_write_size(from._internal_optimal_write_size());
  }
  if (from._internal_eui64() != 0) {
    _internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_pref_write_granularity() != 0) {
    _internal_set_pref_write_granularity(from._internal_pref_write_granularity());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceSpec::CopyFrom(const NVMeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceSpec::IsInitialized() const {
  return true;
}

void NVMeNamespaceSpec::InternalSwap(NVMeNamespaceSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nguid_, lhs_arena,
      &other->nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespaceSpec, pref_write_granularity_)
      + sizeof(NVMeNamespaceSpec::pref_write_granularity_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespaceSpec, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[7]);
}

// ===================================================================

class NVMeNamespaceStatus::_Internal {
 public:
};

NVMeNamespaceStatus::NVMeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatus)
}
NVMeNamespaceStatus::NVMeNamespaceStatus(const NVMeNamespaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&pci_state_, &from.pci_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&pci_oper_state_) -
    reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatus)
}

inline void NVMeNamespaceStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pci_state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pci_oper_state_) -
    reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
}

NVMeNamespaceStatus::~NVMeNamespaceStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeNamespaceStatus::ArenaDtor(void* object) {
  NVMeNamespaceStatus* _this = reinterpret_cast< NVMeNamespaceStatus* >(object);
  (void)_this;
}
void NVMeNamespaceStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&pci_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pci_oper_state_) -
      reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_state(static_cast<::opi_api::storage::v1::NVMeNamespacePciState>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_oper_state(static_cast<::opi_api::storage::v1::NVMeNamespacePciOperState>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
  if (this->_internal_pci_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pci_state(), target);
  }

  // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
  if (this->_internal_pci_oper_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_pci_oper_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatus)
  return target;
}

size_t NVMeNamespaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
  if (this->_internal_pci_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pci_state());
  }

  // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
  if (this->_internal_pci_oper_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pci_oper_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatus::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatus *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatus &>(from));
}


void NVMeNamespaceStatus::MergeFrom(const NVMeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pci_state() != 0) {
    _internal_set_pci_state(from._internal_pci_state());
  }
  if (from._internal_pci_oper_state() != 0) {
    _internal_set_pci_oper_state(from._internal_pci_oper_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatus::CopyFrom(const NVMeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatus::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatus::InternalSwap(NVMeNamespaceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespaceStatus, pci_oper_state_)
      + sizeof(NVMeNamespaceStatus::pci_oper_state_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespaceStatus, pci_state_)>(
          reinterpret_cast<char*>(&pci_state_),
          reinterpret_cast<char*>(&other->pci_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[8]);
}

// ===================================================================

class NVMeSubsystemCreateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystem& subsystem(const NVMeSubsystemCreateRequest* msg);
};

const ::opi_api::storage::v1::NVMeSubsystem&
NVMeSubsystemCreateRequest::_Internal::subsystem(const NVMeSubsystemCreateRequest* msg) {
  return *msg->subsystem_;
}
NVMeSubsystemCreateRequest::NVMeSubsystemCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemCreateRequest)
}
NVMeSubsystemCreateRequest::NVMeSubsystemCreateRequest(const NVMeSubsystemCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem()) {
    subsystem_ = new ::opi_api::storage::v1::NVMeSubsystem(*from.subsystem_);
  } else {
    subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemCreateRequest)
}

inline void NVMeSubsystemCreateRequest::SharedCtor() {
subsystem_ = nullptr;
}

NVMeSubsystemCreateRequest::~NVMeSubsystemCreateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_;
}

void NVMeSubsystemCreateRequest::ArenaDtor(void* object) {
  NVMeSubsystemCreateRequest* _this = reinterpret_cast< NVMeSubsystemCreateRequest* >(object);
  (void)_this;
}
void NVMeSubsystemCreateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemCreateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemCreateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  return target;
}

size_t NVMeSubsystemCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemCreateRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemCreateRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemCreateRequest &>(from));
}


void NVMeSubsystemCreateRequest::MergeFrom(const NVMeSubsystemCreateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem()) {
    _internal_mutable_subsystem()->::opi_api::storage::v1::NVMeSubsystem::MergeFrom(from._internal_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemCreateRequest::CopyFrom(const NVMeSubsystemCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemCreateRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemCreateRequest::InternalSwap(NVMeSubsystemCreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_, other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemCreateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[9]);
}

// ===================================================================

class NVMeSubsystemDeleteRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemDeleteRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemDeleteRequest::_Internal::subsystem_id(const NVMeSubsystemDeleteRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemDeleteRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemDeleteRequest::NVMeSubsystemDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
}
NVMeSubsystemDeleteRequest::NVMeSubsystemDeleteRequest(const NVMeSubsystemDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
}

inline void NVMeSubsystemDeleteRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemDeleteRequest::~NVMeSubsystemDeleteRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemDeleteRequest::ArenaDtor(void* object) {
  NVMeSubsystemDeleteRequest* _this = reinterpret_cast< NVMeSubsystemDeleteRequest* >(object);
  (void)_this;
}
void NVMeSubsystemDeleteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemDeleteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  return target;
}

size_t NVMeSubsystemDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemDeleteRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemDeleteRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemDeleteRequest &>(from));
}


void NVMeSubsystemDeleteRequest::MergeFrom(const NVMeSubsystemDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemDeleteRequest::CopyFrom(const NVMeSubsystemDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemDeleteRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemDeleteRequest::InternalSwap(NVMeSubsystemDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemDeleteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[10]);
}

// ===================================================================

class NVMeSubsystemUpdateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystem& subsystem(const NVMeSubsystemUpdateRequest* msg);
};

const ::opi_api::storage::v1::NVMeSubsystem&
NVMeSubsystemUpdateRequest::_Internal::subsystem(const NVMeSubsystemUpdateRequest* msg) {
  return *msg->subsystem_;
}
NVMeSubsystemUpdateRequest::NVMeSubsystemUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
}
NVMeSubsystemUpdateRequest::NVMeSubsystemUpdateRequest(const NVMeSubsystemUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem()) {
    subsystem_ = new ::opi_api::storage::v1::NVMeSubsystem(*from.subsystem_);
  } else {
    subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
}

inline void NVMeSubsystemUpdateRequest::SharedCtor() {
subsystem_ = nullptr;
}

NVMeSubsystemUpdateRequest::~NVMeSubsystemUpdateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_;
}

void NVMeSubsystemUpdateRequest::ArenaDtor(void* object) {
  NVMeSubsystemUpdateRequest* _this = reinterpret_cast< NVMeSubsystemUpdateRequest* >(object);
  (void)_this;
}
void NVMeSubsystemUpdateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  return target;
}

size_t NVMeSubsystemUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemUpdateRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemUpdateRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemUpdateRequest &>(from));
}


void NVMeSubsystemUpdateRequest::MergeFrom(const NVMeSubsystemUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem()) {
    _internal_mutable_subsystem()->::opi_api::storage::v1::NVMeSubsystem::MergeFrom(from._internal_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemUpdateRequest::CopyFrom(const NVMeSubsystemUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemUpdateRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemUpdateRequest::InternalSwap(NVMeSubsystemUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_, other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemUpdateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[11]);
}

// ===================================================================

class NVMeSubsystemListRequest::_Internal {
 public:
};

NVMeSubsystemListRequest::NVMeSubsystemListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemListRequest)
}
NVMeSubsystemListRequest::NVMeSubsystemListRequest(const NVMeSubsystemListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemListRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemListRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemListRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[12]);
}

// ===================================================================

class NVMeSubsystemListResponse::_Internal {
 public:
};

NVMeSubsystemListResponse::NVMeSubsystemListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  subsystem_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemListResponse)
}
NVMeSubsystemListResponse::NVMeSubsystemListResponse(const NVMeSubsystemListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      subsystem_(from.subsystem_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemListResponse)
}

inline void NVMeSubsystemListResponse::SharedCtor() {
}

NVMeSubsystemListResponse::~NVMeSubsystemListResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemListResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeSubsystemListResponse::ArenaDtor(void* object) {
  NVMeSubsystemListResponse* _this = reinterpret_cast< NVMeSubsystemListResponse* >(object);
  (void)_this;
}
void NVMeSubsystemListResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemListResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subsystem_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemListResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subsystem(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_subsystem_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_subsystem(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemListResponse)
  return target;
}

size_t NVMeSubsystemListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  total_size += 1UL * this->_internal_subsystem_size();
  for (const auto& msg : this->subsystem_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemListResponse::GetClassData() const { return &_class_data_; }

void NVMeSubsystemListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemListResponse *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemListResponse &>(from));
}


void NVMeSubsystemListResponse::MergeFrom(const NVMeSubsystemListResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  subsystem_.MergeFrom(from.subsystem_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemListResponse::CopyFrom(const NVMeSubsystemListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemListResponse::IsInitialized() const {
  return true;
}

void NVMeSubsystemListResponse::InternalSwap(NVMeSubsystemListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  subsystem_.InternalSwap(&other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemListResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[13]);
}

// ===================================================================

class NVMeSubsystemGetRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemGetRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemGetRequest::_Internal::subsystem_id(const NVMeSubsystemGetRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemGetRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemGetRequest::NVMeSubsystemGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemGetRequest)
}
NVMeSubsystemGetRequest::NVMeSubsystemGetRequest(const NVMeSubsystemGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemGetRequest)
}

inline void NVMeSubsystemGetRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemGetRequest::~NVMeSubsystemGetRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemGetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemGetRequest::ArenaDtor(void* object) {
  NVMeSubsystemGetRequest* _this = reinterpret_cast< NVMeSubsystemGetRequest* >(object);
  (void)_this;
}
void NVMeSubsystemGetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemGetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemGetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemGetRequest)
  return target;
}

size_t NVMeSubsystemGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemGetRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemGetRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemGetRequest &>(from));
}


void NVMeSubsystemGetRequest::MergeFrom(const NVMeSubsystemGetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemGetRequest::CopyFrom(const NVMeSubsystemGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemGetRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemGetRequest::InternalSwap(NVMeSubsystemGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemGetRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[14]);
}

// ===================================================================

class NVMeSubsystemStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemStatsRequest::_Internal::subsystem_id(const NVMeSubsystemStatsRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemStatsRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
}
NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(const NVMeSubsystemStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
}

inline void NVMeSubsystemStatsRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemStatsRequest::~NVMeSubsystemStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemStatsRequest::ArenaDtor(void* object) {
  NVMeSubsystemStatsRequest* _this = reinterpret_cast< NVMeSubsystemStatsRequest* >(object);
  (void)_this;
}
void NVMeSubsystemStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  return target;
}

size_t NVMeSubsystemStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatsRequest &>(from));
}


void NVMeSubsystemStatsRequest::MergeFrom(const NVMeSubsystemStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatsRequest::CopyFrom(const NVMeSubsystemStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatsRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatsRequest::InternalSwap(NVMeSubsystemStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[15]);
}

// ===================================================================

class NVMeSubsystemStatsResponse::_Internal {
 public:
};

NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
}
NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(const NVMeSubsystemStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
}

inline void NVMeSubsystemStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NVMeSubsystemStatsResponse::~NVMeSubsystemStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NVMeSubsystemStatsResponse::ArenaDtor(void* object) {
  NVMeSubsystemStatsResponse* _this = reinterpret_cast< NVMeSubsystemStatsResponse* >(object);
  (void)_this;
}
void NVMeSubsystemStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string stats = 1;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  return target;
}

size_t NVMeSubsystemStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 1;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatsResponse &>(from));
}


void NVMeSubsystemStatsResponse::MergeFrom(const NVMeSubsystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatsResponse::CopyFrom(const NVMeSubsystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatsResponse::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatsResponse::InternalSwap(NVMeSubsystemStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[16]);
}

// ===================================================================

class NVMeControllerCreateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeController& controller(const NVMeControllerCreateRequest* msg);
};

const ::opi_api::storage::v1::NVMeController&
NVMeControllerCreateRequest::_Internal::controller(const NVMeControllerCreateRequest* msg) {
  return *msg->controller_;
}
NVMeControllerCreateRequest::NVMeControllerCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerCreateRequest)
}
NVMeControllerCreateRequest::NVMeControllerCreateRequest(const NVMeControllerCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::opi_api::storage::v1::NVMeController(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerCreateRequest)
}

inline void NVMeControllerCreateRequest::SharedCtor() {
controller_ = nullptr;
}

NVMeControllerCreateRequest::~NVMeControllerCreateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerCreateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_;
}

void NVMeControllerCreateRequest::ArenaDtor(void* object) {
  NVMeControllerCreateRequest* _this = reinterpret_cast< NVMeControllerCreateRequest* >(object);
  (void)_this;
}
void NVMeControllerCreateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerCreateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerCreateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerCreateRequest)
  return target;
}

size_t NVMeControllerCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerCreateRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerCreateRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerCreateRequest &>(from));
}


void NVMeControllerCreateRequest::MergeFrom(const NVMeControllerCreateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller()) {
    _internal_mutable_controller()->::opi_api::storage::v1::NVMeController::MergeFrom(from._internal_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerCreateRequest::CopyFrom(const NVMeControllerCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerCreateRequest::IsInitialized() const {
  return true;
}

void NVMeControllerCreateRequest::InternalSwap(NVMeControllerCreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_, other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerCreateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[17]);
}

// ===================================================================

class NVMeControllerDeleteRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeControllerDeleteRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerDeleteRequest::_Internal::controller_id(const NVMeControllerDeleteRequest* msg) {
  return *msg->controller_id_;
}
void NVMeControllerDeleteRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
NVMeControllerDeleteRequest::NVMeControllerDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerDeleteRequest)
}
NVMeControllerDeleteRequest::NVMeControllerDeleteRequest(const NVMeControllerDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerDeleteRequest)
}

inline void NVMeControllerDeleteRequest::SharedCtor() {
controller_id_ = nullptr;
}

NVMeControllerDeleteRequest::~NVMeControllerDeleteRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerDeleteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_id_;
}

void NVMeControllerDeleteRequest::ArenaDtor(void* object) {
  NVMeControllerDeleteRequest* _this = reinterpret_cast< NVMeControllerDeleteRequest* >(object);
  (void)_this;
}
void NVMeControllerDeleteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerDeleteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerDeleteRequest)
  return target;
}

size_t NVMeControllerDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerDeleteRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerDeleteRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerDeleteRequest &>(from));
}


void NVMeControllerDeleteRequest::MergeFrom(const NVMeControllerDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerDeleteRequest::CopyFrom(const NVMeControllerDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerDeleteRequest::IsInitialized() const {
  return true;
}

void NVMeControllerDeleteRequest::InternalSwap(NVMeControllerDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_id_, other->controller_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerDeleteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[18]);
}

// ===================================================================

class NVMeControllerUpdateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeController& controller(const NVMeControllerUpdateRequest* msg);
};

const ::opi_api::storage::v1::NVMeController&
NVMeControllerUpdateRequest::_Internal::controller(const NVMeControllerUpdateRequest* msg) {
  return *msg->controller_;
}
NVMeControllerUpdateRequest::NVMeControllerUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerUpdateRequest)
}
NVMeControllerUpdateRequest::NVMeControllerUpdateRequest(const NVMeControllerUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::opi_api::storage::v1::NVMeController(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerUpdateRequest)
}

inline void NVMeControllerUpdateRequest::SharedCtor() {
controller_ = nullptr;
}

NVMeControllerUpdateRequest::~NVMeControllerUpdateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerUpdateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_;
}

void NVMeControllerUpdateRequest::ArenaDtor(void* object) {
  NVMeControllerUpdateRequest* _this = reinterpret_cast< NVMeControllerUpdateRequest* >(object);
  (void)_this;
}
void NVMeControllerUpdateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerUpdateRequest)
  return target;
}

size_t NVMeControllerUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerUpdateRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerUpdateRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerUpdateRequest &>(from));
}


void NVMeControllerUpdateRequest::MergeFrom(const NVMeControllerUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller()) {
    _internal_mutable_controller()->::opi_api::storage::v1::NVMeController::MergeFrom(from._internal_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerUpdateRequest::CopyFrom(const NVMeControllerUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerUpdateRequest::IsInitialized() const {
  return true;
}

void NVMeControllerUpdateRequest::InternalSwap(NVMeControllerUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_, other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerUpdateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[19]);
}

// ===================================================================

class NVMeControllerListRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeControllerListRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerListRequest::_Internal::subsystem_id(const NVMeControllerListRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeControllerListRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeControllerListRequest::NVMeControllerListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerListRequest)
}
NVMeControllerListRequest::NVMeControllerListRequest(const NVMeControllerListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerListRequest)
}

inline void NVMeControllerListRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeControllerListRequest::~NVMeControllerListRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerListRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeControllerListRequest::ArenaDtor(void* object) {
  NVMeControllerListRequest* _this = reinterpret_cast< NVMeControllerListRequest* >(object);
  (void)_this;
}
void NVMeControllerListRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerListRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerListRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerListRequest)
  return target;
}

size_t NVMeControllerListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerListRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerListRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerListRequest &>(from));
}


void NVMeControllerListRequest::MergeFrom(const NVMeControllerListRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerListRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerListRequest::CopyFrom(const NVMeControllerListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerListRequest::IsInitialized() const {
  return true;
}

void NVMeControllerListRequest::InternalSwap(NVMeControllerListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerListRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[20]);
}

// ===================================================================

class NVMeControllerListResponse::_Internal {
 public:
};

NVMeControllerListResponse::NVMeControllerListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  controller_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerListResponse)
}
NVMeControllerListResponse::NVMeControllerListResponse(const NVMeControllerListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      controller_(from.controller_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerListResponse)
}

inline void NVMeControllerListResponse::SharedCtor() {
}

NVMeControllerListResponse::~NVMeControllerListResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerListResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeControllerListResponse::ArenaDtor(void* object) {
  NVMeControllerListResponse* _this = reinterpret_cast< NVMeControllerListResponse* >(object);
  (void)_this;
}
void NVMeControllerListResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerListResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  controller_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerListResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_controller(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_controller_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_controller(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerListResponse)
  return target;
}

size_t NVMeControllerListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  total_size += 1UL * this->_internal_controller_size();
  for (const auto& msg : this->controller_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerListResponse::GetClassData() const { return &_class_data_; }

void NVMeControllerListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerListResponse *>(to)->MergeFrom(
      static_cast<const NVMeControllerListResponse &>(from));
}


void NVMeControllerListResponse::MergeFrom(const NVMeControllerListResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerListResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  controller_.MergeFrom(from.controller_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerListResponse::CopyFrom(const NVMeControllerListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerListResponse::IsInitialized() const {
  return true;
}

void NVMeControllerListResponse::InternalSwap(NVMeControllerListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  controller_.InternalSwap(&other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerListResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[21]);
}

// ===================================================================

class NVMeControllerGetRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeControllerGetRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerGetRequest::_Internal::controller_id(const NVMeControllerGetRequest* msg) {
  return *msg->controller_id_;
}
void NVMeControllerGetRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
NVMeControllerGetRequest::NVMeControllerGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerGetRequest)
}
NVMeControllerGetRequest::NVMeControllerGetRequest(const NVMeControllerGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerGetRequest)
}

inline void NVMeControllerGetRequest::SharedCtor() {
controller_id_ = nullptr;
}

NVMeControllerGetRequest::~NVMeControllerGetRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerGetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_id_;
}

void NVMeControllerGetRequest::ArenaDtor(void* object) {
  NVMeControllerGetRequest* _this = reinterpret_cast< NVMeControllerGetRequest* >(object);
  (void)_this;
}
void NVMeControllerGetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerGetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerGetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerGetRequest)
  return target;
}

size_t NVMeControllerGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerGetRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerGetRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerGetRequest &>(from));
}


void NVMeControllerGetRequest::MergeFrom(const NVMeControllerGetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerGetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerGetRequest::CopyFrom(const NVMeControllerGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerGetRequest::IsInitialized() const {
  return true;
}

void NVMeControllerGetRequest::InternalSwap(NVMeControllerGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_id_, other->controller_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerGetRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[22]);
}

// ===================================================================

class NVMeControllerStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerStatsRequest::_Internal::id(const NVMeControllerStatsRequest* msg) {
  return *msg->id_;
}
void NVMeControllerStatsRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeControllerStatsRequest::NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatsRequest)
}
NVMeControllerStatsRequest::NVMeControllerStatsRequest(const NVMeControllerStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatsRequest)
}

inline void NVMeControllerStatsRequest::SharedCtor() {
id_ = nullptr;
}

NVMeControllerStatsRequest::~NVMeControllerStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
}

void NVMeControllerStatsRequest::ArenaDtor(void* object) {
  NVMeControllerStatsRequest* _this = reinterpret_cast< NVMeControllerStatsRequest* >(object);
  (void)_this;
}
void NVMeControllerStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatsRequest)
  return target;
}

size_t NVMeControllerStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatsRequest &>(from));
}


void NVMeControllerStatsRequest::MergeFrom(const NVMeControllerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatsRequest::CopyFrom(const NVMeControllerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatsRequest::IsInitialized() const {
  return true;
}

void NVMeControllerStatsRequest::InternalSwap(NVMeControllerStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[23]);
}

// ===================================================================

class NVMeControllerStatsResponse::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerStatsResponse* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerStatsResponse::_Internal::id(const NVMeControllerStatsResponse* msg) {
  return *msg->id_;
}
void NVMeControllerStatsResponse::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeControllerStatsResponse::NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatsResponse)
}
NVMeControllerStatsResponse::NVMeControllerStatsResponse(const NVMeControllerStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatsResponse)
}

inline void NVMeControllerStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = nullptr;
}

NVMeControllerStatsResponse::~NVMeControllerStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeControllerStatsResponse::ArenaDtor(void* object) {
  NVMeControllerStatsResponse* _this = reinterpret_cast< NVMeControllerStatsResponse* >(object);
  (void)_this;
}
void NVMeControllerStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeControllerStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeControllerStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatsResponse)
  return target;
}

size_t NVMeControllerStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeControllerStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatsResponse &>(from));
}


void NVMeControllerStatsResponse::MergeFrom(const NVMeControllerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatsResponse::CopyFrom(const NVMeControllerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatsResponse::IsInitialized() const {
  return true;
}

void NVMeControllerStatsResponse::InternalSwap(NVMeControllerStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[24]);
}

// ===================================================================

class NVMeNamespaceCreateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespace& namespace_(const NVMeNamespaceCreateRequest* msg);
};

const ::opi_api::storage::v1::NVMeNamespace&
NVMeNamespaceCreateRequest::_Internal::namespace_(const NVMeNamespaceCreateRequest* msg) {
  return *msg->namespace__;
}
NVMeNamespaceCreateRequest::NVMeNamespaceCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceCreateRequest)
}
NVMeNamespaceCreateRequest::NVMeNamespaceCreateRequest(const NVMeNamespaceCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_()) {
    namespace__ = new ::opi_api::storage::v1::NVMeNamespace(*from.namespace__);
  } else {
    namespace__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceCreateRequest)
}

inline void NVMeNamespaceCreateRequest::SharedCtor() {
namespace__ = nullptr;
}

NVMeNamespaceCreateRequest::~NVMeNamespaceCreateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace__;
}

void NVMeNamespaceCreateRequest::ArenaDtor(void* object) {
  NVMeNamespaceCreateRequest* _this = reinterpret_cast< NVMeNamespaceCreateRequest* >(object);
  (void)_this;
}
void NVMeNamespaceCreateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceCreateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceCreateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  return target;
}

size_t NVMeNamespaceCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceCreateRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceCreateRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceCreateRequest &>(from));
}


void NVMeNamespaceCreateRequest::MergeFrom(const NVMeNamespaceCreateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_()) {
    _internal_mutable_namespace_()->::opi_api::storage::v1::NVMeNamespace::MergeFrom(from._internal_namespace_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceCreateRequest::CopyFrom(const NVMeNamespaceCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceCreateRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceCreateRequest::InternalSwap(NVMeNamespaceCreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace__, other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceCreateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[25]);
}

// ===================================================================

class NVMeNamespaceDeleteRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceDeleteRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceDeleteRequest::_Internal::namespace_id(const NVMeNamespaceDeleteRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceDeleteRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceDeleteRequest::NVMeNamespaceDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
}
NVMeNamespaceDeleteRequest::NVMeNamespaceDeleteRequest(const NVMeNamespaceDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
}

inline void NVMeNamespaceDeleteRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceDeleteRequest::~NVMeNamespaceDeleteRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceDeleteRequest::ArenaDtor(void* object) {
  NVMeNamespaceDeleteRequest* _this = reinterpret_cast< NVMeNamespaceDeleteRequest* >(object);
  (void)_this;
}
void NVMeNamespaceDeleteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceDeleteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  return target;
}

size_t NVMeNamespaceDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceDeleteRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceDeleteRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceDeleteRequest &>(from));
}


void NVMeNamespaceDeleteRequest::MergeFrom(const NVMeNamespaceDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceDeleteRequest::CopyFrom(const NVMeNamespaceDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceDeleteRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceDeleteRequest::InternalSwap(NVMeNamespaceDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceDeleteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[26]);
}

// ===================================================================

class NVMeNamespaceUpdateRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespace& namespace_(const NVMeNamespaceUpdateRequest* msg);
};

const ::opi_api::storage::v1::NVMeNamespace&
NVMeNamespaceUpdateRequest::_Internal::namespace_(const NVMeNamespaceUpdateRequest* msg) {
  return *msg->namespace__;
}
NVMeNamespaceUpdateRequest::NVMeNamespaceUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
}
NVMeNamespaceUpdateRequest::NVMeNamespaceUpdateRequest(const NVMeNamespaceUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_()) {
    namespace__ = new ::opi_api::storage::v1::NVMeNamespace(*from.namespace__);
  } else {
    namespace__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
}

inline void NVMeNamespaceUpdateRequest::SharedCtor() {
namespace__ = nullptr;
}

NVMeNamespaceUpdateRequest::~NVMeNamespaceUpdateRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace__;
}

void NVMeNamespaceUpdateRequest::ArenaDtor(void* object) {
  NVMeNamespaceUpdateRequest* _this = reinterpret_cast< NVMeNamespaceUpdateRequest* >(object);
  (void)_this;
}
void NVMeNamespaceUpdateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  return target;
}

size_t NVMeNamespaceUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceUpdateRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceUpdateRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceUpdateRequest &>(from));
}


void NVMeNamespaceUpdateRequest::MergeFrom(const NVMeNamespaceUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_()) {
    _internal_mutable_namespace_()->::opi_api::storage::v1::NVMeNamespace::MergeFrom(from._internal_namespace_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceUpdateRequest::CopyFrom(const NVMeNamespaceUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceUpdateRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceUpdateRequest::InternalSwap(NVMeNamespaceUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace__, other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceUpdateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[27]);
}

// ===================================================================

class NVMeNamespaceListRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeNamespaceListRequest* msg);
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeNamespaceListRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceListRequest::_Internal::subsystem_id(const NVMeNamespaceListRequest* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceListRequest::_Internal::controller_id(const NVMeNamespaceListRequest* msg) {
  return *msg->controller_id_;
}
void NVMeNamespaceListRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeNamespaceListRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
NVMeNamespaceListRequest::NVMeNamespaceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceListRequest)
}
NVMeNamespaceListRequest::NVMeNamespaceListRequest(const NVMeNamespaceListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceListRequest)
}

inline void NVMeNamespaceListRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&subsystem_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&controller_id_) -
    reinterpret_cast<char*>(&subsystem_id_)) + sizeof(controller_id_));
}

NVMeNamespaceListRequest::~NVMeNamespaceListRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceListRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceListRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete controller_id_;
}

void NVMeNamespaceListRequest::ArenaDtor(void* object) {
  NVMeNamespaceListRequest* _this = reinterpret_cast< NVMeNamespaceListRequest* >(object);
  (void)_this;
}
void NVMeNamespaceListRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceListRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceListRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceListRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceListRequest)
  return target;
}

size_t NVMeNamespaceListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceListRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceListRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceListRequest &>(from));
}


void NVMeNamespaceListRequest::MergeFrom(const NVMeNamespaceListRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceListRequest::CopyFrom(const NVMeNamespaceListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceListRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceListRequest::InternalSwap(NVMeNamespaceListRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespaceListRequest, controller_id_)
      + sizeof(NVMeNamespaceListRequest::controller_id_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespaceListRequest, subsystem_id_)>(
          reinterpret_cast<char*>(&subsystem_id_),
          reinterpret_cast<char*>(&other->subsystem_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceListRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[28]);
}

// ===================================================================

class NVMeNamespaceListResponse::_Internal {
 public:
};

NVMeNamespaceListResponse::NVMeNamespaceListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  namespace__(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceListResponse)
}
NVMeNamespaceListResponse::NVMeNamespaceListResponse(const NVMeNamespaceListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      namespace__(from.namespace__) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceListResponse)
}

inline void NVMeNamespaceListResponse::SharedCtor() {
}

NVMeNamespaceListResponse::~NVMeNamespaceListResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceListResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeNamespaceListResponse::ArenaDtor(void* object) {
  NVMeNamespaceListResponse* _this = reinterpret_cast< NVMeNamespaceListResponse* >(object);
  (void)_this;
}
void NVMeNamespaceListResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceListResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  namespace__.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceListResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_namespace_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_namespace__size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_namespace_(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceListResponse)
  return target;
}

size_t NVMeNamespaceListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  total_size += 1UL * this->_internal_namespace__size();
  for (const auto& msg : this->namespace__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceListResponse::GetClassData() const { return &_class_data_; }

void NVMeNamespaceListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceListResponse *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceListResponse &>(from));
}


void NVMeNamespaceListResponse::MergeFrom(const NVMeNamespaceListResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  namespace__.MergeFrom(from.namespace__);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceListResponse::CopyFrom(const NVMeNamespaceListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceListResponse::IsInitialized() const {
  return true;
}

void NVMeNamespaceListResponse::InternalSwap(NVMeNamespaceListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  namespace__.InternalSwap(&other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceListResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[29]);
}

// ===================================================================

class NVMeNamespaceGetRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceGetRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceGetRequest::_Internal::namespace_id(const NVMeNamespaceGetRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceGetRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceGetRequest::NVMeNamespaceGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceGetRequest)
}
NVMeNamespaceGetRequest::NVMeNamespaceGetRequest(const NVMeNamespaceGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceGetRequest)
}

inline void NVMeNamespaceGetRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceGetRequest::~NVMeNamespaceGetRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceGetRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceGetRequest::ArenaDtor(void* object) {
  NVMeNamespaceGetRequest* _this = reinterpret_cast< NVMeNamespaceGetRequest* >(object);
  (void)_this;
}
void NVMeNamespaceGetRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceGetRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceGetRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceGetRequest)
  return target;
}

size_t NVMeNamespaceGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceGetRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceGetRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceGetRequest &>(from));
}


void NVMeNamespaceGetRequest::MergeFrom(const NVMeNamespaceGetRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceGetRequest::CopyFrom(const NVMeNamespaceGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceGetRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceGetRequest::InternalSwap(NVMeNamespaceGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceGetRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[30]);
}

// ===================================================================

class NVMeNamespaceStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceStatsRequest::_Internal::namespace_id(const NVMeNamespaceStatsRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceStatsRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
}
NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(const NVMeNamespaceStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
}

inline void NVMeNamespaceStatsRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceStatsRequest::~NVMeNamespaceStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceStatsRequest::ArenaDtor(void* object) {
  NVMeNamespaceStatsRequest* _this = reinterpret_cast< NVMeNamespaceStatsRequest* >(object);
  (void)_this;
}
void NVMeNamespaceStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  return target;
}

size_t NVMeNamespaceStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatsRequest &>(from));
}


void NVMeNamespaceStatsRequest::MergeFrom(const NVMeNamespaceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatsRequest::CopyFrom(const NVMeNamespaceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatsRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatsRequest::InternalSwap(NVMeNamespaceStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[31]);
}

// ===================================================================

class NVMeNamespaceStatsResponse::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeNamespaceStatsResponse* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceStatsResponse::_Internal::id(const NVMeNamespaceStatsResponse* msg) {
  return *msg->id_;
}
void NVMeNamespaceStatsResponse::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
}
NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(const NVMeNamespaceStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
}

inline void NVMeNamespaceStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = nullptr;
}

NVMeNamespaceStatsResponse::~NVMeNamespaceStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeNamespaceStatsResponse::ArenaDtor(void* object) {
  NVMeNamespaceStatsResponse* _this = reinterpret_cast< NVMeNamespaceStatsResponse* >(object);
  (void)_this;
}
void NVMeNamespaceStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeNamespaceStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeNamespaceStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  return target;
}

size_t NVMeNamespaceStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatsResponse &>(from));
}


void NVMeNamespaceStatsResponse::MergeFrom(const NVMeNamespaceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatsResponse::CopyFrom(const NVMeNamespaceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatsResponse::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatsResponse::InternalSwap(NVMeNamespaceStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[32]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystem* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystem >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeController* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespace* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemCreateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemDeleteRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemUpdateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemListRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemListResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemGetRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerCreateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerDeleteRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerUpdateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerListRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerListResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerGetRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceCreateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceDeleteRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceUpdateRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceListRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceListResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceGetRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatsResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
