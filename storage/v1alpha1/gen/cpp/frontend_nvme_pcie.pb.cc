// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#include "frontend_nvme_pcie.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace opi_api {
namespace storage {
namespace v1 {
constexpr NvmeSubsystem::NvmeSubsystem(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , spec_(nullptr)
  , status_(nullptr){}
struct NvmeSubsystemDefaultTypeInternal {
  constexpr NvmeSubsystemDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeSubsystemDefaultTypeInternal() {}
  union {
    NvmeSubsystem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeSubsystemDefaultTypeInternal _NvmeSubsystem_default_instance_;
constexpr NvmeSubsystemSpec::NvmeSubsystemSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nqn_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , max_namespaces_(int64_t{0}){}
struct NvmeSubsystemSpecDefaultTypeInternal {
  constexpr NvmeSubsystemSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeSubsystemSpecDefaultTypeInternal() {}
  union {
    NvmeSubsystemSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeSubsystemSpecDefaultTypeInternal _NvmeSubsystemSpec_default_instance_;
constexpr NvmeSubsystemStatus::NvmeSubsystemStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : firmware_revision_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fru_guid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct NvmeSubsystemStatusDefaultTypeInternal {
  constexpr NvmeSubsystemStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeSubsystemStatusDefaultTypeInternal() {}
  union {
    NvmeSubsystemStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeSubsystemStatusDefaultTypeInternal _NvmeSubsystemStatus_default_instance_;
constexpr NvmeController::NvmeController(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , spec_(nullptr)
  , status_(nullptr){}
struct NvmeControllerDefaultTypeInternal {
  constexpr NvmeControllerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeControllerDefaultTypeInternal() {}
  union {
    NvmeController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeControllerDefaultTypeInternal _NvmeController_default_instance_;
constexpr NvmeControllerSpec::NvmeControllerSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_name_ref_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , pcie_id_(nullptr)
  , min_limit_(nullptr)
  , max_limit_(nullptr)
  , nvme_controller_id_(0)
  , max_nsq_(0)
  , max_ncq_(0)
  , sqes_(0)
  , cqes_(0)
  , max_namespaces_(0){}
struct NvmeControllerSpecDefaultTypeInternal {
  constexpr NvmeControllerSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeControllerSpecDefaultTypeInternal() {}
  union {
    NvmeControllerSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeControllerSpecDefaultTypeInternal _NvmeControllerSpec_default_instance_;
constexpr NvmeControllerStatus::NvmeControllerStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : active_(false){}
struct NvmeControllerStatusDefaultTypeInternal {
  constexpr NvmeControllerStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeControllerStatusDefaultTypeInternal() {}
  union {
    NvmeControllerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeControllerStatusDefaultTypeInternal _NvmeControllerStatus_default_instance_;
constexpr NvmeNamespace::NvmeNamespace(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , spec_(nullptr)
  , status_(nullptr){}
struct NvmeNamespaceDefaultTypeInternal {
  constexpr NvmeNamespaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeNamespaceDefaultTypeInternal() {}
  union {
    NvmeNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeNamespaceDefaultTypeInternal _NvmeNamespace_default_instance_;
constexpr NvmeNamespaceSpec::NvmeNamespaceSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_name_ref_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nguid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , volume_name_ref_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , uuid_(nullptr)
  , eui64_(int64_t{0})
  , host_nsid_(0){}
struct NvmeNamespaceSpecDefaultTypeInternal {
  constexpr NvmeNamespaceSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeNamespaceSpecDefaultTypeInternal() {}
  union {
    NvmeNamespaceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeNamespaceSpecDefaultTypeInternal _NvmeNamespaceSpec_default_instance_;
constexpr NvmeNamespaceStatus::NvmeNamespaceStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pci_state_(0)

  , pci_oper_state_(0)
{}
struct NvmeNamespaceStatusDefaultTypeInternal {
  constexpr NvmeNamespaceStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NvmeNamespaceStatusDefaultTypeInternal() {}
  union {
    NvmeNamespaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NvmeNamespaceStatusDefaultTypeInternal _NvmeNamespaceStatus_default_instance_;
constexpr CreateNvmeSubsystemRequest::CreateNvmeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_subsystem_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nvme_subsystem_(nullptr){}
struct CreateNvmeSubsystemRequestDefaultTypeInternal {
  constexpr CreateNvmeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    CreateNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateNvmeSubsystemRequestDefaultTypeInternal _CreateNvmeSubsystemRequest_default_instance_;
constexpr DeleteNvmeSubsystemRequest::DeleteNvmeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , allow_missing_(false){}
struct DeleteNvmeSubsystemRequestDefaultTypeInternal {
  constexpr DeleteNvmeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNvmeSubsystemRequestDefaultTypeInternal _DeleteNvmeSubsystemRequest_default_instance_;
constexpr UpdateNvmeSubsystemRequest::UpdateNvmeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_subsystem_(nullptr)
  , update_mask_(nullptr)
  , allow_missing_(false){}
struct UpdateNvmeSubsystemRequestDefaultTypeInternal {
  constexpr UpdateNvmeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNvmeSubsystemRequestDefaultTypeInternal _UpdateNvmeSubsystemRequest_default_instance_;
constexpr ListNvmeSubsystemsRequest::ListNvmeSubsystemsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parent_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_size_(0){}
struct ListNvmeSubsystemsRequestDefaultTypeInternal {
  constexpr ListNvmeSubsystemsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNvmeSubsystemsRequestDefaultTypeInternal() {}
  union {
    ListNvmeSubsystemsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNvmeSubsystemsRequestDefaultTypeInternal _ListNvmeSubsystemsRequest_default_instance_;
constexpr ListNvmeSubsystemsResponse::ListNvmeSubsystemsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_subsystems_()
  , next_page_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ListNvmeSubsystemsResponseDefaultTypeInternal {
  constexpr ListNvmeSubsystemsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNvmeSubsystemsResponseDefaultTypeInternal() {}
  union {
    ListNvmeSubsystemsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNvmeSubsystemsResponseDefaultTypeInternal _ListNvmeSubsystemsResponse_default_instance_;
constexpr GetNvmeSubsystemRequest::GetNvmeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetNvmeSubsystemRequestDefaultTypeInternal {
  constexpr GetNvmeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    GetNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetNvmeSubsystemRequestDefaultTypeInternal _GetNvmeSubsystemRequest_default_instance_;
constexpr StatsNvmeSubsystemRequest::StatsNvmeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StatsNvmeSubsystemRequestDefaultTypeInternal {
  constexpr StatsNvmeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatsNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    StatsNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatsNvmeSubsystemRequestDefaultTypeInternal _StatsNvmeSubsystemRequest_default_instance_;
constexpr StatsNvmeSubsystemResponse::StatsNvmeSubsystemResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(nullptr){}
struct StatsNvmeSubsystemResponseDefaultTypeInternal {
  constexpr StatsNvmeSubsystemResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatsNvmeSubsystemResponseDefaultTypeInternal() {}
  union {
    StatsNvmeSubsystemResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatsNvmeSubsystemResponseDefaultTypeInternal _StatsNvmeSubsystemResponse_default_instance_;
constexpr CreateNvmeControllerRequest::CreateNvmeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_controller_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nvme_controller_(nullptr){}
struct CreateNvmeControllerRequestDefaultTypeInternal {
  constexpr CreateNvmeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateNvmeControllerRequestDefaultTypeInternal() {}
  union {
    CreateNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateNvmeControllerRequestDefaultTypeInternal _CreateNvmeControllerRequest_default_instance_;
constexpr DeleteNvmeControllerRequest::DeleteNvmeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , allow_missing_(false){}
struct DeleteNvmeControllerRequestDefaultTypeInternal {
  constexpr DeleteNvmeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNvmeControllerRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNvmeControllerRequestDefaultTypeInternal _DeleteNvmeControllerRequest_default_instance_;
constexpr UpdateNvmeControllerRequest::UpdateNvmeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_controller_(nullptr)
  , update_mask_(nullptr)
  , allow_missing_(false){}
struct UpdateNvmeControllerRequestDefaultTypeInternal {
  constexpr UpdateNvmeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNvmeControllerRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNvmeControllerRequestDefaultTypeInternal _UpdateNvmeControllerRequest_default_instance_;
constexpr ListNvmeControllersRequest::ListNvmeControllersRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parent_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_size_(0){}
struct ListNvmeControllersRequestDefaultTypeInternal {
  constexpr ListNvmeControllersRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNvmeControllersRequestDefaultTypeInternal() {}
  union {
    ListNvmeControllersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNvmeControllersRequestDefaultTypeInternal _ListNvmeControllersRequest_default_instance_;
constexpr ListNvmeControllersResponse::ListNvmeControllersResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_controllers_()
  , next_page_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ListNvmeControllersResponseDefaultTypeInternal {
  constexpr ListNvmeControllersResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNvmeControllersResponseDefaultTypeInternal() {}
  union {
    ListNvmeControllersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNvmeControllersResponseDefaultTypeInternal _ListNvmeControllersResponse_default_instance_;
constexpr GetNvmeControllerRequest::GetNvmeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetNvmeControllerRequestDefaultTypeInternal {
  constexpr GetNvmeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetNvmeControllerRequestDefaultTypeInternal() {}
  union {
    GetNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetNvmeControllerRequestDefaultTypeInternal _GetNvmeControllerRequest_default_instance_;
constexpr StatsNvmeControllerRequest::StatsNvmeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StatsNvmeControllerRequestDefaultTypeInternal {
  constexpr StatsNvmeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatsNvmeControllerRequestDefaultTypeInternal() {}
  union {
    StatsNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatsNvmeControllerRequestDefaultTypeInternal _StatsNvmeControllerRequest_default_instance_;
constexpr StatsNvmeControllerResponse::StatsNvmeControllerResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(nullptr){}
struct StatsNvmeControllerResponseDefaultTypeInternal {
  constexpr StatsNvmeControllerResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatsNvmeControllerResponseDefaultTypeInternal() {}
  union {
    StatsNvmeControllerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatsNvmeControllerResponseDefaultTypeInternal _StatsNvmeControllerResponse_default_instance_;
constexpr CreateNvmeNamespaceRequest::CreateNvmeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_namespace_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nvme_namespace_(nullptr){}
struct CreateNvmeNamespaceRequestDefaultTypeInternal {
  constexpr CreateNvmeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    CreateNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateNvmeNamespaceRequestDefaultTypeInternal _CreateNvmeNamespaceRequest_default_instance_;
constexpr DeleteNvmeNamespaceRequest::DeleteNvmeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , allow_missing_(false){}
struct DeleteNvmeNamespaceRequestDefaultTypeInternal {
  constexpr DeleteNvmeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNvmeNamespaceRequestDefaultTypeInternal _DeleteNvmeNamespaceRequest_default_instance_;
constexpr UpdateNvmeNamespaceRequest::UpdateNvmeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_namespace_(nullptr)
  , update_mask_(nullptr)
  , allow_missing_(false){}
struct UpdateNvmeNamespaceRequestDefaultTypeInternal {
  constexpr UpdateNvmeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNvmeNamespaceRequestDefaultTypeInternal _UpdateNvmeNamespaceRequest_default_instance_;
constexpr ListNvmeNamespacesRequest::ListNvmeNamespacesRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parent_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , page_size_(0){}
struct ListNvmeNamespacesRequestDefaultTypeInternal {
  constexpr ListNvmeNamespacesRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNvmeNamespacesRequestDefaultTypeInternal() {}
  union {
    ListNvmeNamespacesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNvmeNamespacesRequestDefaultTypeInternal _ListNvmeNamespacesRequest_default_instance_;
constexpr ListNvmeNamespacesResponse::ListNvmeNamespacesResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nvme_namespaces_()
  , next_page_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ListNvmeNamespacesResponseDefaultTypeInternal {
  constexpr ListNvmeNamespacesResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNvmeNamespacesResponseDefaultTypeInternal() {}
  union {
    ListNvmeNamespacesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNvmeNamespacesResponseDefaultTypeInternal _ListNvmeNamespacesResponse_default_instance_;
constexpr GetNvmeNamespaceRequest::GetNvmeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetNvmeNamespaceRequestDefaultTypeInternal {
  constexpr GetNvmeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    GetNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetNvmeNamespaceRequestDefaultTypeInternal _GetNvmeNamespaceRequest_default_instance_;
constexpr StatsNvmeNamespaceRequest::StatsNvmeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StatsNvmeNamespaceRequestDefaultTypeInternal {
  constexpr StatsNvmeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatsNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    StatsNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatsNvmeNamespaceRequestDefaultTypeInternal _StatsNvmeNamespaceRequest_default_instance_;
constexpr StatsNvmeNamespaceResponse::StatsNvmeNamespaceResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(nullptr){}
struct StatsNvmeNamespaceResponseDefaultTypeInternal {
  constexpr StatsNvmeNamespaceResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatsNvmeNamespaceResponseDefaultTypeInternal() {}
  union {
    StatsNvmeNamespaceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatsNvmeNamespaceResponseDefaultTypeInternal _StatsNvmeNamespaceResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_frontend_5fnvme_5fpcie_2eproto[33];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto = nullptr;

const uint32_t TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, nqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, serial_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, model_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, max_namespaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemStatus, firmware_revision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemStatus, fru_guid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, nvme_controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, subsystem_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, pcie_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, max_nsq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, max_ncq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, sqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, cqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, max_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, min_limit_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, max_limit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerStatus, active_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, subsystem_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, host_nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, uuid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, volume_name_ref_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceStatus, pci_state_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceStatus, pci_oper_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeSubsystemRequest, nvme_subsystem_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeSubsystemRequest, nvme_subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeSubsystemRequest, name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeSubsystemRequest, allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, nvme_subsystem_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsResponse, nvme_subsystems_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsResponse, next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeSubsystemRequest, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemRequest, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, nvme_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, nvme_controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeControllerRequest, name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeControllerRequest, allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, nvme_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersResponse, nvme_controllers_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersResponse, next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeControllerRequest, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerRequest, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, nvme_namespace_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, nvme_namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeNamespaceRequest, name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeNamespaceRequest, allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, nvme_namespace_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesResponse, nvme_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesResponse, next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeNamespaceRequest, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceRequest, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceResponse, stats_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NvmeSubsystem)},
  { 9, -1, -1, sizeof(::opi_api::storage::v1::NvmeSubsystemSpec)},
  { 19, -1, -1, sizeof(::opi_api::storage::v1::NvmeSubsystemStatus)},
  { 27, -1, -1, sizeof(::opi_api::storage::v1::NvmeController)},
  { 36, -1, -1, sizeof(::opi_api::storage::v1::NvmeControllerSpec)},
  { 52, -1, -1, sizeof(::opi_api::storage::v1::NvmeControllerStatus)},
  { 59, -1, -1, sizeof(::opi_api::storage::v1::NvmeNamespace)},
  { 68, -1, -1, sizeof(::opi_api::storage::v1::NvmeNamespaceSpec)},
  { 80, -1, -1, sizeof(::opi_api::storage::v1::NvmeNamespaceStatus)},
  { 88, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeSubsystemRequest)},
  { 96, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeSubsystemRequest)},
  { 104, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeSubsystemRequest)},
  { 113, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeSubsystemsRequest)},
  { 122, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeSubsystemsResponse)},
  { 130, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeSubsystemRequest)},
  { 137, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeSubsystemRequest)},
  { 144, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeSubsystemResponse)},
  { 151, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeControllerRequest)},
  { 159, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeControllerRequest)},
  { 167, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeControllerRequest)},
  { 176, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeControllersRequest)},
  { 185, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeControllersResponse)},
  { 193, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeControllerRequest)},
  { 200, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeControllerRequest)},
  { 207, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeControllerResponse)},
  { 214, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeNamespaceRequest)},
  { 222, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeNamespaceRequest)},
  { 230, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeNamespaceRequest)},
  { 239, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeNamespacesRequest)},
  { 248, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeNamespacesResponse)},
  { 256, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeNamespaceRequest)},
  { 263, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeNamespaceRequest)},
  { 270, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeNamespaceResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeSubsystem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeSubsystemSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeSubsystemStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeController_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeControllerSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeControllerStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeNamespace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeNamespaceSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NvmeNamespaceStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_CreateNvmeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_DeleteNvmeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_UpdateNvmeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNvmeSubsystemsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNvmeSubsystemsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_GetNvmeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_StatsNvmeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_StatsNvmeSubsystemResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_CreateNvmeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_DeleteNvmeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_UpdateNvmeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNvmeControllersRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNvmeControllersResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_GetNvmeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_StatsNvmeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_StatsNvmeControllerResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_CreateNvmeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_DeleteNvmeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_UpdateNvmeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNvmeNamespacesRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNvmeNamespacesResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_GetNvmeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_StatsNvmeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_StatsNvmeNamespaceResponse_default_instance_),
};

const char descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030frontend_nvme_pcie.proto\022\022opi_api.stor"
  "age.v1\032\017opicommon.proto\032\nuuid.proto\032\027goo"
  "gle/api/client.proto\032\031google/api/resourc"
  "e.proto\032\033google/protobuf/empty.proto\032\034go"
  "ogle/api/annotations.proto\032\037google/api/f"
  "ield_behavior.proto\032 google/protobuf/fie"
  "ld_mask.proto\"\365\001\n\rNvmeSubsystem\0229\n\004name\030"
  "\001 \001(\tB+\340A\003\340A\005\372A\"\n opi_api.storage.v1/Nvm"
  "eSubsystem\0223\n\004spec\030\002 \001(\0132%.opi_api.stora"
  "ge.v1.NvmeSubsystemSpec\0227\n\006status\030\003 \001(\0132"
  "\'.opi_api.storage.v1.NvmeSubsystemStatus"
  ":;\352A8\n$storage.opiproject.org/NvmeSubsys"
  "tem\022\020volumes/{volume}\"e\n\021NvmeSubsystemSp"
  "ec\022\013\n\003nqn\030\001 \001(\t\022\025\n\rserial_number\030\002 \001(\t\022\024"
  "\n\014model_number\030\003 \001(\t\022\026\n\016max_namespaces\030\004"
  " \001(\003\"B\n\023NvmeSubsystemStatus\022\031\n\021firmware_"
  "revision\030\001 \001(\t\022\020\n\010fru_guid\030\002 \001(\014\"\372\001\n\016Nvm"
  "eController\022:\n\004name\030\001 \001(\tB,\340A\003\340A\005\372A#\n!op"
  "i_api.storage.v1/NvmeController\0224\n\004spec\030"
  "\002 \001(\0132&.opi_api.storage.v1.NvmeControlle"
  "rSpec\0228\n\006status\030\003 \001(\0132(.opi_api.storage."
  "v1.NvmeControllerStatus:<\352A9\n%storage.op"
  "iproject.org/NvmeController\022\020volumes/{vo"
  "lume}\"\340\002\n\022NvmeControllerSpec\022\032\n\022nvme_con"
  "troller_id\030\001 \001(\005\022D\n\022subsystem_name_ref\030\002"
  " \001(\tB(\340A\002\372A\"\n opi_api.storage.v1/NvmeSub"
  "system\0220\n\007pcie_id\030\003 \001(\0132\037.opi_api.storag"
  "e.v1.PciEndpoint\022\017\n\007max_nsq\030\004 \001(\005\022\017\n\007max"
  "_ncq\030\005 \001(\005\022\014\n\004sqes\030\006 \001(\005\022\014\n\004cqes\030\007 \001(\005\022\026"
  "\n\016max_namespaces\030\010 \001(\005\022/\n\tmin_limit\030\t \001("
  "\0132\034.opi_api.storage.v1.QosLimit\022/\n\tmax_l"
  "imit\030\n \001(\0132\034.opi_api.storage.v1.QosLimit"
  "\"&\n\024NvmeControllerStatus\022\016\n\006active\030\001 \001(\010"
  "\"\365\001\n\rNvmeNamespace\0229\n\004name\030\001 \001(\tB+\340A\003\340A\005"
  "\372A\"\n opi_api.storage.v1/NvmeNamespace\0223\n"
  "\004spec\030\002 \001(\0132%.opi_api.storage.v1.NvmeNam"
  "espaceSpec\0227\n\006status\030\003 \001(\0132\'.opi_api.sto"
  "rage.v1.NvmeNamespaceStatus:;\352A8\n$storag"
  "e.opiproject.org/NvmeNamespace\022\020volumes/"
  "{volume}\"\317\001\n\021NvmeNamespaceSpec\022D\n\022subsys"
  "tem_name_ref\030\001 \001(\tB(\340A\002\372A\"\n opi_api.stor"
  "age.v1/NvmeSubsystem\022\021\n\thost_nsid\030\002 \001(\005\022"
  "\r\n\005nguid\030\003 \001(\t\022\r\n\005eui64\030\004 \001(\003\022%\n\004uuid\030\005 "
  "\001(\0132\027.opi_api.common.v1.Uuid\022\034\n\017volume_n"
  "ame_ref\030\006 \001(\tB\003\340A\002\"\232\001\n\023NvmeNamespaceStat"
  "us\022<\n\tpci_state\030\001 \001(\0162).opi_api.storage."
  "v1.NvmeNamespacePciState\022E\n\016pci_oper_sta"
  "te\030\002 \001(\0162-.opi_api.storage.v1.NvmeNamesp"
  "acePciOperState\"w\n\032CreateNvmeSubsystemRe"
  "quest\022>\n\016nvme_subsystem\030\001 \001(\0132!.opi_api."
  "storage.v1.NvmeSubsystemB\003\340A\002\022\031\n\021nvme_su"
  "bsystem_id\030\002 \001(\t\"k\n\032DeleteNvmeSubsystemR"
  "equest\0226\n\004name\030\001 \001(\tB(\340A\002\372A\"\n opi_api.st"
  "orage.v1/NvmeSubsystem\022\025\n\rallow_missing\030"
  "\002 \001(\010\"\237\001\n\032UpdateNvmeSubsystemRequest\0229\n\016"
  "nvme_subsystem\030\001 \001(\0132!.opi_api.storage.v"
  "1.NvmeSubsystem\022/\n\013update_mask\030\002 \001(\0132\032.g"
  "oogle.protobuf.FieldMask\022\025\n\rallow_missin"
  "g\030\003 \001(\010\"|\n\031ListNvmeSubsystemsRequest\0228\n\006"
  "parent\030\001 \001(\tB(\340A\002\372A\"\n opi_api.storage.v1"
  "/NvmeSubsystem\022\021\n\tpage_size\030\002 \001(\005\022\022\n\npag"
  "e_token\030\003 \001(\t\"q\n\032ListNvmeSubsystemsRespo"
  "nse\022:\n\017nvme_subsystems\030\001 \003(\0132!.opi_api.s"
  "torage.v1.NvmeSubsystem\022\027\n\017next_page_tok"
  "en\030\002 \001(\t\"Q\n\027GetNvmeSubsystemRequest\0226\n\004n"
  "ame\030\001 \001(\tB(\340A\002\372A\"\n opi_api.storage.v1/Nv"
  "meSubsystem\"S\n\031StatsNvmeSubsystemRequest"
  "\0226\n\004name\030\001 \001(\tB(\340A\002\372A\"\n opi_api.storage."
  "v1/NvmeSubsystem\"L\n\032StatsNvmeSubsystemRe"
  "sponse\022.\n\005stats\030\001 \001(\0132\037.opi_api.storage."
  "v1.VolumeStats\"{\n\033CreateNvmeControllerRe"
  "quest\022@\n\017nvme_controller\030\001 \001(\0132\".opi_api"
  ".storage.v1.NvmeControllerB\003\340A\002\022\032\n\022nvme_"
  "controller_id\030\002 \001(\t\"m\n\033DeleteNvmeControl"
  "lerRequest\0227\n\004name\030\001 \001(\tB)\340A\002\372A#\n!opi_ap"
  "i.storage.v1/NvmeController\022\025\n\rallow_mis"
  "sing\030\002 \001(\010\"\242\001\n\033UpdateNvmeControllerReque"
  "st\022;\n\017nvme_controller\030\001 \001(\0132\".opi_api.st"
  "orage.v1.NvmeController\022/\n\013update_mask\030\002"
  " \001(\0132\032.google.protobuf.FieldMask\022\025\n\rallo"
  "w_missing\030\003 \001(\010\"~\n\032ListNvmeControllersRe"
  "quest\0229\n\006parent\030\001 \001(\tB)\340A\002\372A#\n!opi_api.s"
  "torage.v1/NvmeController\022\021\n\tpage_size\030\002 "
  "\001(\005\022\022\n\npage_token\030\003 \001(\t\"t\n\033ListNvmeContr"
  "ollersResponse\022<\n\020nvme_controllers\030\001 \003(\013"
  "2\".opi_api.storage.v1.NvmeController\022\027\n\017"
  "next_page_token\030\002 \001(\t\"S\n\030GetNvmeControll"
  "erRequest\0227\n\004name\030\001 \001(\tB)\340A\002\372A#\n!opi_api"
  ".storage.v1/NvmeController\"U\n\032StatsNvmeC"
  "ontrollerRequest\0227\n\004name\030\001 \001(\tB)\340A\002\372A#\n!"
  "opi_api.storage.v1/NvmeController\"M\n\033Sta"
  "tsNvmeControllerResponse\022.\n\005stats\030\001 \001(\0132"
  "\037.opi_api.storage.v1.VolumeStats\"w\n\032Crea"
  "teNvmeNamespaceRequest\022>\n\016nvme_namespace"
  "\030\001 \001(\0132!.opi_api.storage.v1.NvmeNamespac"
  "eB\003\340A\002\022\031\n\021nvme_namespace_id\030\002 \001(\t\"k\n\032Del"
  "eteNvmeNamespaceRequest\0226\n\004name\030\001 \001(\tB(\340"
  "A\002\372A\"\n opi_api.storage.v1/NvmeNamespace\022"
  "\025\n\rallow_missing\030\002 \001(\010\"\237\001\n\032UpdateNvmeNam"
  "espaceRequest\0229\n\016nvme_namespace\030\001 \001(\0132!."
  "opi_api.storage.v1.NvmeNamespace\022/\n\013upda"
  "te_mask\030\002 \001(\0132\032.google.protobuf.FieldMas"
  "k\022\025\n\rallow_missing\030\003 \001(\010\"|\n\031ListNvmeName"
  "spacesRequest\0228\n\006parent\030\001 \001(\tB(\340A\002\372A\"\n o"
  "pi_api.storage.v1/NvmeNamespace\022\021\n\tpage_"
  "size\030\002 \001(\005\022\022\n\npage_token\030\003 \001(\t\"q\n\032ListNv"
  "meNamespacesResponse\022:\n\017nvme_namespaces\030"
  "\001 \003(\0132!.opi_api.storage.v1.NvmeNamespace"
  "\022\027\n\017next_page_token\030\002 \001(\t\"Q\n\027GetNvmeName"
  "spaceRequest\0226\n\004name\030\001 \001(\tB(\340A\002\372A\"\n opi_"
  "api.storage.v1/NvmeNamespace\"S\n\031StatsNvm"
  "eNamespaceRequest\0226\n\004name\030\001 \001(\tB(\340A\002\372A\"\n"
  " opi_api.storage.v1/NvmeNamespace\"L\n\032Sta"
  "tsNvmeNamespaceResponse\022.\n\005stats\030\001 \001(\0132\037"
  ".opi_api.storage.v1.VolumeStats*\265\001\n\025Nvme"
  "NamespacePciState\022(\n$NVME_NAMESPACE_PCI_"
  "STATE_UNSPECIFIED\020\000\022%\n!NVME_NAMESPACE_PC"
  "I_STATE_DISABLED\020\001\022$\n NVME_NAMESPACE_PCI"
  "_STATE_ENABLED\020\002\022%\n!NVME_NAMESPACE_PCI_S"
  "TATE_DELETING\020\003*\237\001\n\031NvmeNamespacePciOper"
  "State\022-\n)NVME_NAMESPACE_PCI_OPER_STATE_U"
  "NSPECIFIED\020\000\022(\n$NVME_NAMESPACE_PCI_OPER_"
  "STATE_ONLINE\020\001\022)\n%NVME_NAMESPACE_PCI_OPE"
  "R_STATE_OFFLINE\020\0022\311\027\n\023FrontendNvmeServic"
  "e\022\260\001\n\023CreateNvmeSubsystem\022..opi_api.stor"
  "age.v1.CreateNvmeSubsystemRequest\032!.opi_"
  "api.storage.v1.NvmeSubsystem\"F\202\323\344\223\002\035\"\013/v"
  "1/volumes:\016nvme_subsystem\332A nvme_subsyst"
  "em,nvme_subsystem_id\022\211\001\n\023DeleteNvmeSubsy"
  "stem\022..opi_api.storage.v1.DeleteNvmeSubs"
  "ystemRequest\032\026.google.protobuf.Empty\"*\202\323"
  "\344\223\002\035*\033/v1/{name=NvmeSubsystems/*}\332A\004name"
  "\022\303\001\n\023UpdateNvmeSubsystem\022..opi_api.stora"
  "ge.v1.UpdateNvmeSubsystemRequest\032!.opi_a"
  "pi.storage.v1.NvmeSubsystem\"Y\202\323\344\223\00262$/v1"
  "/{nvme_subsystem.name=subsystems}:\016nvme_"
  "subsystem\332A\032nvme_subsystem,update_mask\022\235"
  "\001\n\022ListNvmeSubsystems\022-.opi_api.storage."
  "v1.ListNvmeSubsystemsRequest\032..opi_api.s"
  "torage.v1.ListNvmeSubsystemsResponse\"(\202\323"
  "\344\223\002\031\022\027/v1/{parent=subsystems}\332A\006parent\022\216"
  "\001\n\020GetNvmeSubsystem\022+.opi_api.storage.v1"
  ".GetNvmeSubsystemRequest\032!.opi_api.stora"
  "ge.v1.NvmeSubsystem\"*\202\323\344\223\002\035\022\033/v1/{name=N"
  "vmeSubsystems/*}\332A\004name\022\245\001\n\022StatsNvmeSub"
  "system\022-.opi_api.storage.v1.StatsNvmeSub"
  "systemRequest\032..opi_api.storage.v1.Stats"
  "NvmeSubsystemResponse\"0\202\323\344\223\002#\022!/v1/{name"
  "=NvmeSubsystems/*}:stats\332A\004name\022\266\001\n\024Crea"
  "teNvmeController\022/.opi_api.storage.v1.Cr"
  "eateNvmeControllerRequest\032\".opi_api.stor"
  "age.v1.NvmeController\"I\202\323\344\223\002\036\"\013/v1/volum"
  "es:\017nvme_controller\332A\"nvme_controller,nv"
  "me_controller_id\022\214\001\n\024DeleteNvmeControlle"
  "r\022/.opi_api.storage.v1.DeleteNvmeControl"
  "lerRequest\032\026.google.protobuf.Empty\"+\202\323\344\223"
  "\002\036*\034/v1/{name=NvmeControllers/*}\332A\004name\022"
  "\311\001\n\024UpdateNvmeController\022/.opi_api.stora"
  "ge.v1.UpdateNvmeControllerRequest\032\".opi_"
  "api.storage.v1.NvmeController\"\\\202\323\344\223\00282%/"
  "v1/{nvme_controller.name=subsystems}:\017nv"
  "me_controller\332A\033nvme_controller,update_m"
  "ask\022\240\001\n\023ListNvmeControllers\022..opi_api.st"
  "orage.v1.ListNvmeControllersRequest\032/.op"
  "i_api.storage.v1.ListNvmeControllersResp"
  "onse\"(\202\323\344\223\002\031\022\027/v1/{parent=subsystems}\332A\006"
  "parent\022\222\001\n\021GetNvmeController\022,.opi_api.s"
  "torage.v1.GetNvmeControllerRequest\032\".opi"
  "_api.storage.v1.NvmeController\"+\202\323\344\223\002\036\022\034"
  "/v1/{name=NvmeControllers/*}\332A\004name\022\251\001\n\023"
  "StatsNvmeController\022..opi_api.storage.v1"
  ".StatsNvmeControllerRequest\032/.opi_api.st"
  "orage.v1.StatsNvmeControllerResponse\"1\202\323"
  "\344\223\002$\022\"/v1/{name=NvmeControllers/*}:stats"
  "\332A\004name\022\260\001\n\023CreateNvmeNamespace\022..opi_ap"
  "i.storage.v1.CreateNvmeNamespaceRequest\032"
  "!.opi_api.storage.v1.NvmeNamespace\"F\202\323\344\223"
  "\002\035\"\013/v1/volumes:\016nvme_namespace\332A nvme_n"
  "amespace,nvme_namespace_id\022\211\001\n\023DeleteNvm"
  "eNamespace\022..opi_api.storage.v1.DeleteNv"
  "meNamespaceRequest\032\026.google.protobuf.Emp"
  "ty\"*\202\323\344\223\002\035*\033/v1/{name=NvmeNamespaces/*}\332"
  "A\004name\022\303\001\n\023UpdateNvmeNamespace\022..opi_api"
  ".storage.v1.UpdateNvmeNamespaceRequest\032!"
  ".opi_api.storage.v1.NvmeNamespace\"Y\202\323\344\223\002"
  "62$/v1/{nvme_namespace.name=subsystems}:"
  "\016nvme_namespace\332A\032nvme_namespace,update_"
  "mask\022\235\001\n\022ListNvmeNamespaces\022-.opi_api.st"
  "orage.v1.ListNvmeNamespacesRequest\032..opi"
  "_api.storage.v1.ListNvmeNamespacesRespon"
  "se\"(\202\323\344\223\002\031\022\027/v1/{parent=subsystems}\332A\006pa"
  "rent\022\216\001\n\020GetNvmeNamespace\022+.opi_api.stor"
  "age.v1.GetNvmeNamespaceRequest\032!.opi_api"
  ".storage.v1.NvmeNamespace\"*\202\323\344\223\002\035\022\033/v1/{"
  "name=NvmeNamespaces/*}\332A\004name\022\245\001\n\022StatsN"
  "vmeNamespace\022-.opi_api.storage.v1.StatsN"
  "vmeNamespaceRequest\032..opi_api.storage.v1"
  ".StatsNvmeNamespaceResponse\"0\202\323\344\223\002#\022!/v1"
  "/{name=NvmeNamespaces/*}:stats\332A\004nameBd\n"
  "\022opi_api.storage.v1B\025FrontendNvmePciePro"
  "toP\001Z5github.com/opiproject/opi-api/stor"
  "age/v1alpha1/gen/gob\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps[8] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2fclient_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ffield_5fmask_2eproto,
  &::descriptor_table_opicommon_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_frontend_5fnvme_5fpcie_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto = {
  false, false, 8067, descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto, "frontend_nvme_pcie.proto", 
  &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once, descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps, 8, 33,
  schemas, file_default_instances, TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets,
  file_level_metadata_frontend_5fnvme_5fpcie_2eproto, file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto, file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter() {
  return &descriptor_table_frontend_5fnvme_5fpcie_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_frontend_5fnvme_5fpcie_2eproto(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeNamespacePciState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[0];
}
bool NvmeNamespacePciState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeNamespacePciOperState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[1];
}
bool NvmeNamespacePciOperState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NvmeSubsystem::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeSubsystemSpec& spec(const NvmeSubsystem* msg);
  static const ::opi_api::storage::v1::NvmeSubsystemStatus& status(const NvmeSubsystem* msg);
};

const ::opi_api::storage::v1::NvmeSubsystemSpec&
NvmeSubsystem::_Internal::spec(const NvmeSubsystem* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NvmeSubsystemStatus&
NvmeSubsystem::_Internal::status(const NvmeSubsystem* msg) {
  return *msg->status_;
}
NvmeSubsystem::NvmeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeSubsystem)
}
NvmeSubsystem::NvmeSubsystem(const NvmeSubsystem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NvmeSubsystemSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NvmeSubsystemStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeSubsystem)
}

inline void NvmeSubsystem::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NvmeSubsystem::~NvmeSubsystem() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeSubsystem)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeSubsystem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NvmeSubsystem::ArenaDtor(void* object) {
  NvmeSubsystem* _this = reinterpret_cast< NvmeSubsystem* >(object);
  (void)_this;
}
void NvmeSubsystem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeSubsystem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeSubsystem::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeSubsystem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeSubsystem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystem.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeSubsystemStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeSubsystem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeSubsystem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NvmeSubsystemStatus status = 3;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeSubsystem)
  return target;
}

size_t NvmeSubsystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeSubsystem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NvmeSubsystemStatus status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeSubsystem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeSubsystem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeSubsystem::GetClassData() const { return &_class_data_; }

void NvmeSubsystem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeSubsystem *>(to)->MergeFrom(
      static_cast<const NvmeSubsystem &>(from));
}


void NvmeSubsystem::MergeFrom(const NvmeSubsystem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeSubsystem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NvmeSubsystemSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NvmeSubsystemStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeSubsystem::CopyFrom(const NvmeSubsystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeSubsystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeSubsystem::IsInitialized() const {
  return true;
}

void NvmeSubsystem::InternalSwap(NvmeSubsystem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeSubsystem, status_)
      + sizeof(NvmeSubsystem::status_)
      - PROTOBUF_FIELD_OFFSET(NvmeSubsystem, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeSubsystem::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[0]);
}

// ===================================================================

class NvmeSubsystemSpec::_Internal {
 public:
};

NvmeSubsystemSpec::NvmeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeSubsystemSpec)
}
NvmeSubsystemSpec::NvmeSubsystemSpec(const NvmeSubsystemSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nqn().empty()) {
    nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nqn(), 
      GetArenaForAllocation());
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial_number(), 
      GetArenaForAllocation());
  }
  model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_number().empty()) {
    model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_number(), 
      GetArenaForAllocation());
  }
  max_namespaces_ = from.max_namespaces_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeSubsystemSpec)
}

inline void NvmeSubsystemSpec::SharedCtor() {
nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
max_namespaces_ = int64_t{0};
}

NvmeSubsystemSpec::~NvmeSubsystemSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeSubsystemSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeSubsystemSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nqn_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NvmeSubsystemSpec::ArenaDtor(void* object) {
  NvmeSubsystemSpec* _this = reinterpret_cast< NvmeSubsystemSpec* >(object);
  (void)_this;
}
void NvmeSubsystemSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeSubsystemSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeSubsystemSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nqn_.ClearToEmpty();
  serial_number_.ClearToEmpty();
  model_number_.ClearToEmpty();
  max_namespaces_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeSubsystemSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string nqn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nqn();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemSpec.nqn"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemSpec.serial_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemSpec.model_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_namespaces = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeSubsystemSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string nqn = 1;
  if (!this->_internal_nqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nqn().data(), static_cast<int>(this->_internal_nqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemSpec.nqn");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nqn(), target);
  }

  // string serial_number = 2;
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemSpec.serial_number");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_serial_number(), target);
  }

  // string model_number = 3;
  if (!this->_internal_model_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_number().data(), static_cast<int>(this->_internal_model_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemSpec.model_number");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_number(), target);
  }

  // int64 max_namespaces = 4;
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_max_namespaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeSubsystemSpec)
  return target;
}

size_t NvmeSubsystemSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeSubsystemSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nqn = 1;
  if (!this->_internal_nqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nqn());
  }

  // string serial_number = 2;
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // string model_number = 3;
  if (!this->_internal_model_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_number());
  }

  // int64 max_namespaces = 4;
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeSubsystemSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeSubsystemSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeSubsystemSpec::GetClassData() const { return &_class_data_; }

void NvmeSubsystemSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeSubsystemSpec *>(to)->MergeFrom(
      static_cast<const NvmeSubsystemSpec &>(from));
}


void NvmeSubsystemSpec::MergeFrom(const NvmeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeSubsystemSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nqn().empty()) {
    _internal_set_nqn(from._internal_nqn());
  }
  if (!from._internal_serial_number().empty()) {
    _internal_set_serial_number(from._internal_serial_number());
  }
  if (!from._internal_model_number().empty()) {
    _internal_set_model_number(from._internal_model_number());
  }
  if (from._internal_max_namespaces() != 0) {
    _internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeSubsystemSpec::CopyFrom(const NvmeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeSubsystemSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeSubsystemSpec::IsInitialized() const {
  return true;
}

void NvmeSubsystemSpec::InternalSwap(NvmeSubsystemSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nqn_, lhs_arena,
      &other->nqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_number_, lhs_arena,
      &other->serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_number_, lhs_arena,
      &other->model_number_, rhs_arena
  );
  swap(max_namespaces_, other->max_namespaces_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeSubsystemSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[1]);
}

// ===================================================================

class NvmeSubsystemStatus::_Internal {
 public:
};

NvmeSubsystemStatus::NvmeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeSubsystemStatus)
}
NvmeSubsystemStatus::NvmeSubsystemStatus(const NvmeSubsystemStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_revision().empty()) {
    firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_firmware_revision(), 
      GetArenaForAllocation());
  }
  fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fru_guid().empty()) {
    fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_fru_guid(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeSubsystemStatus)
}

inline void NvmeSubsystemStatus::SharedCtor() {
firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeSubsystemStatus::~NvmeSubsystemStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeSubsystemStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeSubsystemStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  firmware_revision_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fru_guid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NvmeSubsystemStatus::ArenaDtor(void* object) {
  NvmeSubsystemStatus* _this = reinterpret_cast< NvmeSubsystemStatus* >(object);
  (void)_this;
}
void NvmeSubsystemStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeSubsystemStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeSubsystemStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  firmware_revision_.ClearToEmpty();
  fru_guid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeSubsystemStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string firmware_revision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firmware_revision();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes fru_guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fru_guid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeSubsystemStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string firmware_revision = 1;
  if (!this->_internal_firmware_revision().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_revision().data(), static_cast<int>(this->_internal_firmware_revision().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firmware_revision(), target);
  }

  // bytes fru_guid = 2;
  if (!this->_internal_fru_guid().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fru_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeSubsystemStatus)
  return target;
}

size_t NvmeSubsystemStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeSubsystemStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string firmware_revision = 1;
  if (!this->_internal_firmware_revision().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_revision());
  }

  // bytes fru_guid = 2;
  if (!this->_internal_fru_guid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fru_guid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeSubsystemStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeSubsystemStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeSubsystemStatus::GetClassData() const { return &_class_data_; }

void NvmeSubsystemStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeSubsystemStatus *>(to)->MergeFrom(
      static_cast<const NvmeSubsystemStatus &>(from));
}


void NvmeSubsystemStatus::MergeFrom(const NvmeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeSubsystemStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_firmware_revision().empty()) {
    _internal_set_firmware_revision(from._internal_firmware_revision());
  }
  if (!from._internal_fru_guid().empty()) {
    _internal_set_fru_guid(from._internal_fru_guid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeSubsystemStatus::CopyFrom(const NvmeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeSubsystemStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeSubsystemStatus::IsInitialized() const {
  return true;
}

void NvmeSubsystemStatus::InternalSwap(NvmeSubsystemStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &firmware_revision_, lhs_arena,
      &other->firmware_revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &fru_guid_, lhs_arena,
      &other->fru_guid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeSubsystemStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[2]);
}

// ===================================================================

class NvmeController::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeControllerSpec& spec(const NvmeController* msg);
  static const ::opi_api::storage::v1::NvmeControllerStatus& status(const NvmeController* msg);
};

const ::opi_api::storage::v1::NvmeControllerSpec&
NvmeController::_Internal::spec(const NvmeController* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NvmeControllerStatus&
NvmeController::_Internal::status(const NvmeController* msg) {
  return *msg->status_;
}
NvmeController::NvmeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeController)
}
NvmeController::NvmeController(const NvmeController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NvmeControllerSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NvmeControllerStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeController)
}

inline void NvmeController::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NvmeController::~NvmeController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeController)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NvmeController::ArenaDtor(void* object) {
  NvmeController* _this = reinterpret_cast< NvmeController* >(object);
  (void)_this;
}
void NvmeController::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeController::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeController::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeController.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeControllerSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeControllerStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeController.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeControllerSpec spec = 2;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NvmeControllerStatus status = 3;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeController)
  return target;
}

size_t NvmeController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.NvmeControllerSpec spec = 2;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NvmeControllerStatus status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeController::GetClassData() const { return &_class_data_; }

void NvmeController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeController *>(to)->MergeFrom(
      static_cast<const NvmeController &>(from));
}


void NvmeController::MergeFrom(const NvmeController& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeController)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NvmeControllerSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NvmeControllerStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeController::CopyFrom(const NvmeController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeController::IsInitialized() const {
  return true;
}

void NvmeController::InternalSwap(NvmeController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeController, status_)
      + sizeof(NvmeController::status_)
      - PROTOBUF_FIELD_OFFSET(NvmeController, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeController::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[3]);
}

// ===================================================================

class NvmeControllerSpec::_Internal {
 public:
  static const ::opi_api::storage::v1::PciEndpoint& pcie_id(const NvmeControllerSpec* msg);
  static const ::opi_api::storage::v1::QosLimit& min_limit(const NvmeControllerSpec* msg);
  static const ::opi_api::storage::v1::QosLimit& max_limit(const NvmeControllerSpec* msg);
};

const ::opi_api::storage::v1::PciEndpoint&
NvmeControllerSpec::_Internal::pcie_id(const NvmeControllerSpec* msg) {
  return *msg->pcie_id_;
}
const ::opi_api::storage::v1::QosLimit&
NvmeControllerSpec::_Internal::min_limit(const NvmeControllerSpec* msg) {
  return *msg->min_limit_;
}
const ::opi_api::storage::v1::QosLimit&
NvmeControllerSpec::_Internal::max_limit(const NvmeControllerSpec* msg) {
  return *msg->max_limit_;
}
void NvmeControllerSpec::clear_pcie_id() {
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
}
void NvmeControllerSpec::clear_min_limit() {
  if (GetArenaForAllocation() == nullptr && min_limit_ != nullptr) {
    delete min_limit_;
  }
  min_limit_ = nullptr;
}
void NvmeControllerSpec::clear_max_limit() {
  if (GetArenaForAllocation() == nullptr && max_limit_ != nullptr) {
    delete max_limit_;
  }
  max_limit_ = nullptr;
}
NvmeControllerSpec::NvmeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeControllerSpec)
}
NvmeControllerSpec::NvmeControllerSpec(const NvmeControllerSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  subsystem_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    subsystem_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subsystem_name_ref().empty()) {
    subsystem_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_subsystem_name_ref(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_pcie_id()) {
    pcie_id_ = new ::opi_api::storage::v1::PciEndpoint(*from.pcie_id_);
  } else {
    pcie_id_ = nullptr;
  }
  if (from._internal_has_min_limit()) {
    min_limit_ = new ::opi_api::storage::v1::QosLimit(*from.min_limit_);
  } else {
    min_limit_ = nullptr;
  }
  if (from._internal_has_max_limit()) {
    max_limit_ = new ::opi_api::storage::v1::QosLimit(*from.max_limit_);
  } else {
    max_limit_ = nullptr;
  }
  ::memcpy(&nvme_controller_id_, &from.nvme_controller_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_namespaces_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeControllerSpec)
}

inline void NvmeControllerSpec::SharedCtor() {
subsystem_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  subsystem_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pcie_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&pcie_id_)) + sizeof(max_namespaces_));
}

NvmeControllerSpec::~NvmeControllerSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeControllerSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeControllerSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  subsystem_name_ref_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pcie_id_;
  if (this != internal_default_instance()) delete min_limit_;
  if (this != internal_default_instance()) delete max_limit_;
}

void NvmeControllerSpec::ArenaDtor(void* object) {
  NvmeControllerSpec* _this = reinterpret_cast< NvmeControllerSpec* >(object);
  (void)_this;
}
void NvmeControllerSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeControllerSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeControllerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeControllerSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subsystem_name_ref_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && min_limit_ != nullptr) {
    delete min_limit_;
  }
  min_limit_ = nullptr;
  if (GetArenaForAllocation() == nullptr && max_limit_ != nullptr) {
    delete max_limit_;
  }
  max_limit_ = nullptr;
  ::memset(&nvme_controller_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_namespaces_) -
      reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_namespaces_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeControllerSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 nvme_controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          nvme_controller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string subsystem_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subsystem_name_ref();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeControllerSpec.subsystem_name_ref"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.PciEndpoint pcie_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pcie_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_nsq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          max_nsq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_ncq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_ncq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sqes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          sqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 cqes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          cqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_namespaces = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.QosLimit min_limit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_min_limit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.QosLimit max_limit = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_max_limit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeControllerSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeControllerSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 nvme_controller_id = 1;
  if (this->_internal_nvme_controller_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_nvme_controller_id(), target);
  }

  // string subsystem_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_subsystem_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subsystem_name_ref().data(), static_cast<int>(this->_internal_subsystem_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeControllerSpec.subsystem_name_ref");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_subsystem_name_ref(), target);
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 3;
  if (this->_internal_has_pcie_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::pcie_id(this), target, stream);
  }

  // int32 max_nsq = 4;
  if (this->_internal_max_nsq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_nsq(), target);
  }

  // int32 max_ncq = 5;
  if (this->_internal_max_ncq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_max_ncq(), target);
  }

  // int32 sqes = 6;
  if (this->_internal_sqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_sqes(), target);
  }

  // int32 cqes = 7;
  if (this->_internal_cqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_cqes(), target);
  }

  // int32 max_namespaces = 8;
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_max_namespaces(), target);
  }

  // .opi_api.storage.v1.QosLimit min_limit = 9;
  if (this->_internal_has_min_limit()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::min_limit(this), target, stream);
  }

  // .opi_api.storage.v1.QosLimit max_limit = 10;
  if (this->_internal_has_max_limit()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::max_limit(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeControllerSpec)
  return target;
}

size_t NvmeControllerSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeControllerSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subsystem_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_subsystem_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subsystem_name_ref());
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 3;
  if (this->_internal_has_pcie_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pcie_id_);
  }

  // .opi_api.storage.v1.QosLimit min_limit = 9;
  if (this->_internal_has_min_limit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *min_limit_);
  }

  // .opi_api.storage.v1.QosLimit max_limit = 10;
  if (this->_internal_has_max_limit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *max_limit_);
  }

  // int32 nvme_controller_id = 1;
  if (this->_internal_nvme_controller_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nvme_controller_id());
  }

  // int32 max_nsq = 4;
  if (this->_internal_max_nsq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_nsq());
  }

  // int32 max_ncq = 5;
  if (this->_internal_max_ncq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_ncq());
  }

  // int32 sqes = 6;
  if (this->_internal_sqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sqes());
  }

  // int32 cqes = 7;
  if (this->_internal_cqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cqes());
  }

  // int32 max_namespaces = 8;
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeControllerSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeControllerSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeControllerSpec::GetClassData() const { return &_class_data_; }

void NvmeControllerSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeControllerSpec *>(to)->MergeFrom(
      static_cast<const NvmeControllerSpec &>(from));
}


void NvmeControllerSpec::MergeFrom(const NvmeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeControllerSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subsystem_name_ref().empty()) {
    _internal_set_subsystem_name_ref(from._internal_subsystem_name_ref());
  }
  if (from._internal_has_pcie_id()) {
    _internal_mutable_pcie_id()->::opi_api::storage::v1::PciEndpoint::MergeFrom(from._internal_pcie_id());
  }
  if (from._internal_has_min_limit()) {
    _internal_mutable_min_limit()->::opi_api::storage::v1::QosLimit::MergeFrom(from._internal_min_limit());
  }
  if (from._internal_has_max_limit()) {
    _internal_mutable_max_limit()->::opi_api::storage::v1::QosLimit::MergeFrom(from._internal_max_limit());
  }
  if (from._internal_nvme_controller_id() != 0) {
    _internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_max_nsq() != 0) {
    _internal_set_max_nsq(from._internal_max_nsq());
  }
  if (from._internal_max_ncq() != 0) {
    _internal_set_max_ncq(from._internal_max_ncq());
  }
  if (from._internal_sqes() != 0) {
    _internal_set_sqes(from._internal_sqes());
  }
  if (from._internal_cqes() != 0) {
    _internal_set_cqes(from._internal_cqes());
  }
  if (from._internal_max_namespaces() != 0) {
    _internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeControllerSpec::CopyFrom(const NvmeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeControllerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeControllerSpec::IsInitialized() const {
  return true;
}

void NvmeControllerSpec::InternalSwap(NvmeControllerSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &subsystem_name_ref_, lhs_arena,
      &other->subsystem_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeControllerSpec, max_namespaces_)
      + sizeof(NvmeControllerSpec::max_namespaces_)
      - PROTOBUF_FIELD_OFFSET(NvmeControllerSpec, pcie_id_)>(
          reinterpret_cast<char*>(&pcie_id_),
          reinterpret_cast<char*>(&other->pcie_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeControllerSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[4]);
}

// ===================================================================

class NvmeControllerStatus::_Internal {
 public:
};

NvmeControllerStatus::NvmeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeControllerStatus)
}
NvmeControllerStatus::NvmeControllerStatus(const NvmeControllerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  active_ = from.active_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeControllerStatus)
}

inline void NvmeControllerStatus::SharedCtor() {
active_ = false;
}

NvmeControllerStatus::~NvmeControllerStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeControllerStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeControllerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NvmeControllerStatus::ArenaDtor(void* object) {
  NvmeControllerStatus* _this = reinterpret_cast< NvmeControllerStatus* >(object);
  (void)_this;
}
void NvmeControllerStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeControllerStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeControllerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeControllerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  active_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeControllerStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeControllerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeControllerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool active = 1;
  if (this->_internal_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeControllerStatus)
  return target;
}

size_t NvmeControllerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeControllerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool active = 1;
  if (this->_internal_active() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeControllerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeControllerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeControllerStatus::GetClassData() const { return &_class_data_; }

void NvmeControllerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeControllerStatus *>(to)->MergeFrom(
      static_cast<const NvmeControllerStatus &>(from));
}


void NvmeControllerStatus::MergeFrom(const NvmeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeControllerStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_active() != 0) {
    _internal_set_active(from._internal_active());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeControllerStatus::CopyFrom(const NvmeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeControllerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeControllerStatus::IsInitialized() const {
  return true;
}

void NvmeControllerStatus::InternalSwap(NvmeControllerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(active_, other->active_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeControllerStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[5]);
}

// ===================================================================

class NvmeNamespace::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeNamespaceSpec& spec(const NvmeNamespace* msg);
  static const ::opi_api::storage::v1::NvmeNamespaceStatus& status(const NvmeNamespace* msg);
};

const ::opi_api::storage::v1::NvmeNamespaceSpec&
NvmeNamespace::_Internal::spec(const NvmeNamespace* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NvmeNamespaceStatus&
NvmeNamespace::_Internal::status(const NvmeNamespace* msg) {
  return *msg->status_;
}
NvmeNamespace::NvmeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeNamespace)
}
NvmeNamespace::NvmeNamespace(const NvmeNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NvmeNamespaceSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NvmeNamespaceStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeNamespace)
}

inline void NvmeNamespace::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NvmeNamespace::~NvmeNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeNamespace)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NvmeNamespace::ArenaDtor(void* object) {
  NvmeNamespace* _this = reinterpret_cast< NvmeNamespace* >(object);
  (void)_this;
}
void NvmeNamespace::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeNamespace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeNamespace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespace.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespaceStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespace.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NvmeNamespaceStatus status = 3;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeNamespace)
  return target;
}

size_t NvmeNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NvmeNamespaceStatus status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeNamespace::GetClassData() const { return &_class_data_; }

void NvmeNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeNamespace *>(to)->MergeFrom(
      static_cast<const NvmeNamespace &>(from));
}


void NvmeNamespace::MergeFrom(const NvmeNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NvmeNamespaceSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NvmeNamespaceStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeNamespace::CopyFrom(const NvmeNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeNamespace::IsInitialized() const {
  return true;
}

void NvmeNamespace::InternalSwap(NvmeNamespace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeNamespace, status_)
      + sizeof(NvmeNamespace::status_)
      - PROTOBUF_FIELD_OFFSET(NvmeNamespace, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeNamespace::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[6]);
}

// ===================================================================

class NvmeNamespaceSpec::_Internal {
 public:
  static const ::opi_api::common::v1::Uuid& uuid(const NvmeNamespaceSpec* msg);
};

const ::opi_api::common::v1::Uuid&
NvmeNamespaceSpec::_Internal::uuid(const NvmeNamespaceSpec* msg) {
  return *msg->uuid_;
}
void NvmeNamespaceSpec::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
}
NvmeNamespaceSpec::NvmeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeNamespaceSpec)
}
NvmeNamespaceSpec::NvmeNamespaceSpec(const NvmeNamespaceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  subsystem_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    subsystem_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subsystem_name_ref().empty()) {
    subsystem_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_subsystem_name_ref(), 
      GetArenaForAllocation());
  }
  nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nguid(), 
      GetArenaForAllocation());
  }
  volume_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    volume_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_volume_name_ref().empty()) {
    volume_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_volume_name_ref(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_uuid()) {
    uuid_ = new ::opi_api::common::v1::Uuid(*from.uuid_);
  } else {
    uuid_ = nullptr;
  }
  ::memcpy(&eui64_, &from.eui64_,
    static_cast<size_t>(reinterpret_cast<char*>(&host_nsid_) -
    reinterpret_cast<char*>(&eui64_)) + sizeof(host_nsid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeNamespaceSpec)
}

inline void NvmeNamespaceSpec::SharedCtor() {
subsystem_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  subsystem_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
volume_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  volume_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&uuid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&host_nsid_) -
    reinterpret_cast<char*>(&uuid_)) + sizeof(host_nsid_));
}

NvmeNamespaceSpec::~NvmeNamespaceSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeNamespaceSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeNamespaceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  subsystem_name_ref_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nguid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  volume_name_ref_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete uuid_;
}

void NvmeNamespaceSpec::ArenaDtor(void* object) {
  NvmeNamespaceSpec* _this = reinterpret_cast< NvmeNamespaceSpec* >(object);
  (void)_this;
}
void NvmeNamespaceSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeNamespaceSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeNamespaceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subsystem_name_ref_.ClearToEmpty();
  nguid_.ClearToEmpty();
  volume_name_ref_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
  ::memset(&eui64_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&host_nsid_) -
      reinterpret_cast<char*>(&eui64_)) + sizeof(host_nsid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeNamespaceSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subsystem_name_ref = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subsystem_name_ref();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespaceSpec.subsystem_name_ref"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 host_nsid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          host_nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nguid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespaceSpec.nguid"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_volume_name_ref();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeNamespaceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subsystem_name_ref = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_subsystem_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subsystem_name_ref().data(), static_cast<int>(this->_internal_subsystem_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespaceSpec.subsystem_name_ref");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_subsystem_name_ref(), target);
  }

  // int32 host_nsid = 2;
  if (this->_internal_host_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_host_nsid(), target);
  }

  // string nguid = 3;
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespaceSpec.nguid");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nguid(), target);
  }

  // int64 eui64 = 4;
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 5;
  if (this->_internal_has_uuid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::uuid(this), target, stream);
  }

  // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_volume_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_volume_name_ref().data(), static_cast<int>(this->_internal_volume_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_volume_name_ref(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeNamespaceSpec)
  return target;
}

size_t NvmeNamespaceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeNamespaceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subsystem_name_ref = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_subsystem_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subsystem_name_ref());
  }

  // string nguid = 3;
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_volume_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_volume_name_ref());
  }

  // .opi_api.common.v1.Uuid uuid = 5;
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *uuid_);
  }

  // int64 eui64 = 4;
  if (this->_internal_eui64() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 host_nsid = 2;
  if (this->_internal_host_nsid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_host_nsid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeNamespaceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeNamespaceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeNamespaceSpec::GetClassData() const { return &_class_data_; }

void NvmeNamespaceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeNamespaceSpec *>(to)->MergeFrom(
      static_cast<const NvmeNamespaceSpec &>(from));
}


void NvmeNamespaceSpec::MergeFrom(const NvmeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeNamespaceSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subsystem_name_ref().empty()) {
    _internal_set_subsystem_name_ref(from._internal_subsystem_name_ref());
  }
  if (!from._internal_nguid().empty()) {
    _internal_set_nguid(from._internal_nguid());
  }
  if (!from._internal_volume_name_ref().empty()) {
    _internal_set_volume_name_ref(from._internal_volume_name_ref());
  }
  if (from._internal_has_uuid()) {
    _internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(from._internal_uuid());
  }
  if (from._internal_eui64() != 0) {
    _internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_host_nsid() != 0) {
    _internal_set_host_nsid(from._internal_host_nsid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeNamespaceSpec::CopyFrom(const NvmeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeNamespaceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeNamespaceSpec::IsInitialized() const {
  return true;
}

void NvmeNamespaceSpec::InternalSwap(NvmeNamespaceSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &subsystem_name_ref_, lhs_arena,
      &other->subsystem_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nguid_, lhs_arena,
      &other->nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &volume_name_ref_, lhs_arena,
      &other->volume_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeNamespaceSpec, host_nsid_)
      + sizeof(NvmeNamespaceSpec::host_nsid_)
      - PROTOBUF_FIELD_OFFSET(NvmeNamespaceSpec, uuid_)>(
          reinterpret_cast<char*>(&uuid_),
          reinterpret_cast<char*>(&other->uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeNamespaceSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[7]);
}

// ===================================================================

class NvmeNamespaceStatus::_Internal {
 public:
};

NvmeNamespaceStatus::NvmeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeNamespaceStatus)
}
NvmeNamespaceStatus::NvmeNamespaceStatus(const NvmeNamespaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&pci_state_, &from.pci_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&pci_oper_state_) -
    reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeNamespaceStatus)
}

inline void NvmeNamespaceStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pci_state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pci_oper_state_) -
    reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
}

NvmeNamespaceStatus::~NvmeNamespaceStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeNamespaceStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NvmeNamespaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NvmeNamespaceStatus::ArenaDtor(void* object) {
  NvmeNamespaceStatus* _this = reinterpret_cast< NvmeNamespaceStatus* >(object);
  (void)_this;
}
void NvmeNamespaceStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NvmeNamespaceStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NvmeNamespaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&pci_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pci_oper_state_) -
      reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeNamespaceStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_state(static_cast<::opi_api::storage::v1::NvmeNamespacePciState>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_oper_state(static_cast<::opi_api::storage::v1::NvmeNamespacePciOperState>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeNamespaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1;
  if (this->_internal_pci_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pci_state(), target);
  }

  // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2;
  if (this->_internal_pci_oper_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_pci_oper_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeNamespaceStatus)
  return target;
}

size_t NvmeNamespaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeNamespaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1;
  if (this->_internal_pci_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pci_state());
  }

  // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2;
  if (this->_internal_pci_oper_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pci_oper_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeNamespaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NvmeNamespaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeNamespaceStatus::GetClassData() const { return &_class_data_; }

void NvmeNamespaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NvmeNamespaceStatus *>(to)->MergeFrom(
      static_cast<const NvmeNamespaceStatus &>(from));
}


void NvmeNamespaceStatus::MergeFrom(const NvmeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeNamespaceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pci_state() != 0) {
    _internal_set_pci_state(from._internal_pci_state());
  }
  if (from._internal_pci_oper_state() != 0) {
    _internal_set_pci_oper_state(from._internal_pci_oper_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeNamespaceStatus::CopyFrom(const NvmeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeNamespaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeNamespaceStatus::IsInitialized() const {
  return true;
}

void NvmeNamespaceStatus::InternalSwap(NvmeNamespaceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeNamespaceStatus, pci_oper_state_)
      + sizeof(NvmeNamespaceStatus::pci_oper_state_)
      - PROTOBUF_FIELD_OFFSET(NvmeNamespaceStatus, pci_state_)>(
          reinterpret_cast<char*>(&pci_state_),
          reinterpret_cast<char*>(&other->pci_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeNamespaceStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[8]);
}

// ===================================================================

class CreateNvmeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystem(const CreateNvmeSubsystemRequest* msg);
};

const ::opi_api::storage::v1::NvmeSubsystem&
CreateNvmeSubsystemRequest::_Internal::nvme_subsystem(const CreateNvmeSubsystemRequest* msg) {
  return *msg->nvme_subsystem_;
}
CreateNvmeSubsystemRequest::CreateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeSubsystemRequest)
}
CreateNvmeSubsystemRequest::CreateNvmeSubsystemRequest(const CreateNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nvme_subsystem_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nvme_subsystem_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_subsystem_id().empty()) {
    nvme_subsystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nvme_subsystem_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_nvme_subsystem()) {
    nvme_subsystem_ = new ::opi_api::storage::v1::NvmeSubsystem(*from.nvme_subsystem_);
  } else {
    nvme_subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeSubsystemRequest)
}

inline void CreateNvmeSubsystemRequest::SharedCtor() {
nvme_subsystem_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nvme_subsystem_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nvme_subsystem_ = nullptr;
}

CreateNvmeSubsystemRequest::~CreateNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nvme_subsystem_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete nvme_subsystem_;
}

void CreateNvmeSubsystemRequest::ArenaDtor(void* object) {
  CreateNvmeSubsystemRequest* _this = reinterpret_cast< CreateNvmeSubsystemRequest* >(object);
  (void)_this;
}
void CreateNvmeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateNvmeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nvme_subsystem_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && nvme_subsystem_ != nullptr) {
    delete nvme_subsystem_;
  }
  nvme_subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_subsystem_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_subsystem_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::nvme_subsystem(this), target, stream);
  }

  // string nvme_subsystem_id = 2;
  if (!this->_internal_nvme_subsystem_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_subsystem_id().data(), static_cast<int>(this->_internal_nvme_subsystem_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_subsystem_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  return target;
}

size_t CreateNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_subsystem_id = 2;
  if (!this->_internal_nvme_subsystem_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_subsystem_id());
  }

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nvme_subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }

void CreateNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateNvmeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const CreateNvmeSubsystemRequest &>(from));
}


void CreateNvmeSubsystemRequest::MergeFrom(const CreateNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_subsystem_id().empty()) {
    _internal_set_nvme_subsystem_id(from._internal_nvme_subsystem_id());
  }
  if (from._internal_has_nvme_subsystem()) {
    _internal_mutable_nvme_subsystem()->::opi_api::storage::v1::NvmeSubsystem::MergeFrom(from._internal_nvme_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeSubsystemRequest::CopyFrom(const CreateNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void CreateNvmeSubsystemRequest::InternalSwap(CreateNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nvme_subsystem_id_, lhs_arena,
      &other->nvme_subsystem_id_, rhs_arena
  );
  swap(nvme_subsystem_, other->nvme_subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[9]);
}

// ===================================================================

class DeleteNvmeSubsystemRequest::_Internal {
 public:
};

DeleteNvmeSubsystemRequest::DeleteNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
}
DeleteNvmeSubsystemRequest::DeleteNvmeSubsystemRequest(const DeleteNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  allow_missing_ = from.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
}

inline void DeleteNvmeSubsystemRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
allow_missing_ = false;
}

DeleteNvmeSubsystemRequest::~DeleteNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DeleteNvmeSubsystemRequest::ArenaDtor(void* object) {
  DeleteNvmeSubsystemRequest* _this = reinterpret_cast< DeleteNvmeSubsystemRequest* >(object);
  (void)_this;
}
void DeleteNvmeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNvmeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeSubsystemRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeSubsystemRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2;
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  return target;
}

size_t DeleteNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2;
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }

void DeleteNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNvmeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const DeleteNvmeSubsystemRequest &>(from));
}


void DeleteNvmeSubsystemRequest::MergeFrom(const DeleteNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _internal_set_allow_missing(from._internal_allow_missing());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeSubsystemRequest::CopyFrom(const DeleteNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeSubsystemRequest::InternalSwap(DeleteNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(allow_missing_, other->allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[10]);
}

// ===================================================================

class UpdateNvmeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystem(const UpdateNvmeSubsystemRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeSubsystemRequest* msg);
};

const ::opi_api::storage::v1::NvmeSubsystem&
UpdateNvmeSubsystemRequest::_Internal::nvme_subsystem(const UpdateNvmeSubsystemRequest* msg) {
  return *msg->nvme_subsystem_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeSubsystemRequest::_Internal::update_mask(const UpdateNvmeSubsystemRequest* msg) {
  return *msg->update_mask_;
}
void UpdateNvmeSubsystemRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && update_mask_ != nullptr) {
    delete update_mask_;
  }
  update_mask_ = nullptr;
}
UpdateNvmeSubsystemRequest::UpdateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
}
UpdateNvmeSubsystemRequest::UpdateNvmeSubsystemRequest(const UpdateNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_subsystem()) {
    nvme_subsystem_ = new ::opi_api::storage::v1::NvmeSubsystem(*from.nvme_subsystem_);
  } else {
    nvme_subsystem_ = nullptr;
  }
  if (from._internal_has_update_mask()) {
    update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from.update_mask_);
  } else {
    update_mask_ = nullptr;
  }
  allow_missing_ = from.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
}

inline void UpdateNvmeSubsystemRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&nvme_subsystem_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_missing_) -
    reinterpret_cast<char*>(&nvme_subsystem_)) + sizeof(allow_missing_));
}

UpdateNvmeSubsystemRequest::~UpdateNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete nvme_subsystem_;
  if (this != internal_default_instance()) delete update_mask_;
}

void UpdateNvmeSubsystemRequest::ArenaDtor(void* object) {
  UpdateNvmeSubsystemRequest* _this = reinterpret_cast< UpdateNvmeSubsystemRequest* >(object);
  (void)_this;
}
void UpdateNvmeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNvmeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && nvme_subsystem_ != nullptr) {
    delete nvme_subsystem_;
  }
  nvme_subsystem_ = nullptr;
  if (GetArenaForAllocation() == nullptr && update_mask_ != nullptr) {
    delete update_mask_;
  }
  update_mask_ = nullptr;
  allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1;
  if (this->_internal_has_nvme_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::nvme_subsystem(this), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2;
  if (this->_internal_has_update_mask()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::update_mask(this), target, stream);
  }

  // bool allow_missing = 3;
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  return target;
}

size_t UpdateNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1;
  if (this->_internal_has_nvme_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nvme_subsystem_);
  }

  // .google.protobuf.FieldMask update_mask = 2;
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *update_mask_);
  }

  // bool allow_missing = 3;
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }

void UpdateNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNvmeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const UpdateNvmeSubsystemRequest &>(from));
}


void UpdateNvmeSubsystemRequest::MergeFrom(const UpdateNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_subsystem()) {
    _internal_mutable_nvme_subsystem()->::opi_api::storage::v1::NvmeSubsystem::MergeFrom(from._internal_nvme_subsystem());
  }
  if (from._internal_has_update_mask()) {
    _internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _internal_set_allow_missing(from._internal_allow_missing());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeSubsystemRequest::CopyFrom(const UpdateNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeSubsystemRequest::InternalSwap(UpdateNvmeSubsystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeSubsystemRequest, allow_missing_)
      + sizeof(UpdateNvmeSubsystemRequest::allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeSubsystemRequest, nvme_subsystem_)>(
          reinterpret_cast<char*>(&nvme_subsystem_),
          reinterpret_cast<char*>(&other->nvme_subsystem_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[11]);
}

// ===================================================================

class ListNvmeSubsystemsRequest::_Internal {
 public:
};

ListNvmeSubsystemsRequest::ListNvmeSubsystemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeSubsystemsRequest)
}
ListNvmeSubsystemsRequest::ListNvmeSubsystemsRequest(const ListNvmeSubsystemsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_parent(), 
      GetArenaForAllocation());
  }
  page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_page_token(), 
      GetArenaForAllocation());
  }
  page_size_ = from.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeSubsystemsRequest)
}

inline void ListNvmeSubsystemsRequest::SharedCtor() {
parent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_size_ = 0;
}

ListNvmeSubsystemsRequest::~ListNvmeSubsystemsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNvmeSubsystemsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  parent_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  page_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ListNvmeSubsystemsRequest::ArenaDtor(void* object) {
  ListNvmeSubsystemsRequest* _this = reinterpret_cast< ListNvmeSubsystemsRequest* >(object);
  (void)_this;
}
void ListNvmeSubsystemsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNvmeSubsystemsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNvmeSubsystemsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parent_.ClearToEmpty();
  page_token_.ClearToEmpty();
  page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeSubsystemsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeSubsystemsRequest.parent"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeSubsystemsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeSubsystemsRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2;
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3;
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  return target;
}

size_t ListNvmeSubsystemsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3;
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2;
  if (this->_internal_page_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeSubsystemsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNvmeSubsystemsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeSubsystemsRequest::GetClassData() const { return &_class_data_; }

void ListNvmeSubsystemsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNvmeSubsystemsRequest *>(to)->MergeFrom(
      static_cast<const ListNvmeSubsystemsRequest &>(from));
}


void ListNvmeSubsystemsRequest::MergeFrom(const ListNvmeSubsystemsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _internal_set_page_size(from._internal_page_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeSubsystemsRequest::CopyFrom(const ListNvmeSubsystemsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeSubsystemsRequest::IsInitialized() const {
  return true;
}

void ListNvmeSubsystemsRequest::InternalSwap(ListNvmeSubsystemsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &parent_, lhs_arena,
      &other->parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &page_token_, lhs_arena,
      &other->page_token_, rhs_arena
  );
  swap(page_size_, other->page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeSubsystemsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[12]);
}

// ===================================================================

class ListNvmeSubsystemsResponse::_Internal {
 public:
};

ListNvmeSubsystemsResponse::ListNvmeSubsystemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nvme_subsystems_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeSubsystemsResponse)
}
ListNvmeSubsystemsResponse::ListNvmeSubsystemsResponse(const ListNvmeSubsystemsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nvme_subsystems_(from.nvme_subsystems_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  next_page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_next_page_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeSubsystemsResponse)
}

inline void ListNvmeSubsystemsResponse::SharedCtor() {
next_page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeSubsystemsResponse::~ListNvmeSubsystemsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNvmeSubsystemsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  next_page_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ListNvmeSubsystemsResponse::ArenaDtor(void* object) {
  ListNvmeSubsystemsResponse* _this = reinterpret_cast< ListNvmeSubsystemsResponse* >(object);
  (void)_this;
}
void ListNvmeSubsystemsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNvmeSubsystemsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNvmeSubsystemsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nvme_subsystems_.Clear();
  next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeSubsystemsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_subsystems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeSubsystemsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nvme_subsystems_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_nvme_subsystems(i), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  return target;
}

size_t ListNvmeSubsystemsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
  total_size += 1UL * this->_internal_nvme_subsystems_size();
  for (const auto& msg : this->nvme_subsystems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeSubsystemsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNvmeSubsystemsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeSubsystemsResponse::GetClassData() const { return &_class_data_; }

void ListNvmeSubsystemsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNvmeSubsystemsResponse *>(to)->MergeFrom(
      static_cast<const ListNvmeSubsystemsResponse &>(from));
}


void ListNvmeSubsystemsResponse::MergeFrom(const ListNvmeSubsystemsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nvme_subsystems_.MergeFrom(from.nvme_subsystems_);
  if (!from._internal_next_page_token().empty()) {
    _internal_set_next_page_token(from._internal_next_page_token());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeSubsystemsResponse::CopyFrom(const ListNvmeSubsystemsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeSubsystemsResponse::IsInitialized() const {
  return true;
}

void ListNvmeSubsystemsResponse::InternalSwap(ListNvmeSubsystemsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nvme_subsystems_.InternalSwap(&other->nvme_subsystems_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &next_page_token_, lhs_arena,
      &other->next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeSubsystemsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[13]);
}

// ===================================================================

class GetNvmeSubsystemRequest::_Internal {
 public:
};

GetNvmeSubsystemRequest::GetNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeSubsystemRequest)
}
GetNvmeSubsystemRequest::GetNvmeSubsystemRequest(const GetNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeSubsystemRequest)
}

inline void GetNvmeSubsystemRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeSubsystemRequest::~GetNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetNvmeSubsystemRequest::ArenaDtor(void* object) {
  GetNvmeSubsystemRequest* _this = reinterpret_cast< GetNvmeSubsystemRequest* >(object);
  (void)_this;
}
void GetNvmeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetNvmeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeSubsystemRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeSubsystemRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeSubsystemRequest)
  return target;
}

size_t GetNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }

void GetNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetNvmeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const GetNvmeSubsystemRequest &>(from));
}


void GetNvmeSubsystemRequest::MergeFrom(const GetNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeSubsystemRequest::CopyFrom(const GetNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void GetNvmeSubsystemRequest::InternalSwap(GetNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[14]);
}

// ===================================================================

class StatsNvmeSubsystemRequest::_Internal {
 public:
};

StatsNvmeSubsystemRequest::StatsNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeSubsystemRequest)
}
StatsNvmeSubsystemRequest::StatsNvmeSubsystemRequest(const StatsNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeSubsystemRequest)
}

inline void StatsNvmeSubsystemRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeSubsystemRequest::~StatsNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StatsNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StatsNvmeSubsystemRequest::ArenaDtor(void* object) {
  StatsNvmeSubsystemRequest* _this = reinterpret_cast< StatsNvmeSubsystemRequest* >(object);
  (void)_this;
}
void StatsNvmeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatsNvmeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeSubsystemRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeSubsystemRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  return target;
}

size_t StatsNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StatsNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }

void StatsNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StatsNvmeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const StatsNvmeSubsystemRequest &>(from));
}


void StatsNvmeSubsystemRequest::MergeFrom(const StatsNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeSubsystemRequest::CopyFrom(const StatsNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void StatsNvmeSubsystemRequest::InternalSwap(StatsNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[15]);
}

// ===================================================================

class StatsNvmeSubsystemResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeSubsystemResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeSubsystemResponse::_Internal::stats(const StatsNvmeSubsystemResponse* msg) {
  return *msg->stats_;
}
void StatsNvmeSubsystemResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
StatsNvmeSubsystemResponse::StatsNvmeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeSubsystemResponse)
}
StatsNvmeSubsystemResponse::StatsNvmeSubsystemResponse(const StatsNvmeSubsystemResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    stats_ = new ::opi_api::storage::v1::VolumeStats(*from.stats_);
  } else {
    stats_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeSubsystemResponse)
}

inline void StatsNvmeSubsystemResponse::SharedCtor() {
stats_ = nullptr;
}

StatsNvmeSubsystemResponse::~StatsNvmeSubsystemResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StatsNvmeSubsystemResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete stats_;
}

void StatsNvmeSubsystemResponse::ArenaDtor(void* object) {
  StatsNvmeSubsystemResponse* _this = reinterpret_cast< StatsNvmeSubsystemResponse* >(object);
  (void)_this;
}
void StatsNvmeSubsystemResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatsNvmeSubsystemResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsNvmeSubsystemResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeSubsystemResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeSubsystemResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::stats(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  return target;
}

size_t StatsNvmeSubsystemResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeSubsystemResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StatsNvmeSubsystemResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeSubsystemResponse::GetClassData() const { return &_class_data_; }

void StatsNvmeSubsystemResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StatsNvmeSubsystemResponse *>(to)->MergeFrom(
      static_cast<const StatsNvmeSubsystemResponse &>(from));
}


void StatsNvmeSubsystemResponse::MergeFrom(const StatsNvmeSubsystemResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(from._internal_stats());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeSubsystemResponse::CopyFrom(const StatsNvmeSubsystemResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeSubsystemResponse::IsInitialized() const {
  return true;
}

void StatsNvmeSubsystemResponse::InternalSwap(StatsNvmeSubsystemResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(stats_, other->stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeSubsystemResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[16]);
}

// ===================================================================

class CreateNvmeControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeController& nvme_controller(const CreateNvmeControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeController&
CreateNvmeControllerRequest::_Internal::nvme_controller(const CreateNvmeControllerRequest* msg) {
  return *msg->nvme_controller_;
}
CreateNvmeControllerRequest::CreateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeControllerRequest)
}
CreateNvmeControllerRequest::CreateNvmeControllerRequest(const CreateNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nvme_controller_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nvme_controller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_controller_id().empty()) {
    nvme_controller_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nvme_controller_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_nvme_controller()) {
    nvme_controller_ = new ::opi_api::storage::v1::NvmeController(*from.nvme_controller_);
  } else {
    nvme_controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeControllerRequest)
}

inline void CreateNvmeControllerRequest::SharedCtor() {
nvme_controller_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nvme_controller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nvme_controller_ = nullptr;
}

CreateNvmeControllerRequest::~CreateNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nvme_controller_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete nvme_controller_;
}

void CreateNvmeControllerRequest::ArenaDtor(void* object) {
  CreateNvmeControllerRequest* _this = reinterpret_cast< CreateNvmeControllerRequest* >(object);
  (void)_this;
}
void CreateNvmeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateNvmeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nvme_controller_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && nvme_controller_ != nullptr) {
    delete nvme_controller_;
  }
  nvme_controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_controller_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::nvme_controller(this), target, stream);
  }

  // string nvme_controller_id = 2;
  if (!this->_internal_nvme_controller_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_controller_id().data(), static_cast<int>(this->_internal_nvme_controller_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_controller_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeControllerRequest)
  return target;
}

size_t CreateNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_controller_id = 2;
  if (!this->_internal_nvme_controller_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_controller_id());
  }

  // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nvme_controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeControllerRequest::GetClassData() const { return &_class_data_; }

void CreateNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateNvmeControllerRequest *>(to)->MergeFrom(
      static_cast<const CreateNvmeControllerRequest &>(from));
}


void CreateNvmeControllerRequest::MergeFrom(const CreateNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_controller_id().empty()) {
    _internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_has_nvme_controller()) {
    _internal_mutable_nvme_controller()->::opi_api::storage::v1::NvmeController::MergeFrom(from._internal_nvme_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeControllerRequest::CopyFrom(const CreateNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeControllerRequest::IsInitialized() const {
  return true;
}

void CreateNvmeControllerRequest::InternalSwap(CreateNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nvme_controller_id_, lhs_arena,
      &other->nvme_controller_id_, rhs_arena
  );
  swap(nvme_controller_, other->nvme_controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[17]);
}

// ===================================================================

class DeleteNvmeControllerRequest::_Internal {
 public:
};

DeleteNvmeControllerRequest::DeleteNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeControllerRequest)
}
DeleteNvmeControllerRequest::DeleteNvmeControllerRequest(const DeleteNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  allow_missing_ = from.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeControllerRequest)
}

inline void DeleteNvmeControllerRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
allow_missing_ = false;
}

DeleteNvmeControllerRequest::~DeleteNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DeleteNvmeControllerRequest::ArenaDtor(void* object) {
  DeleteNvmeControllerRequest* _this = reinterpret_cast< DeleteNvmeControllerRequest* >(object);
  (void)_this;
}
void DeleteNvmeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNvmeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeControllerRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2;
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeControllerRequest)
  return target;
}

size_t DeleteNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2;
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeControllerRequest::GetClassData() const { return &_class_data_; }

void DeleteNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNvmeControllerRequest *>(to)->MergeFrom(
      static_cast<const DeleteNvmeControllerRequest &>(from));
}


void DeleteNvmeControllerRequest::MergeFrom(const DeleteNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _internal_set_allow_missing(from._internal_allow_missing());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeControllerRequest::CopyFrom(const DeleteNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeControllerRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeControllerRequest::InternalSwap(DeleteNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(allow_missing_, other->allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[18]);
}

// ===================================================================

class UpdateNvmeControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeController& nvme_controller(const UpdateNvmeControllerRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeController&
UpdateNvmeControllerRequest::_Internal::nvme_controller(const UpdateNvmeControllerRequest* msg) {
  return *msg->nvme_controller_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeControllerRequest::_Internal::update_mask(const UpdateNvmeControllerRequest* msg) {
  return *msg->update_mask_;
}
void UpdateNvmeControllerRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && update_mask_ != nullptr) {
    delete update_mask_;
  }
  update_mask_ = nullptr;
}
UpdateNvmeControllerRequest::UpdateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeControllerRequest)
}
UpdateNvmeControllerRequest::UpdateNvmeControllerRequest(const UpdateNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_controller()) {
    nvme_controller_ = new ::opi_api::storage::v1::NvmeController(*from.nvme_controller_);
  } else {
    nvme_controller_ = nullptr;
  }
  if (from._internal_has_update_mask()) {
    update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from.update_mask_);
  } else {
    update_mask_ = nullptr;
  }
  allow_missing_ = from.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeControllerRequest)
}

inline void UpdateNvmeControllerRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&nvme_controller_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_missing_) -
    reinterpret_cast<char*>(&nvme_controller_)) + sizeof(allow_missing_));
}

UpdateNvmeControllerRequest::~UpdateNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete nvme_controller_;
  if (this != internal_default_instance()) delete update_mask_;
}

void UpdateNvmeControllerRequest::ArenaDtor(void* object) {
  UpdateNvmeControllerRequest* _this = reinterpret_cast< UpdateNvmeControllerRequest* >(object);
  (void)_this;
}
void UpdateNvmeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNvmeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && nvme_controller_ != nullptr) {
    delete nvme_controller_;
  }
  nvme_controller_ = nullptr;
  if (GetArenaForAllocation() == nullptr && update_mask_ != nullptr) {
    delete update_mask_;
  }
  update_mask_ = nullptr;
  allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeController nvme_controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeController nvme_controller = 1;
  if (this->_internal_has_nvme_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::nvme_controller(this), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2;
  if (this->_internal_has_update_mask()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::update_mask(this), target, stream);
  }

  // bool allow_missing = 3;
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeControllerRequest)
  return target;
}

size_t UpdateNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeController nvme_controller = 1;
  if (this->_internal_has_nvme_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nvme_controller_);
  }

  // .google.protobuf.FieldMask update_mask = 2;
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *update_mask_);
  }

  // bool allow_missing = 3;
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeControllerRequest::GetClassData() const { return &_class_data_; }

void UpdateNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNvmeControllerRequest *>(to)->MergeFrom(
      static_cast<const UpdateNvmeControllerRequest &>(from));
}


void UpdateNvmeControllerRequest::MergeFrom(const UpdateNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_controller()) {
    _internal_mutable_nvme_controller()->::opi_api::storage::v1::NvmeController::MergeFrom(from._internal_nvme_controller());
  }
  if (from._internal_has_update_mask()) {
    _internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _internal_set_allow_missing(from._internal_allow_missing());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeControllerRequest::CopyFrom(const UpdateNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeControllerRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeControllerRequest::InternalSwap(UpdateNvmeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeControllerRequest, allow_missing_)
      + sizeof(UpdateNvmeControllerRequest::allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeControllerRequest, nvme_controller_)>(
          reinterpret_cast<char*>(&nvme_controller_),
          reinterpret_cast<char*>(&other->nvme_controller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[19]);
}

// ===================================================================

class ListNvmeControllersRequest::_Internal {
 public:
};

ListNvmeControllersRequest::ListNvmeControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeControllersRequest)
}
ListNvmeControllersRequest::ListNvmeControllersRequest(const ListNvmeControllersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_parent(), 
      GetArenaForAllocation());
  }
  page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_page_token(), 
      GetArenaForAllocation());
  }
  page_size_ = from.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeControllersRequest)
}

inline void ListNvmeControllersRequest::SharedCtor() {
parent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_size_ = 0;
}

ListNvmeControllersRequest::~ListNvmeControllersRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeControllersRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNvmeControllersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  parent_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  page_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ListNvmeControllersRequest::ArenaDtor(void* object) {
  ListNvmeControllersRequest* _this = reinterpret_cast< ListNvmeControllersRequest* >(object);
  (void)_this;
}
void ListNvmeControllersRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNvmeControllersRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNvmeControllersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeControllersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parent_.ClearToEmpty();
  page_token_.ClearToEmpty();
  page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeControllersRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeControllersRequest.parent"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeControllersRequest.page_token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeControllersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeControllersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeControllersRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2;
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3;
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeControllersRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeControllersRequest)
  return target;
}

size_t ListNvmeControllersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeControllersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3;
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2;
  if (this->_internal_page_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeControllersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNvmeControllersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeControllersRequest::GetClassData() const { return &_class_data_; }

void ListNvmeControllersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNvmeControllersRequest *>(to)->MergeFrom(
      static_cast<const ListNvmeControllersRequest &>(from));
}


void ListNvmeControllersRequest::MergeFrom(const ListNvmeControllersRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeControllersRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _internal_set_page_size(from._internal_page_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeControllersRequest::CopyFrom(const ListNvmeControllersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeControllersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeControllersRequest::IsInitialized() const {
  return true;
}

void ListNvmeControllersRequest::InternalSwap(ListNvmeControllersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &parent_, lhs_arena,
      &other->parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &page_token_, lhs_arena,
      &other->page_token_, rhs_arena
  );
  swap(page_size_, other->page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeControllersRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[20]);
}

// ===================================================================

class ListNvmeControllersResponse::_Internal {
 public:
};

ListNvmeControllersResponse::ListNvmeControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nvme_controllers_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeControllersResponse)
}
ListNvmeControllersResponse::ListNvmeControllersResponse(const ListNvmeControllersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nvme_controllers_(from.nvme_controllers_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  next_page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_next_page_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeControllersResponse)
}

inline void ListNvmeControllersResponse::SharedCtor() {
next_page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeControllersResponse::~ListNvmeControllersResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeControllersResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNvmeControllersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  next_page_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ListNvmeControllersResponse::ArenaDtor(void* object) {
  ListNvmeControllersResponse* _this = reinterpret_cast< ListNvmeControllersResponse* >(object);
  (void)_this;
}
void ListNvmeControllersResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNvmeControllersResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNvmeControllersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeControllersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nvme_controllers_.Clear();
  next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeControllersResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_controllers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeControllersResponse.next_page_token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeControllersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeControllersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nvme_controllers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_nvme_controllers(i), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeControllersResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeControllersResponse)
  return target;
}

size_t ListNvmeControllersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeControllersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
  total_size += 1UL * this->_internal_nvme_controllers_size();
  for (const auto& msg : this->nvme_controllers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeControllersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNvmeControllersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeControllersResponse::GetClassData() const { return &_class_data_; }

void ListNvmeControllersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNvmeControllersResponse *>(to)->MergeFrom(
      static_cast<const ListNvmeControllersResponse &>(from));
}


void ListNvmeControllersResponse::MergeFrom(const ListNvmeControllersResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeControllersResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nvme_controllers_.MergeFrom(from.nvme_controllers_);
  if (!from._internal_next_page_token().empty()) {
    _internal_set_next_page_token(from._internal_next_page_token());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeControllersResponse::CopyFrom(const ListNvmeControllersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeControllersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeControllersResponse::IsInitialized() const {
  return true;
}

void ListNvmeControllersResponse::InternalSwap(ListNvmeControllersResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nvme_controllers_.InternalSwap(&other->nvme_controllers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &next_page_token_, lhs_arena,
      &other->next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeControllersResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[21]);
}

// ===================================================================

class GetNvmeControllerRequest::_Internal {
 public:
};

GetNvmeControllerRequest::GetNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeControllerRequest)
}
GetNvmeControllerRequest::GetNvmeControllerRequest(const GetNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeControllerRequest)
}

inline void GetNvmeControllerRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeControllerRequest::~GetNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetNvmeControllerRequest::ArenaDtor(void* object) {
  GetNvmeControllerRequest* _this = reinterpret_cast< GetNvmeControllerRequest* >(object);
  (void)_this;
}
void GetNvmeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetNvmeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeControllerRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeControllerRequest)
  return target;
}

size_t GetNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeControllerRequest::GetClassData() const { return &_class_data_; }

void GetNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetNvmeControllerRequest *>(to)->MergeFrom(
      static_cast<const GetNvmeControllerRequest &>(from));
}


void GetNvmeControllerRequest::MergeFrom(const GetNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeControllerRequest::CopyFrom(const GetNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeControllerRequest::IsInitialized() const {
  return true;
}

void GetNvmeControllerRequest::InternalSwap(GetNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[22]);
}

// ===================================================================

class StatsNvmeControllerRequest::_Internal {
 public:
};

StatsNvmeControllerRequest::StatsNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeControllerRequest)
}
StatsNvmeControllerRequest::StatsNvmeControllerRequest(const StatsNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeControllerRequest)
}

inline void StatsNvmeControllerRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeControllerRequest::~StatsNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StatsNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StatsNvmeControllerRequest::ArenaDtor(void* object) {
  StatsNvmeControllerRequest* _this = reinterpret_cast< StatsNvmeControllerRequest* >(object);
  (void)_this;
}
void StatsNvmeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatsNvmeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeControllerRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeControllerRequest)
  return target;
}

size_t StatsNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StatsNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeControllerRequest::GetClassData() const { return &_class_data_; }

void StatsNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StatsNvmeControllerRequest *>(to)->MergeFrom(
      static_cast<const StatsNvmeControllerRequest &>(from));
}


void StatsNvmeControllerRequest::MergeFrom(const StatsNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeControllerRequest::CopyFrom(const StatsNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeControllerRequest::IsInitialized() const {
  return true;
}

void StatsNvmeControllerRequest::InternalSwap(StatsNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[23]);
}

// ===================================================================

class StatsNvmeControllerResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeControllerResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeControllerResponse::_Internal::stats(const StatsNvmeControllerResponse* msg) {
  return *msg->stats_;
}
void StatsNvmeControllerResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
StatsNvmeControllerResponse::StatsNvmeControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeControllerResponse)
}
StatsNvmeControllerResponse::StatsNvmeControllerResponse(const StatsNvmeControllerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    stats_ = new ::opi_api::storage::v1::VolumeStats(*from.stats_);
  } else {
    stats_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeControllerResponse)
}

inline void StatsNvmeControllerResponse::SharedCtor() {
stats_ = nullptr;
}

StatsNvmeControllerResponse::~StatsNvmeControllerResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeControllerResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StatsNvmeControllerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete stats_;
}

void StatsNvmeControllerResponse::ArenaDtor(void* object) {
  StatsNvmeControllerResponse* _this = reinterpret_cast< StatsNvmeControllerResponse* >(object);
  (void)_this;
}
void StatsNvmeControllerResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatsNvmeControllerResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsNvmeControllerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeControllerResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeControllerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::stats(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeControllerResponse)
  return target;
}

size_t StatsNvmeControllerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeControllerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StatsNvmeControllerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeControllerResponse::GetClassData() const { return &_class_data_; }

void StatsNvmeControllerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StatsNvmeControllerResponse *>(to)->MergeFrom(
      static_cast<const StatsNvmeControllerResponse &>(from));
}


void StatsNvmeControllerResponse::MergeFrom(const StatsNvmeControllerResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(from._internal_stats());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeControllerResponse::CopyFrom(const StatsNvmeControllerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeControllerResponse::IsInitialized() const {
  return true;
}

void StatsNvmeControllerResponse::InternalSwap(StatsNvmeControllerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(stats_, other->stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeControllerResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[24]);
}

// ===================================================================

class CreateNvmeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeNamespace& nvme_namespace(const CreateNvmeNamespaceRequest* msg);
};

const ::opi_api::storage::v1::NvmeNamespace&
CreateNvmeNamespaceRequest::_Internal::nvme_namespace(const CreateNvmeNamespaceRequest* msg) {
  return *msg->nvme_namespace_;
}
CreateNvmeNamespaceRequest::CreateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeNamespaceRequest)
}
CreateNvmeNamespaceRequest::CreateNvmeNamespaceRequest(const CreateNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nvme_namespace_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nvme_namespace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_namespace_id().empty()) {
    nvme_namespace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nvme_namespace_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_nvme_namespace()) {
    nvme_namespace_ = new ::opi_api::storage::v1::NvmeNamespace(*from.nvme_namespace_);
  } else {
    nvme_namespace_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeNamespaceRequest)
}

inline void CreateNvmeNamespaceRequest::SharedCtor() {
nvme_namespace_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nvme_namespace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nvme_namespace_ = nullptr;
}

CreateNvmeNamespaceRequest::~CreateNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nvme_namespace_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete nvme_namespace_;
}

void CreateNvmeNamespaceRequest::ArenaDtor(void* object) {
  CreateNvmeNamespaceRequest* _this = reinterpret_cast< CreateNvmeNamespaceRequest* >(object);
  (void)_this;
}
void CreateNvmeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateNvmeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nvme_namespace_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && nvme_namespace_ != nullptr) {
    delete nvme_namespace_;
  }
  nvme_namespace_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_namespace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_namespace_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_namespace_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_namespace()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::nvme_namespace(this), target, stream);
  }

  // string nvme_namespace_id = 2;
  if (!this->_internal_nvme_namespace_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_namespace_id().data(), static_cast<int>(this->_internal_nvme_namespace_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_namespace_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  return target;
}

size_t CreateNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_namespace_id = 2;
  if (!this->_internal_nvme_namespace_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_namespace_id());
  }

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_namespace()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nvme_namespace_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }

void CreateNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateNvmeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const CreateNvmeNamespaceRequest &>(from));
}


void CreateNvmeNamespaceRequest::MergeFrom(const CreateNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_namespace_id().empty()) {
    _internal_set_nvme_namespace_id(from._internal_nvme_namespace_id());
  }
  if (from._internal_has_nvme_namespace()) {
    _internal_mutable_nvme_namespace()->::opi_api::storage::v1::NvmeNamespace::MergeFrom(from._internal_nvme_namespace());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeNamespaceRequest::CopyFrom(const CreateNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void CreateNvmeNamespaceRequest::InternalSwap(CreateNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nvme_namespace_id_, lhs_arena,
      &other->nvme_namespace_id_, rhs_arena
  );
  swap(nvme_namespace_, other->nvme_namespace_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[25]);
}

// ===================================================================

class DeleteNvmeNamespaceRequest::_Internal {
 public:
};

DeleteNvmeNamespaceRequest::DeleteNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
}
DeleteNvmeNamespaceRequest::DeleteNvmeNamespaceRequest(const DeleteNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  allow_missing_ = from.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
}

inline void DeleteNvmeNamespaceRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
allow_missing_ = false;
}

DeleteNvmeNamespaceRequest::~DeleteNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DeleteNvmeNamespaceRequest::ArenaDtor(void* object) {
  DeleteNvmeNamespaceRequest* _this = reinterpret_cast< DeleteNvmeNamespaceRequest* >(object);
  (void)_this;
}
void DeleteNvmeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNvmeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeNamespaceRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2;
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  return target;
}

size_t DeleteNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2;
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }

void DeleteNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNvmeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const DeleteNvmeNamespaceRequest &>(from));
}


void DeleteNvmeNamespaceRequest::MergeFrom(const DeleteNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _internal_set_allow_missing(from._internal_allow_missing());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeNamespaceRequest::CopyFrom(const DeleteNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeNamespaceRequest::InternalSwap(DeleteNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(allow_missing_, other->allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[26]);
}

// ===================================================================

class UpdateNvmeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeNamespace& nvme_namespace(const UpdateNvmeNamespaceRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeNamespaceRequest* msg);
};

const ::opi_api::storage::v1::NvmeNamespace&
UpdateNvmeNamespaceRequest::_Internal::nvme_namespace(const UpdateNvmeNamespaceRequest* msg) {
  return *msg->nvme_namespace_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeNamespaceRequest::_Internal::update_mask(const UpdateNvmeNamespaceRequest* msg) {
  return *msg->update_mask_;
}
void UpdateNvmeNamespaceRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && update_mask_ != nullptr) {
    delete update_mask_;
  }
  update_mask_ = nullptr;
}
UpdateNvmeNamespaceRequest::UpdateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
}
UpdateNvmeNamespaceRequest::UpdateNvmeNamespaceRequest(const UpdateNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_namespace()) {
    nvme_namespace_ = new ::opi_api::storage::v1::NvmeNamespace(*from.nvme_namespace_);
  } else {
    nvme_namespace_ = nullptr;
  }
  if (from._internal_has_update_mask()) {
    update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from.update_mask_);
  } else {
    update_mask_ = nullptr;
  }
  allow_missing_ = from.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
}

inline void UpdateNvmeNamespaceRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&nvme_namespace_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_missing_) -
    reinterpret_cast<char*>(&nvme_namespace_)) + sizeof(allow_missing_));
}

UpdateNvmeNamespaceRequest::~UpdateNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete nvme_namespace_;
  if (this != internal_default_instance()) delete update_mask_;
}

void UpdateNvmeNamespaceRequest::ArenaDtor(void* object) {
  UpdateNvmeNamespaceRequest* _this = reinterpret_cast< UpdateNvmeNamespaceRequest* >(object);
  (void)_this;
}
void UpdateNvmeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNvmeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && nvme_namespace_ != nullptr) {
    delete nvme_namespace_;
  }
  nvme_namespace_ = nullptr;
  if (GetArenaForAllocation() == nullptr && update_mask_ != nullptr) {
    delete update_mask_;
  }
  update_mask_ = nullptr;
  allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_namespace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1;
  if (this->_internal_has_nvme_namespace()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::nvme_namespace(this), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2;
  if (this->_internal_has_update_mask()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::update_mask(this), target, stream);
  }

  // bool allow_missing = 3;
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  return target;
}

size_t UpdateNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1;
  if (this->_internal_has_nvme_namespace()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nvme_namespace_);
  }

  // .google.protobuf.FieldMask update_mask = 2;
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *update_mask_);
  }

  // bool allow_missing = 3;
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }

void UpdateNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNvmeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const UpdateNvmeNamespaceRequest &>(from));
}


void UpdateNvmeNamespaceRequest::MergeFrom(const UpdateNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_namespace()) {
    _internal_mutable_nvme_namespace()->::opi_api::storage::v1::NvmeNamespace::MergeFrom(from._internal_nvme_namespace());
  }
  if (from._internal_has_update_mask()) {
    _internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _internal_set_allow_missing(from._internal_allow_missing());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeNamespaceRequest::CopyFrom(const UpdateNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeNamespaceRequest::InternalSwap(UpdateNvmeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeNamespaceRequest, allow_missing_)
      + sizeof(UpdateNvmeNamespaceRequest::allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeNamespaceRequest, nvme_namespace_)>(
          reinterpret_cast<char*>(&nvme_namespace_),
          reinterpret_cast<char*>(&other->nvme_namespace_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[27]);
}

// ===================================================================

class ListNvmeNamespacesRequest::_Internal {
 public:
};

ListNvmeNamespacesRequest::ListNvmeNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeNamespacesRequest)
}
ListNvmeNamespacesRequest::ListNvmeNamespacesRequest(const ListNvmeNamespacesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  parent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_parent(), 
      GetArenaForAllocation());
  }
  page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_page_token(), 
      GetArenaForAllocation());
  }
  page_size_ = from.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeNamespacesRequest)
}

inline void ListNvmeNamespacesRequest::SharedCtor() {
parent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
page_size_ = 0;
}

ListNvmeNamespacesRequest::~ListNvmeNamespacesRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeNamespacesRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNvmeNamespacesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  parent_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  page_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ListNvmeNamespacesRequest::ArenaDtor(void* object) {
  ListNvmeNamespacesRequest* _this = reinterpret_cast< ListNvmeNamespacesRequest* >(object);
  (void)_this;
}
void ListNvmeNamespacesRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNvmeNamespacesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNvmeNamespacesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parent_.ClearToEmpty();
  page_token_.ClearToEmpty();
  page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeNamespacesRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeNamespacesRequest.parent"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeNamespacesRequest.page_token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeNamespacesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeNamespacesRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2;
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3;
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeNamespacesRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeNamespacesRequest)
  return target;
}

size_t ListNvmeNamespacesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3;
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2;
  if (this->_internal_page_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeNamespacesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNvmeNamespacesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeNamespacesRequest::GetClassData() const { return &_class_data_; }

void ListNvmeNamespacesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNvmeNamespacesRequest *>(to)->MergeFrom(
      static_cast<const ListNvmeNamespacesRequest &>(from));
}


void ListNvmeNamespacesRequest::MergeFrom(const ListNvmeNamespacesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _internal_set_page_size(from._internal_page_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeNamespacesRequest::CopyFrom(const ListNvmeNamespacesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeNamespacesRequest::IsInitialized() const {
  return true;
}

void ListNvmeNamespacesRequest::InternalSwap(ListNvmeNamespacesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &parent_, lhs_arena,
      &other->parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &page_token_, lhs_arena,
      &other->page_token_, rhs_arena
  );
  swap(page_size_, other->page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeNamespacesRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[28]);
}

// ===================================================================

class ListNvmeNamespacesResponse::_Internal {
 public:
};

ListNvmeNamespacesResponse::ListNvmeNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nvme_namespaces_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeNamespacesResponse)
}
ListNvmeNamespacesResponse::ListNvmeNamespacesResponse(const ListNvmeNamespacesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nvme_namespaces_(from.nvme_namespaces_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  next_page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_next_page_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeNamespacesResponse)
}

inline void ListNvmeNamespacesResponse::SharedCtor() {
next_page_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeNamespacesResponse::~ListNvmeNamespacesResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeNamespacesResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNvmeNamespacesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  next_page_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ListNvmeNamespacesResponse::ArenaDtor(void* object) {
  ListNvmeNamespacesResponse* _this = reinterpret_cast< ListNvmeNamespacesResponse* >(object);
  (void)_this;
}
void ListNvmeNamespacesResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNvmeNamespacesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNvmeNamespacesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nvme_namespaces_.Clear();
  next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeNamespacesResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_namespaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeNamespacesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nvme_namespaces_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_nvme_namespaces(i), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeNamespacesResponse)
  return target;
}

size_t ListNvmeNamespacesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
  total_size += 1UL * this->_internal_nvme_namespaces_size();
  for (const auto& msg : this->nvme_namespaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeNamespacesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNvmeNamespacesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeNamespacesResponse::GetClassData() const { return &_class_data_; }

void ListNvmeNamespacesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNvmeNamespacesResponse *>(to)->MergeFrom(
      static_cast<const ListNvmeNamespacesResponse &>(from));
}


void ListNvmeNamespacesResponse::MergeFrom(const ListNvmeNamespacesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nvme_namespaces_.MergeFrom(from.nvme_namespaces_);
  if (!from._internal_next_page_token().empty()) {
    _internal_set_next_page_token(from._internal_next_page_token());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeNamespacesResponse::CopyFrom(const ListNvmeNamespacesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeNamespacesResponse::IsInitialized() const {
  return true;
}

void ListNvmeNamespacesResponse::InternalSwap(ListNvmeNamespacesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nvme_namespaces_.InternalSwap(&other->nvme_namespaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &next_page_token_, lhs_arena,
      &other->next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeNamespacesResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[29]);
}

// ===================================================================

class GetNvmeNamespaceRequest::_Internal {
 public:
};

GetNvmeNamespaceRequest::GetNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeNamespaceRequest)
}
GetNvmeNamespaceRequest::GetNvmeNamespaceRequest(const GetNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeNamespaceRequest)
}

inline void GetNvmeNamespaceRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeNamespaceRequest::~GetNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetNvmeNamespaceRequest::ArenaDtor(void* object) {
  GetNvmeNamespaceRequest* _this = reinterpret_cast< GetNvmeNamespaceRequest* >(object);
  (void)_this;
}
void GetNvmeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetNvmeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeNamespaceRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeNamespaceRequest)
  return target;
}

size_t GetNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }

void GetNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetNvmeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const GetNvmeNamespaceRequest &>(from));
}


void GetNvmeNamespaceRequest::MergeFrom(const GetNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeNamespaceRequest::CopyFrom(const GetNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void GetNvmeNamespaceRequest::InternalSwap(GetNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[30]);
}

// ===================================================================

class StatsNvmeNamespaceRequest::_Internal {
 public:
};

StatsNvmeNamespaceRequest::StatsNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeNamespaceRequest)
}
StatsNvmeNamespaceRequest::StatsNvmeNamespaceRequest(const StatsNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeNamespaceRequest)
}

inline void StatsNvmeNamespaceRequest::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeNamespaceRequest::~StatsNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StatsNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StatsNvmeNamespaceRequest::ArenaDtor(void* object) {
  StatsNvmeNamespaceRequest* _this = reinterpret_cast< StatsNvmeNamespaceRequest* >(object);
  (void)_this;
}
void StatsNvmeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatsNvmeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeNamespaceRequest.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  return target;
}

size_t StatsNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StatsNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }

void StatsNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StatsNvmeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const StatsNvmeNamespaceRequest &>(from));
}


void StatsNvmeNamespaceRequest::MergeFrom(const StatsNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeNamespaceRequest::CopyFrom(const StatsNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void StatsNvmeNamespaceRequest::InternalSwap(StatsNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[31]);
}

// ===================================================================

class StatsNvmeNamespaceResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeNamespaceResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeNamespaceResponse::_Internal::stats(const StatsNvmeNamespaceResponse* msg) {
  return *msg->stats_;
}
void StatsNvmeNamespaceResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
StatsNvmeNamespaceResponse::StatsNvmeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeNamespaceResponse)
}
StatsNvmeNamespaceResponse::StatsNvmeNamespaceResponse(const StatsNvmeNamespaceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    stats_ = new ::opi_api::storage::v1::VolumeStats(*from.stats_);
  } else {
    stats_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeNamespaceResponse)
}

inline void StatsNvmeNamespaceResponse::SharedCtor() {
stats_ = nullptr;
}

StatsNvmeNamespaceResponse::~StatsNvmeNamespaceResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StatsNvmeNamespaceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete stats_;
}

void StatsNvmeNamespaceResponse::ArenaDtor(void* object) {
  StatsNvmeNamespaceResponse* _this = reinterpret_cast< StatsNvmeNamespaceResponse* >(object);
  (void)_this;
}
void StatsNvmeNamespaceResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatsNvmeNamespaceResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsNvmeNamespaceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeNamespaceResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeNamespaceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::stats(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  return target;
}

size_t StatsNvmeNamespaceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeNamespaceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StatsNvmeNamespaceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeNamespaceResponse::GetClassData() const { return &_class_data_; }

void StatsNvmeNamespaceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StatsNvmeNamespaceResponse *>(to)->MergeFrom(
      static_cast<const StatsNvmeNamespaceResponse &>(from));
}


void StatsNvmeNamespaceResponse::MergeFrom(const StatsNvmeNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(from._internal_stats());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeNamespaceResponse::CopyFrom(const StatsNvmeNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeNamespaceResponse::IsInitialized() const {
  return true;
}

void StatsNvmeNamespaceResponse::InternalSwap(StatsNvmeNamespaceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(stats_, other->stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeNamespaceResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[32]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeSubsystem* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeSubsystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeSubsystem >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeSubsystemSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeSubsystemSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeSubsystemSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeSubsystemStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeSubsystemStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeSubsystemStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeController* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeControllerSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeControllerSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeControllerSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeControllerStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeControllerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeControllerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeNamespace* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeNamespaceSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeNamespaceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeNamespaceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeNamespaceStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeNamespaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeNamespaceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeSubsystemsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeSubsystemsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeSubsystemsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeSubsystemsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeSubsystemsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeSubsystemsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeSubsystemResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeSubsystemResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeSubsystemResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeControllersRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeControllersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeControllersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeControllersResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeControllersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeControllersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeControllerResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeControllerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeControllerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeNamespacesRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeNamespacesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeNamespacesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeNamespacesResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeNamespacesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeNamespacesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeNamespaceResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeNamespaceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeNamespaceResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
