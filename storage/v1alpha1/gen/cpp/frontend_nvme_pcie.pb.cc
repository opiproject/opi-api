// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#include "frontend_nvme_pcie.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace opi_api {
namespace storage {
namespace v1 {
constexpr NVMeSubsystem::NVMeSubsystem(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spec_(nullptr)
  , status_(nullptr){}
struct NVMeSubsystemDefaultTypeInternal {
  constexpr NVMeSubsystemDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemDefaultTypeInternal() {}
  union {
    NVMeSubsystem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemDefaultTypeInternal _NVMeSubsystem_default_instance_;
constexpr NVMeSubsystemSpec::NVMeSubsystemSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nqn_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_number_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr)
  , max_namespaces_(int64_t{0}){}
struct NVMeSubsystemSpecDefaultTypeInternal {
  constexpr NVMeSubsystemSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemSpecDefaultTypeInternal() {}
  union {
    NVMeSubsystemSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemSpecDefaultTypeInternal _NVMeSubsystemSpec_default_instance_;
constexpr NVMeSubsystemStatus::NVMeSubsystemStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : firmware_revision_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fru_guid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct NVMeSubsystemStatusDefaultTypeInternal {
  constexpr NVMeSubsystemStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatusDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatusDefaultTypeInternal _NVMeSubsystemStatus_default_instance_;
constexpr NVMeController::NVMeController(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spec_(nullptr)
  , status_(nullptr){}
struct NVMeControllerDefaultTypeInternal {
  constexpr NVMeControllerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerDefaultTypeInternal() {}
  union {
    NVMeController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerDefaultTypeInternal _NVMeController_default_instance_;
constexpr NVMeControllerSpec::NVMeControllerSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr)
  , subsystem_id_(nullptr)
  , pcie_id_(nullptr)
  , nvme_controller_id_(0)
  , max_nsq_(0)
  , max_ncq_(0)
  , sqes_(0)
  , cqes_(0)
  , max_namespaces_(0){}
struct NVMeControllerSpecDefaultTypeInternal {
  constexpr NVMeControllerSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerSpecDefaultTypeInternal() {}
  union {
    NVMeControllerSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerSpecDefaultTypeInternal _NVMeControllerSpec_default_instance_;
constexpr NVMeControllerStatus::NVMeControllerStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : active_(false){}
struct NVMeControllerStatusDefaultTypeInternal {
  constexpr NVMeControllerStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatusDefaultTypeInternal() {}
  union {
    NVMeControllerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatusDefaultTypeInternal _NVMeControllerStatus_default_instance_;
constexpr NVMeNamespace::NVMeNamespace(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : spec_(nullptr)
  , status_(nullptr){}
struct NVMeNamespaceDefaultTypeInternal {
  constexpr NVMeNamespaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceDefaultTypeInternal() {}
  union {
    NVMeNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceDefaultTypeInternal _NVMeNamespace_default_instance_;
constexpr NVMeNamespaceSpec::NVMeNamespaceSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nguid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr)
  , subsystem_id_(nullptr)
  , controller_id_(nullptr)
  , uuid_(nullptr)
  , volume_id_(nullptr)
  , block_size_(int64_t{0})
  , blocks_count_(int64_t{0})
  , host_nsid_(0)
  , optimal_write_size_(0)
  , eui64_(int64_t{0})
  , pref_write_granularity_(0){}
struct NVMeNamespaceSpecDefaultTypeInternal {
  constexpr NVMeNamespaceSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceSpecDefaultTypeInternal() {}
  union {
    NVMeNamespaceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceSpecDefaultTypeInternal _NVMeNamespaceSpec_default_instance_;
constexpr NVMeNamespaceStatus::NVMeNamespaceStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pci_state_(0)

  , pci_oper_state_(0)
{}
struct NVMeNamespaceStatusDefaultTypeInternal {
  constexpr NVMeNamespaceStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatusDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatusDefaultTypeInternal _NVMeNamespaceStatus_default_instance_;
constexpr CreateNVMeSubsystemRequest::CreateNVMeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(nullptr){}
struct CreateNVMeSubsystemRequestDefaultTypeInternal {
  constexpr CreateNVMeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateNVMeSubsystemRequestDefaultTypeInternal() {}
  union {
    CreateNVMeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateNVMeSubsystemRequestDefaultTypeInternal _CreateNVMeSubsystemRequest_default_instance_;
constexpr DeleteNVMeSubsystemRequest::DeleteNVMeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct DeleteNVMeSubsystemRequestDefaultTypeInternal {
  constexpr DeleteNVMeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNVMeSubsystemRequestDefaultTypeInternal() {}
  union {
    DeleteNVMeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNVMeSubsystemRequestDefaultTypeInternal _DeleteNVMeSubsystemRequest_default_instance_;
constexpr UpdateNVMeSubsystemRequest::UpdateNVMeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(nullptr){}
struct UpdateNVMeSubsystemRequestDefaultTypeInternal {
  constexpr UpdateNVMeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNVMeSubsystemRequestDefaultTypeInternal() {}
  union {
    UpdateNVMeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNVMeSubsystemRequestDefaultTypeInternal _UpdateNVMeSubsystemRequest_default_instance_;
constexpr ListNVMeSubsystemRequest::ListNVMeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ListNVMeSubsystemRequestDefaultTypeInternal {
  constexpr ListNVMeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNVMeSubsystemRequestDefaultTypeInternal() {}
  union {
    ListNVMeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNVMeSubsystemRequestDefaultTypeInternal _ListNVMeSubsystemRequest_default_instance_;
constexpr ListNVMeSubsystemResponse::ListNVMeSubsystemResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_(){}
struct ListNVMeSubsystemResponseDefaultTypeInternal {
  constexpr ListNVMeSubsystemResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNVMeSubsystemResponseDefaultTypeInternal() {}
  union {
    ListNVMeSubsystemResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNVMeSubsystemResponseDefaultTypeInternal _ListNVMeSubsystemResponse_default_instance_;
constexpr GetNVMeSubsystemRequest::GetNVMeSubsystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct GetNVMeSubsystemRequestDefaultTypeInternal {
  constexpr GetNVMeSubsystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetNVMeSubsystemRequestDefaultTypeInternal() {}
  union {
    GetNVMeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetNVMeSubsystemRequestDefaultTypeInternal _GetNVMeSubsystemRequest_default_instance_;
constexpr NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct NVMeSubsystemStatsRequestDefaultTypeInternal {
  constexpr NVMeSubsystemStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatsRequestDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatsRequestDefaultTypeInternal _NVMeSubsystemStatsRequest_default_instance_;
constexpr NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct NVMeSubsystemStatsResponseDefaultTypeInternal {
  constexpr NVMeSubsystemStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeSubsystemStatsResponseDefaultTypeInternal() {}
  union {
    NVMeSubsystemStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeSubsystemStatsResponseDefaultTypeInternal _NVMeSubsystemStatsResponse_default_instance_;
constexpr CreateNVMeControllerRequest::CreateNVMeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(nullptr){}
struct CreateNVMeControllerRequestDefaultTypeInternal {
  constexpr CreateNVMeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateNVMeControllerRequestDefaultTypeInternal() {}
  union {
    CreateNVMeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateNVMeControllerRequestDefaultTypeInternal _CreateNVMeControllerRequest_default_instance_;
constexpr DeleteNVMeControllerRequest::DeleteNVMeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_id_(nullptr){}
struct DeleteNVMeControllerRequestDefaultTypeInternal {
  constexpr DeleteNVMeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNVMeControllerRequestDefaultTypeInternal() {}
  union {
    DeleteNVMeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNVMeControllerRequestDefaultTypeInternal _DeleteNVMeControllerRequest_default_instance_;
constexpr UpdateNVMeControllerRequest::UpdateNVMeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(nullptr){}
struct UpdateNVMeControllerRequestDefaultTypeInternal {
  constexpr UpdateNVMeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNVMeControllerRequestDefaultTypeInternal() {}
  union {
    UpdateNVMeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNVMeControllerRequestDefaultTypeInternal _UpdateNVMeControllerRequest_default_instance_;
constexpr ListNVMeControllerRequest::ListNVMeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr){}
struct ListNVMeControllerRequestDefaultTypeInternal {
  constexpr ListNVMeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNVMeControllerRequestDefaultTypeInternal() {}
  union {
    ListNVMeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNVMeControllerRequestDefaultTypeInternal _ListNVMeControllerRequest_default_instance_;
constexpr ListNVMeControllerResponse::ListNVMeControllerResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_(){}
struct ListNVMeControllerResponseDefaultTypeInternal {
  constexpr ListNVMeControllerResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNVMeControllerResponseDefaultTypeInternal() {}
  union {
    ListNVMeControllerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNVMeControllerResponseDefaultTypeInternal _ListNVMeControllerResponse_default_instance_;
constexpr GetNVMeControllerRequest::GetNVMeControllerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_id_(nullptr){}
struct GetNVMeControllerRequestDefaultTypeInternal {
  constexpr GetNVMeControllerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetNVMeControllerRequestDefaultTypeInternal() {}
  union {
    GetNVMeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetNVMeControllerRequestDefaultTypeInternal _GetNVMeControllerRequest_default_instance_;
constexpr NVMeControllerStatsRequest::NVMeControllerStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(nullptr){}
struct NVMeControllerStatsRequestDefaultTypeInternal {
  constexpr NVMeControllerStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatsRequestDefaultTypeInternal() {}
  union {
    NVMeControllerStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatsRequestDefaultTypeInternal _NVMeControllerStatsRequest_default_instance_;
constexpr NVMeControllerStatsResponse::NVMeControllerStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr){}
struct NVMeControllerStatsResponseDefaultTypeInternal {
  constexpr NVMeControllerStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeControllerStatsResponseDefaultTypeInternal() {}
  union {
    NVMeControllerStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeControllerStatsResponseDefaultTypeInternal _NVMeControllerStatsResponse_default_instance_;
constexpr CreateNVMeNamespaceRequest::CreateNVMeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(nullptr){}
struct CreateNVMeNamespaceRequestDefaultTypeInternal {
  constexpr CreateNVMeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CreateNVMeNamespaceRequestDefaultTypeInternal() {}
  union {
    CreateNVMeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CreateNVMeNamespaceRequestDefaultTypeInternal _CreateNVMeNamespaceRequest_default_instance_;
constexpr DeleteNVMeNamespaceRequest::DeleteNVMeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct DeleteNVMeNamespaceRequestDefaultTypeInternal {
  constexpr DeleteNVMeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNVMeNamespaceRequestDefaultTypeInternal() {}
  union {
    DeleteNVMeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNVMeNamespaceRequestDefaultTypeInternal _DeleteNVMeNamespaceRequest_default_instance_;
constexpr UpdateNVMeNamespaceRequest::UpdateNVMeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(nullptr){}
struct UpdateNVMeNamespaceRequestDefaultTypeInternal {
  constexpr UpdateNVMeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNVMeNamespaceRequestDefaultTypeInternal() {}
  union {
    UpdateNVMeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNVMeNamespaceRequestDefaultTypeInternal _UpdateNVMeNamespaceRequest_default_instance_;
constexpr ListNVMeNamespaceRequest::ListNVMeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subsystem_id_(nullptr)
  , controller_id_(nullptr){}
struct ListNVMeNamespaceRequestDefaultTypeInternal {
  constexpr ListNVMeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNVMeNamespaceRequestDefaultTypeInternal() {}
  union {
    ListNVMeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNVMeNamespaceRequestDefaultTypeInternal _ListNVMeNamespaceRequest_default_instance_;
constexpr ListNVMeNamespaceResponse::ListNVMeNamespaceResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(){}
struct ListNVMeNamespaceResponseDefaultTypeInternal {
  constexpr ListNVMeNamespaceResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ListNVMeNamespaceResponseDefaultTypeInternal() {}
  union {
    ListNVMeNamespaceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ListNVMeNamespaceResponseDefaultTypeInternal _ListNVMeNamespaceResponse_default_instance_;
constexpr GetNVMeNamespaceRequest::GetNVMeNamespaceRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct GetNVMeNamespaceRequestDefaultTypeInternal {
  constexpr GetNVMeNamespaceRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetNVMeNamespaceRequestDefaultTypeInternal() {}
  union {
    GetNVMeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetNVMeNamespaceRequestDefaultTypeInternal _GetNVMeNamespaceRequest_default_instance_;
constexpr NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace_id_(nullptr){}
struct NVMeNamespaceStatsRequestDefaultTypeInternal {
  constexpr NVMeNamespaceStatsRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatsRequestDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatsRequestDefaultTypeInternal _NVMeNamespaceStatsRequest_default_instance_;
constexpr NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(nullptr){}
struct NVMeNamespaceStatsResponseDefaultTypeInternal {
  constexpr NVMeNamespaceStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NVMeNamespaceStatsResponseDefaultTypeInternal() {}
  union {
    NVMeNamespaceStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NVMeNamespaceStatsResponseDefaultTypeInternal _NVMeNamespaceStatsResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_frontend_5fnvme_5fpcie_2eproto[33];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto = nullptr;

const uint32_t TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystem, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, nqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, serial_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, model_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemSpec, max_namespaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatus, firmware_revision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatus, fru_guid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeController, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, nvme_controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, pcie_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, max_nsq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, max_ncq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, sqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, cqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerSpec, max_namespaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatus, active_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespace, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, host_nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, block_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, blocks_count_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, uuid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, volume_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, optimal_write_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceSpec, pref_write_granularity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatus, pci_state_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatus, pci_oper_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNVMeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNVMeSubsystemRequest, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNVMeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNVMeSubsystemRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNVMeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNVMeSubsystemRequest, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeSubsystemResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeSubsystemResponse, subsystem_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNVMeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNVMeSubsystemRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeSubsystemStatsResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNVMeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNVMeControllerRequest, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNVMeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNVMeControllerRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNVMeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNVMeControllerRequest, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeControllerRequest, subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeControllerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeControllerResponse, controller_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNVMeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNVMeControllerRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsRequest, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeControllerStatsResponse, stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNVMeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNVMeNamespaceRequest, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNVMeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNVMeNamespaceRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNVMeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNVMeNamespaceRequest, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeNamespaceRequest, subsystem_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeNamespaceRequest, controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeNamespaceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNVMeNamespaceResponse, namespace__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNVMeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNVMeNamespaceRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsRequest, namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NVMeNamespaceStatsResponse, stats_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystem)},
  { 8, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemSpec)},
  { 19, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatus)},
  { 27, -1, -1, sizeof(::opi_api::storage::v1::NVMeController)},
  { 35, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerSpec)},
  { 50, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatus)},
  { 57, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespace)},
  { 65, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceSpec)},
  { 83, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatus)},
  { 91, -1, -1, sizeof(::opi_api::storage::v1::CreateNVMeSubsystemRequest)},
  { 98, -1, -1, sizeof(::opi_api::storage::v1::DeleteNVMeSubsystemRequest)},
  { 105, -1, -1, sizeof(::opi_api::storage::v1::UpdateNVMeSubsystemRequest)},
  { 112, -1, -1, sizeof(::opi_api::storage::v1::ListNVMeSubsystemRequest)},
  { 118, -1, -1, sizeof(::opi_api::storage::v1::ListNVMeSubsystemResponse)},
  { 125, -1, -1, sizeof(::opi_api::storage::v1::GetNVMeSubsystemRequest)},
  { 132, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatsRequest)},
  { 139, -1, -1, sizeof(::opi_api::storage::v1::NVMeSubsystemStatsResponse)},
  { 146, -1, -1, sizeof(::opi_api::storage::v1::CreateNVMeControllerRequest)},
  { 153, -1, -1, sizeof(::opi_api::storage::v1::DeleteNVMeControllerRequest)},
  { 160, -1, -1, sizeof(::opi_api::storage::v1::UpdateNVMeControllerRequest)},
  { 167, -1, -1, sizeof(::opi_api::storage::v1::ListNVMeControllerRequest)},
  { 174, -1, -1, sizeof(::opi_api::storage::v1::ListNVMeControllerResponse)},
  { 181, -1, -1, sizeof(::opi_api::storage::v1::GetNVMeControllerRequest)},
  { 188, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatsRequest)},
  { 195, -1, -1, sizeof(::opi_api::storage::v1::NVMeControllerStatsResponse)},
  { 203, -1, -1, sizeof(::opi_api::storage::v1::CreateNVMeNamespaceRequest)},
  { 210, -1, -1, sizeof(::opi_api::storage::v1::DeleteNVMeNamespaceRequest)},
  { 217, -1, -1, sizeof(::opi_api::storage::v1::UpdateNVMeNamespaceRequest)},
  { 224, -1, -1, sizeof(::opi_api::storage::v1::ListNVMeNamespaceRequest)},
  { 232, -1, -1, sizeof(::opi_api::storage::v1::ListNVMeNamespaceResponse)},
  { 239, -1, -1, sizeof(::opi_api::storage::v1::GetNVMeNamespaceRequest)},
  { 246, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatsRequest)},
  { 253, -1, -1, sizeof(::opi_api::storage::v1::NVMeNamespaceStatsResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeController_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_CreateNVMeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_DeleteNVMeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_UpdateNVMeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNVMeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNVMeSubsystemResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_GetNVMeSubsystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeSubsystemStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_CreateNVMeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_DeleteNVMeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_UpdateNVMeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNVMeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNVMeControllerResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_GetNVMeControllerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeControllerStatsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_CreateNVMeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_DeleteNVMeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_UpdateNVMeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNVMeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_ListNVMeNamespaceResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_GetNVMeNamespaceRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::opi_api::storage::v1::_NVMeNamespaceStatsResponse_default_instance_),
};

const char descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030frontend_nvme_pcie.proto\022\022opi_api.stor"
  "age.v1\032\014common.proto\032\020object_key.proto\032\n"
  "uuid.proto\032\033google/protobuf/empty.proto\032"
  "\034google/api/annotations.proto\"}\n\rNVMeSub"
  "system\0223\n\004spec\030\001 \001(\0132%.opi_api.storage.v"
  "1.NVMeSubsystemSpec\0227\n\006status\030\002 \001(\0132\'.op"
  "i_api.storage.v1.NVMeSubsystemStatus\"\217\001\n"
  "\021NVMeSubsystemSpec\022(\n\002id\030\001 \001(\0132\034.opi_api"
  ".common.v1.ObjectKey\022\013\n\003nqn\030\002 \001(\t\022\025\n\rser"
  "ial_number\030\003 \001(\t\022\024\n\014model_number\030\004 \001(\t\022\026"
  "\n\016max_namespaces\030\005 \001(\003\"B\n\023NVMeSubsystemS"
  "tatus\022\031\n\021firmware_revision\030\001 \001(\t\022\020\n\010fru_"
  "guid\030\002 \001(\014\"\200\001\n\016NVMeController\0224\n\004spec\030\001 "
  "\001(\0132&.opi_api.storage.v1.NVMeControllerS"
  "pec\0228\n\006status\030\002 \001(\0132(.opi_api.storage.v1"
  ".NVMeControllerStatus\"\226\002\n\022NVMeController"
  "Spec\022(\n\002id\030\001 \001(\0132\034.opi_api.common.v1.Obj"
  "ectKey\022\032\n\022nvme_controller_id\030\002 \001(\005\0222\n\014su"
  "bsystem_id\030\003 \001(\0132\034.opi_api.common.v1.Obj"
  "ectKey\0220\n\007pcie_id\030\004 \001(\0132\037.opi_api.storag"
  "e.v1.PciEndpoint\022\017\n\007max_nsq\030\005 \001(\005\022\017\n\007max"
  "_ncq\030\006 \001(\005\022\014\n\004sqes\030\007 \001(\005\022\014\n\004cqes\030\010 \001(\005\022\026"
  "\n\016max_namespaces\030\t \001(\005\"&\n\024NVMeController"
  "Status\022\016\n\006active\030\001 \001(\010\"}\n\rNVMeNamespace\022"
  "3\n\004spec\030\001 \001(\0132%.opi_api.storage.v1.NVMeN"
  "amespaceSpec\0227\n\006status\030\002 \001(\0132\'.opi_api.s"
  "torage.v1.NVMeNamespaceStatus\"\225\003\n\021NVMeNa"
  "mespaceSpec\022(\n\002id\030\001 \001(\0132\034.opi_api.common"
  ".v1.ObjectKey\0222\n\014subsystem_id\030\002 \001(\0132\034.op"
  "i_api.common.v1.ObjectKey\0223\n\rcontroller_"
  "id\030\003 \001(\0132\034.opi_api.common.v1.ObjectKey\022\021"
  "\n\thost_nsid\030\004 \001(\005\022\022\n\nblock_size\030\005 \001(\003\022\024\n"
  "\014blocks_count\030\006 \001(\003\022\r\n\005nguid\030\007 \001(\t\022\r\n\005eu"
  "i64\030\010 \001(\003\022%\n\004uuid\030\t \001(\0132\027.opi_api.common"
  ".v1.Uuid\022/\n\tvolume_id\030\n \001(\0132\034.opi_api.co"
  "mmon.v1.ObjectKey\022\032\n\022optimal_write_size\030"
  "\013 \001(\005\022\036\n\026pref_write_granularity\030\014 \001(\005\"\232\001"
  "\n\023NVMeNamespaceStatus\022<\n\tpci_state\030\001 \001(\016"
  "2).opi_api.storage.v1.NVMeNamespacePciSt"
  "ate\022E\n\016pci_oper_state\030\002 \001(\0162-.opi_api.st"
  "orage.v1.NVMeNamespacePciOperState\"R\n\032Cr"
  "eateNVMeSubsystemRequest\0224\n\tsubsystem\030\001 "
  "\001(\0132!.opi_api.storage.v1.NVMeSubsystem\"P"
  "\n\032DeleteNVMeSubsystemRequest\0222\n\014subsyste"
  "m_id\030\001 \001(\0132\034.opi_api.common.v1.ObjectKey"
  "\"R\n\032UpdateNVMeSubsystemRequest\0224\n\tsubsys"
  "tem\030\001 \001(\0132!.opi_api.storage.v1.NVMeSubsy"
  "stem\"\032\n\030ListNVMeSubsystemRequest\"Q\n\031List"
  "NVMeSubsystemResponse\0224\n\tsubsystem\030\001 \003(\013"
  "2!.opi_api.storage.v1.NVMeSubsystem\"M\n\027G"
  "etNVMeSubsystemRequest\0222\n\014subsystem_id\030\001"
  " \001(\0132\034.opi_api.common.v1.ObjectKey\"O\n\031NV"
  "MeSubsystemStatsRequest\0222\n\014subsystem_id\030"
  "\001 \001(\0132\034.opi_api.common.v1.ObjectKey\"+\n\032N"
  "VMeSubsystemStatsResponse\022\r\n\005stats\030\001 \001(\t"
  "\"U\n\033CreateNVMeControllerRequest\0226\n\ncontr"
  "oller\030\001 \001(\0132\".opi_api.storage.v1.NVMeCon"
  "troller\"R\n\033DeleteNVMeControllerRequest\0223"
  "\n\rcontroller_id\030\001 \001(\0132\034.opi_api.common.v"
  "1.ObjectKey\"U\n\033UpdateNVMeControllerReque"
  "st\0226\n\ncontroller\030\001 \001(\0132\".opi_api.storage"
  ".v1.NVMeController\"O\n\031ListNVMeController"
  "Request\0222\n\014subsystem_id\030\001 \001(\0132\034.opi_api."
  "common.v1.ObjectKey\"T\n\032ListNVMeControlle"
  "rResponse\0226\n\ncontroller\030\001 \003(\0132\".opi_api."
  "storage.v1.NVMeController\"O\n\030GetNVMeCont"
  "rollerRequest\0223\n\rcontroller_id\030\001 \001(\0132\034.o"
  "pi_api.common.v1.ObjectKey\"F\n\032NVMeContro"
  "llerStatsRequest\022(\n\002id\030\001 \001(\0132\034.opi_api.c"
  "ommon.v1.ObjectKey\"V\n\033NVMeControllerStat"
  "sResponse\022(\n\002id\030\001 \001(\0132\034.opi_api.common.v"
  "1.ObjectKey\022\r\n\005stats\030\002 \001(\t\"R\n\032CreateNVMe"
  "NamespaceRequest\0224\n\tnamespace\030\001 \001(\0132!.op"
  "i_api.storage.v1.NVMeNamespace\"P\n\032Delete"
  "NVMeNamespaceRequest\0222\n\014namespace_id\030\001 \001"
  "(\0132\034.opi_api.common.v1.ObjectKey\"R\n\032Upda"
  "teNVMeNamespaceRequest\0224\n\tnamespace\030\001 \001("
  "\0132!.opi_api.storage.v1.NVMeNamespace\"\203\001\n"
  "\030ListNVMeNamespaceRequest\0222\n\014subsystem_i"
  "d\030\001 \001(\0132\034.opi_api.common.v1.ObjectKey\0223\n"
  "\rcontroller_id\030\002 \001(\0132\034.opi_api.common.v1"
  ".ObjectKey\"Q\n\031ListNVMeNamespaceResponse\022"
  "4\n\tnamespace\030\001 \003(\0132!.opi_api.storage.v1."
  "NVMeNamespace\"M\n\027GetNVMeNamespaceRequest"
  "\0222\n\014namespace_id\030\001 \001(\0132\034.opi_api.common."
  "v1.ObjectKey\"O\n\031NVMeNamespaceStatsReques"
  "t\0222\n\014namespace_id\030\001 \001(\0132\034.opi_api.common"
  ".v1.ObjectKey\"U\n\032NVMeNamespaceStatsRespo"
  "nse\022(\n\002id\030\001 \001(\0132\034.opi_api.common.v1.Obje"
  "ctKey\022\r\n\005stats\030\002 \001(\t*\266\001\n\025NVMeNamespacePc"
  "iState\022)\n%NV_ME_NAMESPACE_PCI_STATE_UNSP"
  "ECIFIED\020\000\022%\n!NVME_NAMESPACE_PCI_STATE_DI"
  "SABLED\020\001\022$\n NVME_NAMESPACE_PCI_STATE_ENA"
  "BLED\020\002\022%\n!NVME_NAMESPACE_PCI_STATE_DELET"
  "ING\020\003*\240\001\n\031NVMeNamespacePciOperState\022.\n*N"
  "V_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIE"
  "D\020\000\022(\n$NVME_NAMESPACE_PCI_OPER_STATE_ONL"
  "INE\020\001\022)\n%NVME_NAMESPACE_PCI_OPER_STATE_O"
  "FFLINE\020\0022\260\023\n\023FrontendNvmeService\022\213\001\n\023Cre"
  "ateNVMeSubsystem\022..opi_api.storage.v1.Cr"
  "eateNVMeSubsystemRequest\032!.opi_api.stora"
  "ge.v1.NVMeSubsystem\"!\202\323\344\223\002\033\"\016/v1/subsyst"
  "ems:\tsubsystem\022\201\001\n\023DeleteNVMeSubsystem\022."
  ".opi_api.storage.v1.DeleteNVMeSubsystemR"
  "equest\032\026.google.protobuf.Empty\"\"\202\323\344\223\002\034*\032"
  "/v1/subsystems/{subsystem}\022\213\001\n\023UpdateNVM"
  "eSubsystem\022..opi_api.storage.v1.UpdateNV"
  "MeSubsystemRequest\032!.opi_api.storage.v1."
  "NVMeSubsystem\"!\202\323\344\223\002\0332\016/v1/subsystems:\ts"
  "ubsystem\022\210\001\n\021ListNVMeSubsystem\022,.opi_api"
  ".storage.v1.ListNVMeSubsystemRequest\032-.o"
  "pi_api.storage.v1.ListNVMeSubsystemRespo"
  "nse\"\026\202\323\344\223\002\020\022\016/v1/subsystems\022\206\001\n\020GetNVMeS"
  "ubsystem\022+.opi_api.storage.v1.GetNVMeSub"
  "systemRequest\032!.opi_api.storage.v1.NVMeS"
  "ubsystem\"\"\202\323\344\223\002\034\022\032/v1/subsystems/{subsys"
  "tem}\022u\n\022NVMeSubsystemStats\022-.opi_api.sto"
  "rage.v1.NVMeSubsystemStatsRequest\032..opi_"
  "api.storage.v1.NVMeSubsystemStatsRespons"
  "e\"\000\022\220\001\n\024CreateNVMeController\022/.opi_api.s"
  "torage.v1.CreateNVMeControllerRequest\032\"."
  "opi_api.storage.v1.NVMeController\"#\202\323\344\223\002"
  "\035\"\017/v1/controllers:\ncontroller\022\205\001\n\024Delet"
  "eNVMeController\022/.opi_api.storage.v1.Del"
  "eteNVMeControllerRequest\032\026.google.protob"
  "uf.Empty\"$\202\323\344\223\002\036*\034/v1/controllers/{contr"
  "oller}\022\220\001\n\024UpdateNVMeController\022/.opi_ap"
  "i.storage.v1.UpdateNVMeControllerRequest"
  "\032\".opi_api.storage.v1.NVMeController\"#\202\323"
  "\344\223\002\0352\017/v1/controllers:\ncontroller\022\214\001\n\022Li"
  "stNVMeController\022-.opi_api.storage.v1.Li"
  "stNVMeControllerRequest\032..opi_api.storag"
  "e.v1.ListNVMeControllerResponse\"\027\202\323\344\223\002\021\022"
  "\017/v1/controllers\022\213\001\n\021GetNVMeController\022,"
  ".opi_api.storage.v1.GetNVMeControllerReq"
  "uest\032\".opi_api.storage.v1.NVMeController"
  "\"$\202\323\344\223\002\036\022\034/v1/controllers/{controller}\022x"
  "\n\023NVMeControllerStats\022..opi_api.storage."
  "v1.NVMeControllerStatsRequest\032/.opi_api."
  "storage.v1.NVMeControllerStatsResponse\"\000"
  "\022\213\001\n\023CreateNVMeNamespace\022..opi_api.stora"
  "ge.v1.CreateNVMeNamespaceRequest\032!.opi_a"
  "pi.storage.v1.NVMeNamespace\"!\202\323\344\223\002\033\"\016/v1"
  "/namespaces:\tnamespace\022\201\001\n\023DeleteNVMeNam"
  "espace\022..opi_api.storage.v1.DeleteNVMeNa"
  "mespaceRequest\032\026.google.protobuf.Empty\"\""
  "\202\323\344\223\002\034*\032/v1/namespaces/{namespace}\022\213\001\n\023U"
  "pdateNVMeNamespace\022..opi_api.storage.v1."
  "UpdateNVMeNamespaceRequest\032!.opi_api.sto"
  "rage.v1.NVMeNamespace\"!\202\323\344\223\002\0332\016/v1/names"
  "paces:\tnamespace\022\210\001\n\021ListNVMeNamespace\022,"
  ".opi_api.storage.v1.ListNVMeNamespaceReq"
  "uest\032-.opi_api.storage.v1.ListNVMeNamesp"
  "aceResponse\"\026\202\323\344\223\002\020\022\016/v1/namespaces\022\206\001\n\020"
  "GetNVMeNamespace\022+.opi_api.storage.v1.Ge"
  "tNVMeNamespaceRequest\032!.opi_api.storage."
  "v1.NVMeNamespace\"\"\202\323\344\223\002\034\022\032/v1/namespaces"
  "/{namespace}\022u\n\022NVMeNamespaceStats\022-.opi"
  "_api.storage.v1.NVMeNamespaceStatsReques"
  "t\032..opi_api.storage.v1.NVMeNamespaceStat"
  "sResponse\"\000Bd\n\022opi_api.storage.v1B\025Front"
  "endNvmePcieProtoP\001Z5github.com/opiprojec"
  "t/opi-api/storage/v1alpha1/gen/gob\006proto"
  "3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps[5] = {
  &::descriptor_table_common_2eproto,
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_object_5fkey_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_frontend_5fnvme_5fpcie_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto = {
  false, false, 6521, descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto, "frontend_nvme_pcie.proto", 
  &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once, descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps, 5, 33,
  schemas, file_default_instances, TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets,
  file_level_metadata_frontend_5fnvme_5fpcie_2eproto, file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto, file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter() {
  return &descriptor_table_frontend_5fnvme_5fpcie_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_frontend_5fnvme_5fpcie_2eproto(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[0];
}
bool NVMeNamespacePciState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciOperState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[1];
}
bool NVMeNamespacePciOperState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NVMeSubsystem::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystemSpec& spec(const NVMeSubsystem* msg);
  static const ::opi_api::storage::v1::NVMeSubsystemStatus& status(const NVMeSubsystem* msg);
};

const ::opi_api::storage::v1::NVMeSubsystemSpec&
NVMeSubsystem::_Internal::spec(const NVMeSubsystem* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NVMeSubsystemStatus&
NVMeSubsystem::_Internal::status(const NVMeSubsystem* msg) {
  return *msg->status_;
}
NVMeSubsystem::NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystem)
}
NVMeSubsystem::NVMeSubsystem(const NVMeSubsystem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NVMeSubsystemSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NVMeSubsystemStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystem)
}

inline void NVMeSubsystem::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NVMeSubsystem::~NVMeSubsystem() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystem)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NVMeSubsystem::ArenaDtor(void* object) {
  NVMeSubsystem* _this = reinterpret_cast< NVMeSubsystem* >(object);
  (void)_this;
}
void NVMeSubsystem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystem::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystem)
  return target;
}

size_t NVMeSubsystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystem::GetClassData() const { return &_class_data_; }

void NVMeSubsystem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystem *>(to)->MergeFrom(
      static_cast<const NVMeSubsystem &>(from));
}


void NVMeSubsystem::MergeFrom(const NVMeSubsystem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NVMeSubsystemSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NVMeSubsystemStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystem::CopyFrom(const NVMeSubsystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystem::IsInitialized() const {
  return true;
}

void NVMeSubsystem::InternalSwap(NVMeSubsystem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeSubsystem, status_)
      + sizeof(NVMeSubsystem::status_)
      - PROTOBUF_FIELD_OFFSET(NVMeSubsystem, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystem::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[0]);
}

// ===================================================================

class NVMeSubsystemSpec::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeSubsystemSpec* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemSpec::_Internal::id(const NVMeSubsystemSpec* msg) {
  return *msg->id_;
}
void NVMeSubsystemSpec::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeSubsystemSpec::NVMeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemSpec)
}
NVMeSubsystemSpec::NVMeSubsystemSpec(const NVMeSubsystemSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nqn().empty()) {
    nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nqn(), 
      GetArenaForAllocation());
  }
  serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial_number(), 
      GetArenaForAllocation());
  }
  model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_number().empty()) {
    model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_number(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  max_namespaces_ = from.max_namespaces_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemSpec)
}

inline void NVMeSubsystemSpec::SharedCtor() {
nqn_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serial_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_number_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_namespaces_));
}

NVMeSubsystemSpec::~NVMeSubsystemSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nqn_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_number_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeSubsystemSpec::ArenaDtor(void* object) {
  NVMeSubsystemSpec* _this = reinterpret_cast< NVMeSubsystemSpec* >(object);
  (void)_this;
}
void NVMeSubsystemSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nqn_.ClearToEmpty();
  serial_number_.ClearToEmpty();
  model_number_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  max_namespaces_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nqn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nqn();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemSpec.nqn"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemSpec.serial_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_model_number();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemSpec.model_number"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_namespaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string nqn = 2;
  if (!this->_internal_nqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nqn().data(), static_cast<int>(this->_internal_nqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemSpec.nqn");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nqn(), target);
  }

  // string serial_number = 3;
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemSpec.serial_number");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_serial_number(), target);
  }

  // string model_number = 4;
  if (!this->_internal_model_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_number().data(), static_cast<int>(this->_internal_model_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemSpec.model_number");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_model_number(), target);
  }

  // int64 max_namespaces = 5;
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_max_namespaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemSpec)
  return target;
}

size_t NVMeSubsystemSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nqn = 2;
  if (!this->_internal_nqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nqn());
  }

  // string serial_number = 3;
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // string model_number = 4;
  if (!this->_internal_model_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_number());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // int64 max_namespaces = 5;
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemSpec::GetClassData() const { return &_class_data_; }

void NVMeSubsystemSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemSpec *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemSpec &>(from));
}


void NVMeSubsystemSpec::MergeFrom(const NVMeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nqn().empty()) {
    _internal_set_nqn(from._internal_nqn());
  }
  if (!from._internal_serial_number().empty()) {
    _internal_set_serial_number(from._internal_serial_number());
  }
  if (!from._internal_model_number().empty()) {
    _internal_set_model_number(from._internal_model_number());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_max_namespaces() != 0) {
    _internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemSpec::CopyFrom(const NVMeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemSpec::IsInitialized() const {
  return true;
}

void NVMeSubsystemSpec::InternalSwap(NVMeSubsystemSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nqn_, lhs_arena,
      &other->nqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_number_, lhs_arena,
      &other->serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_number_, lhs_arena,
      &other->model_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeSubsystemSpec, max_namespaces_)
      + sizeof(NVMeSubsystemSpec::max_namespaces_)
      - PROTOBUF_FIELD_OFFSET(NVMeSubsystemSpec, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[1]);
}

// ===================================================================

class NVMeSubsystemStatus::_Internal {
 public:
};

NVMeSubsystemStatus::NVMeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatus)
}
NVMeSubsystemStatus::NVMeSubsystemStatus(const NVMeSubsystemStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_revision().empty()) {
    firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_firmware_revision(), 
      GetArenaForAllocation());
  }
  fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fru_guid().empty()) {
    fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_fru_guid(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatus)
}

inline void NVMeSubsystemStatus::SharedCtor() {
firmware_revision_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fru_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NVMeSubsystemStatus::~NVMeSubsystemStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  firmware_revision_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fru_guid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NVMeSubsystemStatus::ArenaDtor(void* object) {
  NVMeSubsystemStatus* _this = reinterpret_cast< NVMeSubsystemStatus* >(object);
  (void)_this;
}
void NVMeSubsystemStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  firmware_revision_.ClearToEmpty();
  fru_guid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string firmware_revision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firmware_revision();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes fru_guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fru_guid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string firmware_revision = 1;
  if (!this->_internal_firmware_revision().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_revision().data(), static_cast<int>(this->_internal_firmware_revision().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firmware_revision(), target);
  }

  // bytes fru_guid = 2;
  if (!this->_internal_fru_guid().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fru_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatus)
  return target;
}

size_t NVMeSubsystemStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string firmware_revision = 1;
  if (!this->_internal_firmware_revision().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_revision());
  }

  // bytes fru_guid = 2;
  if (!this->_internal_fru_guid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fru_guid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatus::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatus *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatus &>(from));
}


void NVMeSubsystemStatus::MergeFrom(const NVMeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_firmware_revision().empty()) {
    _internal_set_firmware_revision(from._internal_firmware_revision());
  }
  if (!from._internal_fru_guid().empty()) {
    _internal_set_fru_guid(from._internal_fru_guid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatus::CopyFrom(const NVMeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatus::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatus::InternalSwap(NVMeSubsystemStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &firmware_revision_, lhs_arena,
      &other->firmware_revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &fru_guid_, lhs_arena,
      &other->fru_guid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[2]);
}

// ===================================================================

class NVMeController::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeControllerSpec& spec(const NVMeController* msg);
  static const ::opi_api::storage::v1::NVMeControllerStatus& status(const NVMeController* msg);
};

const ::opi_api::storage::v1::NVMeControllerSpec&
NVMeController::_Internal::spec(const NVMeController* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NVMeControllerStatus&
NVMeController::_Internal::status(const NVMeController* msg) {
  return *msg->status_;
}
NVMeController::NVMeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeController)
}
NVMeController::NVMeController(const NVMeController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NVMeControllerSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NVMeControllerStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeController)
}

inline void NVMeController::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NVMeController::~NVMeController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeController)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NVMeController::ArenaDtor(void* object) {
  NVMeController* _this = reinterpret_cast< NVMeController* >(object);
  (void)_this;
}
void NVMeController::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeController::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeController::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeControllerStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NVMeControllerStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeController)
  return target;
}

size_t NVMeController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NVMeControllerStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeController::GetClassData() const { return &_class_data_; }

void NVMeController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeController *>(to)->MergeFrom(
      static_cast<const NVMeController &>(from));
}


void NVMeController::MergeFrom(const NVMeController& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeController)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NVMeControllerSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NVMeControllerStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeController::CopyFrom(const NVMeController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeController::IsInitialized() const {
  return true;
}

void NVMeController::InternalSwap(NVMeController* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeController, status_)
      + sizeof(NVMeController::status_)
      - PROTOBUF_FIELD_OFFSET(NVMeController, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeController::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[3]);
}

// ===================================================================

class NVMeControllerSpec::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeControllerSpec* msg);
  static const ::opi_api::storage::v1::PciEndpoint& pcie_id(const NVMeControllerSpec* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerSpec::_Internal::id(const NVMeControllerSpec* msg) {
  return *msg->id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeControllerSpec::_Internal::subsystem_id(const NVMeControllerSpec* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::storage::v1::PciEndpoint&
NVMeControllerSpec::_Internal::pcie_id(const NVMeControllerSpec* msg) {
  return *msg->pcie_id_;
}
void NVMeControllerSpec::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void NVMeControllerSpec::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeControllerSpec::clear_pcie_id() {
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
}
NVMeControllerSpec::NVMeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerSpec)
}
NVMeControllerSpec::NVMeControllerSpec(const NVMeControllerSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_pcie_id()) {
    pcie_id_ = new ::opi_api::storage::v1::PciEndpoint(*from.pcie_id_);
  } else {
    pcie_id_ = nullptr;
  }
  ::memcpy(&nvme_controller_id_, &from.nvme_controller_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_namespaces_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerSpec)
}

inline void NVMeControllerSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_namespaces_) -
    reinterpret_cast<char*>(&id_)) + sizeof(max_namespaces_));
}

NVMeControllerSpec::~NVMeControllerSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete pcie_id_;
}

void NVMeControllerSpec::ArenaDtor(void* object) {
  NVMeControllerSpec* _this = reinterpret_cast< NVMeControllerSpec* >(object);
  (void)_this;
}
void NVMeControllerSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && pcie_id_ != nullptr) {
    delete pcie_id_;
  }
  pcie_id_ = nullptr;
  ::memset(&nvme_controller_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_namespaces_) -
      reinterpret_cast<char*>(&nvme_controller_id_)) + sizeof(max_namespaces_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nvme_controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          nvme_controller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey subsystem_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pcie_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_nsq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          max_nsq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_ncq = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          max_ncq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sqes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          sqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 cqes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          cqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_namespaces = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // int32 nvme_controller_id = 2;
  if (this->_internal_nvme_controller_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_nvme_controller_id(), target);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
  if (this->_internal_has_pcie_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::pcie_id(this), target, stream);
  }

  // int32 max_nsq = 5;
  if (this->_internal_max_nsq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_max_nsq(), target);
  }

  // int32 max_ncq = 6;
  if (this->_internal_max_ncq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_max_ncq(), target);
  }

  // int32 sqes = 7;
  if (this->_internal_sqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_sqes(), target);
  }

  // int32 cqes = 8;
  if (this->_internal_cqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_cqes(), target);
  }

  // int32 max_namespaces = 9;
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_max_namespaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerSpec)
  return target;
}

size_t NVMeControllerSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
  if (this->_internal_has_pcie_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pcie_id_);
  }

  // int32 nvme_controller_id = 2;
  if (this->_internal_nvme_controller_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nvme_controller_id());
  }

  // int32 max_nsq = 5;
  if (this->_internal_max_nsq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_nsq());
  }

  // int32 max_ncq = 6;
  if (this->_internal_max_ncq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_ncq());
  }

  // int32 sqes = 7;
  if (this->_internal_sqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sqes());
  }

  // int32 cqes = 8;
  if (this->_internal_cqes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cqes());
  }

  // int32 max_namespaces = 9;
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerSpec::GetClassData() const { return &_class_data_; }

void NVMeControllerSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerSpec *>(to)->MergeFrom(
      static_cast<const NVMeControllerSpec &>(from));
}


void NVMeControllerSpec::MergeFrom(const NVMeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_pcie_id()) {
    _internal_mutable_pcie_id()->::opi_api::storage::v1::PciEndpoint::MergeFrom(from._internal_pcie_id());
  }
  if (from._internal_nvme_controller_id() != 0) {
    _internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_max_nsq() != 0) {
    _internal_set_max_nsq(from._internal_max_nsq());
  }
  if (from._internal_max_ncq() != 0) {
    _internal_set_max_ncq(from._internal_max_ncq());
  }
  if (from._internal_sqes() != 0) {
    _internal_set_sqes(from._internal_sqes());
  }
  if (from._internal_cqes() != 0) {
    _internal_set_cqes(from._internal_cqes());
  }
  if (from._internal_max_namespaces() != 0) {
    _internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerSpec::CopyFrom(const NVMeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerSpec::IsInitialized() const {
  return true;
}

void NVMeControllerSpec::InternalSwap(NVMeControllerSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeControllerSpec, max_namespaces_)
      + sizeof(NVMeControllerSpec::max_namespaces_)
      - PROTOBUF_FIELD_OFFSET(NVMeControllerSpec, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[4]);
}

// ===================================================================

class NVMeControllerStatus::_Internal {
 public:
};

NVMeControllerStatus::NVMeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatus)
}
NVMeControllerStatus::NVMeControllerStatus(const NVMeControllerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  active_ = from.active_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatus)
}

inline void NVMeControllerStatus::SharedCtor() {
active_ = false;
}

NVMeControllerStatus::~NVMeControllerStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeControllerStatus::ArenaDtor(void* object) {
  NVMeControllerStatus* _this = reinterpret_cast< NVMeControllerStatus* >(object);
  (void)_this;
}
void NVMeControllerStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  active_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool active = 1;
  if (this->_internal_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatus)
  return target;
}

size_t NVMeControllerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool active = 1;
  if (this->_internal_active() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatus::GetClassData() const { return &_class_data_; }

void NVMeControllerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatus *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatus &>(from));
}


void NVMeControllerStatus::MergeFrom(const NVMeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_active() != 0) {
    _internal_set_active(from._internal_active());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatus::CopyFrom(const NVMeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatus::IsInitialized() const {
  return true;
}

void NVMeControllerStatus::InternalSwap(NVMeControllerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(active_, other->active_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[5]);
}

// ===================================================================

class NVMeNamespace::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespaceSpec& spec(const NVMeNamespace* msg);
  static const ::opi_api::storage::v1::NVMeNamespaceStatus& status(const NVMeNamespace* msg);
};

const ::opi_api::storage::v1::NVMeNamespaceSpec&
NVMeNamespace::_Internal::spec(const NVMeNamespace* msg) {
  return *msg->spec_;
}
const ::opi_api::storage::v1::NVMeNamespaceStatus&
NVMeNamespace::_Internal::status(const NVMeNamespace* msg) {
  return *msg->status_;
}
NVMeNamespace::NVMeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespace)
}
NVMeNamespace::NVMeNamespace(const NVMeNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::opi_api::storage::v1::NVMeNamespaceSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::opi_api::storage::v1::NVMeNamespaceStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespace)
}

inline void NVMeNamespace::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(status_));
}

NVMeNamespace::~NVMeNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespace)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete status_;
}

void NVMeNamespace::ArenaDtor(void* object) {
  NVMeNamespace* _this = reinterpret_cast< NVMeNamespace* >(object);
  (void)_this;
}
void NVMeNamespace::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
  if (this->_internal_has_spec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::spec(this), target, stream);
  }

  // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
  if (this->_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespace)
  return target;
}

size_t NVMeNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespace::GetClassData() const { return &_class_data_; }

void NVMeNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespace *>(to)->MergeFrom(
      static_cast<const NVMeNamespace &>(from));
}


void NVMeNamespace::MergeFrom(const NVMeNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::opi_api::storage::v1::NVMeNamespaceSpec::MergeFrom(from._internal_spec());
  }
  if (from._internal_has_status()) {
    _internal_mutable_status()->::opi_api::storage::v1::NVMeNamespaceStatus::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespace::CopyFrom(const NVMeNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespace::IsInitialized() const {
  return true;
}

void NVMeNamespace::InternalSwap(NVMeNamespace* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespace, status_)
      + sizeof(NVMeNamespace::status_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespace, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespace::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[6]);
}

// ===================================================================

class NVMeNamespaceSpec::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& controller_id(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::Uuid& uuid(const NVMeNamespaceSpec* msg);
  static const ::opi_api::common::v1::ObjectKey& volume_id(const NVMeNamespaceSpec* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::id(const NVMeNamespaceSpec* msg) {
  return *msg->id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::subsystem_id(const NVMeNamespaceSpec* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::controller_id(const NVMeNamespaceSpec* msg) {
  return *msg->controller_id_;
}
const ::opi_api::common::v1::Uuid&
NVMeNamespaceSpec::_Internal::uuid(const NVMeNamespaceSpec* msg) {
  return *msg->uuid_;
}
const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceSpec::_Internal::volume_id(const NVMeNamespaceSpec* msg) {
  return *msg->volume_id_;
}
void NVMeNamespaceSpec::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
void NVMeNamespaceSpec::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void NVMeNamespaceSpec::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
void NVMeNamespaceSpec::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
}
void NVMeNamespaceSpec::clear_volume_id() {
  if (GetArenaForAllocation() == nullptr && volume_id_ != nullptr) {
    delete volume_id_;
  }
  volume_id_ = nullptr;
}
NVMeNamespaceSpec::NVMeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceSpec)
}
NVMeNamespaceSpec::NVMeNamespaceSpec(const NVMeNamespaceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nguid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  if (from._internal_has_uuid()) {
    uuid_ = new ::opi_api::common::v1::Uuid(*from.uuid_);
  } else {
    uuid_ = nullptr;
  }
  if (from._internal_has_volume_id()) {
    volume_id_ = new ::opi_api::common::v1::ObjectKey(*from.volume_id_);
  } else {
    volume_id_ = nullptr;
  }
  ::memcpy(&block_size_, &from.block_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&pref_write_granularity_) -
    reinterpret_cast<char*>(&block_size_)) + sizeof(pref_write_granularity_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceSpec)
}

inline void NVMeNamespaceSpec::SharedCtor() {
nguid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pref_write_granularity_) -
    reinterpret_cast<char*>(&id_)) + sizeof(pref_write_granularity_));
}

NVMeNamespaceSpec::~NVMeNamespaceSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nguid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete controller_id_;
  if (this != internal_default_instance()) delete uuid_;
  if (this != internal_default_instance()) delete volume_id_;
}

void NVMeNamespaceSpec::ArenaDtor(void* object) {
  NVMeNamespaceSpec* _this = reinterpret_cast< NVMeNamespaceSpec* >(object);
  (void)_this;
}
void NVMeNamespaceSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nguid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && uuid_ != nullptr) {
    delete uuid_;
  }
  uuid_ = nullptr;
  if (GetArenaForAllocation() == nullptr && volume_id_ != nullptr) {
    delete volume_id_;
  }
  volume_id_ = nullptr;
  ::memset(&block_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pref_write_granularity_) -
      reinterpret_cast<char*>(&block_size_)) + sizeof(pref_write_granularity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey subsystem_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey controller_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 host_nsid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          host_nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 block_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 blocks_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          blocks_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_nguid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeNamespaceSpec.nguid"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey volume_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 optimal_write_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          optimal_write_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 pref_write_granularity = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          pref_write_granularity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::controller_id(this), target, stream);
  }

  // int32 host_nsid = 4;
  if (this->_internal_host_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_host_nsid(), target);
  }

  // int64 block_size = 5;
  if (this->_internal_block_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_block_size(), target);
  }

  // int64 blocks_count = 6;
  if (this->_internal_blocks_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_blocks_count(), target);
  }

  // string nguid = 7;
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeNamespaceSpec.nguid");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_nguid(), target);
  }

  // int64 eui64 = 8;
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 9;
  if (this->_internal_has_uuid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::uuid(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  if (this->_internal_has_volume_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::volume_id(this), target, stream);
  }

  // int32 optimal_write_size = 11;
  if (this->_internal_optimal_write_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_optimal_write_size(), target);
  }

  // int32 pref_write_granularity = 12;
  if (this->_internal_pref_write_granularity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_pref_write_granularity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceSpec)
  return target;
}

size_t NVMeNamespaceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nguid = 7;
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 3;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  // .opi_api.common.v1.Uuid uuid = 9;
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *uuid_);
  }

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  if (this->_internal_has_volume_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *volume_id_);
  }

  // int64 block_size = 5;
  if (this->_internal_block_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_block_size());
  }

  // int64 blocks_count = 6;
  if (this->_internal_blocks_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_blocks_count());
  }

  // int32 host_nsid = 4;
  if (this->_internal_host_nsid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_host_nsid());
  }

  // int32 optimal_write_size = 11;
  if (this->_internal_optimal_write_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_optimal_write_size());
  }

  // int64 eui64 = 8;
  if (this->_internal_eui64() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 pref_write_granularity = 12;
  if (this->_internal_pref_write_granularity() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_pref_write_granularity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceSpec::GetClassData() const { return &_class_data_; }

void NVMeNamespaceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceSpec *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceSpec &>(from));
}


void NVMeNamespaceSpec::MergeFrom(const NVMeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nguid().empty()) {
    _internal_set_nguid(from._internal_nguid());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  if (from._internal_has_uuid()) {
    _internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(from._internal_uuid());
  }
  if (from._internal_has_volume_id()) {
    _internal_mutable_volume_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_volume_id());
  }
  if (from._internal_block_size() != 0) {
    _internal_set_block_size(from._internal_block_size());
  }
  if (from._internal_blocks_count() != 0) {
    _internal_set_blocks_count(from._internal_blocks_count());
  }
  if (from._internal_host_nsid() != 0) {
    _internal_set_host_nsid(from._internal_host_nsid());
  }
  if (from._internal_optimal_write_size() != 0) {
    _internal_set_optimal_write_size(from._internal_optimal_write_size());
  }
  if (from._internal_eui64() != 0) {
    _internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_pref_write_granularity() != 0) {
    _internal_set_pref_write_granularity(from._internal_pref_write_granularity());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceSpec::CopyFrom(const NVMeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceSpec::IsInitialized() const {
  return true;
}

void NVMeNamespaceSpec::InternalSwap(NVMeNamespaceSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nguid_, lhs_arena,
      &other->nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespaceSpec, pref_write_granularity_)
      + sizeof(NVMeNamespaceSpec::pref_write_granularity_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespaceSpec, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[7]);
}

// ===================================================================

class NVMeNamespaceStatus::_Internal {
 public:
};

NVMeNamespaceStatus::NVMeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatus)
}
NVMeNamespaceStatus::NVMeNamespaceStatus(const NVMeNamespaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&pci_state_, &from.pci_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&pci_oper_state_) -
    reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatus)
}

inline void NVMeNamespaceStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pci_state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pci_oper_state_) -
    reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
}

NVMeNamespaceStatus::~NVMeNamespaceStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NVMeNamespaceStatus::ArenaDtor(void* object) {
  NVMeNamespaceStatus* _this = reinterpret_cast< NVMeNamespaceStatus* >(object);
  (void)_this;
}
void NVMeNamespaceStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&pci_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pci_oper_state_) -
      reinterpret_cast<char*>(&pci_state_)) + sizeof(pci_oper_state_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_state(static_cast<::opi_api::storage::v1::NVMeNamespacePciState>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_oper_state(static_cast<::opi_api::storage::v1::NVMeNamespacePciOperState>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
  if (this->_internal_pci_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pci_state(), target);
  }

  // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
  if (this->_internal_pci_oper_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_pci_oper_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatus)
  return target;
}

size_t NVMeNamespaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
  if (this->_internal_pci_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pci_state());
  }

  // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
  if (this->_internal_pci_oper_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pci_oper_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatus::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatus *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatus &>(from));
}


void NVMeNamespaceStatus::MergeFrom(const NVMeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pci_state() != 0) {
    _internal_set_pci_state(from._internal_pci_state());
  }
  if (from._internal_pci_oper_state() != 0) {
    _internal_set_pci_oper_state(from._internal_pci_oper_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatus::CopyFrom(const NVMeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatus::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatus::InternalSwap(NVMeNamespaceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NVMeNamespaceStatus, pci_oper_state_)
      + sizeof(NVMeNamespaceStatus::pci_oper_state_)
      - PROTOBUF_FIELD_OFFSET(NVMeNamespaceStatus, pci_state_)>(
          reinterpret_cast<char*>(&pci_state_),
          reinterpret_cast<char*>(&other->pci_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[8]);
}

// ===================================================================

class CreateNVMeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystem& subsystem(const CreateNVMeSubsystemRequest* msg);
};

const ::opi_api::storage::v1::NVMeSubsystem&
CreateNVMeSubsystemRequest::_Internal::subsystem(const CreateNVMeSubsystemRequest* msg) {
  return *msg->subsystem_;
}
CreateNVMeSubsystemRequest::CreateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNVMeSubsystemRequest)
}
CreateNVMeSubsystemRequest::CreateNVMeSubsystemRequest(const CreateNVMeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem()) {
    subsystem_ = new ::opi_api::storage::v1::NVMeSubsystem(*from.subsystem_);
  } else {
    subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNVMeSubsystemRequest)
}

inline void CreateNVMeSubsystemRequest::SharedCtor() {
subsystem_ = nullptr;
}

CreateNVMeSubsystemRequest::~CreateNVMeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateNVMeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_;
}

void CreateNVMeSubsystemRequest::ArenaDtor(void* object) {
  CreateNVMeSubsystemRequest* _this = reinterpret_cast< CreateNVMeSubsystemRequest* >(object);
  (void)_this;
}
void CreateNVMeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateNVMeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNVMeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNVMeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNVMeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  return target;
}

size_t CreateNVMeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNVMeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateNVMeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNVMeSubsystemRequest::GetClassData() const { return &_class_data_; }

void CreateNVMeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateNVMeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const CreateNVMeSubsystemRequest &>(from));
}


void CreateNVMeSubsystemRequest::MergeFrom(const CreateNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem()) {
    _internal_mutable_subsystem()->::opi_api::storage::v1::NVMeSubsystem::MergeFrom(from._internal_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNVMeSubsystemRequest::CopyFrom(const CreateNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNVMeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNVMeSubsystemRequest::IsInitialized() const {
  return true;
}

void CreateNVMeSubsystemRequest::InternalSwap(CreateNVMeSubsystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_, other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNVMeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[9]);
}

// ===================================================================

class DeleteNVMeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const DeleteNVMeSubsystemRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
DeleteNVMeSubsystemRequest::_Internal::subsystem_id(const DeleteNVMeSubsystemRequest* msg) {
  return *msg->subsystem_id_;
}
void DeleteNVMeSubsystemRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
DeleteNVMeSubsystemRequest::DeleteNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
}
DeleteNVMeSubsystemRequest::DeleteNVMeSubsystemRequest(const DeleteNVMeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
}

inline void DeleteNVMeSubsystemRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

DeleteNVMeSubsystemRequest::~DeleteNVMeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNVMeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void DeleteNVMeSubsystemRequest::ArenaDtor(void* object) {
  DeleteNVMeSubsystemRequest* _this = reinterpret_cast< DeleteNVMeSubsystemRequest* >(object);
  (void)_this;
}
void DeleteNVMeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNVMeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNVMeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNVMeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNVMeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  return target;
}

size_t DeleteNVMeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNVMeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNVMeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNVMeSubsystemRequest::GetClassData() const { return &_class_data_; }

void DeleteNVMeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNVMeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const DeleteNVMeSubsystemRequest &>(from));
}


void DeleteNVMeSubsystemRequest::MergeFrom(const DeleteNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNVMeSubsystemRequest::CopyFrom(const DeleteNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNVMeSubsystemRequest::IsInitialized() const {
  return true;
}

void DeleteNVMeSubsystemRequest::InternalSwap(DeleteNVMeSubsystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNVMeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[10]);
}

// ===================================================================

class UpdateNVMeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeSubsystem& subsystem(const UpdateNVMeSubsystemRequest* msg);
};

const ::opi_api::storage::v1::NVMeSubsystem&
UpdateNVMeSubsystemRequest::_Internal::subsystem(const UpdateNVMeSubsystemRequest* msg) {
  return *msg->subsystem_;
}
UpdateNVMeSubsystemRequest::UpdateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
}
UpdateNVMeSubsystemRequest::UpdateNVMeSubsystemRequest(const UpdateNVMeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem()) {
    subsystem_ = new ::opi_api::storage::v1::NVMeSubsystem(*from.subsystem_);
  } else {
    subsystem_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
}

inline void UpdateNVMeSubsystemRequest::SharedCtor() {
subsystem_ = nullptr;
}

UpdateNVMeSubsystemRequest::~UpdateNVMeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNVMeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_;
}

void UpdateNVMeSubsystemRequest::ArenaDtor(void* object) {
  UpdateNVMeSubsystemRequest* _this = reinterpret_cast< UpdateNVMeSubsystemRequest* >(object);
  (void)_this;
}
void UpdateNVMeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNVMeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNVMeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_ != nullptr) {
    delete subsystem_;
  }
  subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNVMeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNVMeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  return target;
}

size_t UpdateNVMeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  if (this->_internal_has_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNVMeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNVMeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNVMeSubsystemRequest::GetClassData() const { return &_class_data_; }

void UpdateNVMeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNVMeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const UpdateNVMeSubsystemRequest &>(from));
}


void UpdateNVMeSubsystemRequest::MergeFrom(const UpdateNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem()) {
    _internal_mutable_subsystem()->::opi_api::storage::v1::NVMeSubsystem::MergeFrom(from._internal_subsystem());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNVMeSubsystemRequest::CopyFrom(const UpdateNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNVMeSubsystemRequest::IsInitialized() const {
  return true;
}

void UpdateNVMeSubsystemRequest::InternalSwap(UpdateNVMeSubsystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_, other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNVMeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[11]);
}

// ===================================================================

class ListNVMeSubsystemRequest::_Internal {
 public:
};

ListNVMeSubsystemRequest::ListNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNVMeSubsystemRequest)
}
ListNVMeSubsystemRequest::ListNVMeSubsystemRequest(const ListNVMeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNVMeSubsystemRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNVMeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNVMeSubsystemRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ListNVMeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[12]);
}

// ===================================================================

class ListNVMeSubsystemResponse::_Internal {
 public:
};

ListNVMeSubsystemResponse::ListNVMeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  subsystem_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNVMeSubsystemResponse)
}
ListNVMeSubsystemResponse::ListNVMeSubsystemResponse(const ListNVMeSubsystemResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      subsystem_(from.subsystem_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNVMeSubsystemResponse)
}

inline void ListNVMeSubsystemResponse::SharedCtor() {
}

ListNVMeSubsystemResponse::~ListNVMeSubsystemResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNVMeSubsystemResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNVMeSubsystemResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ListNVMeSubsystemResponse::ArenaDtor(void* object) {
  ListNVMeSubsystemResponse* _this = reinterpret_cast< ListNVMeSubsystemResponse* >(object);
  (void)_this;
}
void ListNVMeSubsystemResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNVMeSubsystemResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNVMeSubsystemResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNVMeSubsystemResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subsystem_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNVMeSubsystemResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subsystem(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNVMeSubsystemResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNVMeSubsystemResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_subsystem_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_subsystem(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNVMeSubsystemResponse)
  return target;
}

size_t ListNVMeSubsystemResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNVMeSubsystemResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeSubsystem subsystem = 1;
  total_size += 1UL * this->_internal_subsystem_size();
  for (const auto& msg : this->subsystem_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNVMeSubsystemResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNVMeSubsystemResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNVMeSubsystemResponse::GetClassData() const { return &_class_data_; }

void ListNVMeSubsystemResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNVMeSubsystemResponse *>(to)->MergeFrom(
      static_cast<const ListNVMeSubsystemResponse &>(from));
}


void ListNVMeSubsystemResponse::MergeFrom(const ListNVMeSubsystemResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNVMeSubsystemResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  subsystem_.MergeFrom(from.subsystem_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNVMeSubsystemResponse::CopyFrom(const ListNVMeSubsystemResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNVMeSubsystemResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNVMeSubsystemResponse::IsInitialized() const {
  return true;
}

void ListNVMeSubsystemResponse::InternalSwap(ListNVMeSubsystemResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  subsystem_.InternalSwap(&other->subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNVMeSubsystemResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[13]);
}

// ===================================================================

class GetNVMeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const GetNVMeSubsystemRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
GetNVMeSubsystemRequest::_Internal::subsystem_id(const GetNVMeSubsystemRequest* msg) {
  return *msg->subsystem_id_;
}
void GetNVMeSubsystemRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
GetNVMeSubsystemRequest::GetNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNVMeSubsystemRequest)
}
GetNVMeSubsystemRequest::GetNVMeSubsystemRequest(const GetNVMeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNVMeSubsystemRequest)
}

inline void GetNVMeSubsystemRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

GetNVMeSubsystemRequest::~GetNVMeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNVMeSubsystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetNVMeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void GetNVMeSubsystemRequest::ArenaDtor(void* object) {
  GetNVMeSubsystemRequest* _this = reinterpret_cast< GetNVMeSubsystemRequest* >(object);
  (void)_this;
}
void GetNVMeSubsystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetNVMeSubsystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetNVMeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNVMeSubsystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNVMeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNVMeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNVMeSubsystemRequest)
  return target;
}

size_t GetNVMeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNVMeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNVMeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetNVMeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNVMeSubsystemRequest::GetClassData() const { return &_class_data_; }

void GetNVMeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetNVMeSubsystemRequest *>(to)->MergeFrom(
      static_cast<const GetNVMeSubsystemRequest &>(from));
}


void GetNVMeSubsystemRequest::MergeFrom(const GetNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNVMeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNVMeSubsystemRequest::CopyFrom(const GetNVMeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNVMeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNVMeSubsystemRequest::IsInitialized() const {
  return true;
}

void GetNVMeSubsystemRequest::InternalSwap(GetNVMeSubsystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNVMeSubsystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[14]);
}

// ===================================================================

class NVMeSubsystemStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const NVMeSubsystemStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeSubsystemStatsRequest::_Internal::subsystem_id(const NVMeSubsystemStatsRequest* msg) {
  return *msg->subsystem_id_;
}
void NVMeSubsystemStatsRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
}
NVMeSubsystemStatsRequest::NVMeSubsystemStatsRequest(const NVMeSubsystemStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
}

inline void NVMeSubsystemStatsRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

NVMeSubsystemStatsRequest::~NVMeSubsystemStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void NVMeSubsystemStatsRequest::ArenaDtor(void* object) {
  NVMeSubsystemStatsRequest* _this = reinterpret_cast< NVMeSubsystemStatsRequest* >(object);
  (void)_this;
}
void NVMeSubsystemStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  return target;
}

size_t NVMeSubsystemStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatsRequest &>(from));
}


void NVMeSubsystemStatsRequest::MergeFrom(const NVMeSubsystemStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatsRequest::CopyFrom(const NVMeSubsystemStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatsRequest::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatsRequest::InternalSwap(NVMeSubsystemStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[15]);
}

// ===================================================================

class NVMeSubsystemStatsResponse::_Internal {
 public:
};

NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
}
NVMeSubsystemStatsResponse::NVMeSubsystemStatsResponse(const NVMeSubsystemStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
}

inline void NVMeSubsystemStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NVMeSubsystemStatsResponse::~NVMeSubsystemStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeSubsystemStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NVMeSubsystemStatsResponse::ArenaDtor(void* object) {
  NVMeSubsystemStatsResponse* _this = reinterpret_cast< NVMeSubsystemStatsResponse* >(object);
  (void)_this;
}
void NVMeSubsystemStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeSubsystemStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeSubsystemStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeSubsystemStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeSubsystemStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeSubsystemStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string stats = 1;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeSubsystemStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  return target;
}

size_t NVMeSubsystemStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 1;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeSubsystemStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeSubsystemStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeSubsystemStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeSubsystemStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeSubsystemStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeSubsystemStatsResponse &>(from));
}


void NVMeSubsystemStatsResponse::MergeFrom(const NVMeSubsystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeSubsystemStatsResponse::CopyFrom(const NVMeSubsystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeSubsystemStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeSubsystemStatsResponse::IsInitialized() const {
  return true;
}

void NVMeSubsystemStatsResponse::InternalSwap(NVMeSubsystemStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeSubsystemStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[16]);
}

// ===================================================================

class CreateNVMeControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeController& controller(const CreateNVMeControllerRequest* msg);
};

const ::opi_api::storage::v1::NVMeController&
CreateNVMeControllerRequest::_Internal::controller(const CreateNVMeControllerRequest* msg) {
  return *msg->controller_;
}
CreateNVMeControllerRequest::CreateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNVMeControllerRequest)
}
CreateNVMeControllerRequest::CreateNVMeControllerRequest(const CreateNVMeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::opi_api::storage::v1::NVMeController(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNVMeControllerRequest)
}

inline void CreateNVMeControllerRequest::SharedCtor() {
controller_ = nullptr;
}

CreateNVMeControllerRequest::~CreateNVMeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNVMeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateNVMeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_;
}

void CreateNVMeControllerRequest::ArenaDtor(void* object) {
  CreateNVMeControllerRequest* _this = reinterpret_cast< CreateNVMeControllerRequest* >(object);
  (void)_this;
}
void CreateNVMeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateNVMeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNVMeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNVMeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNVMeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNVMeControllerRequest)
  return target;
}

size_t CreateNVMeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNVMeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNVMeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateNVMeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNVMeControllerRequest::GetClassData() const { return &_class_data_; }

void CreateNVMeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateNVMeControllerRequest *>(to)->MergeFrom(
      static_cast<const CreateNVMeControllerRequest &>(from));
}


void CreateNVMeControllerRequest::MergeFrom(const CreateNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNVMeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller()) {
    _internal_mutable_controller()->::opi_api::storage::v1::NVMeController::MergeFrom(from._internal_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNVMeControllerRequest::CopyFrom(const CreateNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNVMeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNVMeControllerRequest::IsInitialized() const {
  return true;
}

void CreateNVMeControllerRequest::InternalSwap(CreateNVMeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_, other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNVMeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[17]);
}

// ===================================================================

class DeleteNVMeControllerRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& controller_id(const DeleteNVMeControllerRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
DeleteNVMeControllerRequest::_Internal::controller_id(const DeleteNVMeControllerRequest* msg) {
  return *msg->controller_id_;
}
void DeleteNVMeControllerRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
DeleteNVMeControllerRequest::DeleteNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNVMeControllerRequest)
}
DeleteNVMeControllerRequest::DeleteNVMeControllerRequest(const DeleteNVMeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNVMeControllerRequest)
}

inline void DeleteNVMeControllerRequest::SharedCtor() {
controller_id_ = nullptr;
}

DeleteNVMeControllerRequest::~DeleteNVMeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNVMeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNVMeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_id_;
}

void DeleteNVMeControllerRequest::ArenaDtor(void* object) {
  DeleteNVMeControllerRequest* _this = reinterpret_cast< DeleteNVMeControllerRequest* >(object);
  (void)_this;
}
void DeleteNVMeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNVMeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNVMeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNVMeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNVMeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNVMeControllerRequest)
  return target;
}

size_t DeleteNVMeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNVMeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNVMeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNVMeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNVMeControllerRequest::GetClassData() const { return &_class_data_; }

void DeleteNVMeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNVMeControllerRequest *>(to)->MergeFrom(
      static_cast<const DeleteNVMeControllerRequest &>(from));
}


void DeleteNVMeControllerRequest::MergeFrom(const DeleteNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNVMeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNVMeControllerRequest::CopyFrom(const DeleteNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNVMeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNVMeControllerRequest::IsInitialized() const {
  return true;
}

void DeleteNVMeControllerRequest::InternalSwap(DeleteNVMeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_id_, other->controller_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNVMeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[18]);
}

// ===================================================================

class UpdateNVMeControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeController& controller(const UpdateNVMeControllerRequest* msg);
};

const ::opi_api::storage::v1::NVMeController&
UpdateNVMeControllerRequest::_Internal::controller(const UpdateNVMeControllerRequest* msg) {
  return *msg->controller_;
}
UpdateNVMeControllerRequest::UpdateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNVMeControllerRequest)
}
UpdateNVMeControllerRequest::UpdateNVMeControllerRequest(const UpdateNVMeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::opi_api::storage::v1::NVMeController(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNVMeControllerRequest)
}

inline void UpdateNVMeControllerRequest::SharedCtor() {
controller_ = nullptr;
}

UpdateNVMeControllerRequest::~UpdateNVMeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNVMeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNVMeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_;
}

void UpdateNVMeControllerRequest::ArenaDtor(void* object) {
  UpdateNVMeControllerRequest* _this = reinterpret_cast< UpdateNVMeControllerRequest* >(object);
  (void)_this;
}
void UpdateNVMeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNVMeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNVMeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_ != nullptr) {
    delete controller_;
  }
  controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNVMeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNVMeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNVMeControllerRequest)
  return target;
}

size_t UpdateNVMeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNVMeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeController controller = 1;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNVMeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNVMeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNVMeControllerRequest::GetClassData() const { return &_class_data_; }

void UpdateNVMeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNVMeControllerRequest *>(to)->MergeFrom(
      static_cast<const UpdateNVMeControllerRequest &>(from));
}


void UpdateNVMeControllerRequest::MergeFrom(const UpdateNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNVMeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller()) {
    _internal_mutable_controller()->::opi_api::storage::v1::NVMeController::MergeFrom(from._internal_controller());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNVMeControllerRequest::CopyFrom(const UpdateNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNVMeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNVMeControllerRequest::IsInitialized() const {
  return true;
}

void UpdateNVMeControllerRequest::InternalSwap(UpdateNVMeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_, other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNVMeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[19]);
}

// ===================================================================

class ListNVMeControllerRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const ListNVMeControllerRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
ListNVMeControllerRequest::_Internal::subsystem_id(const ListNVMeControllerRequest* msg) {
  return *msg->subsystem_id_;
}
void ListNVMeControllerRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
ListNVMeControllerRequest::ListNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNVMeControllerRequest)
}
ListNVMeControllerRequest::ListNVMeControllerRequest(const ListNVMeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNVMeControllerRequest)
}

inline void ListNVMeControllerRequest::SharedCtor() {
subsystem_id_ = nullptr;
}

ListNVMeControllerRequest::~ListNVMeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNVMeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNVMeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
}

void ListNVMeControllerRequest::ArenaDtor(void* object) {
  ListNVMeControllerRequest* _this = reinterpret_cast< ListNVMeControllerRequest* >(object);
  (void)_this;
}
void ListNVMeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNVMeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNVMeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNVMeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNVMeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNVMeControllerRequest)
  return target;
}

size_t ListNVMeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNVMeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNVMeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNVMeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNVMeControllerRequest::GetClassData() const { return &_class_data_; }

void ListNVMeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNVMeControllerRequest *>(to)->MergeFrom(
      static_cast<const ListNVMeControllerRequest &>(from));
}


void ListNVMeControllerRequest::MergeFrom(const ListNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNVMeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNVMeControllerRequest::CopyFrom(const ListNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNVMeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNVMeControllerRequest::IsInitialized() const {
  return true;
}

void ListNVMeControllerRequest::InternalSwap(ListNVMeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(subsystem_id_, other->subsystem_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNVMeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[20]);
}

// ===================================================================

class ListNVMeControllerResponse::_Internal {
 public:
};

ListNVMeControllerResponse::ListNVMeControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  controller_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNVMeControllerResponse)
}
ListNVMeControllerResponse::ListNVMeControllerResponse(const ListNVMeControllerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      controller_(from.controller_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNVMeControllerResponse)
}

inline void ListNVMeControllerResponse::SharedCtor() {
}

ListNVMeControllerResponse::~ListNVMeControllerResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNVMeControllerResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNVMeControllerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ListNVMeControllerResponse::ArenaDtor(void* object) {
  ListNVMeControllerResponse* _this = reinterpret_cast< ListNVMeControllerResponse* >(object);
  (void)_this;
}
void ListNVMeControllerResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNVMeControllerResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNVMeControllerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNVMeControllerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  controller_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNVMeControllerResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeController controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_controller(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNVMeControllerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNVMeControllerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_controller_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_controller(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNVMeControllerResponse)
  return target;
}

size_t ListNVMeControllerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNVMeControllerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeController controller = 1;
  total_size += 1UL * this->_internal_controller_size();
  for (const auto& msg : this->controller_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNVMeControllerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNVMeControllerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNVMeControllerResponse::GetClassData() const { return &_class_data_; }

void ListNVMeControllerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNVMeControllerResponse *>(to)->MergeFrom(
      static_cast<const ListNVMeControllerResponse &>(from));
}


void ListNVMeControllerResponse::MergeFrom(const ListNVMeControllerResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNVMeControllerResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  controller_.MergeFrom(from.controller_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNVMeControllerResponse::CopyFrom(const ListNVMeControllerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNVMeControllerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNVMeControllerResponse::IsInitialized() const {
  return true;
}

void ListNVMeControllerResponse::InternalSwap(ListNVMeControllerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  controller_.InternalSwap(&other->controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNVMeControllerResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[21]);
}

// ===================================================================

class GetNVMeControllerRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& controller_id(const GetNVMeControllerRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
GetNVMeControllerRequest::_Internal::controller_id(const GetNVMeControllerRequest* msg) {
  return *msg->controller_id_;
}
void GetNVMeControllerRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
GetNVMeControllerRequest::GetNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNVMeControllerRequest)
}
GetNVMeControllerRequest::GetNVMeControllerRequest(const GetNVMeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNVMeControllerRequest)
}

inline void GetNVMeControllerRequest::SharedCtor() {
controller_id_ = nullptr;
}

GetNVMeControllerRequest::~GetNVMeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNVMeControllerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetNVMeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete controller_id_;
}

void GetNVMeControllerRequest::ArenaDtor(void* object) {
  GetNVMeControllerRequest* _this = reinterpret_cast< GetNVMeControllerRequest* >(object);
  (void)_this;
}
void GetNVMeControllerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetNVMeControllerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetNVMeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNVMeControllerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey controller_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNVMeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNVMeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNVMeControllerRequest)
  return target;
}

size_t GetNVMeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNVMeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey controller_id = 1;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNVMeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetNVMeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNVMeControllerRequest::GetClassData() const { return &_class_data_; }

void GetNVMeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetNVMeControllerRequest *>(to)->MergeFrom(
      static_cast<const GetNVMeControllerRequest &>(from));
}


void GetNVMeControllerRequest::MergeFrom(const GetNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNVMeControllerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNVMeControllerRequest::CopyFrom(const GetNVMeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNVMeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNVMeControllerRequest::IsInitialized() const {
  return true;
}

void GetNVMeControllerRequest::InternalSwap(GetNVMeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(controller_id_, other->controller_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNVMeControllerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[22]);
}

// ===================================================================

class NVMeControllerStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerStatsRequest::_Internal::id(const NVMeControllerStatsRequest* msg) {
  return *msg->id_;
}
void NVMeControllerStatsRequest::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeControllerStatsRequest::NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatsRequest)
}
NVMeControllerStatsRequest::NVMeControllerStatsRequest(const NVMeControllerStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatsRequest)
}

inline void NVMeControllerStatsRequest::SharedCtor() {
id_ = nullptr;
}

NVMeControllerStatsRequest::~NVMeControllerStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete id_;
}

void NVMeControllerStatsRequest::ArenaDtor(void* object) {
  NVMeControllerStatsRequest* _this = reinterpret_cast< NVMeControllerStatsRequest* >(object);
  (void)_this;
}
void NVMeControllerStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatsRequest)
  return target;
}

size_t NVMeControllerStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeControllerStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatsRequest &>(from));
}


void NVMeControllerStatsRequest::MergeFrom(const NVMeControllerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatsRequest::CopyFrom(const NVMeControllerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatsRequest::IsInitialized() const {
  return true;
}

void NVMeControllerStatsRequest::InternalSwap(NVMeControllerStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[23]);
}

// ===================================================================

class NVMeControllerStatsResponse::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeControllerStatsResponse* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeControllerStatsResponse::_Internal::id(const NVMeControllerStatsResponse* msg) {
  return *msg->id_;
}
void NVMeControllerStatsResponse::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeControllerStatsResponse::NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeControllerStatsResponse)
}
NVMeControllerStatsResponse::NVMeControllerStatsResponse(const NVMeControllerStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeControllerStatsResponse)
}

inline void NVMeControllerStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = nullptr;
}

NVMeControllerStatsResponse::~NVMeControllerStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeControllerStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeControllerStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeControllerStatsResponse::ArenaDtor(void* object) {
  NVMeControllerStatsResponse* _this = reinterpret_cast< NVMeControllerStatsResponse* >(object);
  (void)_this;
}
void NVMeControllerStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeControllerStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeControllerStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeControllerStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeControllerStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeControllerStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeControllerStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeControllerStatsResponse)
  return target;
}

size_t NVMeControllerStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeControllerStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeControllerStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeControllerStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeControllerStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeControllerStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeControllerStatsResponse &>(from));
}


void NVMeControllerStatsResponse::MergeFrom(const NVMeControllerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeControllerStatsResponse::CopyFrom(const NVMeControllerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeControllerStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeControllerStatsResponse::IsInitialized() const {
  return true;
}

void NVMeControllerStatsResponse::InternalSwap(NVMeControllerStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeControllerStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[24]);
}

// ===================================================================

class CreateNVMeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespace& namespace_(const CreateNVMeNamespaceRequest* msg);
};

const ::opi_api::storage::v1::NVMeNamespace&
CreateNVMeNamespaceRequest::_Internal::namespace_(const CreateNVMeNamespaceRequest* msg) {
  return *msg->namespace__;
}
CreateNVMeNamespaceRequest::CreateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNVMeNamespaceRequest)
}
CreateNVMeNamespaceRequest::CreateNVMeNamespaceRequest(const CreateNVMeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_()) {
    namespace__ = new ::opi_api::storage::v1::NVMeNamespace(*from.namespace__);
  } else {
    namespace__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNVMeNamespaceRequest)
}

inline void CreateNVMeNamespaceRequest::SharedCtor() {
namespace__ = nullptr;
}

CreateNVMeNamespaceRequest::~CreateNVMeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CreateNVMeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace__;
}

void CreateNVMeNamespaceRequest::ArenaDtor(void* object) {
  CreateNVMeNamespaceRequest* _this = reinterpret_cast< CreateNVMeNamespaceRequest* >(object);
  (void)_this;
}
void CreateNVMeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CreateNVMeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNVMeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNVMeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNVMeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  return target;
}

size_t CreateNVMeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNVMeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateNVMeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNVMeNamespaceRequest::GetClassData() const { return &_class_data_; }

void CreateNVMeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateNVMeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const CreateNVMeNamespaceRequest &>(from));
}


void CreateNVMeNamespaceRequest::MergeFrom(const CreateNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_()) {
    _internal_mutable_namespace_()->::opi_api::storage::v1::NVMeNamespace::MergeFrom(from._internal_namespace_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNVMeNamespaceRequest::CopyFrom(const CreateNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNVMeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNVMeNamespaceRequest::IsInitialized() const {
  return true;
}

void CreateNVMeNamespaceRequest::InternalSwap(CreateNVMeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace__, other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNVMeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[25]);
}

// ===================================================================

class DeleteNVMeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const DeleteNVMeNamespaceRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
DeleteNVMeNamespaceRequest::_Internal::namespace_id(const DeleteNVMeNamespaceRequest* msg) {
  return *msg->namespace_id_;
}
void DeleteNVMeNamespaceRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
DeleteNVMeNamespaceRequest::DeleteNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
}
DeleteNVMeNamespaceRequest::DeleteNVMeNamespaceRequest(const DeleteNVMeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
}

inline void DeleteNVMeNamespaceRequest::SharedCtor() {
namespace_id_ = nullptr;
}

DeleteNVMeNamespaceRequest::~DeleteNVMeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNVMeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void DeleteNVMeNamespaceRequest::ArenaDtor(void* object) {
  DeleteNVMeNamespaceRequest* _this = reinterpret_cast< DeleteNVMeNamespaceRequest* >(object);
  (void)_this;
}
void DeleteNVMeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNVMeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNVMeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNVMeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNVMeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  return target;
}

size_t DeleteNVMeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNVMeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNVMeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNVMeNamespaceRequest::GetClassData() const { return &_class_data_; }

void DeleteNVMeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNVMeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const DeleteNVMeNamespaceRequest &>(from));
}


void DeleteNVMeNamespaceRequest::MergeFrom(const DeleteNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNVMeNamespaceRequest::CopyFrom(const DeleteNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNVMeNamespaceRequest::IsInitialized() const {
  return true;
}

void DeleteNVMeNamespaceRequest::InternalSwap(DeleteNVMeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNVMeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[26]);
}

// ===================================================================

class UpdateNVMeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NVMeNamespace& namespace_(const UpdateNVMeNamespaceRequest* msg);
};

const ::opi_api::storage::v1::NVMeNamespace&
UpdateNVMeNamespaceRequest::_Internal::namespace_(const UpdateNVMeNamespaceRequest* msg) {
  return *msg->namespace__;
}
UpdateNVMeNamespaceRequest::UpdateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
}
UpdateNVMeNamespaceRequest::UpdateNVMeNamespaceRequest(const UpdateNVMeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_()) {
    namespace__ = new ::opi_api::storage::v1::NVMeNamespace(*from.namespace__);
  } else {
    namespace__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
}

inline void UpdateNVMeNamespaceRequest::SharedCtor() {
namespace__ = nullptr;
}

UpdateNVMeNamespaceRequest::~UpdateNVMeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNVMeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace__;
}

void UpdateNVMeNamespaceRequest::ArenaDtor(void* object) {
  UpdateNVMeNamespaceRequest* _this = reinterpret_cast< UpdateNVMeNamespaceRequest* >(object);
  (void)_this;
}
void UpdateNVMeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNVMeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNVMeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace__ != nullptr) {
    delete namespace__;
  }
  namespace__ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNVMeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNVMeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  return target;
}

size_t UpdateNVMeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NVMeNamespace namespace = 1;
  if (this->_internal_has_namespace_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace__);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNVMeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNVMeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNVMeNamespaceRequest::GetClassData() const { return &_class_data_; }

void UpdateNVMeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNVMeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const UpdateNVMeNamespaceRequest &>(from));
}


void UpdateNVMeNamespaceRequest::MergeFrom(const UpdateNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_()) {
    _internal_mutable_namespace_()->::opi_api::storage::v1::NVMeNamespace::MergeFrom(from._internal_namespace_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNVMeNamespaceRequest::CopyFrom(const UpdateNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNVMeNamespaceRequest::IsInitialized() const {
  return true;
}

void UpdateNVMeNamespaceRequest::InternalSwap(UpdateNVMeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace__, other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNVMeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[27]);
}

// ===================================================================

class ListNVMeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& subsystem_id(const ListNVMeNamespaceRequest* msg);
  static const ::opi_api::common::v1::ObjectKey& controller_id(const ListNVMeNamespaceRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
ListNVMeNamespaceRequest::_Internal::subsystem_id(const ListNVMeNamespaceRequest* msg) {
  return *msg->subsystem_id_;
}
const ::opi_api::common::v1::ObjectKey&
ListNVMeNamespaceRequest::_Internal::controller_id(const ListNVMeNamespaceRequest* msg) {
  return *msg->controller_id_;
}
void ListNVMeNamespaceRequest::clear_subsystem_id() {
  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
}
void ListNVMeNamespaceRequest::clear_controller_id() {
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
}
ListNVMeNamespaceRequest::ListNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNVMeNamespaceRequest)
}
ListNVMeNamespaceRequest::ListNVMeNamespaceRequest(const ListNVMeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subsystem_id()) {
    subsystem_id_ = new ::opi_api::common::v1::ObjectKey(*from.subsystem_id_);
  } else {
    subsystem_id_ = nullptr;
  }
  if (from._internal_has_controller_id()) {
    controller_id_ = new ::opi_api::common::v1::ObjectKey(*from.controller_id_);
  } else {
    controller_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNVMeNamespaceRequest)
}

inline void ListNVMeNamespaceRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&subsystem_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&controller_id_) -
    reinterpret_cast<char*>(&subsystem_id_)) + sizeof(controller_id_));
}

ListNVMeNamespaceRequest::~ListNVMeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNVMeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNVMeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subsystem_id_;
  if (this != internal_default_instance()) delete controller_id_;
}

void ListNVMeNamespaceRequest::ArenaDtor(void* object) {
  ListNVMeNamespaceRequest* _this = reinterpret_cast< ListNVMeNamespaceRequest* >(object);
  (void)_this;
}
void ListNVMeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNVMeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNVMeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && subsystem_id_ != nullptr) {
    delete subsystem_id_;
  }
  subsystem_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && controller_id_ != nullptr) {
    delete controller_id_;
  }
  controller_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNVMeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey subsystem_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subsystem_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.ObjectKey controller_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNVMeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::subsystem_id(this), target, stream);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  if (this->_internal_has_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::controller_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNVMeNamespaceRequest)
  return target;
}

size_t ListNVMeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNVMeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  if (this->_internal_has_subsystem_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subsystem_id_);
  }

  // .opi_api.common.v1.ObjectKey controller_id = 2;
  if (this->_internal_has_controller_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *controller_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNVMeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNVMeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNVMeNamespaceRequest::GetClassData() const { return &_class_data_; }

void ListNVMeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNVMeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const ListNVMeNamespaceRequest &>(from));
}


void ListNVMeNamespaceRequest::MergeFrom(const ListNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNVMeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subsystem_id()) {
    _internal_mutable_subsystem_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_subsystem_id());
  }
  if (from._internal_has_controller_id()) {
    _internal_mutable_controller_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_controller_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNVMeNamespaceRequest::CopyFrom(const ListNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNVMeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNVMeNamespaceRequest::IsInitialized() const {
  return true;
}

void ListNVMeNamespaceRequest::InternalSwap(ListNVMeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListNVMeNamespaceRequest, controller_id_)
      + sizeof(ListNVMeNamespaceRequest::controller_id_)
      - PROTOBUF_FIELD_OFFSET(ListNVMeNamespaceRequest, subsystem_id_)>(
          reinterpret_cast<char*>(&subsystem_id_),
          reinterpret_cast<char*>(&other->subsystem_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNVMeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[28]);
}

// ===================================================================

class ListNVMeNamespaceResponse::_Internal {
 public:
};

ListNVMeNamespaceResponse::ListNVMeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  namespace__(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNVMeNamespaceResponse)
}
ListNVMeNamespaceResponse::ListNVMeNamespaceResponse(const ListNVMeNamespaceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      namespace__(from.namespace__) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNVMeNamespaceResponse)
}

inline void ListNVMeNamespaceResponse::SharedCtor() {
}

ListNVMeNamespaceResponse::~ListNVMeNamespaceResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNVMeNamespaceResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ListNVMeNamespaceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ListNVMeNamespaceResponse::ArenaDtor(void* object) {
  ListNVMeNamespaceResponse* _this = reinterpret_cast< ListNVMeNamespaceResponse* >(object);
  (void)_this;
}
void ListNVMeNamespaceResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListNVMeNamespaceResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListNVMeNamespaceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNVMeNamespaceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  namespace__.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNVMeNamespaceResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_namespace_(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNVMeNamespaceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNVMeNamespaceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_namespace__size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_namespace_(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNVMeNamespaceResponse)
  return target;
}

size_t ListNVMeNamespaceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNVMeNamespaceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NVMeNamespace namespace = 1;
  total_size += 1UL * this->_internal_namespace__size();
  for (const auto& msg : this->namespace__) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNVMeNamespaceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ListNVMeNamespaceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNVMeNamespaceResponse::GetClassData() const { return &_class_data_; }

void ListNVMeNamespaceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ListNVMeNamespaceResponse *>(to)->MergeFrom(
      static_cast<const ListNVMeNamespaceResponse &>(from));
}


void ListNVMeNamespaceResponse::MergeFrom(const ListNVMeNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNVMeNamespaceResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  namespace__.MergeFrom(from.namespace__);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNVMeNamespaceResponse::CopyFrom(const ListNVMeNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNVMeNamespaceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNVMeNamespaceResponse::IsInitialized() const {
  return true;
}

void ListNVMeNamespaceResponse::InternalSwap(ListNVMeNamespaceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  namespace__.InternalSwap(&other->namespace__);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNVMeNamespaceResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[29]);
}

// ===================================================================

class GetNVMeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const GetNVMeNamespaceRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
GetNVMeNamespaceRequest::_Internal::namespace_id(const GetNVMeNamespaceRequest* msg) {
  return *msg->namespace_id_;
}
void GetNVMeNamespaceRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
GetNVMeNamespaceRequest::GetNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNVMeNamespaceRequest)
}
GetNVMeNamespaceRequest::GetNVMeNamespaceRequest(const GetNVMeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNVMeNamespaceRequest)
}

inline void GetNVMeNamespaceRequest::SharedCtor() {
namespace_id_ = nullptr;
}

GetNVMeNamespaceRequest::~GetNVMeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNVMeNamespaceRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetNVMeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void GetNVMeNamespaceRequest::ArenaDtor(void* object) {
  GetNVMeNamespaceRequest* _this = reinterpret_cast< GetNVMeNamespaceRequest* >(object);
  (void)_this;
}
void GetNVMeNamespaceRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetNVMeNamespaceRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetNVMeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNVMeNamespaceRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNVMeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNVMeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNVMeNamespaceRequest)
  return target;
}

size_t GetNVMeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNVMeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNVMeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetNVMeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNVMeNamespaceRequest::GetClassData() const { return &_class_data_; }

void GetNVMeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetNVMeNamespaceRequest *>(to)->MergeFrom(
      static_cast<const GetNVMeNamespaceRequest &>(from));
}


void GetNVMeNamespaceRequest::MergeFrom(const GetNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNVMeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNVMeNamespaceRequest::CopyFrom(const GetNVMeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNVMeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNVMeNamespaceRequest::IsInitialized() const {
  return true;
}

void GetNVMeNamespaceRequest::InternalSwap(GetNVMeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNVMeNamespaceRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[30]);
}

// ===================================================================

class NVMeNamespaceStatsRequest::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& namespace_id(const NVMeNamespaceStatsRequest* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceStatsRequest::_Internal::namespace_id(const NVMeNamespaceStatsRequest* msg) {
  return *msg->namespace_id_;
}
void NVMeNamespaceStatsRequest::clear_namespace_id() {
  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
}
NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
}
NVMeNamespaceStatsRequest::NVMeNamespaceStatsRequest(const NVMeNamespaceStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_namespace_id()) {
    namespace_id_ = new ::opi_api::common::v1::ObjectKey(*from.namespace_id_);
  } else {
    namespace_id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
}

inline void NVMeNamespaceStatsRequest::SharedCtor() {
namespace_id_ = nullptr;
}

NVMeNamespaceStatsRequest::~NVMeNamespaceStatsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete namespace_id_;
}

void NVMeNamespaceStatsRequest::ArenaDtor(void* object) {
  NVMeNamespaceStatsRequest* _this = reinterpret_cast< NVMeNamespaceStatsRequest* >(object);
  (void)_this;
}
void NVMeNamespaceStatsRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && namespace_id_ != nullptr) {
    delete namespace_id_;
  }
  namespace_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey namespace_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespace_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::namespace_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  return target;
}

size_t NVMeNamespaceStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  if (this->_internal_has_namespace_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *namespace_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatsRequest::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatsRequest *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatsRequest &>(from));
}


void NVMeNamespaceStatsRequest::MergeFrom(const NVMeNamespaceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_namespace_id()) {
    _internal_mutable_namespace_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_namespace_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatsRequest::CopyFrom(const NVMeNamespaceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatsRequest::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatsRequest::InternalSwap(NVMeNamespaceStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(namespace_id_, other->namespace_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatsRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[31]);
}

// ===================================================================

class NVMeNamespaceStatsResponse::_Internal {
 public:
  static const ::opi_api::common::v1::ObjectKey& id(const NVMeNamespaceStatsResponse* msg);
};

const ::opi_api::common::v1::ObjectKey&
NVMeNamespaceStatsResponse::_Internal::id(const NVMeNamespaceStatsResponse* msg) {
  return *msg->id_;
}
void NVMeNamespaceStatsResponse::clear_id() {
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
}
NVMeNamespaceStatsResponse::NVMeNamespaceStatsResponse(const NVMeNamespaceStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stats().empty()) {
    stats_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_stats(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_id()) {
    id_ = new ::opi_api::common::v1::ObjectKey(*from.id_);
  } else {
    id_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
}

inline void NVMeNamespaceStatsResponse::SharedCtor() {
stats_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stats_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = nullptr;
}

NVMeNamespaceStatsResponse::~NVMeNamespaceStatsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void NVMeNamespaceStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  stats_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void NVMeNamespaceStatsResponse::ArenaDtor(void* object) {
  NVMeNamespaceStatsResponse* _this = reinterpret_cast< NVMeNamespaceStatsResponse* >(object);
  (void)_this;
}
void NVMeNamespaceStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NVMeNamespaceStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NVMeNamespaceStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NVMeNamespaceStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.common.v1.ObjectKey id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "opi_api.storage.v1.NVMeNamespaceStatsResponse.stats"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NVMeNamespaceStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::id(this), target, stream);
  }

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stats().data(), static_cast<int>(this->_internal_stats().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NVMeNamespaceStatsResponse.stats");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stats(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  return target;
}

size_t NVMeNamespaceStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stats = 2;
  if (!this->_internal_stats().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stats());
  }

  // .opi_api.common.v1.ObjectKey id = 1;
  if (this->_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NVMeNamespaceStatsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NVMeNamespaceStatsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NVMeNamespaceStatsResponse::GetClassData() const { return &_class_data_; }

void NVMeNamespaceStatsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NVMeNamespaceStatsResponse *>(to)->MergeFrom(
      static_cast<const NVMeNamespaceStatsResponse &>(from));
}


void NVMeNamespaceStatsResponse::MergeFrom(const NVMeNamespaceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stats().empty()) {
    _internal_set_stats(from._internal_stats());
  }
  if (from._internal_has_id()) {
    _internal_mutable_id()->::opi_api::common::v1::ObjectKey::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NVMeNamespaceStatsResponse::CopyFrom(const NVMeNamespaceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NVMeNamespaceStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NVMeNamespaceStatsResponse::IsInitialized() const {
  return true;
}

void NVMeNamespaceStatsResponse::InternalSwap(NVMeNamespaceStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &stats_, lhs_arena,
      &other->stats_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NVMeNamespaceStatsResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[32]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystem* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystem >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeController* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespace* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceSpec* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatus* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNVMeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNVMeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNVMeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNVMeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNVMeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNVMeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNVMeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNVMeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNVMeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNVMeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNVMeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNVMeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNVMeSubsystemResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNVMeSubsystemResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNVMeSubsystemResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNVMeSubsystemRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNVMeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNVMeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeSubsystemStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeSubsystemStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeSubsystemStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNVMeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNVMeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNVMeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNVMeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNVMeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNVMeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNVMeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNVMeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNVMeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNVMeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNVMeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNVMeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNVMeControllerResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNVMeControllerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNVMeControllerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNVMeControllerRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNVMeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNVMeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeControllerStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeControllerStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeControllerStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNVMeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNVMeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNVMeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNVMeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNVMeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNVMeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNVMeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNVMeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNVMeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNVMeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNVMeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNVMeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNVMeNamespaceResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNVMeNamespaceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNVMeNamespaceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNVMeNamespaceRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNVMeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNVMeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatsRequest* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NVMeNamespaceStatsResponse* Arena::CreateMaybeMessage< ::opi_api::storage::v1::NVMeNamespaceStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NVMeNamespaceStatsResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
