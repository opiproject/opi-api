// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: middleend_qos_volume.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_middleend_5fqos_5fvolume_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_middleend_5fqos_5fvolume_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "opicommon.pb.h"
#include "object_key.pb.h"
#include "google/api/client.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/field_mask.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_middleend_5fqos_5fvolume_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_middleend_5fqos_5fvolume_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_middleend_5fqos_5fvolume_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class CreateQosVolumeRequest;
struct CreateQosVolumeRequestDefaultTypeInternal;
extern CreateQosVolumeRequestDefaultTypeInternal _CreateQosVolumeRequest_default_instance_;
class DeleteQosVolumeRequest;
struct DeleteQosVolumeRequestDefaultTypeInternal;
extern DeleteQosVolumeRequestDefaultTypeInternal _DeleteQosVolumeRequest_default_instance_;
class GetQosVolumeRequest;
struct GetQosVolumeRequestDefaultTypeInternal;
extern GetQosVolumeRequestDefaultTypeInternal _GetQosVolumeRequest_default_instance_;
class ListQosVolumesRequest;
struct ListQosVolumesRequestDefaultTypeInternal;
extern ListQosVolumesRequestDefaultTypeInternal _ListQosVolumesRequest_default_instance_;
class ListQosVolumesResponse;
struct ListQosVolumesResponseDefaultTypeInternal;
extern ListQosVolumesResponseDefaultTypeInternal _ListQosVolumesResponse_default_instance_;
class QosVolume;
struct QosVolumeDefaultTypeInternal;
extern QosVolumeDefaultTypeInternal _QosVolume_default_instance_;
class StatsQosVolumeRequest;
struct StatsQosVolumeRequestDefaultTypeInternal;
extern StatsQosVolumeRequestDefaultTypeInternal _StatsQosVolumeRequest_default_instance_;
class StatsQosVolumeResponse;
struct StatsQosVolumeResponseDefaultTypeInternal;
extern StatsQosVolumeResponseDefaultTypeInternal _StatsQosVolumeResponse_default_instance_;
class UpdateQosVolumeRequest;
struct UpdateQosVolumeRequestDefaultTypeInternal;
extern UpdateQosVolumeRequestDefaultTypeInternal _UpdateQosVolumeRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::CreateQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::GetQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::ListQosVolumesRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListQosVolumesRequest>(Arena*);
template<> ::opi_api::storage::v1::ListQosVolumesResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListQosVolumesResponse>(Arena*);
template<> ::opi_api::storage::v1::QosVolume* Arena::CreateMaybeMessage<::opi_api::storage::v1::QosVolume>(Arena*);
template<> ::opi_api::storage::v1::StatsQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsQosVolumeResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsQosVolumeResponse>(Arena*);
template<> ::opi_api::storage::v1::UpdateQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateQosVolumeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

// ===================================================================

class QosVolume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.QosVolume) */ {
 public:
  inline QosVolume() : QosVolume(nullptr) {}
  ~QosVolume() override;
  explicit constexpr QosVolume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QosVolume(const QosVolume& from);
  QosVolume(QosVolume&& from) noexcept
    : QosVolume() {
    *this = ::std::move(from);
  }

  inline QosVolume& operator=(const QosVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline QosVolume& operator=(QosVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QosVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const QosVolume* internal_default_instance() {
    return reinterpret_cast<const QosVolume*>(
               &_QosVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(QosVolume& a, QosVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(QosVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QosVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QosVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QosVolume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QosVolume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QosVolume& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QosVolume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.QosVolume";
  }
  protected:
  explicit QosVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVolumeIdFieldNumber = 2,
    kMinLimitFieldNumber = 3,
    kMaxLimitFieldNumber = 4,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.common.v1.ObjectKey volume_id = 2;
  bool has_volume_id() const;
  private:
  bool _internal_has_volume_id() const;
  public:
  void clear_volume_id();
  const ::opi_api::common::v1::ObjectKey& volume_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_volume_id();
  ::opi_api::common::v1::ObjectKey* mutable_volume_id();
  void set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_volume_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_volume_id();
  public:
  void unsafe_arena_set_allocated_volume_id(
      ::opi_api::common::v1::ObjectKey* volume_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_volume_id();

  // .opi_api.storage.v1.QosLimit min_limit = 3;
  bool has_min_limit() const;
  private:
  bool _internal_has_min_limit() const;
  public:
  void clear_min_limit();
  const ::opi_api::storage::v1::QosLimit& min_limit() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosLimit* release_min_limit();
  ::opi_api::storage::v1::QosLimit* mutable_min_limit();
  void set_allocated_min_limit(::opi_api::storage::v1::QosLimit* min_limit);
  private:
  const ::opi_api::storage::v1::QosLimit& _internal_min_limit() const;
  ::opi_api::storage::v1::QosLimit* _internal_mutable_min_limit();
  public:
  void unsafe_arena_set_allocated_min_limit(
      ::opi_api::storage::v1::QosLimit* min_limit);
  ::opi_api::storage::v1::QosLimit* unsafe_arena_release_min_limit();

  // .opi_api.storage.v1.QosLimit max_limit = 4;
  bool has_max_limit() const;
  private:
  bool _internal_has_max_limit() const;
  public:
  void clear_max_limit();
  const ::opi_api::storage::v1::QosLimit& max_limit() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosLimit* release_max_limit();
  ::opi_api::storage::v1::QosLimit* mutable_max_limit();
  void set_allocated_max_limit(::opi_api::storage::v1::QosLimit* max_limit);
  private:
  const ::opi_api::storage::v1::QosLimit& _internal_max_limit() const;
  ::opi_api::storage::v1::QosLimit* _internal_mutable_max_limit();
  public:
  void unsafe_arena_set_allocated_max_limit(
      ::opi_api::storage::v1::QosLimit* max_limit);
  ::opi_api::storage::v1::QosLimit* unsafe_arena_release_max_limit();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.QosVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::opi_api::common::v1::ObjectKey* volume_id_;
  ::opi_api::storage::v1::QosLimit* min_limit_;
  ::opi_api::storage::v1::QosLimit* max_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class CreateQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateQosVolumeRequest) */ {
 public:
  inline CreateQosVolumeRequest() : CreateQosVolumeRequest(nullptr) {}
  ~CreateQosVolumeRequest() override;
  explicit constexpr CreateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateQosVolumeRequest(const CreateQosVolumeRequest& from);
  CreateQosVolumeRequest(CreateQosVolumeRequest&& from) noexcept
    : CreateQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline CreateQosVolumeRequest& operator=(const CreateQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateQosVolumeRequest& operator=(CreateQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateQosVolumeRequest*>(
               &_CreateQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateQosVolumeRequest& a, CreateQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateQosVolumeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateQosVolumeRequest";
  }
  protected:
  explicit CreateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQosVolumeIdFieldNumber = 2,
    kQosVolumeFieldNumber = 1,
  };
  // string qos_volume_id = 2;
  void clear_qos_volume_id();
  const std::string& qos_volume_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_qos_volume_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_qos_volume_id();
  PROTOBUF_NODISCARD std::string* release_qos_volume_id();
  void set_allocated_qos_volume_id(std::string* qos_volume_id);
  private:
  const std::string& _internal_qos_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qos_volume_id(const std::string& value);
  std::string* _internal_mutable_qos_volume_id();
  public:

  // .opi_api.storage.v1.QosVolume qos_volume = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_qos_volume() const;
  private:
  bool _internal_has_qos_volume() const;
  public:
  void clear_qos_volume();
  const ::opi_api::storage::v1::QosVolume& qos_volume() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosVolume* release_qos_volume();
  ::opi_api::storage::v1::QosVolume* mutable_qos_volume();
  void set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume);
  private:
  const ::opi_api::storage::v1::QosVolume& _internal_qos_volume() const;
  ::opi_api::storage::v1::QosVolume* _internal_mutable_qos_volume();
  public:
  void unsafe_arena_set_allocated_qos_volume(
      ::opi_api::storage::v1::QosVolume* qos_volume);
  ::opi_api::storage::v1::QosVolume* unsafe_arena_release_qos_volume();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qos_volume_id_;
  ::opi_api::storage::v1::QosVolume* qos_volume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class DeleteQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteQosVolumeRequest) */ {
 public:
  inline DeleteQosVolumeRequest() : DeleteQosVolumeRequest(nullptr) {}
  ~DeleteQosVolumeRequest() override;
  explicit constexpr DeleteQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteQosVolumeRequest(const DeleteQosVolumeRequest& from);
  DeleteQosVolumeRequest(DeleteQosVolumeRequest&& from) noexcept
    : DeleteQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteQosVolumeRequest& operator=(const DeleteQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteQosVolumeRequest& operator=(DeleteQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteQosVolumeRequest*>(
               &_DeleteQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteQosVolumeRequest& a, DeleteQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteQosVolumeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteQosVolumeRequest";
  }
  protected:
  explicit DeleteQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2;
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool allow_missing_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class UpdateQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateQosVolumeRequest) */ {
 public:
  inline UpdateQosVolumeRequest() : UpdateQosVolumeRequest(nullptr) {}
  ~UpdateQosVolumeRequest() override;
  explicit constexpr UpdateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateQosVolumeRequest(const UpdateQosVolumeRequest& from);
  UpdateQosVolumeRequest(UpdateQosVolumeRequest&& from) noexcept
    : UpdateQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline UpdateQosVolumeRequest& operator=(const UpdateQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateQosVolumeRequest& operator=(UpdateQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateQosVolumeRequest*>(
               &_UpdateQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateQosVolumeRequest& a, UpdateQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateQosVolumeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateQosVolumeRequest";
  }
  protected:
  explicit UpdateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQosVolumeFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.QosVolume qos_volume = 1;
  bool has_qos_volume() const;
  private:
  bool _internal_has_qos_volume() const;
  public:
  void clear_qos_volume();
  const ::opi_api::storage::v1::QosVolume& qos_volume() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosVolume* release_qos_volume();
  ::opi_api::storage::v1::QosVolume* mutable_qos_volume();
  void set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume);
  private:
  const ::opi_api::storage::v1::QosVolume& _internal_qos_volume() const;
  ::opi_api::storage::v1::QosVolume* _internal_mutable_qos_volume();
  public:
  void unsafe_arena_set_allocated_qos_volume(
      ::opi_api::storage::v1::QosVolume* qos_volume);
  ::opi_api::storage::v1::QosVolume* unsafe_arena_release_qos_volume();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3;
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::QosVolume* qos_volume_;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
  bool allow_missing_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class ListQosVolumesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListQosVolumesRequest) */ {
 public:
  inline ListQosVolumesRequest() : ListQosVolumesRequest(nullptr) {}
  ~ListQosVolumesRequest() override;
  explicit constexpr ListQosVolumesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListQosVolumesRequest(const ListQosVolumesRequest& from);
  ListQosVolumesRequest(ListQosVolumesRequest&& from) noexcept
    : ListQosVolumesRequest() {
    *this = ::std::move(from);
  }

  inline ListQosVolumesRequest& operator=(const ListQosVolumesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListQosVolumesRequest& operator=(ListQosVolumesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListQosVolumesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListQosVolumesRequest* internal_default_instance() {
    return reinterpret_cast<const ListQosVolumesRequest*>(
               &_ListQosVolumesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListQosVolumesRequest& a, ListQosVolumesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListQosVolumesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListQosVolumesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListQosVolumesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListQosVolumesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListQosVolumesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListQosVolumesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListQosVolumesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListQosVolumesRequest";
  }
  protected:
  explicit ListQosVolumesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListQosVolumesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class ListQosVolumesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListQosVolumesResponse) */ {
 public:
  inline ListQosVolumesResponse() : ListQosVolumesResponse(nullptr) {}
  ~ListQosVolumesResponse() override;
  explicit constexpr ListQosVolumesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListQosVolumesResponse(const ListQosVolumesResponse& from);
  ListQosVolumesResponse(ListQosVolumesResponse&& from) noexcept
    : ListQosVolumesResponse() {
    *this = ::std::move(from);
  }

  inline ListQosVolumesResponse& operator=(const ListQosVolumesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListQosVolumesResponse& operator=(ListQosVolumesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListQosVolumesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListQosVolumesResponse* internal_default_instance() {
    return reinterpret_cast<const ListQosVolumesResponse*>(
               &_ListQosVolumesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListQosVolumesResponse& a, ListQosVolumesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListQosVolumesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListQosVolumesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListQosVolumesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListQosVolumesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListQosVolumesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListQosVolumesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListQosVolumesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListQosVolumesResponse";
  }
  protected:
  explicit ListQosVolumesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQosVolumesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.QosVolume qos_volumes = 1;
  int qos_volumes_size() const;
  private:
  int _internal_qos_volumes_size() const;
  public:
  void clear_qos_volumes();
  ::opi_api::storage::v1::QosVolume* mutable_qos_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >*
      mutable_qos_volumes();
  private:
  const ::opi_api::storage::v1::QosVolume& _internal_qos_volumes(int index) const;
  ::opi_api::storage::v1::QosVolume* _internal_add_qos_volumes();
  public:
  const ::opi_api::storage::v1::QosVolume& qos_volumes(int index) const;
  ::opi_api::storage::v1::QosVolume* add_qos_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >&
      qos_volumes() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListQosVolumesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume > qos_volumes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class GetQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetQosVolumeRequest) */ {
 public:
  inline GetQosVolumeRequest() : GetQosVolumeRequest(nullptr) {}
  ~GetQosVolumeRequest() override;
  explicit constexpr GetQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQosVolumeRequest(const GetQosVolumeRequest& from);
  GetQosVolumeRequest(GetQosVolumeRequest&& from) noexcept
    : GetQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline GetQosVolumeRequest& operator=(const GetQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQosVolumeRequest& operator=(GetQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const GetQosVolumeRequest*>(
               &_GetQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetQosVolumeRequest& a, GetQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetQosVolumeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetQosVolumeRequest";
  }
  protected:
  explicit GetQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class StatsQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsQosVolumeRequest) */ {
 public:
  inline StatsQosVolumeRequest() : StatsQosVolumeRequest(nullptr) {}
  ~StatsQosVolumeRequest() override;
  explicit constexpr StatsQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsQosVolumeRequest(const StatsQosVolumeRequest& from);
  StatsQosVolumeRequest(StatsQosVolumeRequest&& from) noexcept
    : StatsQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline StatsQosVolumeRequest& operator=(const StatsQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsQosVolumeRequest& operator=(StatsQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const StatsQosVolumeRequest*>(
               &_StatsQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StatsQosVolumeRequest& a, StatsQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatsQosVolumeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsQosVolumeRequest";
  }
  protected:
  explicit StatsQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class StatsQosVolumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsQosVolumeResponse) */ {
 public:
  inline StatsQosVolumeResponse() : StatsQosVolumeResponse(nullptr) {}
  ~StatsQosVolumeResponse() override;
  explicit constexpr StatsQosVolumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsQosVolumeResponse(const StatsQosVolumeResponse& from);
  StatsQosVolumeResponse(StatsQosVolumeResponse&& from) noexcept
    : StatsQosVolumeResponse() {
    *this = ::std::move(from);
  }

  inline StatsQosVolumeResponse& operator=(const StatsQosVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsQosVolumeResponse& operator=(StatsQosVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsQosVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsQosVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const StatsQosVolumeResponse*>(
               &_StatsQosVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StatsQosVolumeResponse& a, StatsQosVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsQosVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsQosVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsQosVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsQosVolumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsQosVolumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatsQosVolumeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsQosVolumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsQosVolumeResponse";
  }
  protected:
  explicit StatsQosVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsQosVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::VolumeStats* stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QosVolume

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
inline void QosVolume::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& QosVolume::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QosVolume::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.QosVolume.name)
}
inline std::string* QosVolume::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.name)
  return _s;
}
inline const std::string& QosVolume::_internal_name() const {
  return name_.Get();
}
inline void QosVolume::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QosVolume::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QosVolume::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QosVolume::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.name)
}

// .opi_api.common.v1.ObjectKey volume_id = 2;
inline bool QosVolume::_internal_has_volume_id() const {
  return this != internal_default_instance() && volume_id_ != nullptr;
}
inline bool QosVolume::has_volume_id() const {
  return _internal_has_volume_id();
}
inline const ::opi_api::common::v1::ObjectKey& QosVolume::_internal_volume_id() const {
  const ::opi_api::common::v1::ObjectKey* p = volume_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& QosVolume::volume_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.volume_id)
  return _internal_volume_id();
}
inline void QosVolume::unsafe_arena_set_allocated_volume_id(
    ::opi_api::common::v1::ObjectKey* volume_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  volume_id_ = volume_id;
  if (volume_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.QosVolume.volume_id)
}
inline ::opi_api::common::v1::ObjectKey* QosVolume::release_volume_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* QosVolume::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.volume_id)
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* QosVolume::_internal_mutable_volume_id() {
  
  if (volume_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    volume_id_ = p;
  }
  return volume_id_;
}
inline ::opi_api::common::v1::ObjectKey* QosVolume::mutable_volume_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.volume_id)
  return _msg;
}
inline void QosVolume::set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  if (volume_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id));
    if (message_arena != submessage_arena) {
      volume_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_id, submessage_arena);
    }
    
  } else {
    
  }
  volume_id_ = volume_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.volume_id)
}

// .opi_api.storage.v1.QosLimit min_limit = 3;
inline bool QosVolume::_internal_has_min_limit() const {
  return this != internal_default_instance() && min_limit_ != nullptr;
}
inline bool QosVolume::has_min_limit() const {
  return _internal_has_min_limit();
}
inline const ::opi_api::storage::v1::QosLimit& QosVolume::_internal_min_limit() const {
  const ::opi_api::storage::v1::QosLimit* p = min_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosLimit&>(
      ::opi_api::storage::v1::_QosLimit_default_instance_);
}
inline const ::opi_api::storage::v1::QosLimit& QosVolume::min_limit() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.min_limit)
  return _internal_min_limit();
}
inline void QosVolume::unsafe_arena_set_allocated_min_limit(
    ::opi_api::storage::v1::QosLimit* min_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_limit_);
  }
  min_limit_ = min_limit;
  if (min_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.QosVolume.min_limit)
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::release_min_limit() {
  
  ::opi_api::storage::v1::QosLimit* temp = min_limit_;
  min_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::unsafe_arena_release_min_limit() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.min_limit)
  
  ::opi_api::storage::v1::QosLimit* temp = min_limit_;
  min_limit_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::_internal_mutable_min_limit() {
  
  if (min_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosLimit>(GetArenaForAllocation());
    min_limit_ = p;
  }
  return min_limit_;
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::mutable_min_limit() {
  ::opi_api::storage::v1::QosLimit* _msg = _internal_mutable_min_limit();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.min_limit)
  return _msg;
}
inline void QosVolume::set_allocated_min_limit(::opi_api::storage::v1::QosLimit* min_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_limit_);
  }
  if (min_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_limit));
    if (message_arena != submessage_arena) {
      min_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_limit, submessage_arena);
    }
    
  } else {
    
  }
  min_limit_ = min_limit;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.min_limit)
}

// .opi_api.storage.v1.QosLimit max_limit = 4;
inline bool QosVolume::_internal_has_max_limit() const {
  return this != internal_default_instance() && max_limit_ != nullptr;
}
inline bool QosVolume::has_max_limit() const {
  return _internal_has_max_limit();
}
inline const ::opi_api::storage::v1::QosLimit& QosVolume::_internal_max_limit() const {
  const ::opi_api::storage::v1::QosLimit* p = max_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosLimit&>(
      ::opi_api::storage::v1::_QosLimit_default_instance_);
}
inline const ::opi_api::storage::v1::QosLimit& QosVolume::max_limit() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.max_limit)
  return _internal_max_limit();
}
inline void QosVolume::unsafe_arena_set_allocated_max_limit(
    ::opi_api::storage::v1::QosLimit* max_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_limit_);
  }
  max_limit_ = max_limit;
  if (max_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.QosVolume.max_limit)
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::release_max_limit() {
  
  ::opi_api::storage::v1::QosLimit* temp = max_limit_;
  max_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::unsafe_arena_release_max_limit() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.max_limit)
  
  ::opi_api::storage::v1::QosLimit* temp = max_limit_;
  max_limit_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::_internal_mutable_max_limit() {
  
  if (max_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosLimit>(GetArenaForAllocation());
    max_limit_ = p;
  }
  return max_limit_;
}
inline ::opi_api::storage::v1::QosLimit* QosVolume::mutable_max_limit() {
  ::opi_api::storage::v1::QosLimit* _msg = _internal_mutable_max_limit();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.max_limit)
  return _msg;
}
inline void QosVolume::set_allocated_max_limit(::opi_api::storage::v1::QosLimit* max_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_limit_);
  }
  if (max_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_limit));
    if (message_arena != submessage_arena) {
      max_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_limit, submessage_arena);
    }
    
  } else {
    
  }
  max_limit_ = max_limit;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.max_limit)
}

// -------------------------------------------------------------------

// CreateQosVolumeRequest

// .opi_api.storage.v1.QosVolume qos_volume = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateQosVolumeRequest::_internal_has_qos_volume() const {
  return this != internal_default_instance() && qos_volume_ != nullptr;
}
inline bool CreateQosVolumeRequest::has_qos_volume() const {
  return _internal_has_qos_volume();
}
inline void CreateQosVolumeRequest::clear_qos_volume() {
  if (GetArenaForAllocation() == nullptr && qos_volume_ != nullptr) {
    delete qos_volume_;
  }
  qos_volume_ = nullptr;
}
inline const ::opi_api::storage::v1::QosVolume& CreateQosVolumeRequest::_internal_qos_volume() const {
  const ::opi_api::storage::v1::QosVolume* p = qos_volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosVolume&>(
      ::opi_api::storage::v1::_QosVolume_default_instance_);
}
inline const ::opi_api::storage::v1::QosVolume& CreateQosVolumeRequest::qos_volume() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
  return _internal_qos_volume();
}
inline void CreateQosVolumeRequest::unsafe_arena_set_allocated_qos_volume(
    ::opi_api::storage::v1::QosVolume* qos_volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(qos_volume_);
  }
  qos_volume_ = qos_volume;
  if (qos_volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::release_qos_volume() {
  
  ::opi_api::storage::v1::QosVolume* temp = qos_volume_;
  qos_volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::unsafe_arena_release_qos_volume() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
  
  ::opi_api::storage::v1::QosVolume* temp = qos_volume_;
  qos_volume_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::_internal_mutable_qos_volume() {
  
  if (qos_volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosVolume>(GetArenaForAllocation());
    qos_volume_ = p;
  }
  return qos_volume_;
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::mutable_qos_volume() {
  ::opi_api::storage::v1::QosVolume* _msg = _internal_mutable_qos_volume();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
  return _msg;
}
inline void CreateQosVolumeRequest::set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete qos_volume_;
  }
  if (qos_volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::QosVolume>::GetOwningArena(qos_volume);
    if (message_arena != submessage_arena) {
      qos_volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qos_volume, submessage_arena);
    }
    
  } else {
    
  }
  qos_volume_ = qos_volume;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
}

// string qos_volume_id = 2;
inline void CreateQosVolumeRequest::clear_qos_volume_id() {
  qos_volume_id_.ClearToEmpty();
}
inline const std::string& CreateQosVolumeRequest::qos_volume_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
  return _internal_qos_volume_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateQosVolumeRequest::set_qos_volume_id(ArgT0&& arg0, ArgT... args) {
 
 qos_volume_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
}
inline std::string* CreateQosVolumeRequest::mutable_qos_volume_id() {
  std::string* _s = _internal_mutable_qos_volume_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
  return _s;
}
inline const std::string& CreateQosVolumeRequest::_internal_qos_volume_id() const {
  return qos_volume_id_.Get();
}
inline void CreateQosVolumeRequest::_internal_set_qos_volume_id(const std::string& value) {
  
  qos_volume_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateQosVolumeRequest::_internal_mutable_qos_volume_id() {
  
  return qos_volume_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateQosVolumeRequest::release_qos_volume_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
  return qos_volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateQosVolumeRequest::set_allocated_qos_volume_id(std::string* qos_volume_id) {
  if (qos_volume_id != nullptr) {
    
  } else {
    
  }
  qos_volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), qos_volume_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (qos_volume_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    qos_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
}

// -------------------------------------------------------------------

// DeleteQosVolumeRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteQosVolumeRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DeleteQosVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteQosVolumeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteQosVolumeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteQosVolumeRequest.name)
}
inline std::string* DeleteQosVolumeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteQosVolumeRequest.name)
  return _s;
}
inline const std::string& DeleteQosVolumeRequest::_internal_name() const {
  return name_.Get();
}
inline void DeleteQosVolumeRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteQosVolumeRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteQosVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteQosVolumeRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteQosVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteQosVolumeRequest.name)
}

// bool allow_missing = 2;
inline void DeleteQosVolumeRequest::clear_allow_missing() {
  allow_missing_ = false;
}
inline bool DeleteQosVolumeRequest::_internal_allow_missing() const {
  return allow_missing_;
}
inline bool DeleteQosVolumeRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteQosVolumeRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteQosVolumeRequest::_internal_set_allow_missing(bool value) {
  
  allow_missing_ = value;
}
inline void DeleteQosVolumeRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteQosVolumeRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateQosVolumeRequest

// .opi_api.storage.v1.QosVolume qos_volume = 1;
inline bool UpdateQosVolumeRequest::_internal_has_qos_volume() const {
  return this != internal_default_instance() && qos_volume_ != nullptr;
}
inline bool UpdateQosVolumeRequest::has_qos_volume() const {
  return _internal_has_qos_volume();
}
inline void UpdateQosVolumeRequest::clear_qos_volume() {
  if (GetArenaForAllocation() == nullptr && qos_volume_ != nullptr) {
    delete qos_volume_;
  }
  qos_volume_ = nullptr;
}
inline const ::opi_api::storage::v1::QosVolume& UpdateQosVolumeRequest::_internal_qos_volume() const {
  const ::opi_api::storage::v1::QosVolume* p = qos_volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosVolume&>(
      ::opi_api::storage::v1::_QosVolume_default_instance_);
}
inline const ::opi_api::storage::v1::QosVolume& UpdateQosVolumeRequest::qos_volume() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
  return _internal_qos_volume();
}
inline void UpdateQosVolumeRequest::unsafe_arena_set_allocated_qos_volume(
    ::opi_api::storage::v1::QosVolume* qos_volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(qos_volume_);
  }
  qos_volume_ = qos_volume;
  if (qos_volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::release_qos_volume() {
  
  ::opi_api::storage::v1::QosVolume* temp = qos_volume_;
  qos_volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::unsafe_arena_release_qos_volume() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
  
  ::opi_api::storage::v1::QosVolume* temp = qos_volume_;
  qos_volume_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::_internal_mutable_qos_volume() {
  
  if (qos_volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosVolume>(GetArenaForAllocation());
    qos_volume_ = p;
  }
  return qos_volume_;
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::mutable_qos_volume() {
  ::opi_api::storage::v1::QosVolume* _msg = _internal_mutable_qos_volume();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
  return _msg;
}
inline void UpdateQosVolumeRequest::set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete qos_volume_;
  }
  if (qos_volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::QosVolume>::GetOwningArena(qos_volume);
    if (message_arena != submessage_arena) {
      qos_volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qos_volume, submessage_arena);
    }
    
  } else {
    
  }
  qos_volume_ = qos_volume;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateQosVolumeRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && update_mask_ != nullptr;
}
inline bool UpdateQosVolumeRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateQosVolumeRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateQosVolumeRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateQosVolumeRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::_internal_mutable_update_mask() {
  
  if (update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    update_mask_ = p;
  }
  return update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
  return _msg;
}
inline void UpdateQosVolumeRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
}

// bool allow_missing = 3;
inline void UpdateQosVolumeRequest::clear_allow_missing() {
  allow_missing_ = false;
}
inline bool UpdateQosVolumeRequest::_internal_allow_missing() const {
  return allow_missing_;
}
inline bool UpdateQosVolumeRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateQosVolumeRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateQosVolumeRequest::_internal_set_allow_missing(bool value) {
  
  allow_missing_ = value;
}
inline void UpdateQosVolumeRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateQosVolumeRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListQosVolumesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListQosVolumesRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& ListQosVolumesRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListQosVolumesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesRequest.parent)
}
inline std::string* ListQosVolumesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesRequest.parent)
  return _s;
}
inline const std::string& ListQosVolumesRequest::_internal_parent() const {
  return parent_.Get();
}
inline void ListQosVolumesRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListQosVolumesRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListQosVolumesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListQosVolumesRequest.parent)
}

// int32 page_size = 2;
inline void ListQosVolumesRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListQosVolumesRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListQosVolumesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesRequest.page_size)
  return _internal_page_size();
}
inline void ListQosVolumesRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListQosVolumesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesRequest.page_size)
}

// string page_token = 3;
inline void ListQosVolumesRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListQosVolumesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListQosVolumesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesRequest.page_token)
}
inline std::string* ListQosVolumesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesRequest.page_token)
  return _s;
}
inline const std::string& ListQosVolumesRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListQosVolumesRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListQosVolumesRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListQosVolumesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListQosVolumesRequest.page_token)
}

// -------------------------------------------------------------------

// ListQosVolumesResponse

// repeated .opi_api.storage.v1.QosVolume qos_volumes = 1;
inline int ListQosVolumesResponse::_internal_qos_volumes_size() const {
  return qos_volumes_.size();
}
inline int ListQosVolumesResponse::qos_volumes_size() const {
  return _internal_qos_volumes_size();
}
inline void ListQosVolumesResponse::clear_qos_volumes() {
  qos_volumes_.Clear();
}
inline ::opi_api::storage::v1::QosVolume* ListQosVolumesResponse::mutable_qos_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return qos_volumes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >*
ListQosVolumesResponse::mutable_qos_volumes() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return &qos_volumes_;
}
inline const ::opi_api::storage::v1::QosVolume& ListQosVolumesResponse::_internal_qos_volumes(int index) const {
  return qos_volumes_.Get(index);
}
inline const ::opi_api::storage::v1::QosVolume& ListQosVolumesResponse::qos_volumes(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return _internal_qos_volumes(index);
}
inline ::opi_api::storage::v1::QosVolume* ListQosVolumesResponse::_internal_add_qos_volumes() {
  return qos_volumes_.Add();
}
inline ::opi_api::storage::v1::QosVolume* ListQosVolumesResponse::add_qos_volumes() {
  ::opi_api::storage::v1::QosVolume* _add = _internal_add_qos_volumes();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >&
ListQosVolumesResponse::qos_volumes() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return qos_volumes_;
}

// string next_page_token = 2;
inline void ListQosVolumesResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListQosVolumesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListQosVolumesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
}
inline std::string* ListQosVolumesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
  return _s;
}
inline const std::string& ListQosVolumesResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListQosVolumesResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListQosVolumesResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListQosVolumesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListQosVolumesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetQosVolumeRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetQosVolumeRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetQosVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetQosVolumeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetQosVolumeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetQosVolumeRequest.name)
}
inline std::string* GetQosVolumeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetQosVolumeRequest.name)
  return _s;
}
inline const std::string& GetQosVolumeRequest::_internal_name() const {
  return name_.Get();
}
inline void GetQosVolumeRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetQosVolumeRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetQosVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetQosVolumeRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetQosVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetQosVolumeRequest.name)
}

// -------------------------------------------------------------------

// StatsQosVolumeRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsQosVolumeRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& StatsQosVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsQosVolumeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsQosVolumeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsQosVolumeRequest.name)
}
inline std::string* StatsQosVolumeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsQosVolumeRequest.name)
  return _s;
}
inline const std::string& StatsQosVolumeRequest::_internal_name() const {
  return name_.Get();
}
inline void StatsQosVolumeRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatsQosVolumeRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatsQosVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsQosVolumeRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatsQosVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsQosVolumeRequest.name)
}

// -------------------------------------------------------------------

// StatsQosVolumeResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsQosVolumeResponse::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool StatsQosVolumeResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsQosVolumeResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsQosVolumeResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsQosVolumeResponse.stats)
  return _internal_stats();
}
inline void StatsQosVolumeResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsQosVolumeResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsQosVolumeResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsQosVolumeResponse.stats)
  return _msg;
}
inline void StatsQosVolumeResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsQosVolumeResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_middleend_5fqos_5fvolume_2eproto
