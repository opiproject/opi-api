// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backend_nvme.proto

#include "backend_nvme.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace opi_api {
namespace storage {
namespace v1 {
PROTOBUF_CONSTEXPR NvmeRemoteController::NvmeRemoteController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tcp_)*/nullptr
  , /*decltype(_impl_.io_queues_count_)*/int64_t{0}
  , /*decltype(_impl_.queue_size_)*/int64_t{0}
  , /*decltype(_impl_.multipath_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeRemoteControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeRemoteControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeRemoteControllerDefaultTypeInternal() {}
  union {
    NvmeRemoteController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeRemoteControllerDefaultTypeInternal _NvmeRemoteController_default_instance_;
PROTOBUF_CONSTEXPR TcpController::TcpController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.psk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hdgst_)*/false
  , /*decltype(_impl_.ddgst_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TcpControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TcpControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TcpControllerDefaultTypeInternal() {}
  union {
    TcpController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TcpControllerDefaultTypeInternal _TcpController_default_instance_;
PROTOBUF_CONSTEXPR NvmePath::NvmePath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.traddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fabrics_)*/nullptr
  , /*decltype(_impl_.trtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmePathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmePathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmePathDefaultTypeInternal() {}
  union {
    NvmePath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmePathDefaultTypeInternal _NvmePath_default_instance_;
PROTOBUF_CONSTEXPR FabricsPath::FabricsPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subnqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_traddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostnqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.trsvcid_)*/int64_t{0}
  , /*decltype(_impl_.source_trsvcid_)*/int64_t{0}
  , /*decltype(_impl_.adrfam_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FabricsPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FabricsPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FabricsPathDefaultTypeInternal() {}
  union {
    FabricsPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FabricsPathDefaultTypeInternal _FabricsPath_default_instance_;
PROTOBUF_CONSTEXPR NvmeRemoteNamespace::NvmeRemoteNamespace(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nguid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.eui64_)*/int64_t{0}
  , /*decltype(_impl_.nsid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeRemoteNamespaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeRemoteNamespaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeRemoteNamespaceDefaultTypeInternal() {}
  union {
    NvmeRemoteNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeRemoteNamespaceDefaultTypeInternal _NvmeRemoteNamespace_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controller_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_remote_controller_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    CreateNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmeRemoteControllerRequestDefaultTypeInternal _CreateNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmeRemoteControllerRequestDefaultTypeInternal _DeleteNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controller_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmeRemoteControllerRequestDefaultTypeInternal _UpdateNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteControllersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteControllersRequestDefaultTypeInternal() {}
  union {
    ListNvmeRemoteControllersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteControllersRequestDefaultTypeInternal _ListNvmeRemoteControllersRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controllers_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteControllersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteControllersResponseDefaultTypeInternal() {}
  union {
    ListNvmeRemoteControllersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteControllersResponseDefaultTypeInternal _ListNvmeRemoteControllersResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    GetNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeRemoteControllerRequestDefaultTypeInternal _GetNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResetNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    ResetNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetNvmeRemoteControllerRequestDefaultTypeInternal _ResetNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    StatsNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeRemoteControllerRequestDefaultTypeInternal _StatsNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeRemoteControllerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeRemoteControllerResponseDefaultTypeInternal() {}
  union {
    StatsNvmeRemoteControllerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeRemoteControllerResponseDefaultTypeInternal _StatsNvmeRemoteControllerResponse_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteNamespacesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteNamespacesRequestDefaultTypeInternal() {}
  union {
    ListNvmeRemoteNamespacesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteNamespacesRequestDefaultTypeInternal _ListNvmeRemoteNamespacesRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_namespaces_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteNamespacesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteNamespacesResponseDefaultTypeInternal() {}
  union {
    ListNvmeRemoteNamespacesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteNamespacesResponseDefaultTypeInternal _ListNvmeRemoteNamespacesResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeRemoteNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeRemoteNamespaceRequestDefaultTypeInternal() {}
  union {
    GetNvmeRemoteNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeRemoteNamespaceRequestDefaultTypeInternal _GetNvmeRemoteNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmePathRequest::CreateNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_path_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_path_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmePathRequestDefaultTypeInternal() {}
  union {
    CreateNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmePathRequestDefaultTypeInternal _CreateNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmePathRequest::DeleteNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmePathRequestDefaultTypeInternal() {}
  union {
    DeleteNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmePathRequestDefaultTypeInternal _DeleteNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmePathRequest::UpdateNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_path_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmePathRequestDefaultTypeInternal() {}
  union {
    UpdateNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmePathRequestDefaultTypeInternal _UpdateNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmePathsRequest::ListNvmePathsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmePathsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmePathsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmePathsRequestDefaultTypeInternal() {}
  union {
    ListNvmePathsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmePathsRequestDefaultTypeInternal _ListNvmePathsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmePathsResponse::ListNvmePathsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_paths_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmePathsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmePathsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmePathsResponseDefaultTypeInternal() {}
  union {
    ListNvmePathsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmePathsResponseDefaultTypeInternal _ListNvmePathsResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmePathRequest::GetNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmePathRequestDefaultTypeInternal() {}
  union {
    GetNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmePathRequestDefaultTypeInternal _GetNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmePathRequest::StatsNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmePathRequestDefaultTypeInternal() {}
  union {
    StatsNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmePathRequestDefaultTypeInternal _StatsNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmePathResponse::StatsNvmePathResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmePathResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmePathResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmePathResponseDefaultTypeInternal() {}
  union {
    StatsNvmePathResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmePathResponseDefaultTypeInternal _StatsNvmePathResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::_pb::Metadata file_level_metadata_backend_5fnvme_2eproto[25];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_backend_5fnvme_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_backend_5fnvme_2eproto = nullptr;

const uint32_t TableStruct_backend_5fnvme_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.multipath_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.io_queues_count_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.queue_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.tcp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _impl_.hdgst_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _impl_.ddgst_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _impl_.psk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.trtype_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.traddr_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.fabrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.trsvcid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.subnqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.adrfam_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.source_traddr_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.source_trsvcid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.hostnqn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.uuid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _impl_.nvme_remote_controllers_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse, _impl_.stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _impl_.nvme_remote_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.nvme_path_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.nvme_path_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.nvme_path_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _impl_.nvme_paths_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmePathRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathResponse, _impl_.stats_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NvmeRemoteController)},
  { 11, -1, -1, sizeof(::opi_api::storage::v1::TcpController)},
  { 20, -1, -1, sizeof(::opi_api::storage::v1::NvmePath)},
  { 30, -1, -1, sizeof(::opi_api::storage::v1::FabricsPath)},
  { 42, -1, -1, sizeof(::opi_api::storage::v1::NvmeRemoteNamespace)},
  { 53, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest)},
  { 61, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest)},
  { 69, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest)},
  { 78, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteControllersRequest)},
  { 86, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteControllersResponse)},
  { 94, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeRemoteControllerRequest)},
  { 101, -1, -1, sizeof(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest)},
  { 108, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest)},
  { 115, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse)},
  { 122, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest)},
  { 131, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse)},
  { 139, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest)},
  { 146, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmePathRequest)},
  { 155, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmePathRequest)},
  { 163, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmePathRequest)},
  { 172, -1, -1, sizeof(::opi_api::storage::v1::ListNvmePathsRequest)},
  { 181, -1, -1, sizeof(::opi_api::storage::v1::ListNvmePathsResponse)},
  { 189, -1, -1, sizeof(::opi_api::storage::v1::GetNvmePathRequest)},
  { 196, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmePathRequest)},
  { 203, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmePathResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::opi_api::storage::v1::_NvmeRemoteController_default_instance_._instance,
  &::opi_api::storage::v1::_TcpController_default_instance_._instance,
  &::opi_api::storage::v1::_NvmePath_default_instance_._instance,
  &::opi_api::storage::v1::_FabricsPath_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeRemoteNamespace_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteControllersRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteControllersResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ResetNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeRemoteControllerResponse_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteNamespacesRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteNamespacesResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeRemoteNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmePathsRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmePathsResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmePathResponse_default_instance_._instance,
};

const char descriptor_table_protodef_backend_5fnvme_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022backend_nvme.proto\022\022opi_api.storage.v1"
  "\032\027google/api/client.proto\032\031google/api/re"
  "source.proto\032\033google/protobuf/empty.prot"
  "o\032\034google/api/annotations.proto\032\037google/"
  "api/field_behavior.proto\032 google/protobu"
  "f/field_mask.proto\032\017opicommon.proto\032\nuui"
  "d.proto\"\317\002\n\024NvmeRemoteController\022\021\n\004name"
  "\030\001 \001(\tB\003\340A\010\0229\n\tmultipath\030\002 \001(\0162!.opi_api"
  ".storage.v1.NvmeMultipathB\003\340A\002\022\034\n\017io_que"
  "ues_count\030\003 \001(\003B\003\340A\001\022\027\n\nqueue_size\030\004 \001(\003"
  "B\003\340A\001\0223\n\003tcp\030\005 \001(\0132!.opi_api.storage.v1."
  "TcpControllerB\003\340A\001:}\352Az\n\'opi_api.storage"
  ".v1/NvmeRemoteController\022\"nvmeRemoteCont"
  "rollers/{controller}*\025nvmeRemoteControll"
  "ers2\024nvmeRemoteController\"I\n\rTcpControll"
  "er\022\022\n\005hdgst\030\001 \001(\010B\003\340A\001\022\022\n\005ddgst\030\002 \001(\010B\003\340"
  "A\001\022\020\n\003psk\030\003 \001(\014B\003\340A\001\"\221\002\n\010NvmePath\022\021\n\004nam"
  "e\030\001 \001(\tB\003\340A\010\022:\n\006trtype\030\002 \001(\0162%.opi_api.s"
  "torage.v1.NvmeTransportTypeB\003\340A\002\022\023\n\006trad"
  "dr\030\003 \001(\tB\003\340A\002\0225\n\007fabrics\030\004 \001(\0132\037.opi_api"
  ".storage.v1.FabricsPathB\003\340A\001:j\352Ag\n\033opi_a"
  "pi.storage.v1/NvmePath\0223nvmeRemoteContro"
  "llers/{controller}/nvmePaths/{path}*\tnvm"
  "ePaths2\010nvmePath\"\303\001\n\013FabricsPath\022\024\n\007trsv"
  "cid\030\001 \001(\003B\003\340A\002\022\023\n\006subnqn\030\002 \001(\tB\003\340A\002\022:\n\006a"
  "drfam\030\003 \001(\0162%.opi_api.storage.v1.NvmeAdd"
  "ressFamilyB\003\340A\002\022\032\n\rsource_traddr\030\004 \001(\tB\003"
  "\340A\001\022\033\n\016source_trsvcid\030\005 \001(\003B\003\340A\001\022\024\n\007host"
  "nqn\030\006 \001(\tB\003\340A\001\"\256\002\n\023NvmeRemoteNamespace\022\021"
  "\n\004name\030\001 \001(\tB\003\340A\010\022\021\n\004nsid\030\002 \001(\005B\003\340A\003\022\022\n\005"
  "nguid\030\003 \001(\tB\003\340A\003\022\022\n\005eui64\030\004 \001(\003B\003\340A\003\022*\n\004"
  "uuid\030\005 \001(\0132\027.opi_api.common.v1.UuidB\003\340A\003"
  ":\234\001\352A\230\001\n&opi_api.storage.v1/NvmeRemoteNa"
  "mespace\022CnvmeRemoteControllers/{controll"
  "er}/nvmeRemoteNamespaces/{namespace}*\024nv"
  "meRemoteNamespaces2\023nvmeRemoteNamespace\""
  "\232\001\n!CreateNvmeRemoteControllerRequest\022M\n"
  "\026nvme_remote_controller\030\001 \001(\0132(.opi_api."
  "storage.v1.NvmeRemoteControllerB\003\340A\002\022&\n\031"
  "nvme_remote_controller_id\030\002 \001(\tB\003\340A\001\"~\n!"
  "DeleteNvmeRemoteControllerRequest\022=\n\004nam"
  "e\030\001 \001(\tB/\340A\002\372A)\n\'opi_api.storage.v1/Nvme"
  "RemoteController\022\032\n\rallow_missing\030\002 \001(\010B"
  "\003\340A\001\"\304\001\n!UpdateNvmeRemoteControllerReque"
  "st\022M\n\026nvme_remote_controller\030\001 \001(\0132(.opi"
  "_api.storage.v1.NvmeRemoteControllerB\003\340A"
  "\002\0224\n\013update_mask\030\002 \001(\0132\032.google.protobuf"
  ".FieldMaskB\003\340A\001\022\032\n\rallow_missing\030\003 \001(\010B\003"
  "\340A\001\"S\n ListNvmeRemoteControllersRequest\022"
  "\026\n\tpage_size\030\001 \001(\005B\003\340A\001\022\027\n\npage_token\030\002 "
  "\001(\tB\003\340A\001\"\207\001\n!ListNvmeRemoteControllersRe"
  "sponse\022I\n\027nvme_remote_controllers\030\001 \003(\0132"
  "(.opi_api.storage.v1.NvmeRemoteControlle"
  "r\022\027\n\017next_page_token\030\002 \001(\t\"_\n\036GetNvmeRem"
  "oteControllerRequest\022=\n\004name\030\001 \001(\tB/\340A\002\372"
  "A)\n\'opi_api.storage.v1/NvmeRemoteControl"
  "ler\"a\n ResetNvmeRemoteControllerRequest\022"
  "=\n\004name\030\001 \001(\tB/\340A\002\372A)\n\'opi_api.storage.v"
  "1/NvmeRemoteController\"a\n StatsNvmeRemot"
  "eControllerRequest\022=\n\004name\030\001 \001(\tB/\340A\002\372A)"
  "\n\'opi_api.storage.v1/NvmeRemoteControlle"
  "r\"S\n!StatsNvmeRemoteControllerResponse\022."
  "\n\005stats\030\001 \001(\0132\037.opi_api.storage.v1.Volum"
  "eStats\"\222\001\n\037ListNvmeRemoteNamespacesReque"
  "st\022>\n\006parent\030\001 \001(\tB.\340A\002\372A(\022&opi_api.stor"
  "age.v1/NvmeRemoteNamespace\022\026\n\tpage_size\030"
  "\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 \001(\tB\003\340A\001\"\204\001\n "
  "ListNvmeRemoteNamespacesResponse\022G\n\026nvme"
  "_remote_namespaces\030\001 \003(\0132\'.opi_api.stora"
  "ge.v1.NvmeRemoteNamespace\022\027\n\017next_page_t"
  "oken\030\002 \001(\t\"]\n\035GetNvmeRemoteNamespaceRequ"
  "est\022<\n\004name\030\001 \001(\tB.\340A\002\372A(\n&opi_api.stora"
  "ge.v1/NvmeRemoteNamespace\"\251\001\n\025CreateNvme"
  "PathRequest\022\?\n\006parent\030\001 \001(\tB/\340A\002\372A)\n\'opi"
  "_api.storage.v1/NvmeRemoteController\0224\n\t"
  "nvme_path\030\002 \001(\0132\034.opi_api.storage.v1.Nvm"
  "ePathB\003\340A\002\022\031\n\014nvme_path_id\030\003 \001(\tB\003\340A\001\"f\n"
  "\025DeleteNvmePathRequest\0221\n\004name\030\001 \001(\tB#\340A"
  "\002\372A\035\n\033opi_api.storage.v1/NvmePath\022\032\n\rall"
  "ow_missing\030\002 \001(\010B\003\340A\001\"\237\001\n\025UpdateNvmePath"
  "Request\0224\n\tnvme_path\030\001 \001(\0132\034.opi_api.sto"
  "rage.v1.NvmePathB\003\340A\002\0224\n\013update_mask\030\002 \001"
  "(\0132\032.google.protobuf.FieldMaskB\003\340A\001\022\032\n\ra"
  "llow_missing\030\003 \001(\010B\003\340A\001\"|\n\024ListNvmePaths"
  "Request\0223\n\006parent\030\001 \001(\tB#\340A\002\372A\035\022\033opi_api"
  ".storage.v1/NvmePath\022\026\n\tpage_size\030\002 \001(\005B"
  "\003\340A\001\022\027\n\npage_token\030\003 \001(\tB\003\340A\001\"b\n\025ListNvm"
  "ePathsResponse\0220\n\nnvme_paths\030\001 \003(\0132\034.opi"
  "_api.storage.v1.NvmePath\022\027\n\017next_page_to"
  "ken\030\002 \001(\t\"G\n\022GetNvmePathRequest\0221\n\004name\030"
  "\001 \001(\tB#\340A\002\372A\035\n\033opi_api.storage.v1/NvmePa"
  "th\"I\n\024StatsNvmePathRequest\0221\n\004name\030\001 \001(\t"
  "B#\340A\002\372A\035\n\033opi_api.storage.v1/NvmePath\"G\n"
  "\025StatsNvmePathResponse\022.\n\005stats\030\001 \001(\0132\037."
  "opi_api.storage.v1.VolumeStats*\206\001\n\rNvmeM"
  "ultipath\022\036\n\032NVME_MULTIPATH_UNSPECIFIED\020\000"
  "\022\032\n\026NVME_MULTIPATH_DISABLE\020\001\022\033\n\027NVME_MUL"
  "TIPATH_FAILOVER\020\002\022\034\n\030NVME_MULTIPATH_MULT"
  "IPATH\020\0032\206\026\n\033NvmeRemoteControllerService\022"
  "\353\001\n\032CreateNvmeRemoteController\0225.opi_api"
  ".storage.v1.CreateNvmeRemoteControllerRe"
  "quest\032(.opi_api.storage.v1.NvmeRemoteCon"
  "troller\"l\202\323\344\223\0023\"\031/v1/nvmeRemoteControlle"
  "rs:\026nvme_remote_controller\332A0nvme_remote"
  "_controller,nvme_remote_controller_id\022\236\001"
  "\n\032DeleteNvmeRemoteController\0225.opi_api.s"
  "torage.v1.DeleteNvmeRemoteControllerRequ"
  "est\032\026.google.protobuf.Empty\"1\202\323\344\223\002$*\"/v1"
  "/{name=nvmeRemoteControllers/*}\332A\004name\022\375"
  "\001\n\032UpdateNvmeRemoteController\0225.opi_api."
  "storage.v1.UpdateNvmeRemoteControllerReq"
  "uest\032(.opi_api.storage.v1.NvmeRemoteCont"
  "roller\"~\202\323\344\223\002S29/v1/{nvme_remote_control"
  "ler.name=nvmeRemoteControllers/*}:\026nvme_"
  "remote_controller\332A\"nvme_remote_controll"
  "er,update_mask\022\253\001\n\031ListNvmeRemoteControl"
  "lers\0224.opi_api.storage.v1.ListNvmeRemote"
  "ControllersRequest\0325.opi_api.storage.v1."
  "ListNvmeRemoteControllersResponse\"!\202\323\344\223\002"
  "\033\022\031/v1/nvmeRemoteControllers\022\252\001\n\027GetNvme"
  "RemoteController\0222.opi_api.storage.v1.Ge"
  "tNvmeRemoteControllerRequest\032(.opi_api.s"
  "torage.v1.NvmeRemoteController\"1\202\323\344\223\002$\022\""
  "/v1/{name=nvmeRemoteControllers/*}\332A\004nam"
  "e\022\245\001\n\031ResetNvmeRemoteController\0224.opi_ap"
  "i.storage.v1.ResetNvmeRemoteControllerRe"
  "quest\032\026.google.protobuf.Empty\":\202\323\344\223\002-\"(/"
  "v1/{name=nvmeRemoteControllers/*}:reset:"
  "\001*\332A\004name\022\301\001\n\031StatsNvmeRemoteController\022"
  "4.opi_api.storage.v1.StatsNvmeRemoteCont"
  "rollerRequest\0325.opi_api.storage.v1.Stats"
  "NvmeRemoteControllerResponse\"7\202\323\344\223\002*\022(/v"
  "1/{name=nvmeRemoteControllers/*}:stats\332A"
  "\004name\022\321\001\n\030ListNvmeRemoteNamespaces\0223.opi"
  "_api.storage.v1.ListNvmeRemoteNamespaces"
  "Request\0324.opi_api.storage.v1.ListNvmeRem"
  "oteNamespacesResponse\"J\202\323\344\223\002;\0229/v1/{pare"
  "nt=nvmeRemoteControllers/*}/nvmeRemoteNa"
  "mespaces\332A\006parent\022\276\001\n\026GetNvmeRemoteNames"
  "pace\0221.opi_api.storage.v1.GetNvmeRemoteN"
  "amespaceRequest\032\'.opi_api.storage.v1.Nvm"
  "eRemoteNamespace\"H\202\323\344\223\002;\0229/v1/{name=nvme"
  "RemoteControllers/*/nvmeRemoteNamespaces"
  "/*}\332A\004name\022\274\001\n\016CreateNvmePath\022).opi_api."
  "storage.v1.CreateNvmePathRequest\032\034.opi_a"
  "pi.storage.v1.NvmePath\"a\202\323\344\223\002;\"./v1/{par"
  "ent=nvmeRemoteControllers/*}/nvmePaths:\t"
  "nvme_path\332A\035parent,nvme_path,nvme_path_i"
  "d\022\222\001\n\016DeleteNvmePath\022).opi_api.storage.v"
  "1.DeleteNvmePathRequest\032\026.google.protobu"
  "f.Empty\"=\202\323\344\223\0020*./v1/{name=nvmeRemoteCon"
  "trollers/*/nvmePaths/*}\332A\004name\022\276\001\n\016Updat"
  "eNvmePath\022).opi_api.storage.v1.UpdateNvm"
  "ePathRequest\032\034.opi_api.storage.v1.NvmePa"
  "th\"c\202\323\344\223\002E28/v1/{nvme_path.name=nvmeRemo"
  "teControllers/*/nvmePaths/*}:\tnvme_path\332"
  "A\025nvme_path,update_mask\022\245\001\n\rListNvmePath"
  "s\022(.opi_api.storage.v1.ListNvmePathsRequ"
  "est\032).opi_api.storage.v1.ListNvmePathsRe"
  "sponse\"\?\202\323\344\223\0020\022./v1/{parent=nvmeRemoteCo"
  "ntrollers/*}/nvmePaths\332A\006parent\022\222\001\n\013GetN"
  "vmePath\022&.opi_api.storage.v1.GetNvmePath"
  "Request\032\034.opi_api.storage.v1.NvmePath\"=\202"
  "\323\344\223\0020\022./v1/{name=nvmeRemoteControllers/*"
  "/nvmePaths/*}\332A\004name\022\251\001\n\rStatsNvmePath\022("
  ".opi_api.storage.v1.StatsNvmePathRequest"
  "\032).opi_api.storage.v1.StatsNvmePathRespo"
  "nse\"C\202\323\344\223\0026\0224/v1/{name=nvmeRemoteControl"
  "lers/*/nvmePaths/*}:stats\332A\004nameB_\n\022opi_"
  "api.storage.v1B\020BackendNvmeProtoP\001Z5gith"
  "ub.com/opiproject/opi-api/storage/v1alph"
  "a1/gen/gob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_backend_5fnvme_2eproto_deps[8] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2fclient_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ffield_5fmask_2eproto,
  &::descriptor_table_opicommon_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::_pbi::once_flag descriptor_table_backend_5fnvme_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_backend_5fnvme_2eproto = {
    false, false, 6857, descriptor_table_protodef_backend_5fnvme_2eproto,
    "backend_nvme.proto",
    &descriptor_table_backend_5fnvme_2eproto_once, descriptor_table_backend_5fnvme_2eproto_deps, 8, 25,
    schemas, file_default_instances, TableStruct_backend_5fnvme_2eproto::offsets,
    file_level_metadata_backend_5fnvme_2eproto, file_level_enum_descriptors_backend_5fnvme_2eproto,
    file_level_service_descriptors_backend_5fnvme_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_backend_5fnvme_2eproto_getter() {
  return &descriptor_table_backend_5fnvme_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_backend_5fnvme_2eproto(&descriptor_table_backend_5fnvme_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeMultipath_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_backend_5fnvme_2eproto);
  return file_level_enum_descriptors_backend_5fnvme_2eproto[0];
}
bool NvmeMultipath_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NvmeRemoteController::_Internal {
 public:
  static const ::opi_api::storage::v1::TcpController& tcp(const NvmeRemoteController* msg);
};

const ::opi_api::storage::v1::TcpController&
NvmeRemoteController::_Internal::tcp(const NvmeRemoteController* msg) {
  return *msg->_impl_.tcp_;
}
NvmeRemoteController::NvmeRemoteController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeRemoteController)
}
NvmeRemoteController::NvmeRemoteController(const NvmeRemoteController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeRemoteController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.io_queues_count_){}
    , decltype(_impl_.queue_size_){}
    , decltype(_impl_.multipath_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tcp()) {
    _this->_impl_.tcp_ = new ::opi_api::storage::v1::TcpController(*from._impl_.tcp_);
  }
  ::memcpy(&_impl_.io_queues_count_, &from._impl_.io_queues_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.multipath_) -
    reinterpret_cast<char*>(&_impl_.io_queues_count_)) + sizeof(_impl_.multipath_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeRemoteController)
}

inline void NvmeRemoteController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.io_queues_count_){int64_t{0}}
    , decltype(_impl_.queue_size_){int64_t{0}}
    , decltype(_impl_.multipath_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeRemoteController::~NvmeRemoteController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeRemoteController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeRemoteController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tcp_;
}

void NvmeRemoteController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeRemoteController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeRemoteController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tcp_ != nullptr) {
    delete _impl_.tcp_;
  }
  _impl_.tcp_ = nullptr;
  ::memset(&_impl_.io_queues_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.multipath_) -
      reinterpret_cast<char*>(&_impl_.io_queues_count_)) + sizeof(_impl_.multipath_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeRemoteController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteController.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_multipath(static_cast<::opi_api::storage::v1::NvmeMultipath>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.io_queues_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeRemoteController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeRemoteController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteController.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_multipath() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_multipath(), target);
  }

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_io_queues_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_io_queues_count(), target);
  }

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_queue_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_queue_size(), target);
  }

  // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_tcp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::tcp(this),
        _Internal::tcp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeRemoteController)
  return target;
}

size_t NvmeRemoteController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeRemoteController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_tcp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tcp_);
  }

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_io_queues_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_io_queues_count());
  }

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_queue_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_queue_size());
  }

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_multipath() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_multipath());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeRemoteController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeRemoteController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeRemoteController::GetClassData() const { return &_class_data_; }


void NvmeRemoteController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeRemoteController*>(&to_msg);
  auto& from = static_cast<const NvmeRemoteController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeRemoteController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_tcp()) {
    _this->_internal_mutable_tcp()->::opi_api::storage::v1::TcpController::MergeFrom(
        from._internal_tcp());
  }
  if (from._internal_io_queues_count() != 0) {
    _this->_internal_set_io_queues_count(from._internal_io_queues_count());
  }
  if (from._internal_queue_size() != 0) {
    _this->_internal_set_queue_size(from._internal_queue_size());
  }
  if (from._internal_multipath() != 0) {
    _this->_internal_set_multipath(from._internal_multipath());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeRemoteController::CopyFrom(const NvmeRemoteController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeRemoteController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeRemoteController::IsInitialized() const {
  return true;
}

void NvmeRemoteController::InternalSwap(NvmeRemoteController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeRemoteController, _impl_.multipath_)
      + sizeof(NvmeRemoteController::_impl_.multipath_)
      - PROTOBUF_FIELD_OFFSET(NvmeRemoteController, _impl_.tcp_)>(
          reinterpret_cast<char*>(&_impl_.tcp_),
          reinterpret_cast<char*>(&other->_impl_.tcp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeRemoteController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[0]);
}

// ===================================================================

class TcpController::_Internal {
 public:
};

TcpController::TcpController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.TcpController)
}
TcpController::TcpController(const TcpController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TcpController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.psk_){}
    , decltype(_impl_.hdgst_){}
    , decltype(_impl_.ddgst_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.psk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.psk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_psk().empty()) {
    _this->_impl_.psk_.Set(from._internal_psk(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hdgst_, &from._impl_.hdgst_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ddgst_) -
    reinterpret_cast<char*>(&_impl_.hdgst_)) + sizeof(_impl_.ddgst_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.TcpController)
}

inline void TcpController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.psk_){}
    , decltype(_impl_.hdgst_){false}
    , decltype(_impl_.ddgst_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.psk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.psk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TcpController::~TcpController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.TcpController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TcpController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.psk_.Destroy();
}

void TcpController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TcpController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.TcpController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.psk_.ClearToEmpty();
  ::memset(&_impl_.hdgst_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ddgst_) -
      reinterpret_cast<char*>(&_impl_.hdgst_)) + sizeof(_impl_.ddgst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TcpController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hdgst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ddgst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_psk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TcpController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.TcpController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_hdgst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_hdgst(), target);
  }

  // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_ddgst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_ddgst(), target);
  }

  // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_psk().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_psk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.TcpController)
  return target;
}

size_t TcpController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.TcpController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_psk().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_psk());
  }

  // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_hdgst() != 0) {
    total_size += 1 + 1;
  }

  // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_ddgst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TcpController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TcpController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TcpController::GetClassData() const { return &_class_data_; }


void TcpController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TcpController*>(&to_msg);
  auto& from = static_cast<const TcpController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.TcpController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_psk().empty()) {
    _this->_internal_set_psk(from._internal_psk());
  }
  if (from._internal_hdgst() != 0) {
    _this->_internal_set_hdgst(from._internal_hdgst());
  }
  if (from._internal_ddgst() != 0) {
    _this->_internal_set_ddgst(from._internal_ddgst());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TcpController::CopyFrom(const TcpController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.TcpController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpController::IsInitialized() const {
  return true;
}

void TcpController::InternalSwap(TcpController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.psk_, lhs_arena,
      &other->_impl_.psk_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TcpController, _impl_.ddgst_)
      + sizeof(TcpController::_impl_.ddgst_)
      - PROTOBUF_FIELD_OFFSET(TcpController, _impl_.hdgst_)>(
          reinterpret_cast<char*>(&_impl_.hdgst_),
          reinterpret_cast<char*>(&other->_impl_.hdgst_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TcpController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[1]);
}

// ===================================================================

class NvmePath::_Internal {
 public:
  static const ::opi_api::storage::v1::FabricsPath& fabrics(const NvmePath* msg);
};

const ::opi_api::storage::v1::FabricsPath&
NvmePath::_Internal::fabrics(const NvmePath* msg) {
  return *msg->_impl_.fabrics_;
}
NvmePath::NvmePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmePath)
}
NvmePath::NvmePath(const NvmePath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmePath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.traddr_){}
    , decltype(_impl_.fabrics_){nullptr}
    , decltype(_impl_.trtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_traddr().empty()) {
    _this->_impl_.traddr_.Set(from._internal_traddr(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fabrics()) {
    _this->_impl_.fabrics_ = new ::opi_api::storage::v1::FabricsPath(*from._impl_.fabrics_);
  }
  _this->_impl_.trtype_ = from._impl_.trtype_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmePath)
}

inline void NvmePath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.traddr_){}
    , decltype(_impl_.fabrics_){nullptr}
    , decltype(_impl_.trtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmePath::~NvmePath() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmePath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmePath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.traddr_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fabrics_;
}

void NvmePath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmePath::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmePath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.traddr_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fabrics_ != nullptr) {
    delete _impl_.fabrics_;
  }
  _impl_.fabrics_ = nullptr;
  _impl_.trtype_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmePath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeTransportType trtype = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_trtype(static_cast<::opi_api::storage::v1::NvmeTransportType>(val));
        } else
          goto handle_unusual;
        continue;
      // string traddr = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_traddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.traddr"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.FabricsPath fabrics = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_fabrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmePath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmePath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeTransportType trtype = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_trtype(), target);
  }

  // string traddr = 3 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_traddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_traddr().data(), static_cast<int>(this->_internal_traddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.traddr");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_traddr(), target);
  }

  // .opi_api.storage.v1.FabricsPath fabrics = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_fabrics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::fabrics(this),
        _Internal::fabrics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmePath)
  return target;
}

size_t NvmePath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmePath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string traddr = 3 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_traddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_traddr());
  }

  // .opi_api.storage.v1.FabricsPath fabrics = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_fabrics()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fabrics_);
  }

  // .opi_api.storage.v1.NvmeTransportType trtype = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_trtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmePath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmePath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmePath::GetClassData() const { return &_class_data_; }


void NvmePath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmePath*>(&to_msg);
  auto& from = static_cast<const NvmePath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmePath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_traddr().empty()) {
    _this->_internal_set_traddr(from._internal_traddr());
  }
  if (from._internal_has_fabrics()) {
    _this->_internal_mutable_fabrics()->::opi_api::storage::v1::FabricsPath::MergeFrom(
        from._internal_fabrics());
  }
  if (from._internal_trtype() != 0) {
    _this->_internal_set_trtype(from._internal_trtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmePath::CopyFrom(const NvmePath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmePath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmePath::IsInitialized() const {
  return true;
}

void NvmePath::InternalSwap(NvmePath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.traddr_, lhs_arena,
      &other->_impl_.traddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmePath, _impl_.trtype_)
      + sizeof(NvmePath::_impl_.trtype_)
      - PROTOBUF_FIELD_OFFSET(NvmePath, _impl_.fabrics_)>(
          reinterpret_cast<char*>(&_impl_.fabrics_),
          reinterpret_cast<char*>(&other->_impl_.fabrics_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmePath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[2]);
}

// ===================================================================

class FabricsPath::_Internal {
 public:
};

FabricsPath::FabricsPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.FabricsPath)
}
FabricsPath::FabricsPath(const FabricsPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FabricsPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subnqn_){}
    , decltype(_impl_.source_traddr_){}
    , decltype(_impl_.hostnqn_){}
    , decltype(_impl_.trsvcid_){}
    , decltype(_impl_.source_trsvcid_){}
    , decltype(_impl_.adrfam_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subnqn().empty()) {
    _this->_impl_.subnqn_.Set(from._internal_subnqn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_traddr().empty()) {
    _this->_impl_.source_traddr_.Set(from._internal_source_traddr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hostnqn().empty()) {
    _this->_impl_.hostnqn_.Set(from._internal_hostnqn(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.trsvcid_, &from._impl_.trsvcid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.adrfam_) -
    reinterpret_cast<char*>(&_impl_.trsvcid_)) + sizeof(_impl_.adrfam_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.FabricsPath)
}

inline void FabricsPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.subnqn_){}
    , decltype(_impl_.source_traddr_){}
    , decltype(_impl_.hostnqn_){}
    , decltype(_impl_.trsvcid_){int64_t{0}}
    , decltype(_impl_.source_trsvcid_){int64_t{0}}
    , decltype(_impl_.adrfam_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FabricsPath::~FabricsPath() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.FabricsPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FabricsPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subnqn_.Destroy();
  _impl_.source_traddr_.Destroy();
  _impl_.hostnqn_.Destroy();
}

void FabricsPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FabricsPath::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.FabricsPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subnqn_.ClearToEmpty();
  _impl_.source_traddr_.ClearToEmpty();
  _impl_.hostnqn_.ClearToEmpty();
  ::memset(&_impl_.trsvcid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.adrfam_) -
      reinterpret_cast<char*>(&_impl_.trsvcid_)) + sizeof(_impl_.adrfam_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FabricsPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.trsvcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subnqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.FabricsPath.subnqn"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_adrfam(static_cast<::opi_api::storage::v1::NvmeAddressFamily>(val));
        } else
          goto handle_unusual;
        continue;
      // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_source_traddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.FabricsPath.source_traddr"));
        } else
          goto handle_unusual;
        continue;
      // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.source_trsvcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_hostnqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.FabricsPath.hostnqn"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FabricsPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.FabricsPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trsvcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_trsvcid(), target);
  }

  // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_subnqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subnqn().data(), static_cast<int>(this->_internal_subnqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.FabricsPath.subnqn");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_subnqn(), target);
  }

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_adrfam() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_adrfam(), target);
  }

  // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_source_traddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source_traddr().data(), static_cast<int>(this->_internal_source_traddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.FabricsPath.source_traddr");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_source_traddr(), target);
  }

  // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_source_trsvcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_source_trsvcid(), target);
  }

  // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_hostnqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hostnqn().data(), static_cast<int>(this->_internal_hostnqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.FabricsPath.hostnqn");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_hostnqn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.FabricsPath)
  return target;
}

size_t FabricsPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.FabricsPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_subnqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subnqn());
  }

  // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_source_traddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source_traddr());
  }

  // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_hostnqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostnqn());
  }

  // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trsvcid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_trsvcid());
  }

  // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_source_trsvcid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_source_trsvcid());
  }

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_adrfam() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_adrfam());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FabricsPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FabricsPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FabricsPath::GetClassData() const { return &_class_data_; }


void FabricsPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FabricsPath*>(&to_msg);
  auto& from = static_cast<const FabricsPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.FabricsPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subnqn().empty()) {
    _this->_internal_set_subnqn(from._internal_subnqn());
  }
  if (!from._internal_source_traddr().empty()) {
    _this->_internal_set_source_traddr(from._internal_source_traddr());
  }
  if (!from._internal_hostnqn().empty()) {
    _this->_internal_set_hostnqn(from._internal_hostnqn());
  }
  if (from._internal_trsvcid() != 0) {
    _this->_internal_set_trsvcid(from._internal_trsvcid());
  }
  if (from._internal_source_trsvcid() != 0) {
    _this->_internal_set_source_trsvcid(from._internal_source_trsvcid());
  }
  if (from._internal_adrfam() != 0) {
    _this->_internal_set_adrfam(from._internal_adrfam());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FabricsPath::CopyFrom(const FabricsPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.FabricsPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FabricsPath::IsInitialized() const {
  return true;
}

void FabricsPath::InternalSwap(FabricsPath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.subnqn_, lhs_arena,
      &other->_impl_.subnqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_traddr_, lhs_arena,
      &other->_impl_.source_traddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostnqn_, lhs_arena,
      &other->_impl_.hostnqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FabricsPath, _impl_.adrfam_)
      + sizeof(FabricsPath::_impl_.adrfam_)
      - PROTOBUF_FIELD_OFFSET(FabricsPath, _impl_.trsvcid_)>(
          reinterpret_cast<char*>(&_impl_.trsvcid_),
          reinterpret_cast<char*>(&other->_impl_.trsvcid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FabricsPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[3]);
}

// ===================================================================

class NvmeRemoteNamespace::_Internal {
 public:
  static const ::opi_api::common::v1::Uuid& uuid(const NvmeRemoteNamespace* msg);
};

const ::opi_api::common::v1::Uuid&
NvmeRemoteNamespace::_Internal::uuid(const NvmeRemoteNamespace* msg) {
  return *msg->_impl_.uuid_;
}
void NvmeRemoteNamespace::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
}
NvmeRemoteNamespace::NvmeRemoteNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeRemoteNamespace)
}
NvmeRemoteNamespace::NvmeRemoteNamespace(const NvmeRemoteNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeRemoteNamespace* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.nguid_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){}
    , decltype(_impl_.nsid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    _this->_impl_.nguid_.Set(from._internal_nguid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::opi_api::common::v1::Uuid(*from._impl_.uuid_);
  }
  ::memcpy(&_impl_.eui64_, &from._impl_.eui64_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nsid_) -
    reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.nsid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeRemoteNamespace)
}

inline void NvmeRemoteNamespace::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.nguid_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){int64_t{0}}
    , decltype(_impl_.nsid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeRemoteNamespace::~NvmeRemoteNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeRemoteNamespace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeRemoteNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.nguid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void NvmeRemoteNamespace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeRemoteNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeRemoteNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.nguid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
  ::memset(&_impl_.eui64_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nsid_) -
      reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.nsid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeRemoteNamespace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.name"));
        } else
          goto handle_unusual;
        continue;
      // int32 nsid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nguid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.nguid"));
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeRemoteNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeRemoteNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // int32 nsid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nsid(), target);
  }

  // string nguid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.nguid");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nguid(), target);
  }

  // int64 eui64 = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_uuid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeRemoteNamespace)
  return target;
}

size_t NvmeRemoteNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeRemoteNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = IDENTIFIER];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string nguid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_);
  }

  // int64 eui64 = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_eui64() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 nsid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_nsid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nsid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeRemoteNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeRemoteNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeRemoteNamespace::GetClassData() const { return &_class_data_; }


void NvmeRemoteNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeRemoteNamespace*>(&to_msg);
  auto& from = static_cast<const NvmeRemoteNamespace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeRemoteNamespace)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_nguid().empty()) {
    _this->_internal_set_nguid(from._internal_nguid());
  }
  if (from._internal_has_uuid()) {
    _this->_internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(
        from._internal_uuid());
  }
  if (from._internal_eui64() != 0) {
    _this->_internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_nsid() != 0) {
    _this->_internal_set_nsid(from._internal_nsid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeRemoteNamespace::CopyFrom(const NvmeRemoteNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeRemoteNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeRemoteNamespace::IsInitialized() const {
  return true;
}

void NvmeRemoteNamespace::InternalSwap(NvmeRemoteNamespace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nguid_, lhs_arena,
      &other->_impl_.nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeRemoteNamespace, _impl_.nsid_)
      + sizeof(NvmeRemoteNamespace::_impl_.nsid_)
      - PROTOBUF_FIELD_OFFSET(NvmeRemoteNamespace, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeRemoteNamespace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[4]);
}

// ===================================================================

class CreateNvmeRemoteControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller(const CreateNvmeRemoteControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeRemoteController&
CreateNvmeRemoteControllerRequest::_Internal::nvme_remote_controller(const CreateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.nvme_remote_controller_;
}
CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
}
CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(const CreateNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_id_){}
    , decltype(_impl_.nvme_remote_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nvme_remote_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_remote_controller_id().empty()) {
    _this->_impl_.nvme_remote_controller_id_.Set(from._internal_nvme_remote_controller_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_remote_controller()) {
    _this->_impl_.nvme_remote_controller_ = new ::opi_api::storage::v1::NvmeRemoteController(*from._impl_.nvme_remote_controller_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
}

inline void CreateNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_id_){}
    , decltype(_impl_.nvme_remote_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nvme_remote_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmeRemoteControllerRequest::~CreateNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_controller_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_remote_controller_;
}

void CreateNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_controller_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_remote_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_remote_controller_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_remote_controller(this),
        _Internal::nvme_remote_controller(this).GetCachedSize(), target, stream);
  }

  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_remote_controller_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_remote_controller_id().data(), static_cast<int>(this->_internal_nvme_remote_controller_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_remote_controller_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  return target;
}

size_t CreateNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_remote_controller_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_remote_controller_id());
  }

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_remote_controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void CreateNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_remote_controller_id().empty()) {
    _this->_internal_set_nvme_remote_controller_id(from._internal_nvme_remote_controller_id());
  }
  if (from._internal_has_nvme_remote_controller()) {
    _this->_internal_mutable_nvme_remote_controller()->::opi_api::storage::v1::NvmeRemoteController::MergeFrom(
        from._internal_nvme_remote_controller());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeRemoteControllerRequest::CopyFrom(const CreateNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void CreateNvmeRemoteControllerRequest::InternalSwap(CreateNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_remote_controller_id_, lhs_arena,
      &other->_impl_.nvme_remote_controller_id_, rhs_arena
  );
  swap(_impl_.nvme_remote_controller_, other->_impl_.nvme_remote_controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[5]);
}

// ===================================================================

class DeleteNvmeRemoteControllerRequest::_Internal {
 public:
};

DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
}
DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(const DeleteNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
}

inline void DeleteNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmeRemoteControllerRequest::~DeleteNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  return target;
}

size_t DeleteNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeRemoteControllerRequest::CopyFrom(const DeleteNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeRemoteControllerRequest::InternalSwap(DeleteNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[6]);
}

// ===================================================================

class UpdateNvmeRemoteControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller(const UpdateNvmeRemoteControllerRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeRemoteControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeRemoteController&
UpdateNvmeRemoteControllerRequest::_Internal::nvme_remote_controller(const UpdateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.nvme_remote_controller_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeRemoteControllerRequest::_Internal::update_mask(const UpdateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmeRemoteControllerRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
}
UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(const UpdateNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_remote_controller()) {
    _this->_impl_.nvme_remote_controller_ = new ::opi_api::storage::v1::NvmeRemoteController(*from._impl_.nvme_remote_controller_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
}

inline void UpdateNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmeRemoteControllerRequest::~UpdateNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_remote_controller_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_remote_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_remote_controller(this),
        _Internal::nvme_remote_controller(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  return target;
}

size_t UpdateNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_remote_controller_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_remote_controller()) {
    _this->_internal_mutable_nvme_remote_controller()->::opi_api::storage::v1::NvmeRemoteController::MergeFrom(
        from._internal_nvme_remote_controller());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeRemoteControllerRequest::CopyFrom(const UpdateNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeRemoteControllerRequest::InternalSwap(UpdateNvmeRemoteControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeRemoteControllerRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmeRemoteControllerRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_)>(
          reinterpret_cast<char*>(&_impl_.nvme_remote_controller_),
          reinterpret_cast<char*>(&other->_impl_.nvme_remote_controller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[7]);
}

// ===================================================================

class ListNvmeRemoteControllersRequest::_Internal {
 public:
};

ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
}
ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(const ListNvmeRemoteControllersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteControllersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
}

inline void ListNvmeRemoteControllersRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteControllersRequest::~ListNvmeRemoteControllersRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteControllersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.page_token_.Destroy();
}

void ListNvmeRemoteControllersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteControllersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteControllersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteControllersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_page_size(), target);
  }

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  return target;
}

size_t ListNvmeRemoteControllersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteControllersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteControllersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteControllersRequest::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteControllersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteControllersRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteControllersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteControllersRequest::CopyFrom(const ListNvmeRemoteControllersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteControllersRequest::IsInitialized() const {
  return true;
}

void ListNvmeRemoteControllersRequest::InternalSwap(ListNvmeRemoteControllersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteControllersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[8]);
}

// ===================================================================

class ListNvmeRemoteControllersResponse::_Internal {
 public:
};

ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
}
ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(const ListNvmeRemoteControllersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteControllersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controllers_){from._impl_.nvme_remote_controllers_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
}

inline void ListNvmeRemoteControllersResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controllers_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteControllersResponse::~ListNvmeRemoteControllersResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteControllersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_controllers_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeRemoteControllersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteControllersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_controllers_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteControllersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_remote_controllers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteControllersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_remote_controllers_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_remote_controllers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  return target;
}

size_t ListNvmeRemoteControllersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  total_size += 1UL * this->_internal_nvme_remote_controllers_size();
  for (const auto& msg : this->_impl_.nvme_remote_controllers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteControllersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteControllersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteControllersResponse::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteControllersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteControllersResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteControllersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_remote_controllers_.MergeFrom(from._impl_.nvme_remote_controllers_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteControllersResponse::CopyFrom(const ListNvmeRemoteControllersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteControllersResponse::IsInitialized() const {
  return true;
}

void ListNvmeRemoteControllersResponse::InternalSwap(ListNvmeRemoteControllersResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_remote_controllers_.InternalSwap(&other->_impl_.nvme_remote_controllers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteControllersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[9]);
}

// ===================================================================

class GetNvmeRemoteControllerRequest::_Internal {
 public:
};

GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
}
GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(const GetNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
}

inline void GetNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeRemoteControllerRequest::~GetNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  return target;
}

size_t GetNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void GetNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeRemoteControllerRequest::CopyFrom(const GetNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void GetNvmeRemoteControllerRequest::InternalSwap(GetNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[10]);
}

// ===================================================================

class ResetNvmeRemoteControllerRequest::_Internal {
 public:
};

ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
}
ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(const ResetNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResetNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
}

inline void ResetNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResetNvmeRemoteControllerRequest::~ResetNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ResetNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResetNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResetNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  return target;
}

size_t ResetNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResetNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResetNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResetNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void ResetNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResetNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const ResetNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResetNvmeRemoteControllerRequest::CopyFrom(const ResetNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void ResetNvmeRemoteControllerRequest::InternalSwap(ResetNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ResetNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[11]);
}

// ===================================================================

class StatsNvmeRemoteControllerRequest::_Internal {
 public:
};

StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
}
StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(const StatsNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
}

inline void StatsNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeRemoteControllerRequest::~StatsNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  return target;
}

size_t StatsNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void StatsNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeRemoteControllerRequest::CopyFrom(const StatsNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void StatsNvmeRemoteControllerRequest::InternalSwap(StatsNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[12]);
}

// ===================================================================

class StatsNvmeRemoteControllerResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeRemoteControllerResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeRemoteControllerResponse::_Internal::stats(const StatsNvmeRemoteControllerResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmeRemoteControllerResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
}
StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(const StatsNvmeRemoteControllerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeRemoteControllerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
}

inline void StatsNvmeRemoteControllerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmeRemoteControllerResponse::~StatsNvmeRemoteControllerResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeRemoteControllerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmeRemoteControllerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeRemoteControllerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeRemoteControllerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeRemoteControllerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  return target;
}

size_t StatsNvmeRemoteControllerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeRemoteControllerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeRemoteControllerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeRemoteControllerResponse::GetClassData() const { return &_class_data_; }


void StatsNvmeRemoteControllerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeRemoteControllerResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmeRemoteControllerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeRemoteControllerResponse::CopyFrom(const StatsNvmeRemoteControllerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeRemoteControllerResponse::IsInitialized() const {
  return true;
}

void StatsNvmeRemoteControllerResponse::InternalSwap(StatsNvmeRemoteControllerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeRemoteControllerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[13]);
}

// ===================================================================

class ListNvmeRemoteNamespacesRequest::_Internal {
 public:
};

ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
}
ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(const ListNvmeRemoteNamespacesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteNamespacesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
}

inline void ListNvmeRemoteNamespacesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteNamespacesRequest::~ListNvmeRemoteNamespacesRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteNamespacesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeRemoteNamespacesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteNamespacesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteNamespacesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteNamespacesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  return target;
}

size_t ListNvmeRemoteNamespacesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteNamespacesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteNamespacesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteNamespacesRequest::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteNamespacesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteNamespacesRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteNamespacesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteNamespacesRequest::CopyFrom(const ListNvmeRemoteNamespacesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteNamespacesRequest::IsInitialized() const {
  return true;
}

void ListNvmeRemoteNamespacesRequest::InternalSwap(ListNvmeRemoteNamespacesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteNamespacesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[14]);
}

// ===================================================================

class ListNvmeRemoteNamespacesResponse::_Internal {
 public:
};

ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
}
ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(const ListNvmeRemoteNamespacesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteNamespacesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_namespaces_){from._impl_.nvme_remote_namespaces_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
}

inline void ListNvmeRemoteNamespacesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_namespaces_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteNamespacesResponse::~ListNvmeRemoteNamespacesResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteNamespacesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_namespaces_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeRemoteNamespacesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteNamespacesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_namespaces_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteNamespacesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_remote_namespaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteNamespacesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_remote_namespaces_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_remote_namespaces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  return target;
}

size_t ListNvmeRemoteNamespacesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  total_size += 1UL * this->_internal_nvme_remote_namespaces_size();
  for (const auto& msg : this->_impl_.nvme_remote_namespaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteNamespacesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteNamespacesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteNamespacesResponse::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteNamespacesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteNamespacesResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteNamespacesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_remote_namespaces_.MergeFrom(from._impl_.nvme_remote_namespaces_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteNamespacesResponse::CopyFrom(const ListNvmeRemoteNamespacesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteNamespacesResponse::IsInitialized() const {
  return true;
}

void ListNvmeRemoteNamespacesResponse::InternalSwap(ListNvmeRemoteNamespacesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_remote_namespaces_.InternalSwap(&other->_impl_.nvme_remote_namespaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteNamespacesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[15]);
}

// ===================================================================

class GetNvmeRemoteNamespaceRequest::_Internal {
 public:
};

GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
}
GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(const GetNvmeRemoteNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeRemoteNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
}

inline void GetNvmeRemoteNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeRemoteNamespaceRequest::~GetNvmeRemoteNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeRemoteNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeRemoteNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeRemoteNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeRemoteNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeRemoteNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  return target;
}

size_t GetNvmeRemoteNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeRemoteNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeRemoteNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeRemoteNamespaceRequest::GetClassData() const { return &_class_data_; }


void GetNvmeRemoteNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeRemoteNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeRemoteNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeRemoteNamespaceRequest::CopyFrom(const GetNvmeRemoteNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeRemoteNamespaceRequest::IsInitialized() const {
  return true;
}

void GetNvmeRemoteNamespaceRequest::InternalSwap(GetNvmeRemoteNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeRemoteNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[16]);
}

// ===================================================================

class CreateNvmePathRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmePath& nvme_path(const CreateNvmePathRequest* msg);
};

const ::opi_api::storage::v1::NvmePath&
CreateNvmePathRequest::_Internal::nvme_path(const CreateNvmePathRequest* msg) {
  return *msg->_impl_.nvme_path_;
}
CreateNvmePathRequest::CreateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmePathRequest)
}
CreateNvmePathRequest::CreateNvmePathRequest(const CreateNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.nvme_path_id_){}
    , decltype(_impl_.nvme_path_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nvme_path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_path_id().empty()) {
    _this->_impl_.nvme_path_id_.Set(from._internal_nvme_path_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_path()) {
    _this->_impl_.nvme_path_ = new ::opi_api::storage::v1::NvmePath(*from._impl_.nvme_path_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmePathRequest)
}

inline void CreateNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.nvme_path_id_){}
    , decltype(_impl_.nvme_path_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nvme_path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmePathRequest::~CreateNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.nvme_path_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_path_;
}

void CreateNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.nvme_path_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmePathRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmePath nvme_path = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_path_id = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nvme_path_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmePathRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // .opi_api.storage.v1.NvmePath nvme_path = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nvme_path(this),
        _Internal::nvme_path(this).GetCachedSize(), target, stream);
  }

  // string nvme_path_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_path_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_path_id().data(), static_cast<int>(this->_internal_nvme_path_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nvme_path_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmePathRequest)
  return target;
}

size_t CreateNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string nvme_path_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_path_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_path_id());
  }

  // .opi_api.storage.v1.NvmePath nvme_path = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_path_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmePathRequest::GetClassData() const { return &_class_data_; }


void CreateNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_nvme_path_id().empty()) {
    _this->_internal_set_nvme_path_id(from._internal_nvme_path_id());
  }
  if (from._internal_has_nvme_path()) {
    _this->_internal_mutable_nvme_path()->::opi_api::storage::v1::NvmePath::MergeFrom(
        from._internal_nvme_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmePathRequest::CopyFrom(const CreateNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmePathRequest::IsInitialized() const {
  return true;
}

void CreateNvmePathRequest::InternalSwap(CreateNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_path_id_, lhs_arena,
      &other->_impl_.nvme_path_id_, rhs_arena
  );
  swap(_impl_.nvme_path_, other->_impl_.nvme_path_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[17]);
}

// ===================================================================

class DeleteNvmePathRequest::_Internal {
 public:
};

DeleteNvmePathRequest::DeleteNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmePathRequest)
}
DeleteNvmePathRequest::DeleteNvmePathRequest(const DeleteNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmePathRequest)
}

inline void DeleteNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmePathRequest::~DeleteNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmePathRequest)
  return target;
}

size_t DeleteNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmePathRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmePathRequest::CopyFrom(const DeleteNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmePathRequest::IsInitialized() const {
  return true;
}

void DeleteNvmePathRequest::InternalSwap(DeleteNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[18]);
}

// ===================================================================

class UpdateNvmePathRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmePath& nvme_path(const UpdateNvmePathRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmePathRequest* msg);
};

const ::opi_api::storage::v1::NvmePath&
UpdateNvmePathRequest::_Internal::nvme_path(const UpdateNvmePathRequest* msg) {
  return *msg->_impl_.nvme_path_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmePathRequest::_Internal::update_mask(const UpdateNvmePathRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmePathRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmePathRequest::UpdateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmePathRequest)
}
UpdateNvmePathRequest::UpdateNvmePathRequest(const UpdateNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_path()) {
    _this->_impl_.nvme_path_ = new ::opi_api::storage::v1::NvmePath(*from._impl_.nvme_path_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmePathRequest)
}

inline void UpdateNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmePathRequest::~UpdateNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_path_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_path(this),
        _Internal::nvme_path(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmePathRequest)
  return target;
}

size_t UpdateNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_path_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmePathRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_path()) {
    _this->_internal_mutable_nvme_path()->::opi_api::storage::v1::NvmePath::MergeFrom(
        from._internal_nvme_path());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmePathRequest::CopyFrom(const UpdateNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmePathRequest::IsInitialized() const {
  return true;
}

void UpdateNvmePathRequest::InternalSwap(UpdateNvmePathRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmePathRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmePathRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmePathRequest, _impl_.nvme_path_)>(
          reinterpret_cast<char*>(&_impl_.nvme_path_),
          reinterpret_cast<char*>(&other->_impl_.nvme_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[19]);
}

// ===================================================================

class ListNvmePathsRequest::_Internal {
 public:
};

ListNvmePathsRequest::ListNvmePathsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmePathsRequest)
}
ListNvmePathsRequest::ListNvmePathsRequest(const ListNvmePathsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmePathsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmePathsRequest)
}

inline void ListNvmePathsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmePathsRequest::~ListNvmePathsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmePathsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmePathsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmePathsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmePathsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmePathsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmePathsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmePathsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmePathsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmePathsRequest)
  return target;
}

size_t ListNvmePathsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmePathsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmePathsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmePathsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmePathsRequest::GetClassData() const { return &_class_data_; }


void ListNvmePathsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmePathsRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmePathsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmePathsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmePathsRequest::CopyFrom(const ListNvmePathsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmePathsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmePathsRequest::IsInitialized() const {
  return true;
}

void ListNvmePathsRequest::InternalSwap(ListNvmePathsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmePathsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[20]);
}

// ===================================================================

class ListNvmePathsResponse::_Internal {
 public:
};

ListNvmePathsResponse::ListNvmePathsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmePathsResponse)
}
ListNvmePathsResponse::ListNvmePathsResponse(const ListNvmePathsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmePathsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_paths_){from._impl_.nvme_paths_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmePathsResponse)
}

inline void ListNvmePathsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_paths_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmePathsResponse::~ListNvmePathsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmePathsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmePathsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_paths_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmePathsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmePathsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmePathsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_paths_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmePathsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_paths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmePathsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmePathsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_paths_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_paths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmePathsResponse)
  return target;
}

size_t ListNvmePathsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmePathsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  total_size += 1UL * this->_internal_nvme_paths_size();
  for (const auto& msg : this->_impl_.nvme_paths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmePathsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmePathsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmePathsResponse::GetClassData() const { return &_class_data_; }


void ListNvmePathsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmePathsResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmePathsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmePathsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_paths_.MergeFrom(from._impl_.nvme_paths_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmePathsResponse::CopyFrom(const ListNvmePathsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmePathsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmePathsResponse::IsInitialized() const {
  return true;
}

void ListNvmePathsResponse::InternalSwap(ListNvmePathsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_paths_.InternalSwap(&other->_impl_.nvme_paths_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmePathsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[21]);
}

// ===================================================================

class GetNvmePathRequest::_Internal {
 public:
};

GetNvmePathRequest::GetNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmePathRequest)
}
GetNvmePathRequest::GetNvmePathRequest(const GetNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmePathRequest)
}

inline void GetNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmePathRequest::~GetNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmePathRequest)
  return target;
}

size_t GetNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmePathRequest::GetClassData() const { return &_class_data_; }


void GetNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmePathRequest::CopyFrom(const GetNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmePathRequest::IsInitialized() const {
  return true;
}

void GetNvmePathRequest::InternalSwap(GetNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[22]);
}

// ===================================================================

class StatsNvmePathRequest::_Internal {
 public:
};

StatsNvmePathRequest::StatsNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmePathRequest)
}
StatsNvmePathRequest::StatsNvmePathRequest(const StatsNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmePathRequest)
}

inline void StatsNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmePathRequest::~StatsNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmePathRequest)
  return target;
}

size_t StatsNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmePathRequest::GetClassData() const { return &_class_data_; }


void StatsNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmePathRequest::CopyFrom(const StatsNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmePathRequest::IsInitialized() const {
  return true;
}

void StatsNvmePathRequest::InternalSwap(StatsNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[23]);
}

// ===================================================================

class StatsNvmePathResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmePathResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmePathResponse::_Internal::stats(const StatsNvmePathResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmePathResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmePathResponse::StatsNvmePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmePathResponse)
}
StatsNvmePathResponse::StatsNvmePathResponse(const StatsNvmePathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmePathResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmePathResponse)
}

inline void StatsNvmePathResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmePathResponse::~StatsNvmePathResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmePathResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmePathResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmePathResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmePathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmePathResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmePathResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmePathResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmePathResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmePathResponse)
  return target;
}

size_t StatsNvmePathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmePathResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmePathResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmePathResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmePathResponse::GetClassData() const { return &_class_data_; }


void StatsNvmePathResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmePathResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmePathResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmePathResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmePathResponse::CopyFrom(const StatsNvmePathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmePathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmePathResponse::IsInitialized() const {
  return true;
}

void StatsNvmePathResponse::InternalSwap(StatsNvmePathResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmePathResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[24]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeRemoteController*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeRemoteController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeRemoteController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::TcpController*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::TcpController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::TcpController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmePath*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmePath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmePath >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::FabricsPath*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::FabricsPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::FabricsPath >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeRemoteNamespace*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeRemoteNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeRemoteNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteControllersRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteControllersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteControllersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteControllersResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteControllersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteControllersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmePathsRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmePathsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmePathsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmePathsResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmePathsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmePathsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmePathResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmePathResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmePathResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
