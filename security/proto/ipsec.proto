/*
 * Copyright (C) 2021 Intel Corporation
 * SPDX-License-Identifier: Apache-2.0
 *
 * Major pieces taken from:
 * https://github.com/ligato/cn-infra/blob/master/examples/cryptodata-proto-plugin/ipsec/ipsec.proto
 * https://datatracker.ietf.org/doc/rfc9061/
 */
syntax = "proto3";
package opi.security.v1;
option go_package = "github.com/opiproject/opi-api/security/proto";

service IPsec {
	rpc IPsecVersion (IPsecVersionReq) returns (IPsecVersionResp) {}
	rpc IPsecStats   (IPsecStatsReq)   returns (IPsecStatsResp)   {}
	rpc IPsecInitiate (IPsecInitiateReq) returns (IPsecInitiateResp) {}
	rpc IPsecTerminate (IPsecTerminateReq) returns (IPsecTerminateResp) {}
	rpc IPsecRekey (IPsecRekeyReq) returns (IPsecRekeyResp) {}
	rpc IPsecListSas (IPsecListSasReq) returns (IPsecListSasResp) {}
	rpc IPsecListConns (IPsecListConnsReq) returns (IPsecListConnsResp) {}
	rpc IPsecListCerts (IPsecListCertsReq) returns (IPsecListCertsResp) {}
	rpc IPsecLoadConn (IPsecLoadConnReq) returns (IPsecLoadConnResp) {}
	rpc IPsecUnloadConn (IPsecUnloadConnReq) returns (IPsecUnloadConnResp) {}
}

/* Cryptographic algorithm for encryption */
enum CryptoAlgorithm {
	NONE_CRYPTO  = 0;
	AES128       = 1;
	AES192       = 2;
	AES256       = 3;
	AES128GCM128 = 4;
	AES256GCM128 = 5;
	AES128GMAC   = 6;
	AES256GMAC   = 7;
}
/* Cryptographic algorithm for authentication */
enum IntegAlgorithm {
	NONE_INTEG = 0;
	MD5        = 1;
	MD5_128    = 2;
	SHA1       = 3;
	SHA1_160   = 4;
	SHA256     = 5;
	SHA384     = 7;
	SHA512     = 8;
	SHA256_96  = 9;
}

/* Diffie Hellman Groups */
enum DiffieHellmanGroups {
	NONE_DH_GROUP = 0;
	MODP768      = 1;
	MODP1024     = 2;
	MODP1536     = 3;
	MODP2048     = 4;
	MODP3072     = 5;
	MODP4096     = 6;
	MODP6144     = 7;
	MODP8192     = 8;
	MODP1024S160 = 9;
	MODP2048S224 = 10;
	MODP2048S256 = 11;
	CURVE25519   = 12;
}

enum PseudoRandomFunction {
	NONE_PRF   = 0;
	PRFMD5     = 1;
	PRFSHA1    = 2;
	PRFAESXCBC = 3;
	PRFAESCMAC = 4;
	PRFSHA256  = 5;
	PRFSHA384  = 6;
	PRFSHA512  = 7;
}

/* Tunnel mode */
enum IPsecMode {
	TUNNEL_MODE = 0;
	TRANSPORT_MODE = 1;
}

/* Authentication Type */
enum AuthType {
	PUBKEY = 0;
	PSK    = 1;
	XAUTH  = 2;
	EAP    = 3;
}

/* IKE_SA state */
enum IkeSaState {
	CREATED     = 0;
	CONNECTING  = 1;
	ESTABLISHED = 2;
	PASSIVE     = 3;
	REKEYING    = 4;
	REKEYED     = 5;
	DELETING    = 6;
	DESTROYING  = 7;
}

/* CHILD_SA state */
enum ChildSaState {
	CHILD_CREATED    = 0;
	CHILD_ROUTED     = 1;
	CHILD_INSTALLING = 2;
	CHILD_INSTALLED  = 3;
	CHILD_UPDATING   = 4;
	CHILD_REKEYING   = 5;
	CHILD_REKEYED    = 6;
	CHILD_RETRYING   = 7;
	CHILD_DELETING   = 8;
	CHILD_DELETED    = 9;
	CHILD_DESTROYING = 10;
}

/* Certificate type */
enum CertificateType {
	CERT_X509          = 0;
	CERT_X509_AC       = 1;
	CERT_X509_CRL      = 2;
	CERT_OCSP_RESPONSE = 3;
	CERT_PUBKEY        = 4;
}

/* X.509 certificate flag */
enum X509CertificateFlag {
	X509_CERT_FLAG_NONE = 0;
	X509_CERT_FLAG_CA   = 1;
	X509_CERT_FLAG_AA   = 2;
	X509_CERT_FLAG_OCSP = 3;
}

message Proposals {
	repeated CryptoAlgorithm crypto_alg = 1;
	repeated IntegAlgorithm integ_alg = 2;
	repeated PseudoRandomFunction prf = 3;
	repeated DiffieHellmanGroups dhgroups = 4;
}

message Vips {
	repeated string vip = 1;
}

message Pools {
	repeated string pool = 1;
}

message Certs {
	repeated string cert = 1;
}

message PubKeys {
	repeated string pubkey = 1;
}

message Groups {
	repeated string group = 1;
}

message CertPolicy {
	repeated string cert_policy = 1;
}

message CaCerts {
	repeated string cacert = 1;
}

message LocalAuth {
	AuthType auth    = 1;
	string id        = 2;
	string eap_id    = 3;
	string aaa_id    = 4;
	string xauth_id  = 5;
	Certs certs      = 6;
	PubKeys pubkeys  = 7;
}

message RemoteAuth {
	AuthType auth          = 1;
	string id              = 2;
	string eap_id          = 3;
	Groups groups          = 4;
	CertPolicy cert_policy = 5;
	Certs certs            = 6;
	CaCerts ca_certs       = 7;
	PubKeys pubkeys        = 8;
}

message TrafficSelectors {
	message TrafficSelector {
		string cidr  = 1;
		string proto = 2;
		string port  = 3;
	}
	repeated TrafficSelector ts = 1;
}

/* IP addresses or hostanmes */
message Addrs {
	string addr = 1;
}

/* Child SA */
message Child {
	string name                = 1; /* Child SA name */
	Proposals ag_proposals     = 2;
	Proposals esp_proposals    = 3;
	TrafficSelectors local_ts  = 4;
	TrafficSelectors remote_ts = 5;
	uint32 rekey_time          = 6;
	uint32 life_time           = 7;
	uint32 rand_time           = 8;
	string updown              = 9;
	uint32 inactivity          = 10;
	uint32 mark_in             = 11;
	string mark_in_sa          = 12;
	uint32 mark_out            = 13;
	uint32 set_mark_in         = 14;
	uint32 set_mark_out        = 15;
	string hw_offload          = 16;
}

/* IKE connection */
message Connection {
	string name                 = 1; /* connection name */
	string version              = 2;
	repeated Addrs local_addrs  = 3;
	repeated Addrs remote_addrs = 4;
	uint32 local_port           = 5;
	uint32 remote_port          = 6;
	Proposals proposals         = 7;
	Vips vips                   = 8;
	uint64 dscp                 = 9; /* We use only the lower 6 bytes */
	string encap                = 10;
	string mobike               = 11;
	uint32 dpd_delay            = 12;
	uint32 dpd_timeout          = 13;
	uint32 reauth_time          = 14;
	uint32 rekey_time           = 15;
	Pools pools                 = 16;
	LocalAuth local_auth        = 17;
	RemoteAuth remote_auth      = 18;
	repeated Child children     = 19;
}

message Uuid {
	string value = 1;
}

message IPsecVersionReq {
	/* Intentionally empty */
}

message IPsecVersionResp {
	string daemon  = 1;
	string version = 2;
	string sysname = 3;
	string release = 4;
	string machine = 5;
}

message IPsecStatsReq {
	/* Intentionally empty */
}

message IPsecStatsResp {
	string status = 1; /* Generic status string for now */
}

message IPsecInitiateReq {
	string child    = 1;
	string ike      = 2;
	string timeout  = 3;
	string loglevel = 4;
}

message IPsecInitiateResp {
	/* Intentionally empty */
}

message IPsecTerminateReq {
	string child    = 1;
	string ike      = 2;
	uint64 child_id = 3;
	uint64 ike_id   = 4;
	string force    = 5;
	string timeout  = 6;
	string loglevel = 7;
}

message IPsecTerminateResp {
	string success    = 1;
	uint32 matches    = 2;
	uint32 terminated = 3;
}

message IPsecRekeyReq {
	string child    = 1;
	string ike      = 2;
	uint64 child_id = 3;
	uint64 ike_id   = 4;
	string reauth   = 5;
}

message IPsecRekeyResp {
	string success = 1;
	uint32 matches = 2;
}

message IPsecListSasReq {
	string noblock  = 1;
	string ike      = 2;
	uint64 ike_id   = 3;
	string child    = 4;
	uint64 child_id = 5;
}

message ListChildSa {
	string name = 1;
	string protocol = 2;
	string encap = 3;
	string spi_in = 4;
	string spi_out = 5;
	string cpi_in = 6;
	string cpi_out = 7;
	string mark_in = 8;
	string mark_mask_in = 9;
	string mark_out = 10;
	string mark_mask_out = 11;
	string if_id_in = 12;
	string if_id_out = 13;
	string encr_alg = 14;
	string encr_keysize = 15;
	string integ_alg = 16;
	string integ_keysize = 17;
	string dh_group = 18;
	string esn = 19;
}

message ListIkeSa {
	string name                   = 1; /* IKE_SA name */
	string uniqueid               = 2;
	string version                = 3;
	IkeSaState ikestate           = 4;
	string local_host             = 5;
	string local_port             = 6;
	string local_id               = 7;
	string remote_host            = 8;
	string remote_port            = 9;
	string remote_id              = 10;
	string remote_xauth_id        = 11;
	string remote_eap_id          = 12;
	string initiator              = 13;
	string initiator_spi          = 14;
	string responder_spi          = 15;
	string nat_local              = 16;
	string nat_remote             = 17;
	string nat_fake               = 18;
	string nat_any                = 19;
	string if_id_in               = 20;
	string if_id_out              = 21;
	string encr_alg               = 22;
	string encr_keysize           = 23;
	string integ_alg              = 24;
	string integ_keysize          = 25;
	string prf_alg                = 26;
	string dh_group               = 27;
	string ppk                    = 28;
	string established            = 29;
	string rekey_time             = 30;
	string reauth_time            = 31;
	repeated string local_vips    = 32;
	repeated string remote_vips   = 33;
	repeated string tasks_queued  = 34;
	repeated string tasks_active  = 35;
	repeated string tasks_passive = 36;
	repeated ListChildSa childsas = 37;
}

message IPsecListSasResp {
	repeated ListIkeSa ikesas = 1;
}

message IPsecListConnsReq {
	string ike = 1;
}

message ListConnAuth {
	string  class          = 1;
	string  eaptype        = 2;
	string  eapvendor      = 3;
	string  xauth          = 4;
	string  revocation     = 5;
	string  id             = 6;
	string  ca_id          = 7;
	string  aaa_id         = 8;
	string  eap_id         = 9;
	string  xauth_id       = 10;
	Groups  group          = 11;
	CertPolicy cert_policy = 12;
	Certs   certs          = 13;
	CaCerts cacerts        = 14;
}

message ListChild {
	string           name          = 1; /* Child SA name */
	string           mode          = 2;
	string           label         = 3;
	uint32           rekey_time    = 4;
	uint32           rekey_bytes   = 5;
	uint32           rekey_packets = 6;
	string           dpd_action    = 7;
	string           close_action  = 8;
	TrafficSelectors local_ts      = 9;
	TrafficSelectors remote_ts     = 10;
	string           interface     = 11;
	string           priority      = 12;
}

message ListConnResp {
	string name                       = 1; /* Connection name */
	repeated Addrs local_addrs        = 2;
	repeated Addrs remote_addrs       = 3;
	string version                    = 4;
	uint32 reauth_time                = 5;
	uint32 rekey_time                 = 6;
	string unique                     = 7;
	uint32 dpd_delay                  = 8;
	uint32 dpd_timeout                = 9;
	string ppk                        = 10;
	string ppk_required               = 11;
	repeated ListConnAuth local_auth  = 12;
	repeated ListConnAuth remote_auth = 13;
	repeated ListChild children       = 14;
}

message IPsecListConnsResp {
	repeated ListConnResp connection = 1;
}

message IPsecListCertsReq {
	string type    = 1;
	string flag    = 2;
	string subject = 3;
}

/* list-cert */
message ListCert {
	CertificateType type     = 1;
	X509CertificateFlag flag = 2;
	string hasprivkey        = 3;
	string data              = 4;
	string subject           = 5;
	string notbefore         = 6;
	string notafter          = 7;
}

message IPsecListCertsResp {
	repeated ListCert certs = 1;
}

message IPsecLoadConnReq {
	Connection connection = 1;
}

message IPsecLoadConnResp {
	string success = 1;
}

message IPsecUnloadConnReq {
	string name = 1;
}

message IPsecUnloadConnResp {
	string success = 1;
}

/* IPsec protocol */
enum IPsecProtocol {
	AH = 0;
	ESP = 1;
}

enum DFBits {

	/* Disable the DF (Don't Fragment) bit
        from the outer header. This is the
        default value */
	clear = 0;

	/* Enable the DF bit in the outer header */
	set = 1;

	/* Copy the DF bit to the outer header */
	copy = 2;
}

message Encryption {

	/* "Configuration of ESP
        encryption. With AEAD
        algorithms, the integrity-algorithm
        leaf is not use*/
	CryptoAlgorithm encryption_algorithm = 1;

	/* ESP encryption key value.
		If this leaf is not defined
		the key is not defined
		(e.g. encryption is NULL).
		The key length is
		determined by the
		length of the key set in
		this leaf. By default is
		128 bit */
	string key = 2;

	/* ESP encryption IV value. If
		this leaf is not defined the
		IV is not defined (e.g.
		encryption is NULL */
	string iv = 3;
}

message Integrity {

	/* "Configuration of ESP
        encryption. With AEAD
        algorithms, the integrity-algorithm
        leaf is not use*/
	CryptoAlgorithm integrityn_algorithm = 1;

	/* ESP encryption key value.
		If this leaf is not defined
		the key is not defined
		(e.g. encryption is NULL).
		The key length is
		determined by the
		length of the key set in
		this leaf. By default is
		128 bit */
	string key = 2;
}

/* Different lifetime values limited to an IPsec SA */
message Lifetime {
	
	/* Time in seconds since the IPsec SA was added.
        For example, if this value is 180 seconds it
        means the IPsec SA expires in 180 seconds since
        it was added. The value 0 implies infinite */
	uint32	time = 1;

	/* If the IPsec SA processes the number of bytes
         expressed in this leaf, the IPsec SA expires and
         should be rekeyed. The value 0 implies
         infinit */
	uint32	bytes = 2;

	/* If the IPsec SA processes the number of packets
         expressed in this leaf, the IPsec SA expires and
         should be rekeyed. The value 0 implies
         infinit */
	uint32	packets = 3;

	/* When a NSF stores an IPsec SA, it
        consumes system resources. In an idle NSF this
        is a waste of resources. If the IPsec SA is idle
        during this number of seconds the IPsec SA
        should be removed. The value 0 implies
        infinit */
	uint32	idle_time = 4;
}

/* The parameters required to define the IP tunnel
      endpoints when IPsec SA requires tunnel mode. The
      tunnel is defined by two endpoints: the local IP
      address and the remote IP address */
message Tunnel {
	
	/* Local IP address' tunnel endpoint */
	Addrs local = 1;

	/* Remote IP address' tunnel endpoint */
	Addrs remote = 2;

	/* Allow configuring the DF bit when encapsulating
        tunnel mode IPsec traffic. RFC 4301 describes
        three options to handle the DF bit during
        tunnel encapsulation: clear, set and copy from
        the inner IP header */
	DF_Bits df_bit = 3;

	/* If DSCP (Differentiated Services Code Point)
        values in the inner header have to be used to
        select one IPsec SA among several that match
        the traffic selectors for an outbound packet */
	bool bypass_dscp = 4;

	/* DSCP values allowed for packets carried over
        this IPsec SA */
	repeated uint8 dscp_mapping = 5;

	/* Explicit Congestion Notification (ECN). If true
        copy CE bits to inner header */
	bool ecn = 6;

}

/* Types of ESP encapsulation when Network Address
      Translation (NAT) is present between two NSFs */
enum EspEncap {

	/* NOT ESP encapsulation */
	NONE = 1;

	/* ESP in TCP encapsulation */
	ESPINTCP = 2;

	/* ESP in TCP encapsulation using TLS */
	ESPINTLS = 3;

	/* ESP in UDP encapsulation */
	ESPINUDP = 4;
}

/* This group of nodes allows to define the type of
      encapsulation in case NAT traversal is
      required and port information */
message Encap {

	/* ESP in TCP, ESP in UDP or ESP in TLS*/
	EspEncap esp_encap = 1;

	/* Encapsulation source port */
	uint32 sport = 2;

	/* */
	uint32 dport = 3;

	Addrs oaddr = 4;

}
/* Anti replay state state data */
message Replay_stats {

	/* Current state of replay window */
	uint64 replay_window = 1;

	/* Packets detected out of the
		replay window and dropped
		because they are replay
		packets */
	uint64 packets_dropped = 2;

	/* Number of packets detected out
		of the replay window.*/
	uint32 failed = 3;

	/* A 64-bit counter when this
		IPsec SA is using Extended
		Sequence Number or 32-bit
		counter when it is not.
		Current value of sequence
		number */
	uint64 seq_number_counter = 4;
}

/* IPsec state data */
message Ipsec_sa_state {

	/* SAD Lifetime current */	
	Lifetime sa_lifetime_current = 1;

	/* State data about Anti-Replay Window */
	Replay_stats replay_stats = 2;

}

message PortRange{

	uint16 start_port = 1;
	uint16 end_port = 2;
}

message SaTrafficSelector {

	string local_subnet = 1;
	string remote_subnet = 2;
	unit8 inner_protocol = 3;
	PortRange local_ports = 4;
	PortRange remote_ports = 5;
}
/* Security Association (SA) */
message SecurityAssociations {
	message Sa {
		/* "SAD entry unique name to identify this
          entry.*/
		string name = 1; 
		
		/* "This value allows to link this
			IPsec SA with an IPsec policy with
			the same reqid.*/
		uint64 reqid =2;
			
		/* security parameter index */
		uint32 spi = 3;
		
		/* True if this IPsec SA is using
            extended sequence numbers. True 64
            bit counter, false 32 bit. */
		bool ext_seq_num = 4;

		/* "A 64-bit counter when this IPsec
            SA is using Extended Sequence
            Number or 32-bit counter when it
            is not. It used to generate the
            initial Sequence Number field
            in ESP headers.*/
		uint64 seq_number_counter = 5;

		/* "The flag indicating whether
            overflow of the sequence number
            counter should prevent transmission
            of additional packets on the IPsec
            SA (false) and, therefore needs to
            be rekeyed, or whether rollover is
            permitted (true). If Authenticated
            Encryption with Associated Data
            (AEAD) is used (leaf
            esp-algorithms/encryption/algorithm-type)
            this flag MUST BE false.*/
		bool seq_overflow = 6;

		/* "A 32-bit counter and a bit-map (or
            equivalent) used to determine
            whether an inbound ESP packet is a
            replay. If set to 0 no anti-replay
            mechanism is performed." */
		uint32 anti_replay_window = 7;

		/* Security protocol of IPsec SA ESP/AH */
		IPsecProtocol protocol = 8;

		/* Tunnel or transport mode */
		IPsecMode mode = 9;

		/* Configuration of encryption or
			AEAD algorithm for IPsec
			Encapsulation Security Payload
			(ESP) */
		Encryption encryption = 10;

		/* Configuration of integrity for
			IPsec Encapsulation Security
			Payload (ESP). This container
			allows to configure integrity
			algorithm when no AEAD
			algorithms are used, and
			integrity is required */
		Integrity integrity = 11;

		/*
		CryptoAlgorithm crypto_alg = 4;
		string crypto_key = 5;

		IntegAlgorithm integ_alg = 6;
		string integ_key = 7;
		*/

		/* IPsec SA hard lifetime. The action
            associated is terminate and
            hold */
		Lifetime sa_lifetime_hard = 12;

		/* IPsec SA soft lifetime */
		Lifetime sa_lifetime_soft = 13;

		/* Endpoints of the IPsec tunne */
		Tunnel tunnel = 14;
		
		/* This container carries
            configuration information about
            the source and destination ports
            which will be used for ESP
            encapsulation that ESP packets the
            type of encapsulation when NAT
            traversal is in place */
		Encap encapsulation_type = 15;

		/* The IPsec SA traffic selector */
		SaTrafficSelector traffic_selector = 16;

		/* Details of the IPsec SA state */
		Ipsec_sa_state sa_state = 17;		

	}
	repeated Sa sas = 1;
}

enum IpsecTrafficDirection {
	
		inbound = 1;
		outbout = 2;

}
/* The action when traffic matches an IPsec security
      policy. According to RFC 4301 there are three
      possible values: BYPASS, PROTECT AND DISCARD */
enum IPsecSpdAction {

	/* PROTECT the traffic with IPsec */
	protect = 1;

	/* YPASS the traffic. The packet is forwarded
          without IPsec protection */
	bypass = 2;

	/* DISCARD the traffic. The IP packet is
          discarded */
	discard = 3;

}

/* IPsec SA configuration included in the SPD
          entry */
message IPsecSAConfig {

	/* Each selector has a Populate From
		Packet (PFP) flag. If asserted for a
		given selector X, the flag indicates
		that the IPsec SA to be created should
		take its value (local IP address,
		remote IP address, Next Layer
		Protocol, etc.) for X from the value
		in the packet. Otherwise, the IPsec SA
		should take its value(s) for X from
		the value(s) in the SPD entry */
	bool pfp_flag = 1;

	/* True if this IPsec SA is using extended
		sequence numbers. True 64 bit counter,
		False 32 bit */
	bool ext_seq_number = 2;

	/* The flag indicating whether
		overflow of the sequence number
		counter should prevent transmission
		of additional packets on the IPsec
		SA (false) and, therefore needs to
		be rekeyed, or whether rollover is
		permitted (true). If Authenticated
		Encryption with Associated Data
		(AEAD) is used (leaf
		esp-algorithms/encryption/algorithm-type)
		this flag MUST be false */
	bool seq_overflow = 3;

	/* Indicates whether (true) or not (false)
            stateful fragment checking applies to
            the IPsec SA to be created  */
	bool stateful_frag_check = 4;

	/* IPsec SA has to be processed in
		transport or tunnel mode */
	IPsecMode mode = 5;

	/* Security protocol of the IPsec SA ESP/AH */
	IPsecProtocol ipsec_protocol = 6;

	/* Configuration of ESP authentication
		based on the specified integrity
		algorithm. With AEAD algorithms,
		the integrity node is not use */
	message Integirty {
		IntegAlgorithm integrity_algorithm_type = 1;
	}
	repeated Integirty sa_int = 7;

	message Encryption {

		/* The index of list with the
			different encryption algorithms and
			its key-length (if required) */
		uint8 id = 1;

		/* Default value 20 (ENCR_AES_GCM_16 */
		CryptoAlgorithm algorithm_type = 2;

		/* By default key length is 128
			bit */
		uint16 key_length = 3;

	}
	repeated Encryption sa_enc = 8;

	/* If Traffic Flow Confidentiality
		(TFC) padding for ESP encryption
		can be used (true) or not (false) */
	bool tfc_pad = 9;
	
	/* IPsec tunnel endpoints definition  */
	Tunnel tunnel = 10;

}

message ProcessingInfo {

	IPsecSpdAction action = 1;
	IPsecSaConfig sa_config = 2;
}

message SpdMark {

	/* Mark used to match XFRM policies and
          states */
	uint32 mark = 1;

	/* Mask used to match XFRM policies and
          states */
	uint32 mask = 2;

}

/* Holds configuration information for an IPsec SPD
      entry */
message IpsecPolicyConfig {

	/* A 64-bit counter used to determine whether an
        inbound ESP packet is a replay */
	uint64 anti_replay_window = 1;

	/* Packets are selected for
        processing actions based on the IP and inner
        protocol header information, selectors,
        matched against entries in the SPD */
	SaTrafficSelector traffic_selector = 2;

	/* SPD processing. If the required processing
        action is protect, it contains the required
        information to process the packet */	
	ProcessingInfo processing_info = 3;

	/* The Mark to set for the IPsec SA of this
        connection. This option is only available
        on linux NETKEY/XFRM kernels. It can be
        used with iptables to create custom
        iptables rules using CONNMARK. It can also
        be used with Virtual Tunnel Interfaces
        (VTI) to direct marked traffic to
        specific vtiXX devices */
	SpdMark spd_mark = 4;

}

/* Security Policy Database (SPD) */
message SecurityPolicyDatabases {
	message Spd {
		
		/* SPD entry unique name to identify this
          entry */
		string name = 1;

		/* Inbound traffic or outbound
            traffic. In the IKE-less case the
            I2NSF Controller needs to
            specify the policy direction to be
            applied in the NSF. In the IKE case
            this direction does not need to be
            specified since IKE
            will determine the direction that
            IPsec policy will require */
		IpsecTrafficDirection directon = 2;

		/* This value allows to link this
          IPsec policy with IPsec SAs with the
          same reqid. It is only required in
          the IKE-less model since, in the IKE
          case this link is handled internally
          by IKE */
		uint64 reqid = 3;

		/* This container carries the
          configuration of a IPsec policy */
		IpsecPolicyConfig ipsec_policy = 4;


		/* Interface */
		message Interface {
			string name = 1;    /* interface name */
		}
		repeated Interface interfaces = 5;    /* list of interfaces belonging to this SPD */

		/* Policy Entry */
		message PolicyEntry {
			string sa = 1;     /* security association name */

			int32 priority = 2;
			bool is_outbound = 3;

			string remote_addr_start = 4;
			string remote_addr_stop = 5;
			string local_addr_start = 6;
			string local_addr_stop = 7;

			uint32 protocol = 8;

			uint32 remote_port_start = 9;
			uint32 remote_port_stop = 10;
			uint32 local_port_start = 11;
			uint32 local_port_stop = 12;

			/* Policy action */
			enum Action {
				BYPASS = 0;
				DISCARD = 1;
				//RESOLVE = 2; // unused in VPP
				PROTECT = 3;
			}
			Action action = 13; /* policy action */
		}
		repeated PolicyEntry policy_entries = 6;   /* list of policy entries belonging to this SPD */
	}
	repeated Spd spds = 1;  /* list of all SPDs */
}
