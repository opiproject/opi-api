/*
 * Copyright (C) 2021 Intel Corporation
 * Copyright (c) 2023 Dell Inc, or its subsidiaries.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Service functions for IKE/IPsec resources.
 *
 * Operations are defined for the following resources:
 * - IKE Peer Association Database (PAD)
 * - IKE Connections
 * - IPsec Security Policy Database (SPD)
 * - IPsec Security Associations (SAs)
 *
 * The configuration model is derived from RFC 9061.
 */
syntax = "proto3";

package opi_api.security.v1alpha1;

import "google/api/annotations.proto";
import "google/api/client.proto";
import "google/api/field_behavior.proto";
import "google/api/resource.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";

import "networktypes.proto";

option go_package = "github.com/opiproject/opi-api/security/v1alpha1/gen/go";
option java_multiple_files = true;
option java_outer_classname = "IpsecProto";
option java_package = "opi_api.security.v1alpha1";

// Management of the IKE Peer Association Database (PAD). The PAD contains
// information about the peers that are allowed to establish an IKE connection.
service IkePeerService {
  // Create an IKE peer. This request includes the specification of the keys and certificates
  // associated with the peer.
  rpc CreateIkePeer(CreateIkePeerRequest) returns (IkePeer) {
    option (google.api.http) = {
      post: "/v1alpha1/ikePeers"
      body: "ike_peer"
    };
    option (google.api.method_signature) = "ike_peer,ike_peer_id";
  }
  // Update an existing IKE peer specification.
  rpc UpdateIkePeer(UpdateIkePeerRequest) returns (IkePeer) {
    option (google.api.http) = {
      patch: "/v1alpha1/{ike_peer.name=ikepeers/*}"
      body: "ike_peer"
    };
    option (google.api.method_signature) = "ike_peer,update_mask";
  }
  // Delete an existing IKE peer specification.
  rpc DeleteIkePeer(DeleteIkePeerRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1alpha1/{name=ikePeers/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // Get an existing IKE peer specification.
  rpc GetIkePeer(GetIkePeerRequest) returns (IkePeer) {
    option (google.api.http) = {
      get: "/v1alpha1/{name=ikePeers/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // List existing IKE peers.
  rpc ListIkePeers(ListIkePeersRequest) returns (ListIkePeersResponse) {
    option (google.api.http) = {
      get: "/v1alpha1/ikePeers"
    };
  }
}

// Management of IKE connections. An IKE connection is a logical connection
// between two peers that is used to establish IPsec SAs. An IKE connection
// includes the configuration of the local and remote peers, the IPsec SAs
// that are part of the connection, and the configuration of the IKE connection
// itself.
service IkeConnectionService {
  // Create an IKE connection. The request includes specification of the local
  // and remote IKE peers and the specification of the IPsec SAs (aka child SAs)
  // from this IKE connection.
  rpc CreateIkeConnection(CreateIkeConnectionRequest) returns (IkeConnection) {
    option (google.api.http) = {
      post: "/v1alpha1/ikeConnections"
      body: "ike_connection"
    };
    option (google.api.method_signature) = "ike_connection,ike_connection_id";
  }
  // Update an existing IKE connection.
  rpc UpdateIkeConnection(UpdateIkeConnectionRequest) returns (IkeConnection) {
    option (google.api.http) = {
      patch: "/v1alpha1/{ike_connection.name=ikeConnections/*}"
      body: "ike_connection"
    };
    option (google.api.method_signature) = "ike_connection,update_mask";
  }
  // Delete an existing IKE connection.
  rpc DeleteIkeConnection(DeleteIkeConnectionRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1alpha1/{name=ikeConnections/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // Retrieve an IKE connection.
  rpc GetIkeConnection(GetIkeConnectionRequest) returns (IkeConnection) {
    option (google.api.http) = {
      get: "/v1alpha1/{name=ikeConnections/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // List existing IKE connections.
  rpc ListIkeConnections(ListIkeConnectionsRequest) returns (ListIkeConnectionsResponse) {
    option (google.api.http) = {
      get: "/v1alpha1/ikeConnections"
    };
  }
  // Get IKE connection statistics.
  rpc StatsIkeConnections(StatsIkeConnectionsRequest) returns (StatsIkeConnectionsResponse) {
    option (google.api.http) = {
      get: "/v1alpha1/ikeConnections:stats"
    };
  }
}

// Management of the IPsec Security Association Database (SAD). The SAD
// contains information about the IPsec SAs that are used to protect the
// traffic between two peers
service IpsecSaService {
  // Create an IPsec Security Association
  rpc CreateIpsecSa(CreateIpsecSaRequest) returns (IpsecSa) {
    option (google.api.http) = {
      post: "/v1alpha1/ipsecSas"
      body: "ipsec_sa"
    };
    option (google.api.method_signature) = "ipsec_sa,ipsec_sa_id";
  }
  // Update an existing IPsec Security Association
  rpc UpdateIpsecSa(UpdateIpsecSaRequest) returns (IpsecSa) {
    option (google.api.http) = {
      patch: "/v1alpha1/{ipsec_sa.name=ipsecSas/*}"
      body: "ipsec_sa"
    };
    option (google.api.method_signature) = "ipsec_sa,update_mask";
  }
  // Delete an existing IPsec Security Association
  rpc DeleteIpsecSa(DeleteIpsecSaRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1alpha1/{name=ipsecSas/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // Get an IPsec Security Association
  rpc GetIpsecSa(GetIpsecSaRequest) returns (IpsecSa) {
    option (google.api.http) = {
      get: "/v1alpha1/{name=ipsecSas/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // List existing IPsec Security Associations
  rpc ListIpsecSas(ListIpsecSasRequest) returns (ListIpsecSasResponse) {
    option (google.api.http) = {
      get: "/v1alpha1/ipsecSas"
    };
  }
} 

// Management of the IPsec Security Policy Database (SPD). The SPD contains
// information about the IPsec policies that are used to protect the traffic
// between two peers.
service IpsecPolicyService {
  // Create an IPsec Policy
  rpc CreateIpsecPolicy(CreateIpsecPolicyRequest) returns (IpsecPolicy) {
    option (google.api.http) = {
      post: "/v1alpha1/ipsecPolicies"
      body: "ipsec_policy"
    };
    option (google.api.method_signature) = "ipsec_policy,ipsec_policy_id";
  }
  // Update an existing IPsec Policy
  rpc UpdateIpsecPolicy(UpdateIpsecPolicyRequest) returns (IpsecPolicy) {
    option (google.api.http) = {
      patch: "/v1alpha1/{ipsec_policy.name=ipsecPolicies/*}"
      body: "ipsec_policy"
    };
    option (google.api.method_signature) = "ipsec_policy,update_mask";
  }
  // Delete an existing IPsec Policy
  rpc DeleteIpsecPolicy(DeleteIpsecPolicyRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1alpha1/{name=ipsecPolicies/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // Get an IPsec Policy
  rpc GetIpsecPolicy(GetIpsecPolicyRequest) returns (IpsecPolicy) {
    option (google.api.http) = {
      get: "/v1alpha1/{name=ipsecPolicies/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // List existing IPsec Policies
  rpc ListIpsecPolicies(ListIpsecPoliciesRequest) returns (ListIpsecPoliciesResponse) {
    option (google.api.http) = {
      get: "/v1alpha1/ipsecPolicies"
    };
  }
}

// IKEv2 Fragmentation, as per RFC 7383. If IKEv2 fragmentation is enabled, it
// is possible to specify the MTU.
message IkeFragmentation {
  // Enable/Disable IKEv2 fragmentation.
  bool enabled = 1 [(google.api.field_behavior) = OPTIONAL];
  // When fragmentation is enabled, the MTU that IKEv2 can use for IKEv2
  // fragmentation.
  int32 mtu = 2 [(google.api.field_behavior) = OPTIONAL];
}

// IKE SA soft lifetime. Two lifetime values can be configured, either rekey
// time of the IKE SA or reauth time of the IKE SA. When the rekey lifetime
// expires, a rekey of the IKE SA starts. When reauth lifetime expires, an IKE
// SA re-authentication starts.
message IkeSaLifetimeSoft {
  // Time in seconds between each IKE SA rekey. The value of 0 means infinite.
  google.protobuf.Duration rekey_interval = 1 [(google.api.field_behavior) = OPTIONAL];
  // Time in seconds between each IKE SA re-authentication. The value of 0 means
  // infinite.
  google.protobuf.Duration reauth_interval = 2 [(google.api.field_behavior) = OPTIONAL];
}

// IKE SA hard lifetime. When this time is reached, the IKE SA is removed.
message IkeSaLifetimeHard {
  // Time in seconds before the IKE SA is removed. The value 0 means infinite.
  google.protobuf.Duration max_duration = 1 [(google.api.field_behavior) = OPTIONAL];
}

// Defines a Certificate Authority (CA) certificate.
message CaCerts {
  // List of CA certificates.
  repeated string cacert = 1 [(google.api.field_behavior) = OPTIONAL];
}

// Defines the type of encapsulation in case NAT traversal is required and
// includes port information.
message Encap {
  // Type of encapsulation to use.
  EspEncap espencap = 1 [(google.api.field_behavior) = OPTIONAL];
  // Encapsulation source port. Default = 4500
  int32 sport = 2 [(google.api.field_behavior) = OPTIONAL];
  // Encapsulation destination port. Default = 4500
  int32 dport = 3 [(google.api.field_behavior) = OPTIONAL];
}

// An IKE Connection specification
message IkeConnection {
  option (google.api.resource) = {
    type: "opi_api.security.v1alpha1/IkeConnection"
    pattern: "ikeConnections/{connection}"
    singular: "ikeConnection"
    plural: "ikeConnections"
  };
  
  // Unique name to identify the connection.
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];
  // IKE/IPsec connection startup behavior. Default: AUTO_STARTUP_MODE_ADD
  AutoStartupMode autostartup = 2 [(google.api.field_behavior) = OPTIONAL];
  // IKE version. Only version 2 is supported.
  IkeVersion version = 3 [(google.api.field_behavior) = OPTIONAL];
  // IKE fragmentation
  IkeFragmentation fragmentation = 4 [(google.api.field_behavior) = OPTIONAL];
  // IKE SA soft lifetime
  IkeSaLifetimeSoft ike_sa_lifetime_soft = 5 [(google.api.field_behavior) = OPTIONAL];
  // IKE SA hard lifetime
  IkeSaLifetimeHard ike_sa_lifetime_hard = 6 [(google.api.field_behavior) = OPTIONAL];
  // Encryption algorithms
  repeated EncAlgorithm encryption_alg = 7 [(google.api.field_behavior) = OPTIONAL];
  // Integrity algorithms
  repeated IntegAlgorithm integrity_alg = 8 [(google.api.field_behavior) = OPTIONAL];
  // Pseudo Random Function (PRF) algorithms
  repeated PRF prf = 9 [(google.api.field_behavior) = OPTIONAL];
  // Diffie Hellman groups
  repeated DHGroups dhgroups = 10 [(google.api.field_behavior) = OPTIONAL];
  // Local peer name.
  string local = 11 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference).type = "IkePeer"];
  // Remote peer name.
  string remote = 12 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference).type = "IkePeer"];
  // Configuration information about the encapsulation that should be used when
  // NAT traversal is required. No encapsulation is used if this field is not
  // specified.
  Encap encap = 13 [(google.api.field_behavior) = OPTIONAL];
  // Local UDP port for IKE communication. Defaults to 500 if not specified.
  int32 local_port = 14 [(google.api.field_behavior) = OPTIONAL];
  // Remote UDP port for IKE communication. Defaults to 500 if not specified.
  int32 remote_port = 15 [(google.api.field_behavior) = OPTIONAL];
  // Interface that this connection is associated with. Used for route based
  // VPNs.
  string if_id = 16 [(google.api.field_behavior) = OPTIONAL];
  // IPsec policies that apply to the connection
  repeated string policies = 17 [
    (google.api.field_behavior) = OPTIONAL,
    (google.api.resource_reference).type = "IpsecPolicy"];
  // Connection state / status
  IkeConnectionState state = 18 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// An IPsec Security Association (SA)
message IpsecSa {
  option (google.api.resource) = {
    type: "opi_api.security.v1alpha1/IpsecSa"
    pattern: "ipsecSas/{ipsec_sa}"
    singular: "ipsecSa"
    plural: "ipsecSas"
  };

  // Unique name in the SAD to identify this SA
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];
  // This value allows linking this IPsec SA with an IPsec policy with the same
  // reqid
  int64 reqid = 2 [(google.api.field_behavior) = OPTIONAL];
  // IPsec SA configuration
  IpsecSaConfig config = 3 [(google.api.field_behavior) = REQUIRED];
  // IPsec SA state
  IpsecSaState state = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// IPsec Security Association Configuration
message IpsecSaConfig {
  // IPsec SA Security Parameter Index (SPI)
  // (-- api-linter: core::0141::forbidden-types=disabled
  //     aip.dev/not-precedent: The SPI cannot be negative. --)
  uint32 spi = 1 [(google.api.field_behavior) = REQUIRED];
  // True if this IPsec SA is using extended sequence numbers. If true, the
  // 64-bit extended sequence number counter is used. If false, the normal
  // 32-bit sequence number counter is used.
  bool esn = 2 [(google.api.field_behavior) = OPTIONAL];
  // Anti-Replay-Window size. If not set, the default value is 64, following the
  // recommendation in RFC4303.
  int32 arw_size = 3 [(google.api.field_behavior) = OPTIONAL];
  // Packets are selected for processing actions based on Traffic Selector
  // values, which refer to IP and inner protocol header information.
  TrafficSelector traffic_selector = 4 [(google.api.field_behavior) = OPTIONAL];
  // Security protocol of the IPsec SA. Only ESP is supported.
  IpsecProtocol protocol = 5 [(google.api.field_behavior) = OPTIONAL];
  // IPsec SA has to be processed in transport or tunnel mode. If not specified,
  // transport mode is used.
  IpsecMode mode = 6 [(google.api.field_behavior) = OPTIONAL];
  // IPsec ESP algorithm configuration
  EspAlgorithms esp_algorithms = 7 [(google.api.field_behavior) = OPTIONAL];
  // Tunnel configuration. Only relevant when mode = Tunnel.
  Tunnel tunnel = 8 [(google.api.field_behavior) = OPTIONAL];
  // Soft IPsec SA lifetime. After the lifetime, the lifetime action is
  // performed.
  IpsecSaLifetimeSoft lifetime_soft = 9 [(google.api.field_behavior) = OPTIONAL];
  // Hard IPsec SA lifetime. The action will be used to terminate the IPsec SA.
  IpsecSaLifetimeHard lifetime_hard = 10 [(google.api.field_behavior) = OPTIONAL];
  // Provides information about the encapsulation that the IPsec SA is using.
  Encap encap = 11 [(google.api.field_behavior) = OPTIONAL];
}

// IPsec Security Association State
message IpsecSaState {
  // SA Current Lifetime
  Lifetime lifetime = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // State about the anti-replay window
  AntiReplayStats replay_stats = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Holds configuration information for an IPsec SPD entry.
message IpsecPolicy {
  option (google.api.resource) = {
    type: "opi_api.security.v1alpha1/IpsecPolicy"
    pattern: "ipsecPolicies/{ipsec_policy}"
    singular: "ipsecPolicy"
    plural: "ipsecPolicies"
  };

  // Unique name to identify the IPsec policy in the SPD.
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];
  // This value allows linking this IPsec policy with the IPsec SAs with the
  // same reqid. A value of 0 (the default) means that the reqid is unused.
  int64 reqid = 2 [(google.api.field_behavior) = OPTIONAL];
  // IPsec Policy configuration
  IpsecPolicyConfig config = 3 [(google.api.field_behavior) = REQUIRED];
}

// Holds configuration information for an IPsec SPD entry.
message IpsecPolicyConfig {
  // Anti-Replay-Window size. If not set, the default value is 64, following the
  // recommendation in RFC4303.
  int32 arw_size = 1 [(google.api.field_behavior) = OPTIONAL];
  // Packets are selected for processing actions based on Traffic Selector
  // values, which refer to IP and inner protocol header information.
  TrafficSelector traffic_selector = 2 [(google.api.field_behavior) = OPTIONAL];
  // SPD processing to be performed on packets that match the traffic selector.
  SpdProcessingInfo processing = 3 [(google.api.field_behavior) = OPTIONAL];
}

// A Traffic Selector used in IPsec policies and IPsec SAs.
message TrafficSelector {
  // Local IP address prefix.
  network.opinetcommon.v1alpha1.IPPrefix local_prefix = 1 [(google.api.field_behavior) = OPTIONAL];
  // Remote IP address prefix.
  network.opinetcommon.v1alpha1.IPPrefix remote_prefix = 2 [(google.api.field_behavior) = OPTIONAL];
  // Inner protocol that is going to be protected with IPsec. If no protocol is
  // specified, all inner protocols will be protected. Protocols are encoded
  // using the IP protocol number.
  int32 inner_protocol = 3 [(google.api.field_behavior) = OPTIONAL];
  // List of local ports. When the inner protocol is ICMP, this 16-bit value
  // represents code and type. If this list is not defined, it is assumed that
  // start and end are 0 by default (any port).
  repeated PortRange local_ports = 4 [(google.api.field_behavior) = OPTIONAL];
  // List of remote ports. When the inner protocol is ICMP, this 16-bit value
  // represents code and type. If this list is not defined, it is assumed that
  // start and end are 0 by default (any port).
  repeated PortRange remote_ports = 5 [(google.api.field_behavior) = OPTIONAL];
}

// A port range, such as that expressed in RFC 4301, for example 1500 (Start
// Port Number) - 1600 (End Port Number). A port range is used in the Traffic
// Selector. To express a single prot, set the same value as start and end.
message PortRange {
  // Start port number.
  int32 start = 1 [(google.api.field_behavior) = REQUIRED];
  // End port number. The end port number must be equal to or greater than the
  // start port number.
  int32 end = 2 [(google.api.field_behavior) = REQUIRED];
}

// SPD processing. If the required processing action is protect, it contains the
// required information to process the packet.
message SpdProcessingInfo {
  // Action to be performed on the packet.
  IpsecSpdAction action = 1 [(google.api.field_behavior) = REQUIRED];
  // IPsec SA configuration included in the SPD entry.
  IpsecSaTemplate sa_config = 2 [(google.api.field_behavior) = OPTIONAL];
}

// IPsec SA configuration template
message IpsecSaTemplate {
  // True if this IPsec SA is using extended sequence numbers. If true, the
  // 64-bit extended sequence number counter is used. If false, the normal
  // 32-bit sequence number counter is used.
  bool esn = 1 [(google.api.field_behavior) = OPTIONAL];
  // IPsec SA has to be processed in transport or tunnel mode. If not specified,
  // transport mode is used.
  IpsecMode mode = 2 [(google.api.field_behavior) = OPTIONAL];
  // Security protocol of the IPsec SA. Only ESP is supported.
  IpsecProtocol protocol = 3 [(google.api.field_behavior) = OPTIONAL];
  // IPsec ESP algorithm configuration
  EspAlgorithms esp_algorithms = 4 [(google.api.field_behavior) = OPTIONAL];
  // Tunnel configuration. Only relevant when mode = Tunnel.
  Tunnel tunnel = 5 [(google.api.field_behavior) = OPTIONAL];
}

// Configuration of ESP parameters and algorithms
message EspAlgorithms {
  // Configuration of ESP authentication based on the specified integrity
  // algorithm. With AEAD encryption algorithms, the integrity node is not used.
  repeated IntegAlgorithm integrity = 1 [(google.api.field_behavior) = OPTIONAL];
  // Encryption of AEAD algorithm for the IPsec SAs. This list is ordered from
  // higher priority to lower priority. The first node of the list will be the
  // algorithm with the higher priority. If the list is empty then AES-256-GCM
  // will be applied.
  repeated EncAlgorithm encryption = 2 [(google.api.field_behavior) = OPTIONAL];
  // If Traffic Flow Confidentiality (TFC) padding for ESP encryption can be
  // used (true) or not (false).
  bool tfc_pad = 3 [(google.api.field_behavior) = OPTIONAL];
}

// The parameters required to define the IP tunnel endpoints when IPsec SA
// requires tunnel mode. The tunnel is defined by two endpoints: the local IP
// address and the remote IP address.
message Tunnel {
  // Local IP address tunnel endpoint
  network.opinetcommon.v1alpha1.IPAddress local = 1 [(google.api.field_behavior) = REQUIRED];
  // Remote IP address tunnel endpoint
  network.opinetcommon.v1alpha1.IPAddress remote = 2 [(google.api.field_behavior) = REQUIRED];
  // Allow configuring the DF bit when encapsulating tunnel mode IPsec traffic.
  // RFC 4301 describes three options to handle the DF bit during tunnel
  // encapsulation: clear, set and copy from the inner IP header. This must be
  // ignored or has no meaning when the local/remote IP addresses are IPv6
  // addresses.
  DfBitAction df_bit = 3 [(google.api.field_behavior) = OPTIONAL];
  // If true, copy the DSCP value from the inner header to the outer header. If
  // false, map the DSCP values from an inner header to values in an outer
  // header following the dscp_mapping.
  bool bypass_dscp = 4 [(google.api.field_behavior) = OPTIONAL];
  // A list that represents an array with the mapping from the inner DSCP value
  // to outer DSCP value when bypass_dscp is false. To express a default mapping
  // in the list where any other inner dscp value is not matching a node in the
  // list, a new node has to be included at the end of the list where the
  // inner-dscp is not defined (ANY) and the outer-dscp includes the value of
  // the mapping. If there is no value set in the outer-dscp, the default value
  // for this leaf is 0.
  repeated DscpMapping dscp_mapping = 5 [(google.api.field_behavior) = OPTIONAL];
}

// Mapping from the inner DSCP value to the outer DSCP value.
message DscpMapping {
  // The list entry index with the different mappings.
  int32 id = 1 [(google.api.field_behavior) = REQUIRED];
  // The DSCP value of the inner IP packet.
  int32 inner_dscp = 2 [(google.api.field_behavior) = REQUIRED];
  // The DSCP value of the outer IP packet.
  int32 outer_dscp = 3 [(google.api.field_behavior) = REQUIRED];
}

// Specific information for IPsec SAs. It includes Perfect Forward Secrecy (PFS)
// group and IPsec SA rekey lifetimes.
message ChildSaInfo {
  // If non-zero, forward secrecy is required when a new IPsec SA is being
  // created. The non-zero value indicates the DH group number to use for the
  // key exchange process used to achieve forward secrecy. The list is ordered
  // following from the higher priority to lower priority. The first node of the
  // list will be the algorithm with higher priority.
  repeated int32 fs_groups = 1 [(google.api.field_behavior) = OPTIONAL];
  // Soft IPsec SA lifetime. After the lifetime, the lifetime action is
  // performed.
  IpsecSaLifetimeSoft lifetime_soft = 2 [(google.api.field_behavior) = OPTIONAL];
  // Hard IPsec SA lifetime. The action will be used to terminate the IPsec SA.
  IpsecSaLifetimeHard lifetime_hard = 3 [(google.api.field_behavior) = OPTIONAL];
}

// IPsec SA soft lifetime. Specifies a lifetime and an action to be performed
// once the lifetime expires.
message IpsecSaLifetimeSoft {
  // The lifetime of the IPsec SA.
  Lifetime lifetime = 1 [(google.api.field_behavior) = REQUIRED];
  // The action to be performed once the lifetime expires.
  LifetimeAction action = 2 [(google.api.field_behavior) = REQUIRED];
}

// IPsec SA hard lifetime. Specifies a lifetime after which the IPsec SA should
// be terminated.
message IpsecSaLifetimeHard {
  // The lifetime of the IPsec SA.
  Lifetime lifetime = 1 [(google.api.field_behavior) = REQUIRED];
}

// Lifetime of an IPsec SA. The lifetime can be expressed in terms of time,
// bytes, packets, or idle time.
message Lifetime {
  // Time in seconds since the IPsec SA was added. For example, if this value is
  // 180 seconds, it means the IPsec SA expires in 180 seconds after it was
  // added. A value of 0 implies infinite.
  google.protobuf.Duration duration = 1 [(google.api.field_behavior) = OPTIONAL];
  // If the IPsec SA processes the number of bytes expressed in this field, the
  // IPsec SA expires and should be rekeyed. A value of 0 implies infinite.
  int64 bytes = 2 [(google.api.field_behavior) = OPTIONAL];
  // If the IPsec SA processes the number of packets expressed in this field,
  // the IPsec SA expires and should be rekeyed. A value of 0 implies infinite.
  int64 packets = 3 [(google.api.field_behavior) = OPTIONAL];
  // If the IPsec SA is idle during this number of seconds, the IPsec SA should
  // be removed. A value of 0 implies infinite.
  google.protobuf.Duration idle = 4 [(google.api.field_behavior) = OPTIONAL];
}

// Anti-replay stats
message AntiReplayStats {
  // ARW state
  AntiReplayWindow replay_window = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Packets dropped because they are replay packets
  int64 packet_dropped = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Number of packets detected out of the replay window
  int64 failed = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Current value of the sequence number
  // (-- api-linter: core::0141::forbidden-types=disabled
  //     aip.dev/not-precedent: The sequence number cannot be negative. --)
  uint64 seq_num_counter = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Anti-replay window state. Three parameters define the state of the replay
// window: window size (w), highest sequence number authenticated (t), and lower
// bound of the window (b), according to Appendix A2.1 in RFC 4303 (w = t - b +
// 1)
message AntiReplayWindow {
  // Size of the replay window. A value in the range [1, 4096].
  int32 w = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Highest sequence number authenticated so far, upper bound of window
  // (-- api-linter: core::0141::forbidden-types=disabled
  //     aip.dev/not-precedent: The sequence number cannot be negative. --)
  uint64 t = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Lower bound of window
  // (-- api-linter: core::0141::forbidden-types=disabled
  //     aip.dev/not-precedent: The sequence number cannot be negative. --)
  uint64 b = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// IKE state data for an IKE connection
message IkeConnectionState {
  // True if the local endpoint is acting as the initiator for this connection.
  bool initiator = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Initiator's IKE SA SPI
  int32 initiator_ike_spi = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Responder's IKE SA SPI
  int32 responder_ike_sa = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  // True if the local endpoint is behind a NAT.
  bool nat_local = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
  // True if the remote endpoint is behind a NAT.
  bool nat_remote = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Provides information about the encapsulation that IKE is using.
  Encap encap = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Seconds since this IKE SA has been established.
  int64 established = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Seconds before IKE SA is rekeyed
  google.protobuf.Duration current_rekey_interval = 8 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Seconds before IKE SA is re-authenticated
  google.protobuf.Duration current_reauth_interval = 9 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// General information about the IKE SAs. In particular, it provides the number
// of IKE SAs.
message NumberIkeSAs {
  // Total number of active IKE SAs.
  int64 total = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Number of half-open active IKE SAs.
  int64 half_open = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/* Digital Signature Authentication */
message DSAuth {
  // The digital signature algorithm
  DSAlgorithm algorithm = 1 [(google.api.field_behavior) = OPTIONAL];
  // Raw public key
  string raw_public_key = 2 [(google.api.field_behavior) = OPTIONAL];
  // Certificate
  string cert = 3 [(google.api.field_behavior) = OPTIONAL];
  // Private key
  string private_key = 4 [(google.api.field_behavior) = OPTIONAL];
  // Certificates
  CaCerts ca_certs = 5 [(google.api.field_behavior) = OPTIONAL];
}

// IKE Peer Authentication
message IkePeerAuthentication {
  // Authentication method
  AuthType auth_method = 1 [(google.api.field_behavior) = OPTIONAL];
  // EAP method type specified with a value extracted from the IANA registry.
  // This information provides the particular EAP method to be used. Depending
  // on the EAP method, pre-shared keys or certificates may be used.
  int32 eap_type = 2 [(google.api.field_behavior) = OPTIONAL];
  // Pre-shared secret value. This value MUST be set of the EAP method uses a
  // pre-shared key or pre-shared authentication has been chosen.
  string psk = 3 [(google.api.field_behavior) = OPTIONAL];
  // Digital signature
  DSAuth digital_signature = 4 [(google.api.field_behavior) = OPTIONAL];
}

// IKE Peer
message IkePeer {
  option (google.api.resource) = {
    type: "opi_api.security.v1alpha1/IkePeer"
    pattern: "ikePeers/{ike_peer}"
    singular: "ikePeer"
    plural: "ikePeers"
  };

  // Name to uniquely identify the peer.
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];
  // IPv4 or IPv6 address of the peer.
  network.opinetcommon.v1alpha1.IPAddress ip_address = 2 [(google.api.field_behavior) = OPTIONAL];
  // FQDN of the peer.
  string fqdn = 3 [(google.api.field_behavior) = OPTIONAL];
  // IKE Peer Authentication
  IkePeerAuthentication peer_auth = 4 [(google.api.field_behavior) = OPTIONAL];
}

// Create an IKE Peer
message CreateIkePeerRequest {
  // The ID to use for the IKE Peer. 
  string ike_peer_id = 1 [(google.api.field_behavior) = REQUIRED];
  // The IKE Peer to create.
  IkePeer ike_peer = 2 [(google.api.field_behavior) = REQUIRED];
}

// Update an IKE Peer
message UpdateIkePeerRequest {
  // the peer's `name` field is used to identify the IKE peer to update.
  IkePeer ike_peer = 1 [(google.api.field_behavior) = REQUIRED];
  // The list of fields to update
  google.protobuf.FieldMask update_mask = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Delete an IKE Peer
message DeleteIkePeerRequest {
  // Name of the IKE peer to delete
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IkePeer"];
}

// Get an IKE Peer
message GetIkePeerRequest {
  // Name of the IKE peer to retrieve
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IkePeer"];
}

// List IKE Peers
message ListIkePeersRequest {
  // The maximum number of IKE peers to return. The service may return fewer than this value.
  int32 page_size = 1 [(google.api.field_behavior) = OPTIONAL];
  // A page token, received from a previous `ListIkePeers` call.
  // Provide this to retrieve the subsequent page.
  string page_token = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Response to a ListIkePeersRequest
message ListIkePeersResponse {
  // List of IKE peers
  repeated IkePeer ike_peers = 1;
  
  // A token that can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are not subsequent pages.
  string next_page_token = 2;
}

// Create an IKE Connection
message CreateIkeConnectionRequest {
  // The ID to use for the IKE Connection.
  string ike_connection_id = 1 [(google.api.field_behavior) = REQUIRED];
  
  // The IKE Connection to create.
  IkeConnection ike_connection = 2 [(google.api.field_behavior) = REQUIRED];
}

// Update an IKE Connection
message UpdateIkeConnectionRequest {
  // The connections `name` field identifies the IKE connection to update.
  IkeConnection ike_connection = 1 [(google.api.field_behavior) = REQUIRED];
  // The list of fields to update
  google.protobuf.FieldMask update_mask = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Delete an IKE Connection
message DeleteIkeConnectionRequest {
  // Connection name identifying the IKE connection to delete
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IkeConnection"];
}

// Get an IKE Connection
message GetIkeConnectionRequest {
  // Connection name identifying the IKE connection to retrieve
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IkeConnection"];
}

// List IKE Connections
message ListIkeConnectionsRequest {
  // The maximum number of IKE connections to return. The service may return fewer than this value.
  int32 page_size = 1 [(google.api.field_behavior) = OPTIONAL];
  // A page token, received from a previous `ListIkeConnections` call.
  // Provide this to retrieve the subsequent page.
  string page_token = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Response to a ListIkeConnectionsRequest
message ListIkeConnectionsResponse {
  // List of IKE connections
  repeated IkeConnection ike_connections = 1;
  
  // A token that can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are not subsequent pages.
  string next_page_token = 2;
}

// Request to get IKE Connection statistics
message StatsIkeConnectionsRequest {
}

// Response to a StatsIkeConnectionsRequest
message StatsIkeConnectionsResponse {
  // Number of IKE SAs
  NumberIkeSAs number_ike_sas = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// List IPsec SAs
message ListIpsecSasRequest {
  // The maximum number of IPsec SAs to return. The service may return fewer than this value.
  int32 page_size = 1 [(google.api.field_behavior) = OPTIONAL];
  // A page token, received from a previous `ListIpsecSas` call.
  // Provide this to retrieve the subsequent page.
  string page_token = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Response to a ListIpsecSasRequest
message ListIpsecSasResponse {
  // List of IPsec SAs
  repeated IpsecSa ipsec_sas = 1;
  
  // A token that can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are not subsequent pages.
  string next_page_token = 2;
}

// Get an IPsec SA
message GetIpsecSaRequest {
  // Name of the SA to retrieve
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IpsecSa"];
}

// Create an IPsec SA
message CreateIpsecSaRequest {
  // The ID to use for the IPsec SA.
  string ipsec_sa_id = 1 [(google.api.field_behavior) = REQUIRED];

  // The IPsec SA to create.
  IpsecSa ipsec_sa = 2 [(google.api.field_behavior) = REQUIRED];
}

// Update an IPsec SA
message UpdateIpsecSaRequest {
  // The SA's name field identifies the IPsec SA to update.
  IpsecSa ipsec_sa = 1 [(google.api.field_behavior) = REQUIRED];
  // The list of fields to update
  google.protobuf.FieldMask update_mask = 3 [(google.api.field_behavior) = OPTIONAL];
}

// Delete an IPsec SA
message DeleteIpsecSaRequest {
  // Name of the SA to delete
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IpsecSa"];
}

// Create an IPsec Policy
message CreateIpsecPolicyRequest {
  // The ID to use for the IPsec Policy.
  string ipsec_policy_id = 1 [(google.api.field_behavior) = REQUIRED];
  
  // The IPsec Policy to create.
  IpsecPolicy ipsec_policy = 2 [(google.api.field_behavior) = REQUIRED];
}

// Update an IPsec Policy
message UpdateIpsecPolicyRequest {
  // The policy's name field identifies the IPsec policy to update.
  IpsecPolicy ipsec_policy = 1 [(google.api.field_behavior) = REQUIRED];
  // The list of fields to update
  google.protobuf.FieldMask update_mask = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Delete an IPsec Policy
message DeleteIpsecPolicyRequest {
  // Name of the policy to delete
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IpsecPolicy"];
}

// Get an IPsec Policy
message GetIpsecPolicyRequest {
  // Name of the policy to retrieve
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference).type = "IpsecPolicy"];
}

// List IPsec Policies
message ListIpsecPoliciesRequest {
  // The maximum number of IPsec policies to return. The service may return fewer than this value.
  int32 page_size = 1 [(google.api.field_behavior) = OPTIONAL];
  // A page token, received from a previous `ListIpsecPolicies` call.
  // Provide this to retrieve the subsequent page.
  string page_token = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Response to a ListIpsecPoliciesRequest
message ListIpsecPoliciesResponse {
  // List of IPsec policies
  repeated IpsecPolicy ipsec_policies = 1;
  
  // A token that can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are not subsequent pages.
  string next_page_token = 2;
}

// Cryptographic algorithm for encryption.
enum EncAlgorithm {
  // Encryption algorithm is not specified
  ENC_ALGORITHM_UNSPECIFIED = 0;
  // AES-CBC with a 128 bit key
  ENC_ALGORITHM_AES128CBC = 1;
  // AES-CBC with a 192 bit key
  ENC_ALGORITHM_AES192CBC = 2;
  // AES-CBC with a 256 bit key
  ENC_ALGORITHM_AES256CBC = 3;
  // AES-GCM with a 128 bit key and a 128 byte tag
  ENC_ALGORITHM_AES128GCM128 = 4;
  // AES-GCM with a 192 bit key and a 128 byte tag
  ENC_ALGORITHM_AES192GCM128 = 5;
  // AES-GCM with a 256 bit key and a 128 byte tag
  ENC_ALGORITHM_AES256GCM128 = 6;
  // ChaCha20-Poly1305 AEAD algorithm
  ENC_ALGORITHM_CHACHA20POLY1305 = 7;
}

// Cryptographic algorithm for authentication.
enum IntegAlgorithm {
  // Integrity algorithm is not specified
  INTEG_ALGORITHM_UNSPECIFIED = 0;
  // SHA-1 with a 96 bit truncated hash output length
  INTEG_ALGORITHM_SHA1_96 = 1;
  // SHA-256 with a 128 bit truncated hash output length
  INTEG_ALGORITHM_SHA256_128 = 2;
  // SHA-384 with a 192 bit truncated hash output length
  INTEG_ALGORITHM_SHA384_192 = 3;
  // SHA-512 with a 256 bit truncated hash output length
  INTEG_ALGORITHM_SHA512_512 = 4;
  // AES-GMAC with a 128 bit key
  INTEG_ALGORITHM_AES128GMAC = 5;
  // AES-GMAC with a 256 bit key
  INTEG_ALGORITHM_AES256GMAC = 6;
}

/* Diffie Hellman Groups */
enum DHGroups {
  // DH Group is not specified
  DH_GROUPS_UNSPECIFIED = 0;
  // MODP768 DH Group
  DH_GROUPS_MODP768 = 1;
  // MODP1024 DH Group
  DH_GROUPS_MODP1024 = 2;
  // MODP1536 DH Group
  DH_GROUPS_MODP1536 = 3;
  // MODP2048 DH Group
  DH_GROUPS_MODP2048 = 4;
  // MODP3072 DH Group
  DH_GROUPS_MODP3072 = 5;
  // MODP4096 DH Group
  DH_GROUPS_MODP4096 = 6;
  // MODP6144 DH Group
  DH_GROUPS_MODP6144 = 7;
  // MODP8192 DH Group
  DH_GROUPS_MODP8192 = 8;
  // MODP1024S160 DH Group
  DH_GROUPS_MODP1024S160 = 9;
  // MODP2048S224 DH Group
  DH_GROUPS_MODP2048S224 = 10;
  // MODP2048S256 DH Group
  DH_GROUPS_MODP2048S256 = 11;
  // Curve25519 DH Group
  DH_GROUPS_CURVE25519 = 12;
}

// Pesudo Random Function (PRF) Algorithm
enum PRF {
  // PRF algorithm is not specified
  PRF_UNSPECIFIED = 0;
  // SHA-1 PRF
  PRF_SHA1 = 1;
  // AES-XCBC PRF
  PRF_AESXCBC = 2;
  // AES-CMAC PRF
  PRF_AESCMAC = 3;
  // SHA-256 PRF
  PRF_SHA256 = 4;
  // SHA-384 PRF
  PRF_SHA384 = 5;
  // SHA-512 PRF
  PRF_SHA512 = 6;
}

// IPsec Mode. Tunnel or Transport mode.
enum IpsecMode {
  // IPsec mode is not specified
  IPSEC_MODE_UNSPECIFIED = 0;
  // Tunnel mode IPsec
  IPSEC_MODE_TUNNEL_MODE = 1;
  // Transport mode IPsec
  IPSEC_MODE_TRANSPORT_MODE = 2;
}

// Authentication Type
enum AuthType {
  // Authentication type is not specified
  AUTH_TYPE_UNSPECIFIED = 0;
  // Public Key Authentication
  AUTH_TYPE_PUBKEY = 1;
  // Pre-shared Key Authentication
  AUTH_TYPE_PSK = 2;
  // XAUTH Authentication
  AUTH_TYPE_XAUTH = 3;
  // EAP Authentication
  AUTH_TYPE_EAP = 4;
}

// IKE connection startup behavior
enum AutoStartupMode {
  // IKE connection startup behavior is not specified
  AUTO_STARTUP_MODE_UNSPECIFIED = 0;
  // IKE/IPsec connection configuration is only loaded into the IKE
  // implementation, but IKE/IPsec SA is not started.
  AUTO_STARTUP_MODE_ADD = 1;
  // IKE/IPsec connection configuration is loaded into the IKE implementation.
  // The IPsec policies are configured but the IKE SAs are not established
  // immediately. The IKE implementation will negotiate the IPsec SAs when they
  // are required.
  AUTO_STARTUP_MODE_ON_DEMAND = 2;
  // IKE/IPsec connection configuration is loaded and the IKEv2-based IPsec SAs
  // are established immediately without waiting for any packet.
  AUTO_STARTUP_MODE_START = 3;
}

// IKE Version
enum IkeVersion {
  // IKE version is not specified
  IKE_VERSION_UNSPECIFIED = 0;
  // IKE version 2
  IKE_VERSION_IKEV2 = 2;
}

// ESP Encapsulation method for NAT traversal
enum EspEncap {
  // Unspecified ESP encapsulation method
  ESP_ENCAP_UNSPECIFIED = 0;
  // ESP encapsulation in UDP
  ESP_ENCAP_ESP_IN_UDP = 1;
}

// IPsec Security Policy Actions
enum IpsecSpdAction {
  // IPsec SPD action is not specified
  IPSEC_SPD_ACTION_UNSPECIFIED = 0;
  // Protect the traffic with IPsec.
  IPSEC_SPD_ACTION_PROTECT = 1;
  // Bypass the traffic. The packet is forwarded without IPsec protection.
  IPSEC_SPD_ACTION_BYPASS = 2;
  // Discard the traffic. The IP packet is discarded.
  IPSEC_SPD_ACTION_DISCARD = 3;
}

// IPsec security protocols
enum IpsecProtocol {
  // IPsec protocol is not specified
  IPSEC_PROTOCOL_UNSPECIFIED = 0;
  // IPsec ESP
  IPSEC_PROTOCOL_ESP = 1;
}

// Lifetime action for IPsec SAs
enum LifetimeAction {
  // Lifetime action is not specified
  LIFETIME_ACTION_UNSPECIFIED = 0;
  // Terminates the IPsec SA and allows the packets through.
  LIFETIME_ACTION_TERMINATE_CLEAR = 1;
  // Terminates the IPsec SA and drops the packets.
  LIFETIME_ACTION_TERMINATE_HOLD = 2;
  // Replaces the IPsec SA with a new one. Rekey.
  LIFETIME_ACTION_REPLACE = 3;
}

// Don't Fragment (DF) bit handling when encapsulating tunnel mode IPsec
// traffic.
enum DfBitAction {
  // DF action is not specified.
  DF_BIT_ACTION_UNSPECIFIED = 0;
  // Disable the Don't Fragment (DF) bit in the outer header.
  DF_BIT_ACTION_CLEAR = 1;
  // Enable the DF bit in the outer header
  DF_BIT_ACTION_SET = 2;
  // Copy the DF bit to the outer header
  DF_BIT_ACTION_COPY = 3;
}

// Digital Signature Algorithm
// Encoding follows the IANA encoding for IKEv2 Authentication Method
// https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-12
enum DSAlgorithm {
  // Digital Signature algorithm is not specified
  DS_ALGORITHM_UNSPECIFIED = 0;
  // RSA digital signature algorithm
  DS_ALGORITHM_RSA = 1;
  // ECDSA digital signature algorithm with SHA-256 and a P-256 curve
  DS_ALGORITHM_ECDSA_SHA256_P256 = 9;
  // ECDSA digital signature algorithm with SHA-384 and a P-384 curve
  DS_ALGORITHM_ECDSA_SHA384_P384 = 10;
  // ECDSA digital signature algorithm with SHA-512 and a P-512 curve
  DS_ALGORITHM_ECDSA_SHA512_P512 = 11;
}
