// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ipsec.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ipsec_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ipsec_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ipsec_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ipsec_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ipsec_2eproto;
namespace opi_api {
namespace security {
namespace v1 {
class Addrs;
struct AddrsDefaultTypeInternal;
extern AddrsDefaultTypeInternal _Addrs_default_instance_;
class CaCerts;
struct CaCertsDefaultTypeInternal;
extern CaCertsDefaultTypeInternal _CaCerts_default_instance_;
class CertPolicy;
struct CertPolicyDefaultTypeInternal;
extern CertPolicyDefaultTypeInternal _CertPolicy_default_instance_;
class Certs;
struct CertsDefaultTypeInternal;
extern CertsDefaultTypeInternal _Certs_default_instance_;
class Child;
struct ChildDefaultTypeInternal;
extern ChildDefaultTypeInternal _Child_default_instance_;
class Connection;
struct ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class Groups;
struct GroupsDefaultTypeInternal;
extern GroupsDefaultTypeInternal _Groups_default_instance_;
class IPsecInitiateRequest;
struct IPsecInitiateRequestDefaultTypeInternal;
extern IPsecInitiateRequestDefaultTypeInternal _IPsecInitiateRequest_default_instance_;
class IPsecInitiateResponse;
struct IPsecInitiateResponseDefaultTypeInternal;
extern IPsecInitiateResponseDefaultTypeInternal _IPsecInitiateResponse_default_instance_;
class IPsecListCertsRequest;
struct IPsecListCertsRequestDefaultTypeInternal;
extern IPsecListCertsRequestDefaultTypeInternal _IPsecListCertsRequest_default_instance_;
class IPsecListCertsResponse;
struct IPsecListCertsResponseDefaultTypeInternal;
extern IPsecListCertsResponseDefaultTypeInternal _IPsecListCertsResponse_default_instance_;
class IPsecListConnsRequest;
struct IPsecListConnsRequestDefaultTypeInternal;
extern IPsecListConnsRequestDefaultTypeInternal _IPsecListConnsRequest_default_instance_;
class IPsecListConnsResponse;
struct IPsecListConnsResponseDefaultTypeInternal;
extern IPsecListConnsResponseDefaultTypeInternal _IPsecListConnsResponse_default_instance_;
class IPsecListSasRequest;
struct IPsecListSasRequestDefaultTypeInternal;
extern IPsecListSasRequestDefaultTypeInternal _IPsecListSasRequest_default_instance_;
class IPsecListSasResponse;
struct IPsecListSasResponseDefaultTypeInternal;
extern IPsecListSasResponseDefaultTypeInternal _IPsecListSasResponse_default_instance_;
class IPsecLoadConnRequest;
struct IPsecLoadConnRequestDefaultTypeInternal;
extern IPsecLoadConnRequestDefaultTypeInternal _IPsecLoadConnRequest_default_instance_;
class IPsecLoadConnResponse;
struct IPsecLoadConnResponseDefaultTypeInternal;
extern IPsecLoadConnResponseDefaultTypeInternal _IPsecLoadConnResponse_default_instance_;
class IPsecRekeyRequest;
struct IPsecRekeyRequestDefaultTypeInternal;
extern IPsecRekeyRequestDefaultTypeInternal _IPsecRekeyRequest_default_instance_;
class IPsecRekeyResponse;
struct IPsecRekeyResponseDefaultTypeInternal;
extern IPsecRekeyResponseDefaultTypeInternal _IPsecRekeyResponse_default_instance_;
class IPsecStatsRequest;
struct IPsecStatsRequestDefaultTypeInternal;
extern IPsecStatsRequestDefaultTypeInternal _IPsecStatsRequest_default_instance_;
class IPsecStatsResponse;
struct IPsecStatsResponseDefaultTypeInternal;
extern IPsecStatsResponseDefaultTypeInternal _IPsecStatsResponse_default_instance_;
class IPsecTerminateRequest;
struct IPsecTerminateRequestDefaultTypeInternal;
extern IPsecTerminateRequestDefaultTypeInternal _IPsecTerminateRequest_default_instance_;
class IPsecTerminateResponse;
struct IPsecTerminateResponseDefaultTypeInternal;
extern IPsecTerminateResponseDefaultTypeInternal _IPsecTerminateResponse_default_instance_;
class IPsecUnloadConnRequest;
struct IPsecUnloadConnRequestDefaultTypeInternal;
extern IPsecUnloadConnRequestDefaultTypeInternal _IPsecUnloadConnRequest_default_instance_;
class IPsecUnloadConnResponse;
struct IPsecUnloadConnResponseDefaultTypeInternal;
extern IPsecUnloadConnResponseDefaultTypeInternal _IPsecUnloadConnResponse_default_instance_;
class IPsecVersionRequest;
struct IPsecVersionRequestDefaultTypeInternal;
extern IPsecVersionRequestDefaultTypeInternal _IPsecVersionRequest_default_instance_;
class IPsecVersionResponse;
struct IPsecVersionResponseDefaultTypeInternal;
extern IPsecVersionResponseDefaultTypeInternal _IPsecVersionResponse_default_instance_;
class ListCert;
struct ListCertDefaultTypeInternal;
extern ListCertDefaultTypeInternal _ListCert_default_instance_;
class ListChild;
struct ListChildDefaultTypeInternal;
extern ListChildDefaultTypeInternal _ListChild_default_instance_;
class ListChildSa;
struct ListChildSaDefaultTypeInternal;
extern ListChildSaDefaultTypeInternal _ListChildSa_default_instance_;
class ListConnAuth;
struct ListConnAuthDefaultTypeInternal;
extern ListConnAuthDefaultTypeInternal _ListConnAuth_default_instance_;
class ListConnResp;
struct ListConnRespDefaultTypeInternal;
extern ListConnRespDefaultTypeInternal _ListConnResp_default_instance_;
class ListIkeSa;
struct ListIkeSaDefaultTypeInternal;
extern ListIkeSaDefaultTypeInternal _ListIkeSa_default_instance_;
class LocalAuth;
struct LocalAuthDefaultTypeInternal;
extern LocalAuthDefaultTypeInternal _LocalAuth_default_instance_;
class Pools;
struct PoolsDefaultTypeInternal;
extern PoolsDefaultTypeInternal _Pools_default_instance_;
class Proposals;
struct ProposalsDefaultTypeInternal;
extern ProposalsDefaultTypeInternal _Proposals_default_instance_;
class PubKeys;
struct PubKeysDefaultTypeInternal;
extern PubKeysDefaultTypeInternal _PubKeys_default_instance_;
class RemoteAuth;
struct RemoteAuthDefaultTypeInternal;
extern RemoteAuthDefaultTypeInternal _RemoteAuth_default_instance_;
class TrafficSelectors;
struct TrafficSelectorsDefaultTypeInternal;
extern TrafficSelectorsDefaultTypeInternal _TrafficSelectors_default_instance_;
class TrafficSelectors_TrafficSelector;
struct TrafficSelectors_TrafficSelectorDefaultTypeInternal;
extern TrafficSelectors_TrafficSelectorDefaultTypeInternal _TrafficSelectors_TrafficSelector_default_instance_;
class Vips;
struct VipsDefaultTypeInternal;
extern VipsDefaultTypeInternal _Vips_default_instance_;
}  // namespace v1
}  // namespace security
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::security::v1::Addrs* Arena::CreateMaybeMessage<::opi_api::security::v1::Addrs>(Arena*);
template<> ::opi_api::security::v1::CaCerts* Arena::CreateMaybeMessage<::opi_api::security::v1::CaCerts>(Arena*);
template<> ::opi_api::security::v1::CertPolicy* Arena::CreateMaybeMessage<::opi_api::security::v1::CertPolicy>(Arena*);
template<> ::opi_api::security::v1::Certs* Arena::CreateMaybeMessage<::opi_api::security::v1::Certs>(Arena*);
template<> ::opi_api::security::v1::Child* Arena::CreateMaybeMessage<::opi_api::security::v1::Child>(Arena*);
template<> ::opi_api::security::v1::Connection* Arena::CreateMaybeMessage<::opi_api::security::v1::Connection>(Arena*);
template<> ::opi_api::security::v1::Groups* Arena::CreateMaybeMessage<::opi_api::security::v1::Groups>(Arena*);
template<> ::opi_api::security::v1::IPsecInitiateRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecInitiateRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecInitiateResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecInitiateResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecListCertsRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecListCertsRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecListCertsResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecListCertsResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecListConnsRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecListConnsRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecListConnsResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecListConnsResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecListSasRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecListSasRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecListSasResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecListSasResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecLoadConnRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecLoadConnRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecLoadConnResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecLoadConnResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecRekeyRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecRekeyRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecRekeyResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecRekeyResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecStatsRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecStatsRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecStatsResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecStatsResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecTerminateRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecTerminateRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecTerminateResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecTerminateResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecUnloadConnRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecUnloadConnRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecUnloadConnResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecUnloadConnResponse>(Arena*);
template<> ::opi_api::security::v1::IPsecVersionRequest* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecVersionRequest>(Arena*);
template<> ::opi_api::security::v1::IPsecVersionResponse* Arena::CreateMaybeMessage<::opi_api::security::v1::IPsecVersionResponse>(Arena*);
template<> ::opi_api::security::v1::ListCert* Arena::CreateMaybeMessage<::opi_api::security::v1::ListCert>(Arena*);
template<> ::opi_api::security::v1::ListChild* Arena::CreateMaybeMessage<::opi_api::security::v1::ListChild>(Arena*);
template<> ::opi_api::security::v1::ListChildSa* Arena::CreateMaybeMessage<::opi_api::security::v1::ListChildSa>(Arena*);
template<> ::opi_api::security::v1::ListConnAuth* Arena::CreateMaybeMessage<::opi_api::security::v1::ListConnAuth>(Arena*);
template<> ::opi_api::security::v1::ListConnResp* Arena::CreateMaybeMessage<::opi_api::security::v1::ListConnResp>(Arena*);
template<> ::opi_api::security::v1::ListIkeSa* Arena::CreateMaybeMessage<::opi_api::security::v1::ListIkeSa>(Arena*);
template<> ::opi_api::security::v1::LocalAuth* Arena::CreateMaybeMessage<::opi_api::security::v1::LocalAuth>(Arena*);
template<> ::opi_api::security::v1::Pools* Arena::CreateMaybeMessage<::opi_api::security::v1::Pools>(Arena*);
template<> ::opi_api::security::v1::Proposals* Arena::CreateMaybeMessage<::opi_api::security::v1::Proposals>(Arena*);
template<> ::opi_api::security::v1::PubKeys* Arena::CreateMaybeMessage<::opi_api::security::v1::PubKeys>(Arena*);
template<> ::opi_api::security::v1::RemoteAuth* Arena::CreateMaybeMessage<::opi_api::security::v1::RemoteAuth>(Arena*);
template<> ::opi_api::security::v1::TrafficSelectors* Arena::CreateMaybeMessage<::opi_api::security::v1::TrafficSelectors>(Arena*);
template<> ::opi_api::security::v1::TrafficSelectors_TrafficSelector* Arena::CreateMaybeMessage<::opi_api::security::v1::TrafficSelectors_TrafficSelector>(Arena*);
template<> ::opi_api::security::v1::Vips* Arena::CreateMaybeMessage<::opi_api::security::v1::Vips>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace security {
namespace v1 {

enum CryptoAlgorithm : int {
  CRYPTO_ALGORITHM_UNSPECIFIED = 0,
  CRYPTO_ALGORITHM_AES128 = 1,
  CRYPTO_ALGORITHM_AES192 = 2,
  CRYPTO_ALGORITHM_AES256 = 3,
  CRYPTO_ALGORITHM_AES128GCM128 = 4,
  CRYPTO_ALGORITHM_AES256GCM128 = 5,
  CRYPTO_ALGORITHM_AES128GMAC = 6,
  CRYPTO_ALGORITHM_AES256GMAC = 7,
  CryptoAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CryptoAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CryptoAlgorithm_IsValid(int value);
constexpr CryptoAlgorithm CryptoAlgorithm_MIN = CRYPTO_ALGORITHM_UNSPECIFIED;
constexpr CryptoAlgorithm CryptoAlgorithm_MAX = CRYPTO_ALGORITHM_AES256GMAC;
constexpr int CryptoAlgorithm_ARRAYSIZE = CryptoAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CryptoAlgorithm_descriptor();
template<typename T>
inline const std::string& CryptoAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CryptoAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CryptoAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CryptoAlgorithm_descriptor(), enum_t_value);
}
inline bool CryptoAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CryptoAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CryptoAlgorithm>(
    CryptoAlgorithm_descriptor(), name, value);
}
enum IntegAlgorithm : int {
  INTEG_ALGORITHM_UNSPECIFIED = 0,
  INTEG_ALGORITHM_MD5 = 1,
  INTEG_ALGORITHM_MD5_128 = 2,
  INTEG_ALGORITHM_SHA1 = 3,
  INTEG_ALGORITHM_SHA1_160 = 4,
  INTEG_ALGORITHM_SHA256 = 5,
  INTEG_ALGORITHM_SHA384 = 7,
  INTEG_ALGORITHM_SHA512 = 8,
  INTEG_ALGORITHM_SHA256_96 = 9,
  IntegAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IntegAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IntegAlgorithm_IsValid(int value);
constexpr IntegAlgorithm IntegAlgorithm_MIN = INTEG_ALGORITHM_UNSPECIFIED;
constexpr IntegAlgorithm IntegAlgorithm_MAX = INTEG_ALGORITHM_SHA256_96;
constexpr int IntegAlgorithm_ARRAYSIZE = IntegAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntegAlgorithm_descriptor();
template<typename T>
inline const std::string& IntegAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IntegAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IntegAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IntegAlgorithm_descriptor(), enum_t_value);
}
inline bool IntegAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IntegAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntegAlgorithm>(
    IntegAlgorithm_descriptor(), name, value);
}
enum DHGroups : int {
  DH_GROUPS_UNSPECIFIED = 0,
  DH_GROUPS_MODP768 = 1,
  DH_GROUPS_MODP1024 = 2,
  DH_GROUPS_MODP1536 = 3,
  DH_GROUPS_MODP2048 = 4,
  DH_GROUPS_MODP3072 = 5,
  DH_GROUPS_MODP4096 = 6,
  DH_GROUPS_MODP6144 = 7,
  DH_GROUPS_MODP8192 = 8,
  DH_GROUPS_MODP1024S160 = 9,
  DH_GROUPS_MODP2048S224 = 10,
  DH_GROUPS_MODP2048S256 = 11,
  DH_GROUPS_CURVE25519 = 12,
  DHGroups_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DHGroups_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DHGroups_IsValid(int value);
constexpr DHGroups DHGroups_MIN = DH_GROUPS_UNSPECIFIED;
constexpr DHGroups DHGroups_MAX = DH_GROUPS_CURVE25519;
constexpr int DHGroups_ARRAYSIZE = DHGroups_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DHGroups_descriptor();
template<typename T>
inline const std::string& DHGroups_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DHGroups>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DHGroups_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DHGroups_descriptor(), enum_t_value);
}
inline bool DHGroups_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DHGroups* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DHGroups>(
    DHGroups_descriptor(), name, value);
}
enum PRFunction : int {
  PR_FUNCTION_UNSPECIFIED = 0,
  PR_FUNCTION_MD5 = 1,
  PR_FUNCTION_SHA1 = 2,
  PR_FUNCTION_AESXCBC = 3,
  PR_FUNCTION_AESCMAC = 4,
  PR_FUNCTION_SHA256 = 5,
  PR_FUNCTION_SHA384 = 6,
  PR_FUNCTION_SHA512 = 7,
  PRFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PRFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PRFunction_IsValid(int value);
constexpr PRFunction PRFunction_MIN = PR_FUNCTION_UNSPECIFIED;
constexpr PRFunction PRFunction_MAX = PR_FUNCTION_SHA512;
constexpr int PRFunction_ARRAYSIZE = PRFunction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PRFunction_descriptor();
template<typename T>
inline const std::string& PRFunction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PRFunction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PRFunction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PRFunction_descriptor(), enum_t_value);
}
inline bool PRFunction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PRFunction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PRFunction>(
    PRFunction_descriptor(), name, value);
}
enum IpsecMode : int {
  IPSEC_MODE_UNSPECIFIED = 0,
  IPSEC_MODE_TUNNEL_MODE = 1,
  IPSEC_MODE_TRANSPORT_MODE = 2,
  IpsecMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IpsecMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IpsecMode_IsValid(int value);
constexpr IpsecMode IpsecMode_MIN = IPSEC_MODE_UNSPECIFIED;
constexpr IpsecMode IpsecMode_MAX = IPSEC_MODE_TRANSPORT_MODE;
constexpr int IpsecMode_ARRAYSIZE = IpsecMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IpsecMode_descriptor();
template<typename T>
inline const std::string& IpsecMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IpsecMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IpsecMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IpsecMode_descriptor(), enum_t_value);
}
inline bool IpsecMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IpsecMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IpsecMode>(
    IpsecMode_descriptor(), name, value);
}
enum AuthType : int {
  AUTH_TYPE_UNSPECIFIED = 0,
  AUTH_TYPE_PUBKEY = 1,
  AUTH_TYPE_PSK = 2,
  AUTH_TYPE_XAUTH = 3,
  AUTH_TYPE_EAP = 4,
  AuthType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AuthType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AuthType_IsValid(int value);
constexpr AuthType AuthType_MIN = AUTH_TYPE_UNSPECIFIED;
constexpr AuthType AuthType_MAX = AUTH_TYPE_EAP;
constexpr int AuthType_ARRAYSIZE = AuthType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AuthType_descriptor();
template<typename T>
inline const std::string& AuthType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuthType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuthType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AuthType_descriptor(), enum_t_value);
}
inline bool AuthType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AuthType>(
    AuthType_descriptor(), name, value);
}
enum IkeSaState : int {
  IKE_SA_STATE_UNSPECIFIED = 0,
  IKE_SA_STATE_CREATED = 1,
  IKE_SA_STATE_CONNECTING = 2,
  IKE_SA_STATE_ESTABLISHED = 3,
  IKE_SA_STATE_PASSIVE = 4,
  IKE_SA_STATE_REKEYING = 5,
  IKE_SA_STATE_REKEYED = 6,
  IKE_SA_STATE_DELETING = 7,
  IKE_SA_STATE_DESTROYING = 8,
  IkeSaState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IkeSaState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IkeSaState_IsValid(int value);
constexpr IkeSaState IkeSaState_MIN = IKE_SA_STATE_UNSPECIFIED;
constexpr IkeSaState IkeSaState_MAX = IKE_SA_STATE_DESTROYING;
constexpr int IkeSaState_ARRAYSIZE = IkeSaState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IkeSaState_descriptor();
template<typename T>
inline const std::string& IkeSaState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IkeSaState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IkeSaState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IkeSaState_descriptor(), enum_t_value);
}
inline bool IkeSaState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IkeSaState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IkeSaState>(
    IkeSaState_descriptor(), name, value);
}
enum ChildSaState : int {
  CHILD_SA_STATE_UNSPECIFIED = 0,
  CHILD_SA_STATE_CREATED = 1,
  CHILD_SA_STATE_ROUTED = 2,
  CHILD_SA_STATE_INSTALLING = 3,
  CHILD_SA_STATE_INSTALLED = 4,
  CHILD_SA_STATE_UPDATING = 5,
  CHILD_SA_STATE_REKEYING = 6,
  CHILD_SA_STATE_REKEYED = 7,
  CHILD_SA_STATE_RETRYING = 8,
  CHILD_SA_STATE_DELETING = 9,
  CHILD_SA_STATE_DELETED = 10,
  CHILD_SA_STATE_DESTROYING = 11,
  ChildSaState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChildSaState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChildSaState_IsValid(int value);
constexpr ChildSaState ChildSaState_MIN = CHILD_SA_STATE_UNSPECIFIED;
constexpr ChildSaState ChildSaState_MAX = CHILD_SA_STATE_DESTROYING;
constexpr int ChildSaState_ARRAYSIZE = ChildSaState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChildSaState_descriptor();
template<typename T>
inline const std::string& ChildSaState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChildSaState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChildSaState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChildSaState_descriptor(), enum_t_value);
}
inline bool ChildSaState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChildSaState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChildSaState>(
    ChildSaState_descriptor(), name, value);
}
enum CertificateType : int {
  CERTIFICATE_TYPE_X509_UNSPECIFIED = 0,
  CERTIFICATE_TYPE_X509_AC = 1,
  CERTIFICATE_TYPE_X509_CRL = 2,
  CERTIFICATE_TYPE_OCSP_RESPONSE = 3,
  CERTIFICATE_TYPE_PUBKEY = 4,
  CertificateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CertificateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CertificateType_IsValid(int value);
constexpr CertificateType CertificateType_MIN = CERTIFICATE_TYPE_X509_UNSPECIFIED;
constexpr CertificateType CertificateType_MAX = CERTIFICATE_TYPE_PUBKEY;
constexpr int CertificateType_ARRAYSIZE = CertificateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CertificateType_descriptor();
template<typename T>
inline const std::string& CertificateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CertificateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CertificateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CertificateType_descriptor(), enum_t_value);
}
inline bool CertificateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertificateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CertificateType>(
    CertificateType_descriptor(), name, value);
}
enum X509CertificateFlag : int {
  X509_CERTIFICATE_FLAG_UNSPECIFIED = 0,
  X509_CERTIFICATE_FLAG_CA = 1,
  X509_CERTIFICATE_FLAG_AA = 2,
  X509_CERTIFICATE_FLAG_OCSP = 3,
  X509CertificateFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  X509CertificateFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool X509CertificateFlag_IsValid(int value);
constexpr X509CertificateFlag X509CertificateFlag_MIN = X509_CERTIFICATE_FLAG_UNSPECIFIED;
constexpr X509CertificateFlag X509CertificateFlag_MAX = X509_CERTIFICATE_FLAG_OCSP;
constexpr int X509CertificateFlag_ARRAYSIZE = X509CertificateFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* X509CertificateFlag_descriptor();
template<typename T>
inline const std::string& X509CertificateFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, X509CertificateFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function X509CertificateFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    X509CertificateFlag_descriptor(), enum_t_value);
}
inline bool X509CertificateFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, X509CertificateFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<X509CertificateFlag>(
    X509CertificateFlag_descriptor(), name, value);
}
// ===================================================================

class Proposals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Proposals) */ {
 public:
  inline Proposals() : Proposals(nullptr) {}
  ~Proposals() override;
  explicit PROTOBUF_CONSTEXPR Proposals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proposals(const Proposals& from);
  Proposals(Proposals&& from) noexcept
    : Proposals() {
    *this = ::std::move(from);
  }

  inline Proposals& operator=(const Proposals& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proposals& operator=(Proposals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proposals& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proposals* internal_default_instance() {
    return reinterpret_cast<const Proposals*>(
               &_Proposals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Proposals& a, Proposals& b) {
    a.Swap(&b);
  }
  inline void Swap(Proposals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proposals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proposals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proposals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proposals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proposals& from) {
    Proposals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Proposals";
  }
  protected:
  explicit Proposals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCryptoAlgFieldNumber = 1,
    kIntegAlgFieldNumber = 2,
    kPrfFieldNumber = 3,
    kDhgroupsFieldNumber = 4,
  };
  // repeated .opi_api.security.v1.CryptoAlgorithm crypto_alg = 1;
  int crypto_alg_size() const;
  private:
  int _internal_crypto_alg_size() const;
  public:
  void clear_crypto_alg();
  private:
  ::opi_api::security::v1::CryptoAlgorithm _internal_crypto_alg(int index) const;
  void _internal_add_crypto_alg(::opi_api::security::v1::CryptoAlgorithm value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_crypto_alg();
  public:
  ::opi_api::security::v1::CryptoAlgorithm crypto_alg(int index) const;
  void set_crypto_alg(int index, ::opi_api::security::v1::CryptoAlgorithm value);
  void add_crypto_alg(::opi_api::security::v1::CryptoAlgorithm value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& crypto_alg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_crypto_alg();

  // repeated .opi_api.security.v1.IntegAlgorithm integ_alg = 2;
  int integ_alg_size() const;
  private:
  int _internal_integ_alg_size() const;
  public:
  void clear_integ_alg();
  private:
  ::opi_api::security::v1::IntegAlgorithm _internal_integ_alg(int index) const;
  void _internal_add_integ_alg(::opi_api::security::v1::IntegAlgorithm value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_integ_alg();
  public:
  ::opi_api::security::v1::IntegAlgorithm integ_alg(int index) const;
  void set_integ_alg(int index, ::opi_api::security::v1::IntegAlgorithm value);
  void add_integ_alg(::opi_api::security::v1::IntegAlgorithm value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& integ_alg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_integ_alg();

  // repeated .opi_api.security.v1.PRFunction prf = 3;
  int prf_size() const;
  private:
  int _internal_prf_size() const;
  public:
  void clear_prf();
  private:
  ::opi_api::security::v1::PRFunction _internal_prf(int index) const;
  void _internal_add_prf(::opi_api::security::v1::PRFunction value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_prf();
  public:
  ::opi_api::security::v1::PRFunction prf(int index) const;
  void set_prf(int index, ::opi_api::security::v1::PRFunction value);
  void add_prf(::opi_api::security::v1::PRFunction value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& prf() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_prf();

  // repeated .opi_api.security.v1.DHGroups dhgroups = 4;
  int dhgroups_size() const;
  private:
  int _internal_dhgroups_size() const;
  public:
  void clear_dhgroups();
  private:
  ::opi_api::security::v1::DHGroups _internal_dhgroups(int index) const;
  void _internal_add_dhgroups(::opi_api::security::v1::DHGroups value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_dhgroups();
  public:
  ::opi_api::security::v1::DHGroups dhgroups(int index) const;
  void set_dhgroups(int index, ::opi_api::security::v1::DHGroups value);
  void add_dhgroups(::opi_api::security::v1::DHGroups value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& dhgroups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_dhgroups();

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Proposals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> crypto_alg_;
    mutable std::atomic<int> _crypto_alg_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> integ_alg_;
    mutable std::atomic<int> _integ_alg_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> prf_;
    mutable std::atomic<int> _prf_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> dhgroups_;
    mutable std::atomic<int> _dhgroups_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Vips final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Vips) */ {
 public:
  inline Vips() : Vips(nullptr) {}
  ~Vips() override;
  explicit PROTOBUF_CONSTEXPR Vips(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vips(const Vips& from);
  Vips(Vips&& from) noexcept
    : Vips() {
    *this = ::std::move(from);
  }

  inline Vips& operator=(const Vips& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vips& operator=(Vips&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vips& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vips* internal_default_instance() {
    return reinterpret_cast<const Vips*>(
               &_Vips_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vips& a, Vips& b) {
    a.Swap(&b);
  }
  inline void Swap(Vips* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vips* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vips* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vips>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vips& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vips& from) {
    Vips::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vips* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Vips";
  }
  protected:
  explicit Vips(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVipFieldNumber = 1,
  };
  // repeated string vip = 1;
  int vip_size() const;
  private:
  int _internal_vip_size() const;
  public:
  void clear_vip();
  const std::string& vip(int index) const;
  std::string* mutable_vip(int index);
  void set_vip(int index, const std::string& value);
  void set_vip(int index, std::string&& value);
  void set_vip(int index, const char* value);
  void set_vip(int index, const char* value, size_t size);
  std::string* add_vip();
  void add_vip(const std::string& value);
  void add_vip(std::string&& value);
  void add_vip(const char* value);
  void add_vip(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vip() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vip();
  private:
  const std::string& _internal_vip(int index) const;
  std::string* _internal_add_vip();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Vips)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Pools final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Pools) */ {
 public:
  inline Pools() : Pools(nullptr) {}
  ~Pools() override;
  explicit PROTOBUF_CONSTEXPR Pools(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pools(const Pools& from);
  Pools(Pools&& from) noexcept
    : Pools() {
    *this = ::std::move(from);
  }

  inline Pools& operator=(const Pools& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pools& operator=(Pools&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pools& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pools* internal_default_instance() {
    return reinterpret_cast<const Pools*>(
               &_Pools_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Pools& a, Pools& b) {
    a.Swap(&b);
  }
  inline void Swap(Pools* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pools* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pools* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pools>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pools& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pools& from) {
    Pools::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pools* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Pools";
  }
  protected:
  explicit Pools(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoolFieldNumber = 1,
  };
  // repeated string pool = 1;
  int pool_size() const;
  private:
  int _internal_pool_size() const;
  public:
  void clear_pool();
  const std::string& pool(int index) const;
  std::string* mutable_pool(int index);
  void set_pool(int index, const std::string& value);
  void set_pool(int index, std::string&& value);
  void set_pool(int index, const char* value);
  void set_pool(int index, const char* value, size_t size);
  std::string* add_pool();
  void add_pool(const std::string& value);
  void add_pool(std::string&& value);
  void add_pool(const char* value);
  void add_pool(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pool() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pool();
  private:
  const std::string& _internal_pool(int index) const;
  std::string* _internal_add_pool();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Pools)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Certs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Certs) */ {
 public:
  inline Certs() : Certs(nullptr) {}
  ~Certs() override;
  explicit PROTOBUF_CONSTEXPR Certs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Certs(const Certs& from);
  Certs(Certs&& from) noexcept
    : Certs() {
    *this = ::std::move(from);
  }

  inline Certs& operator=(const Certs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Certs& operator=(Certs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Certs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Certs* internal_default_instance() {
    return reinterpret_cast<const Certs*>(
               &_Certs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Certs& a, Certs& b) {
    a.Swap(&b);
  }
  inline void Swap(Certs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Certs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Certs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Certs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Certs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Certs& from) {
    Certs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Certs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Certs";
  }
  protected:
  explicit Certs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertFieldNumber = 1,
  };
  // repeated string cert = 1;
  int cert_size() const;
  private:
  int _internal_cert_size() const;
  public:
  void clear_cert();
  const std::string& cert(int index) const;
  std::string* mutable_cert(int index);
  void set_cert(int index, const std::string& value);
  void set_cert(int index, std::string&& value);
  void set_cert(int index, const char* value);
  void set_cert(int index, const char* value, size_t size);
  std::string* add_cert();
  void add_cert(const std::string& value);
  void add_cert(std::string&& value);
  void add_cert(const char* value);
  void add_cert(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cert() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cert();
  private:
  const std::string& _internal_cert(int index) const;
  std::string* _internal_add_cert();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Certs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cert_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class PubKeys final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.PubKeys) */ {
 public:
  inline PubKeys() : PubKeys(nullptr) {}
  ~PubKeys() override;
  explicit PROTOBUF_CONSTEXPR PubKeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PubKeys(const PubKeys& from);
  PubKeys(PubKeys&& from) noexcept
    : PubKeys() {
    *this = ::std::move(from);
  }

  inline PubKeys& operator=(const PubKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubKeys& operator=(PubKeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubKeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const PubKeys* internal_default_instance() {
    return reinterpret_cast<const PubKeys*>(
               &_PubKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PubKeys& a, PubKeys& b) {
    a.Swap(&b);
  }
  inline void Swap(PubKeys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubKeys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubKeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PubKeys>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PubKeys& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PubKeys& from) {
    PubKeys::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubKeys* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.PubKeys";
  }
  protected:
  explicit PubKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubkeyFieldNumber = 1,
  };
  // repeated string pubkey = 1;
  int pubkey_size() const;
  private:
  int _internal_pubkey_size() const;
  public:
  void clear_pubkey();
  const std::string& pubkey(int index) const;
  std::string* mutable_pubkey(int index);
  void set_pubkey(int index, const std::string& value);
  void set_pubkey(int index, std::string&& value);
  void set_pubkey(int index, const char* value);
  void set_pubkey(int index, const char* value, size_t size);
  std::string* add_pubkey();
  void add_pubkey(const std::string& value);
  void add_pubkey(std::string&& value);
  void add_pubkey(const char* value);
  void add_pubkey(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pubkey() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pubkey();
  private:
  const std::string& _internal_pubkey(int index) const;
  std::string* _internal_add_pubkey();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.PubKeys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pubkey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Groups final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Groups) */ {
 public:
  inline Groups() : Groups(nullptr) {}
  ~Groups() override;
  explicit PROTOBUF_CONSTEXPR Groups(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Groups(const Groups& from);
  Groups(Groups&& from) noexcept
    : Groups() {
    *this = ::std::move(from);
  }

  inline Groups& operator=(const Groups& from) {
    CopyFrom(from);
    return *this;
  }
  inline Groups& operator=(Groups&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Groups& default_instance() {
    return *internal_default_instance();
  }
  static inline const Groups* internal_default_instance() {
    return reinterpret_cast<const Groups*>(
               &_Groups_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Groups& a, Groups& b) {
    a.Swap(&b);
  }
  inline void Swap(Groups* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Groups* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Groups* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Groups>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Groups& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Groups& from) {
    Groups::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Groups* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Groups";
  }
  protected:
  explicit Groups(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // repeated string group = 1;
  int group_size() const;
  private:
  int _internal_group_size() const;
  public:
  void clear_group();
  const std::string& group(int index) const;
  std::string* mutable_group(int index);
  void set_group(int index, const std::string& value);
  void set_group(int index, std::string&& value);
  void set_group(int index, const char* value);
  void set_group(int index, const char* value, size_t size);
  std::string* add_group();
  void add_group(const std::string& value);
  void add_group(std::string&& value);
  void add_group(const char* value);
  void add_group(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group();
  private:
  const std::string& _internal_group(int index) const;
  std::string* _internal_add_group();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Groups)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class CertPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.CertPolicy) */ {
 public:
  inline CertPolicy() : CertPolicy(nullptr) {}
  ~CertPolicy() override;
  explicit PROTOBUF_CONSTEXPR CertPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertPolicy(const CertPolicy& from);
  CertPolicy(CertPolicy&& from) noexcept
    : CertPolicy() {
    *this = ::std::move(from);
  }

  inline CertPolicy& operator=(const CertPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertPolicy& operator=(CertPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertPolicy* internal_default_instance() {
    return reinterpret_cast<const CertPolicy*>(
               &_CertPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CertPolicy& a, CertPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(CertPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CertPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CertPolicy& from) {
    CertPolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.CertPolicy";
  }
  protected:
  explicit CertPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertPolicyFieldNumber = 1,
  };
  // repeated string cert_policy = 1;
  int cert_policy_size() const;
  private:
  int _internal_cert_policy_size() const;
  public:
  void clear_cert_policy();
  const std::string& cert_policy(int index) const;
  std::string* mutable_cert_policy(int index);
  void set_cert_policy(int index, const std::string& value);
  void set_cert_policy(int index, std::string&& value);
  void set_cert_policy(int index, const char* value);
  void set_cert_policy(int index, const char* value, size_t size);
  std::string* add_cert_policy();
  void add_cert_policy(const std::string& value);
  void add_cert_policy(std::string&& value);
  void add_cert_policy(const char* value);
  void add_cert_policy(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cert_policy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cert_policy();
  private:
  const std::string& _internal_cert_policy(int index) const;
  std::string* _internal_add_cert_policy();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.CertPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cert_policy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class CaCerts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.CaCerts) */ {
 public:
  inline CaCerts() : CaCerts(nullptr) {}
  ~CaCerts() override;
  explicit PROTOBUF_CONSTEXPR CaCerts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaCerts(const CaCerts& from);
  CaCerts(CaCerts&& from) noexcept
    : CaCerts() {
    *this = ::std::move(from);
  }

  inline CaCerts& operator=(const CaCerts& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaCerts& operator=(CaCerts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaCerts& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaCerts* internal_default_instance() {
    return reinterpret_cast<const CaCerts*>(
               &_CaCerts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CaCerts& a, CaCerts& b) {
    a.Swap(&b);
  }
  inline void Swap(CaCerts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaCerts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaCerts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaCerts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaCerts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaCerts& from) {
    CaCerts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaCerts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.CaCerts";
  }
  protected:
  explicit CaCerts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacertFieldNumber = 1,
  };
  // repeated string cacert = 1;
  int cacert_size() const;
  private:
  int _internal_cacert_size() const;
  public:
  void clear_cacert();
  const std::string& cacert(int index) const;
  std::string* mutable_cacert(int index);
  void set_cacert(int index, const std::string& value);
  void set_cacert(int index, std::string&& value);
  void set_cacert(int index, const char* value);
  void set_cacert(int index, const char* value, size_t size);
  std::string* add_cacert();
  void add_cacert(const std::string& value);
  void add_cacert(std::string&& value);
  void add_cacert(const char* value);
  void add_cacert(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cacert() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cacert();
  private:
  const std::string& _internal_cacert(int index) const;
  std::string* _internal_add_cacert();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.CaCerts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cacert_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class LocalAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.LocalAuth) */ {
 public:
  inline LocalAuth() : LocalAuth(nullptr) {}
  ~LocalAuth() override;
  explicit PROTOBUF_CONSTEXPR LocalAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalAuth(const LocalAuth& from);
  LocalAuth(LocalAuth&& from) noexcept
    : LocalAuth() {
    *this = ::std::move(from);
  }

  inline LocalAuth& operator=(const LocalAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalAuth& operator=(LocalAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalAuth* internal_default_instance() {
    return reinterpret_cast<const LocalAuth*>(
               &_LocalAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LocalAuth& a, LocalAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalAuth& from) {
    LocalAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.LocalAuth";
  }
  protected:
  explicit LocalAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kEapIdFieldNumber = 3,
    kAaaIdFieldNumber = 4,
    kXauthIdFieldNumber = 5,
    kCertsFieldNumber = 6,
    kPubkeysFieldNumber = 7,
    kAuthFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string eap_id = 3;
  void clear_eap_id();
  const std::string& eap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eap_id();
  PROTOBUF_NODISCARD std::string* release_eap_id();
  void set_allocated_eap_id(std::string* eap_id);
  private:
  const std::string& _internal_eap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eap_id(const std::string& value);
  std::string* _internal_mutable_eap_id();
  public:

  // string aaa_id = 4;
  void clear_aaa_id();
  const std::string& aaa_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aaa_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aaa_id();
  PROTOBUF_NODISCARD std::string* release_aaa_id();
  void set_allocated_aaa_id(std::string* aaa_id);
  private:
  const std::string& _internal_aaa_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aaa_id(const std::string& value);
  std::string* _internal_mutable_aaa_id();
  public:

  // string xauth_id = 5;
  void clear_xauth_id();
  const std::string& xauth_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xauth_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xauth_id();
  PROTOBUF_NODISCARD std::string* release_xauth_id();
  void set_allocated_xauth_id(std::string* xauth_id);
  private:
  const std::string& _internal_xauth_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xauth_id(const std::string& value);
  std::string* _internal_mutable_xauth_id();
  public:

  // .opi_api.security.v1.Certs certs = 6;
  bool has_certs() const;
  private:
  bool _internal_has_certs() const;
  public:
  void clear_certs();
  const ::opi_api::security::v1::Certs& certs() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Certs* release_certs();
  ::opi_api::security::v1::Certs* mutable_certs();
  void set_allocated_certs(::opi_api::security::v1::Certs* certs);
  private:
  const ::opi_api::security::v1::Certs& _internal_certs() const;
  ::opi_api::security::v1::Certs* _internal_mutable_certs();
  public:
  void unsafe_arena_set_allocated_certs(
      ::opi_api::security::v1::Certs* certs);
  ::opi_api::security::v1::Certs* unsafe_arena_release_certs();

  // .opi_api.security.v1.PubKeys pubkeys = 7;
  bool has_pubkeys() const;
  private:
  bool _internal_has_pubkeys() const;
  public:
  void clear_pubkeys();
  const ::opi_api::security::v1::PubKeys& pubkeys() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::PubKeys* release_pubkeys();
  ::opi_api::security::v1::PubKeys* mutable_pubkeys();
  void set_allocated_pubkeys(::opi_api::security::v1::PubKeys* pubkeys);
  private:
  const ::opi_api::security::v1::PubKeys& _internal_pubkeys() const;
  ::opi_api::security::v1::PubKeys* _internal_mutable_pubkeys();
  public:
  void unsafe_arena_set_allocated_pubkeys(
      ::opi_api::security::v1::PubKeys* pubkeys);
  ::opi_api::security::v1::PubKeys* unsafe_arena_release_pubkeys();

  // .opi_api.security.v1.AuthType auth = 1;
  void clear_auth();
  ::opi_api::security::v1::AuthType auth() const;
  void set_auth(::opi_api::security::v1::AuthType value);
  private:
  ::opi_api::security::v1::AuthType _internal_auth() const;
  void _internal_set_auth(::opi_api::security::v1::AuthType value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.LocalAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eap_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aaa_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xauth_id_;
    ::opi_api::security::v1::Certs* certs_;
    ::opi_api::security::v1::PubKeys* pubkeys_;
    int auth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class RemoteAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.RemoteAuth) */ {
 public:
  inline RemoteAuth() : RemoteAuth(nullptr) {}
  ~RemoteAuth() override;
  explicit PROTOBUF_CONSTEXPR RemoteAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteAuth(const RemoteAuth& from);
  RemoteAuth(RemoteAuth&& from) noexcept
    : RemoteAuth() {
    *this = ::std::move(from);
  }

  inline RemoteAuth& operator=(const RemoteAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteAuth& operator=(RemoteAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteAuth* internal_default_instance() {
    return reinterpret_cast<const RemoteAuth*>(
               &_RemoteAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RemoteAuth& a, RemoteAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoteAuth& from) {
    RemoteAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.RemoteAuth";
  }
  protected:
  explicit RemoteAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kEapIdFieldNumber = 3,
    kGroupsFieldNumber = 4,
    kCertPolicyFieldNumber = 5,
    kCertsFieldNumber = 6,
    kCaCertsFieldNumber = 7,
    kPubkeysFieldNumber = 8,
    kAuthFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string eap_id = 3;
  void clear_eap_id();
  const std::string& eap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eap_id();
  PROTOBUF_NODISCARD std::string* release_eap_id();
  void set_allocated_eap_id(std::string* eap_id);
  private:
  const std::string& _internal_eap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eap_id(const std::string& value);
  std::string* _internal_mutable_eap_id();
  public:

  // .opi_api.security.v1.Groups groups = 4;
  bool has_groups() const;
  private:
  bool _internal_has_groups() const;
  public:
  void clear_groups();
  const ::opi_api::security::v1::Groups& groups() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Groups* release_groups();
  ::opi_api::security::v1::Groups* mutable_groups();
  void set_allocated_groups(::opi_api::security::v1::Groups* groups);
  private:
  const ::opi_api::security::v1::Groups& _internal_groups() const;
  ::opi_api::security::v1::Groups* _internal_mutable_groups();
  public:
  void unsafe_arena_set_allocated_groups(
      ::opi_api::security::v1::Groups* groups);
  ::opi_api::security::v1::Groups* unsafe_arena_release_groups();

  // .opi_api.security.v1.CertPolicy cert_policy = 5;
  bool has_cert_policy() const;
  private:
  bool _internal_has_cert_policy() const;
  public:
  void clear_cert_policy();
  const ::opi_api::security::v1::CertPolicy& cert_policy() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::CertPolicy* release_cert_policy();
  ::opi_api::security::v1::CertPolicy* mutable_cert_policy();
  void set_allocated_cert_policy(::opi_api::security::v1::CertPolicy* cert_policy);
  private:
  const ::opi_api::security::v1::CertPolicy& _internal_cert_policy() const;
  ::opi_api::security::v1::CertPolicy* _internal_mutable_cert_policy();
  public:
  void unsafe_arena_set_allocated_cert_policy(
      ::opi_api::security::v1::CertPolicy* cert_policy);
  ::opi_api::security::v1::CertPolicy* unsafe_arena_release_cert_policy();

  // .opi_api.security.v1.Certs certs = 6;
  bool has_certs() const;
  private:
  bool _internal_has_certs() const;
  public:
  void clear_certs();
  const ::opi_api::security::v1::Certs& certs() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Certs* release_certs();
  ::opi_api::security::v1::Certs* mutable_certs();
  void set_allocated_certs(::opi_api::security::v1::Certs* certs);
  private:
  const ::opi_api::security::v1::Certs& _internal_certs() const;
  ::opi_api::security::v1::Certs* _internal_mutable_certs();
  public:
  void unsafe_arena_set_allocated_certs(
      ::opi_api::security::v1::Certs* certs);
  ::opi_api::security::v1::Certs* unsafe_arena_release_certs();

  // .opi_api.security.v1.CaCerts ca_certs = 7;
  bool has_ca_certs() const;
  private:
  bool _internal_has_ca_certs() const;
  public:
  void clear_ca_certs();
  const ::opi_api::security::v1::CaCerts& ca_certs() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::CaCerts* release_ca_certs();
  ::opi_api::security::v1::CaCerts* mutable_ca_certs();
  void set_allocated_ca_certs(::opi_api::security::v1::CaCerts* ca_certs);
  private:
  const ::opi_api::security::v1::CaCerts& _internal_ca_certs() const;
  ::opi_api::security::v1::CaCerts* _internal_mutable_ca_certs();
  public:
  void unsafe_arena_set_allocated_ca_certs(
      ::opi_api::security::v1::CaCerts* ca_certs);
  ::opi_api::security::v1::CaCerts* unsafe_arena_release_ca_certs();

  // .opi_api.security.v1.PubKeys pubkeys = 8;
  bool has_pubkeys() const;
  private:
  bool _internal_has_pubkeys() const;
  public:
  void clear_pubkeys();
  const ::opi_api::security::v1::PubKeys& pubkeys() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::PubKeys* release_pubkeys();
  ::opi_api::security::v1::PubKeys* mutable_pubkeys();
  void set_allocated_pubkeys(::opi_api::security::v1::PubKeys* pubkeys);
  private:
  const ::opi_api::security::v1::PubKeys& _internal_pubkeys() const;
  ::opi_api::security::v1::PubKeys* _internal_mutable_pubkeys();
  public:
  void unsafe_arena_set_allocated_pubkeys(
      ::opi_api::security::v1::PubKeys* pubkeys);
  ::opi_api::security::v1::PubKeys* unsafe_arena_release_pubkeys();

  // .opi_api.security.v1.AuthType auth = 1;
  void clear_auth();
  ::opi_api::security::v1::AuthType auth() const;
  void set_auth(::opi_api::security::v1::AuthType value);
  private:
  ::opi_api::security::v1::AuthType _internal_auth() const;
  void _internal_set_auth(::opi_api::security::v1::AuthType value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.RemoteAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eap_id_;
    ::opi_api::security::v1::Groups* groups_;
    ::opi_api::security::v1::CertPolicy* cert_policy_;
    ::opi_api::security::v1::Certs* certs_;
    ::opi_api::security::v1::CaCerts* ca_certs_;
    ::opi_api::security::v1::PubKeys* pubkeys_;
    int auth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class TrafficSelectors_TrafficSelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.TrafficSelectors.TrafficSelector) */ {
 public:
  inline TrafficSelectors_TrafficSelector() : TrafficSelectors_TrafficSelector(nullptr) {}
  ~TrafficSelectors_TrafficSelector() override;
  explicit PROTOBUF_CONSTEXPR TrafficSelectors_TrafficSelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficSelectors_TrafficSelector(const TrafficSelectors_TrafficSelector& from);
  TrafficSelectors_TrafficSelector(TrafficSelectors_TrafficSelector&& from) noexcept
    : TrafficSelectors_TrafficSelector() {
    *this = ::std::move(from);
  }

  inline TrafficSelectors_TrafficSelector& operator=(const TrafficSelectors_TrafficSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSelectors_TrafficSelector& operator=(TrafficSelectors_TrafficSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSelectors_TrafficSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSelectors_TrafficSelector* internal_default_instance() {
    return reinterpret_cast<const TrafficSelectors_TrafficSelector*>(
               &_TrafficSelectors_TrafficSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TrafficSelectors_TrafficSelector& a, TrafficSelectors_TrafficSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSelectors_TrafficSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSelectors_TrafficSelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSelectors_TrafficSelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSelectors_TrafficSelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficSelectors_TrafficSelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficSelectors_TrafficSelector& from) {
    TrafficSelectors_TrafficSelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSelectors_TrafficSelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.TrafficSelectors.TrafficSelector";
  }
  protected:
  explicit TrafficSelectors_TrafficSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidrFieldNumber = 1,
    kProtoFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string cidr = 1;
  void clear_cidr();
  const std::string& cidr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cidr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cidr();
  PROTOBUF_NODISCARD std::string* release_cidr();
  void set_allocated_cidr(std::string* cidr);
  private:
  const std::string& _internal_cidr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cidr(const std::string& value);
  std::string* _internal_mutable_cidr();
  public:

  // string proto = 2;
  void clear_proto();
  const std::string& proto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proto();
  PROTOBUF_NODISCARD std::string* release_proto();
  void set_allocated_proto(std::string* proto);
  private:
  const std::string& _internal_proto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proto(const std::string& value);
  std::string* _internal_mutable_proto();
  public:

  // string port = 3;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.TrafficSelectors.TrafficSelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cidr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class TrafficSelectors final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.TrafficSelectors) */ {
 public:
  inline TrafficSelectors() : TrafficSelectors(nullptr) {}
  ~TrafficSelectors() override;
  explicit PROTOBUF_CONSTEXPR TrafficSelectors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficSelectors(const TrafficSelectors& from);
  TrafficSelectors(TrafficSelectors&& from) noexcept
    : TrafficSelectors() {
    *this = ::std::move(from);
  }

  inline TrafficSelectors& operator=(const TrafficSelectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSelectors& operator=(TrafficSelectors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSelectors& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSelectors* internal_default_instance() {
    return reinterpret_cast<const TrafficSelectors*>(
               &_TrafficSelectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TrafficSelectors& a, TrafficSelectors& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSelectors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSelectors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSelectors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSelectors>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficSelectors& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficSelectors& from) {
    TrafficSelectors::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSelectors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.TrafficSelectors";
  }
  protected:
  explicit TrafficSelectors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSelectors_TrafficSelector TrafficSelector;

  // accessors -------------------------------------------------------

  enum : int {
    kTsFieldNumber = 1,
  };
  // repeated .opi_api.security.v1.TrafficSelectors.TrafficSelector ts = 1;
  int ts_size() const;
  private:
  int _internal_ts_size() const;
  public:
  void clear_ts();
  ::opi_api::security::v1::TrafficSelectors_TrafficSelector* mutable_ts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::TrafficSelectors_TrafficSelector >*
      mutable_ts();
  private:
  const ::opi_api::security::v1::TrafficSelectors_TrafficSelector& _internal_ts(int index) const;
  ::opi_api::security::v1::TrafficSelectors_TrafficSelector* _internal_add_ts();
  public:
  const ::opi_api::security::v1::TrafficSelectors_TrafficSelector& ts(int index) const;
  ::opi_api::security::v1::TrafficSelectors_TrafficSelector* add_ts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::TrafficSelectors_TrafficSelector >&
      ts() const;

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.TrafficSelectors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::TrafficSelectors_TrafficSelector > ts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Addrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Addrs) */ {
 public:
  inline Addrs() : Addrs(nullptr) {}
  ~Addrs() override;
  explicit PROTOBUF_CONSTEXPR Addrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Addrs(const Addrs& from);
  Addrs(Addrs&& from) noexcept
    : Addrs() {
    *this = ::std::move(from);
  }

  inline Addrs& operator=(const Addrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Addrs& operator=(Addrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Addrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Addrs* internal_default_instance() {
    return reinterpret_cast<const Addrs*>(
               &_Addrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Addrs& a, Addrs& b) {
    a.Swap(&b);
  }
  inline void Swap(Addrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Addrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Addrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Addrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Addrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Addrs& from) {
    Addrs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Addrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Addrs";
  }
  protected:
  explicit Addrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Addrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Child final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Child) */ {
 public:
  inline Child() : Child(nullptr) {}
  ~Child() override;
  explicit PROTOBUF_CONSTEXPR Child(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Child(const Child& from);
  Child(Child&& from) noexcept
    : Child() {
    *this = ::std::move(from);
  }

  inline Child& operator=(const Child& from) {
    CopyFrom(from);
    return *this;
  }
  inline Child& operator=(Child&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Child& default_instance() {
    return *internal_default_instance();
  }
  static inline const Child* internal_default_instance() {
    return reinterpret_cast<const Child*>(
               &_Child_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Child& a, Child& b) {
    a.Swap(&b);
  }
  inline void Swap(Child* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Child* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Child* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Child>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Child& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Child& from) {
    Child::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Child* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Child";
  }
  protected:
  explicit Child(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUpdownFieldNumber = 9,
    kMarkInSaFieldNumber = 12,
    kHwOffloadFieldNumber = 16,
    kAgProposalsFieldNumber = 2,
    kEspProposalsFieldNumber = 3,
    kLocalTsFieldNumber = 4,
    kRemoteTsFieldNumber = 5,
    kRekeyTimeFieldNumber = 6,
    kLifeTimeFieldNumber = 7,
    kRandTimeFieldNumber = 8,
    kInactivityFieldNumber = 10,
    kMarkInFieldNumber = 11,
    kMarkOutFieldNumber = 13,
    kSetMarkInFieldNumber = 14,
    kSetMarkOutFieldNumber = 15,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string updown = 9;
  void clear_updown();
  const std::string& updown() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updown(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updown();
  PROTOBUF_NODISCARD std::string* release_updown();
  void set_allocated_updown(std::string* updown);
  private:
  const std::string& _internal_updown() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updown(const std::string& value);
  std::string* _internal_mutable_updown();
  public:

  // string mark_in_sa = 12;
  void clear_mark_in_sa();
  const std::string& mark_in_sa() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mark_in_sa(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mark_in_sa();
  PROTOBUF_NODISCARD std::string* release_mark_in_sa();
  void set_allocated_mark_in_sa(std::string* mark_in_sa);
  private:
  const std::string& _internal_mark_in_sa() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_in_sa(const std::string& value);
  std::string* _internal_mutable_mark_in_sa();
  public:

  // string hw_offload = 16;
  void clear_hw_offload();
  const std::string& hw_offload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hw_offload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hw_offload();
  PROTOBUF_NODISCARD std::string* release_hw_offload();
  void set_allocated_hw_offload(std::string* hw_offload);
  private:
  const std::string& _internal_hw_offload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hw_offload(const std::string& value);
  std::string* _internal_mutable_hw_offload();
  public:

  // .opi_api.security.v1.Proposals ag_proposals = 2;
  bool has_ag_proposals() const;
  private:
  bool _internal_has_ag_proposals() const;
  public:
  void clear_ag_proposals();
  const ::opi_api::security::v1::Proposals& ag_proposals() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Proposals* release_ag_proposals();
  ::opi_api::security::v1::Proposals* mutable_ag_proposals();
  void set_allocated_ag_proposals(::opi_api::security::v1::Proposals* ag_proposals);
  private:
  const ::opi_api::security::v1::Proposals& _internal_ag_proposals() const;
  ::opi_api::security::v1::Proposals* _internal_mutable_ag_proposals();
  public:
  void unsafe_arena_set_allocated_ag_proposals(
      ::opi_api::security::v1::Proposals* ag_proposals);
  ::opi_api::security::v1::Proposals* unsafe_arena_release_ag_proposals();

  // .opi_api.security.v1.Proposals esp_proposals = 3;
  bool has_esp_proposals() const;
  private:
  bool _internal_has_esp_proposals() const;
  public:
  void clear_esp_proposals();
  const ::opi_api::security::v1::Proposals& esp_proposals() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Proposals* release_esp_proposals();
  ::opi_api::security::v1::Proposals* mutable_esp_proposals();
  void set_allocated_esp_proposals(::opi_api::security::v1::Proposals* esp_proposals);
  private:
  const ::opi_api::security::v1::Proposals& _internal_esp_proposals() const;
  ::opi_api::security::v1::Proposals* _internal_mutable_esp_proposals();
  public:
  void unsafe_arena_set_allocated_esp_proposals(
      ::opi_api::security::v1::Proposals* esp_proposals);
  ::opi_api::security::v1::Proposals* unsafe_arena_release_esp_proposals();

  // .opi_api.security.v1.TrafficSelectors local_ts = 4;
  bool has_local_ts() const;
  private:
  bool _internal_has_local_ts() const;
  public:
  void clear_local_ts();
  const ::opi_api::security::v1::TrafficSelectors& local_ts() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::TrafficSelectors* release_local_ts();
  ::opi_api::security::v1::TrafficSelectors* mutable_local_ts();
  void set_allocated_local_ts(::opi_api::security::v1::TrafficSelectors* local_ts);
  private:
  const ::opi_api::security::v1::TrafficSelectors& _internal_local_ts() const;
  ::opi_api::security::v1::TrafficSelectors* _internal_mutable_local_ts();
  public:
  void unsafe_arena_set_allocated_local_ts(
      ::opi_api::security::v1::TrafficSelectors* local_ts);
  ::opi_api::security::v1::TrafficSelectors* unsafe_arena_release_local_ts();

  // .opi_api.security.v1.TrafficSelectors remote_ts = 5;
  bool has_remote_ts() const;
  private:
  bool _internal_has_remote_ts() const;
  public:
  void clear_remote_ts();
  const ::opi_api::security::v1::TrafficSelectors& remote_ts() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::TrafficSelectors* release_remote_ts();
  ::opi_api::security::v1::TrafficSelectors* mutable_remote_ts();
  void set_allocated_remote_ts(::opi_api::security::v1::TrafficSelectors* remote_ts);
  private:
  const ::opi_api::security::v1::TrafficSelectors& _internal_remote_ts() const;
  ::opi_api::security::v1::TrafficSelectors* _internal_mutable_remote_ts();
  public:
  void unsafe_arena_set_allocated_remote_ts(
      ::opi_api::security::v1::TrafficSelectors* remote_ts);
  ::opi_api::security::v1::TrafficSelectors* unsafe_arena_release_remote_ts();

  // uint32 rekey_time = 6;
  void clear_rekey_time();
  uint32_t rekey_time() const;
  void set_rekey_time(uint32_t value);
  private:
  uint32_t _internal_rekey_time() const;
  void _internal_set_rekey_time(uint32_t value);
  public:

  // uint32 life_time = 7;
  void clear_life_time();
  uint32_t life_time() const;
  void set_life_time(uint32_t value);
  private:
  uint32_t _internal_life_time() const;
  void _internal_set_life_time(uint32_t value);
  public:

  // uint32 rand_time = 8;
  void clear_rand_time();
  uint32_t rand_time() const;
  void set_rand_time(uint32_t value);
  private:
  uint32_t _internal_rand_time() const;
  void _internal_set_rand_time(uint32_t value);
  public:

  // uint32 inactivity = 10;
  void clear_inactivity();
  uint32_t inactivity() const;
  void set_inactivity(uint32_t value);
  private:
  uint32_t _internal_inactivity() const;
  void _internal_set_inactivity(uint32_t value);
  public:

  // uint32 mark_in = 11;
  void clear_mark_in();
  uint32_t mark_in() const;
  void set_mark_in(uint32_t value);
  private:
  uint32_t _internal_mark_in() const;
  void _internal_set_mark_in(uint32_t value);
  public:

  // uint32 mark_out = 13;
  void clear_mark_out();
  uint32_t mark_out() const;
  void set_mark_out(uint32_t value);
  private:
  uint32_t _internal_mark_out() const;
  void _internal_set_mark_out(uint32_t value);
  public:

  // uint32 set_mark_in = 14;
  void clear_set_mark_in();
  uint32_t set_mark_in() const;
  void set_set_mark_in(uint32_t value);
  private:
  uint32_t _internal_set_mark_in() const;
  void _internal_set_set_mark_in(uint32_t value);
  public:

  // uint32 set_mark_out = 15;
  void clear_set_mark_out();
  uint32_t set_mark_out() const;
  void set_set_mark_out(uint32_t value);
  private:
  uint32_t _internal_set_mark_out() const;
  void _internal_set_set_mark_out(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Child)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updown_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_in_sa_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hw_offload_;
    ::opi_api::security::v1::Proposals* ag_proposals_;
    ::opi_api::security::v1::Proposals* esp_proposals_;
    ::opi_api::security::v1::TrafficSelectors* local_ts_;
    ::opi_api::security::v1::TrafficSelectors* remote_ts_;
    uint32_t rekey_time_;
    uint32_t life_time_;
    uint32_t rand_time_;
    uint32_t inactivity_;
    uint32_t mark_in_;
    uint32_t mark_out_;
    uint32_t set_mark_in_;
    uint32_t set_mark_out_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class Connection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  ~Connection() override;
  explicit PROTOBUF_CONSTEXPR Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Connection& from) {
    Connection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalAddrsFieldNumber = 3,
    kRemoteAddrsFieldNumber = 4,
    kChildrenFieldNumber = 19,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kEncapFieldNumber = 10,
    kMobikeFieldNumber = 11,
    kProposalsFieldNumber = 7,
    kVipsFieldNumber = 8,
    kPoolsFieldNumber = 16,
    kLocalAuthFieldNumber = 17,
    kRemoteAuthFieldNumber = 18,
    kLocalPortFieldNumber = 5,
    kRemotePortFieldNumber = 6,
    kDscpFieldNumber = 9,
    kDpdDelayFieldNumber = 12,
    kDpdTimeoutFieldNumber = 13,
    kReauthTimeFieldNumber = 14,
    kRekeyTimeFieldNumber = 15,
  };
  // repeated .opi_api.security.v1.Addrs local_addrs = 3;
  int local_addrs_size() const;
  private:
  int _internal_local_addrs_size() const;
  public:
  void clear_local_addrs();
  ::opi_api::security::v1::Addrs* mutable_local_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
      mutable_local_addrs();
  private:
  const ::opi_api::security::v1::Addrs& _internal_local_addrs(int index) const;
  ::opi_api::security::v1::Addrs* _internal_add_local_addrs();
  public:
  const ::opi_api::security::v1::Addrs& local_addrs(int index) const;
  ::opi_api::security::v1::Addrs* add_local_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
      local_addrs() const;

  // repeated .opi_api.security.v1.Addrs remote_addrs = 4;
  int remote_addrs_size() const;
  private:
  int _internal_remote_addrs_size() const;
  public:
  void clear_remote_addrs();
  ::opi_api::security::v1::Addrs* mutable_remote_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
      mutable_remote_addrs();
  private:
  const ::opi_api::security::v1::Addrs& _internal_remote_addrs(int index) const;
  ::opi_api::security::v1::Addrs* _internal_add_remote_addrs();
  public:
  const ::opi_api::security::v1::Addrs& remote_addrs(int index) const;
  ::opi_api::security::v1::Addrs* add_remote_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
      remote_addrs() const;

  // repeated .opi_api.security.v1.Child children = 19;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::opi_api::security::v1::Child* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Child >*
      mutable_children();
  private:
  const ::opi_api::security::v1::Child& _internal_children(int index) const;
  ::opi_api::security::v1::Child* _internal_add_children();
  public:
  const ::opi_api::security::v1::Child& children(int index) const;
  ::opi_api::security::v1::Child* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Child >&
      children() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string encap = 10;
  void clear_encap();
  const std::string& encap() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encap(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encap();
  PROTOBUF_NODISCARD std::string* release_encap();
  void set_allocated_encap(std::string* encap);
  private:
  const std::string& _internal_encap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encap(const std::string& value);
  std::string* _internal_mutable_encap();
  public:

  // string mobike = 11;
  void clear_mobike();
  const std::string& mobike() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mobike(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mobike();
  PROTOBUF_NODISCARD std::string* release_mobike();
  void set_allocated_mobike(std::string* mobike);
  private:
  const std::string& _internal_mobike() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mobike(const std::string& value);
  std::string* _internal_mutable_mobike();
  public:

  // .opi_api.security.v1.Proposals proposals = 7;
  bool has_proposals() const;
  private:
  bool _internal_has_proposals() const;
  public:
  void clear_proposals();
  const ::opi_api::security::v1::Proposals& proposals() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Proposals* release_proposals();
  ::opi_api::security::v1::Proposals* mutable_proposals();
  void set_allocated_proposals(::opi_api::security::v1::Proposals* proposals);
  private:
  const ::opi_api::security::v1::Proposals& _internal_proposals() const;
  ::opi_api::security::v1::Proposals* _internal_mutable_proposals();
  public:
  void unsafe_arena_set_allocated_proposals(
      ::opi_api::security::v1::Proposals* proposals);
  ::opi_api::security::v1::Proposals* unsafe_arena_release_proposals();

  // .opi_api.security.v1.Vips vips = 8;
  bool has_vips() const;
  private:
  bool _internal_has_vips() const;
  public:
  void clear_vips();
  const ::opi_api::security::v1::Vips& vips() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Vips* release_vips();
  ::opi_api::security::v1::Vips* mutable_vips();
  void set_allocated_vips(::opi_api::security::v1::Vips* vips);
  private:
  const ::opi_api::security::v1::Vips& _internal_vips() const;
  ::opi_api::security::v1::Vips* _internal_mutable_vips();
  public:
  void unsafe_arena_set_allocated_vips(
      ::opi_api::security::v1::Vips* vips);
  ::opi_api::security::v1::Vips* unsafe_arena_release_vips();

  // .opi_api.security.v1.Pools pools = 16;
  bool has_pools() const;
  private:
  bool _internal_has_pools() const;
  public:
  void clear_pools();
  const ::opi_api::security::v1::Pools& pools() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Pools* release_pools();
  ::opi_api::security::v1::Pools* mutable_pools();
  void set_allocated_pools(::opi_api::security::v1::Pools* pools);
  private:
  const ::opi_api::security::v1::Pools& _internal_pools() const;
  ::opi_api::security::v1::Pools* _internal_mutable_pools();
  public:
  void unsafe_arena_set_allocated_pools(
      ::opi_api::security::v1::Pools* pools);
  ::opi_api::security::v1::Pools* unsafe_arena_release_pools();

  // .opi_api.security.v1.LocalAuth local_auth = 17;
  bool has_local_auth() const;
  private:
  bool _internal_has_local_auth() const;
  public:
  void clear_local_auth();
  const ::opi_api::security::v1::LocalAuth& local_auth() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::LocalAuth* release_local_auth();
  ::opi_api::security::v1::LocalAuth* mutable_local_auth();
  void set_allocated_local_auth(::opi_api::security::v1::LocalAuth* local_auth);
  private:
  const ::opi_api::security::v1::LocalAuth& _internal_local_auth() const;
  ::opi_api::security::v1::LocalAuth* _internal_mutable_local_auth();
  public:
  void unsafe_arena_set_allocated_local_auth(
      ::opi_api::security::v1::LocalAuth* local_auth);
  ::opi_api::security::v1::LocalAuth* unsafe_arena_release_local_auth();

  // .opi_api.security.v1.RemoteAuth remote_auth = 18;
  bool has_remote_auth() const;
  private:
  bool _internal_has_remote_auth() const;
  public:
  void clear_remote_auth();
  const ::opi_api::security::v1::RemoteAuth& remote_auth() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::RemoteAuth* release_remote_auth();
  ::opi_api::security::v1::RemoteAuth* mutable_remote_auth();
  void set_allocated_remote_auth(::opi_api::security::v1::RemoteAuth* remote_auth);
  private:
  const ::opi_api::security::v1::RemoteAuth& _internal_remote_auth() const;
  ::opi_api::security::v1::RemoteAuth* _internal_mutable_remote_auth();
  public:
  void unsafe_arena_set_allocated_remote_auth(
      ::opi_api::security::v1::RemoteAuth* remote_auth);
  ::opi_api::security::v1::RemoteAuth* unsafe_arena_release_remote_auth();

  // uint32 local_port = 5;
  void clear_local_port();
  uint32_t local_port() const;
  void set_local_port(uint32_t value);
  private:
  uint32_t _internal_local_port() const;
  void _internal_set_local_port(uint32_t value);
  public:

  // uint32 remote_port = 6;
  void clear_remote_port();
  uint32_t remote_port() const;
  void set_remote_port(uint32_t value);
  private:
  uint32_t _internal_remote_port() const;
  void _internal_set_remote_port(uint32_t value);
  public:

  // uint64 dscp = 9;
  void clear_dscp();
  uint64_t dscp() const;
  void set_dscp(uint64_t value);
  private:
  uint64_t _internal_dscp() const;
  void _internal_set_dscp(uint64_t value);
  public:

  // uint32 dpd_delay = 12;
  void clear_dpd_delay();
  uint32_t dpd_delay() const;
  void set_dpd_delay(uint32_t value);
  private:
  uint32_t _internal_dpd_delay() const;
  void _internal_set_dpd_delay(uint32_t value);
  public:

  // uint32 dpd_timeout = 13;
  void clear_dpd_timeout();
  uint32_t dpd_timeout() const;
  void set_dpd_timeout(uint32_t value);
  private:
  uint32_t _internal_dpd_timeout() const;
  void _internal_set_dpd_timeout(uint32_t value);
  public:

  // uint32 reauth_time = 14;
  void clear_reauth_time();
  uint32_t reauth_time() const;
  void set_reauth_time(uint32_t value);
  private:
  uint32_t _internal_reauth_time() const;
  void _internal_set_reauth_time(uint32_t value);
  public:

  // uint32 rekey_time = 15;
  void clear_rekey_time();
  uint32_t rekey_time() const;
  void set_rekey_time(uint32_t value);
  private:
  uint32_t _internal_rekey_time() const;
  void _internal_set_rekey_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs > local_addrs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs > remote_addrs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Child > children_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mobike_;
    ::opi_api::security::v1::Proposals* proposals_;
    ::opi_api::security::v1::Vips* vips_;
    ::opi_api::security::v1::Pools* pools_;
    ::opi_api::security::v1::LocalAuth* local_auth_;
    ::opi_api::security::v1::RemoteAuth* remote_auth_;
    uint32_t local_port_;
    uint32_t remote_port_;
    uint64_t dscp_;
    uint32_t dpd_delay_;
    uint32_t dpd_timeout_;
    uint32_t reauth_time_;
    uint32_t rekey_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecVersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecVersionRequest) */ {
 public:
  inline IPsecVersionRequest() : IPsecVersionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR IPsecVersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecVersionRequest(const IPsecVersionRequest& from);
  IPsecVersionRequest(IPsecVersionRequest&& from) noexcept
    : IPsecVersionRequest() {
    *this = ::std::move(from);
  }

  inline IPsecVersionRequest& operator=(const IPsecVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecVersionRequest& operator=(IPsecVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecVersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecVersionRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecVersionRequest*>(
               &_IPsecVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(IPsecVersionRequest& a, IPsecVersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecVersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecVersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecVersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecVersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IPsecVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IPsecVersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecVersionRequest";
  }
  protected:
  explicit IPsecVersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecVersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecVersionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecVersionResponse) */ {
 public:
  inline IPsecVersionResponse() : IPsecVersionResponse(nullptr) {}
  ~IPsecVersionResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecVersionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecVersionResponse(const IPsecVersionResponse& from);
  IPsecVersionResponse(IPsecVersionResponse&& from) noexcept
    : IPsecVersionResponse() {
    *this = ::std::move(from);
  }

  inline IPsecVersionResponse& operator=(const IPsecVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecVersionResponse& operator=(IPsecVersionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecVersionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecVersionResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecVersionResponse*>(
               &_IPsecVersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(IPsecVersionResponse& a, IPsecVersionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecVersionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecVersionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecVersionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecVersionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecVersionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecVersionResponse& from) {
    IPsecVersionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecVersionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecVersionResponse";
  }
  protected:
  explicit IPsecVersionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDaemonFieldNumber = 1,
    kVersionFieldNumber = 2,
    kSysnameFieldNumber = 3,
    kReleaseFieldNumber = 4,
    kMachineFieldNumber = 5,
  };
  // string daemon = 1;
  void clear_daemon();
  const std::string& daemon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_daemon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_daemon();
  PROTOBUF_NODISCARD std::string* release_daemon();
  void set_allocated_daemon(std::string* daemon);
  private:
  const std::string& _internal_daemon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_daemon(const std::string& value);
  std::string* _internal_mutable_daemon();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string sysname = 3;
  void clear_sysname();
  const std::string& sysname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sysname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sysname();
  PROTOBUF_NODISCARD std::string* release_sysname();
  void set_allocated_sysname(std::string* sysname);
  private:
  const std::string& _internal_sysname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sysname(const std::string& value);
  std::string* _internal_mutable_sysname();
  public:

  // string release = 4;
  void clear_release();
  const std::string& release() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_release(ArgT0&& arg0, ArgT... args);
  std::string* mutable_release();
  PROTOBUF_NODISCARD std::string* release_release();
  void set_allocated_release(std::string* release);
  private:
  const std::string& _internal_release() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release(const std::string& value);
  std::string* _internal_mutable_release();
  public:

  // string machine = 5;
  void clear_machine();
  const std::string& machine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine();
  PROTOBUF_NODISCARD std::string* release_machine();
  void set_allocated_machine(std::string* machine);
  private:
  const std::string& _internal_machine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine(const std::string& value);
  std::string* _internal_mutable_machine();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecVersionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr daemon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sysname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr release_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecStatsRequest) */ {
 public:
  inline IPsecStatsRequest() : IPsecStatsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR IPsecStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecStatsRequest(const IPsecStatsRequest& from);
  IPsecStatsRequest(IPsecStatsRequest&& from) noexcept
    : IPsecStatsRequest() {
    *this = ::std::move(from);
  }

  inline IPsecStatsRequest& operator=(const IPsecStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecStatsRequest& operator=(IPsecStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecStatsRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecStatsRequest*>(
               &_IPsecStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IPsecStatsRequest& a, IPsecStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IPsecStatsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IPsecStatsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecStatsRequest";
  }
  protected:
  explicit IPsecStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecStatsResponse) */ {
 public:
  inline IPsecStatsResponse() : IPsecStatsResponse(nullptr) {}
  ~IPsecStatsResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecStatsResponse(const IPsecStatsResponse& from);
  IPsecStatsResponse(IPsecStatsResponse&& from) noexcept
    : IPsecStatsResponse() {
    *this = ::std::move(from);
  }

  inline IPsecStatsResponse& operator=(const IPsecStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecStatsResponse& operator=(IPsecStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecStatsResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecStatsResponse*>(
               &_IPsecStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IPsecStatsResponse& a, IPsecStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecStatsResponse& from) {
    IPsecStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecStatsResponse";
  }
  protected:
  explicit IPsecStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecInitiateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecInitiateRequest) */ {
 public:
  inline IPsecInitiateRequest() : IPsecInitiateRequest(nullptr) {}
  ~IPsecInitiateRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecInitiateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecInitiateRequest(const IPsecInitiateRequest& from);
  IPsecInitiateRequest(IPsecInitiateRequest&& from) noexcept
    : IPsecInitiateRequest() {
    *this = ::std::move(from);
  }

  inline IPsecInitiateRequest& operator=(const IPsecInitiateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecInitiateRequest& operator=(IPsecInitiateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecInitiateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecInitiateRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecInitiateRequest*>(
               &_IPsecInitiateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IPsecInitiateRequest& a, IPsecInitiateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecInitiateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecInitiateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecInitiateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecInitiateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecInitiateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecInitiateRequest& from) {
    IPsecInitiateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecInitiateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecInitiateRequest";
  }
  protected:
  explicit IPsecInitiateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kIkeFieldNumber = 2,
    kTimeoutFieldNumber = 3,
    kLoglevelFieldNumber = 4,
  };
  // string child = 1;
  void clear_child();
  const std::string& child() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child();
  PROTOBUF_NODISCARD std::string* release_child();
  void set_allocated_child(std::string* child);
  private:
  const std::string& _internal_child() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child(const std::string& value);
  std::string* _internal_mutable_child();
  public:

  // string ike = 2;
  void clear_ike();
  const std::string& ike() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ike(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ike();
  PROTOBUF_NODISCARD std::string* release_ike();
  void set_allocated_ike(std::string* ike);
  private:
  const std::string& _internal_ike() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ike(const std::string& value);
  std::string* _internal_mutable_ike();
  public:

  // string timeout = 3;
  void clear_timeout();
  const std::string& timeout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timeout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timeout();
  PROTOBUF_NODISCARD std::string* release_timeout();
  void set_allocated_timeout(std::string* timeout);
  private:
  const std::string& _internal_timeout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeout(const std::string& value);
  std::string* _internal_mutable_timeout();
  public:

  // string loglevel = 4;
  void clear_loglevel();
  const std::string& loglevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loglevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loglevel();
  PROTOBUF_NODISCARD std::string* release_loglevel();
  void set_allocated_loglevel(std::string* loglevel);
  private:
  const std::string& _internal_loglevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loglevel(const std::string& value);
  std::string* _internal_mutable_loglevel();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecInitiateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ike_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loglevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecInitiateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecInitiateResponse) */ {
 public:
  inline IPsecInitiateResponse() : IPsecInitiateResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR IPsecInitiateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecInitiateResponse(const IPsecInitiateResponse& from);
  IPsecInitiateResponse(IPsecInitiateResponse&& from) noexcept
    : IPsecInitiateResponse() {
    *this = ::std::move(from);
  }

  inline IPsecInitiateResponse& operator=(const IPsecInitiateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecInitiateResponse& operator=(IPsecInitiateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecInitiateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecInitiateResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecInitiateResponse*>(
               &_IPsecInitiateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IPsecInitiateResponse& a, IPsecInitiateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecInitiateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecInitiateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecInitiateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecInitiateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IPsecInitiateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IPsecInitiateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecInitiateResponse";
  }
  protected:
  explicit IPsecInitiateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecInitiateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecTerminateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecTerminateRequest) */ {
 public:
  inline IPsecTerminateRequest() : IPsecTerminateRequest(nullptr) {}
  ~IPsecTerminateRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecTerminateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecTerminateRequest(const IPsecTerminateRequest& from);
  IPsecTerminateRequest(IPsecTerminateRequest&& from) noexcept
    : IPsecTerminateRequest() {
    *this = ::std::move(from);
  }

  inline IPsecTerminateRequest& operator=(const IPsecTerminateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecTerminateRequest& operator=(IPsecTerminateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecTerminateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecTerminateRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecTerminateRequest*>(
               &_IPsecTerminateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IPsecTerminateRequest& a, IPsecTerminateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecTerminateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecTerminateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecTerminateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecTerminateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecTerminateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecTerminateRequest& from) {
    IPsecTerminateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecTerminateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecTerminateRequest";
  }
  protected:
  explicit IPsecTerminateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kIkeFieldNumber = 2,
    kForceFieldNumber = 5,
    kTimeoutFieldNumber = 6,
    kLoglevelFieldNumber = 7,
    kChildIdFieldNumber = 3,
    kIkeIdFieldNumber = 4,
  };
  // string child = 1;
  void clear_child();
  const std::string& child() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child();
  PROTOBUF_NODISCARD std::string* release_child();
  void set_allocated_child(std::string* child);
  private:
  const std::string& _internal_child() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child(const std::string& value);
  std::string* _internal_mutable_child();
  public:

  // string ike = 2;
  void clear_ike();
  const std::string& ike() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ike(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ike();
  PROTOBUF_NODISCARD std::string* release_ike();
  void set_allocated_ike(std::string* ike);
  private:
  const std::string& _internal_ike() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ike(const std::string& value);
  std::string* _internal_mutable_ike();
  public:

  // string force = 5;
  void clear_force();
  const std::string& force() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_force(ArgT0&& arg0, ArgT... args);
  std::string* mutable_force();
  PROTOBUF_NODISCARD std::string* release_force();
  void set_allocated_force(std::string* force);
  private:
  const std::string& _internal_force() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_force(const std::string& value);
  std::string* _internal_mutable_force();
  public:

  // string timeout = 6;
  void clear_timeout();
  const std::string& timeout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timeout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timeout();
  PROTOBUF_NODISCARD std::string* release_timeout();
  void set_allocated_timeout(std::string* timeout);
  private:
  const std::string& _internal_timeout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeout(const std::string& value);
  std::string* _internal_mutable_timeout();
  public:

  // string loglevel = 7;
  void clear_loglevel();
  const std::string& loglevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loglevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loglevel();
  PROTOBUF_NODISCARD std::string* release_loglevel();
  void set_allocated_loglevel(std::string* loglevel);
  private:
  const std::string& _internal_loglevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loglevel(const std::string& value);
  std::string* _internal_mutable_loglevel();
  public:

  // uint64 child_id = 3;
  void clear_child_id();
  uint64_t child_id() const;
  void set_child_id(uint64_t value);
  private:
  uint64_t _internal_child_id() const;
  void _internal_set_child_id(uint64_t value);
  public:

  // uint64 ike_id = 4;
  void clear_ike_id();
  uint64_t ike_id() const;
  void set_ike_id(uint64_t value);
  private:
  uint64_t _internal_ike_id() const;
  void _internal_set_ike_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecTerminateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ike_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr force_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loglevel_;
    uint64_t child_id_;
    uint64_t ike_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecTerminateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecTerminateResponse) */ {
 public:
  inline IPsecTerminateResponse() : IPsecTerminateResponse(nullptr) {}
  ~IPsecTerminateResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecTerminateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecTerminateResponse(const IPsecTerminateResponse& from);
  IPsecTerminateResponse(IPsecTerminateResponse&& from) noexcept
    : IPsecTerminateResponse() {
    *this = ::std::move(from);
  }

  inline IPsecTerminateResponse& operator=(const IPsecTerminateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecTerminateResponse& operator=(IPsecTerminateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecTerminateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecTerminateResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecTerminateResponse*>(
               &_IPsecTerminateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(IPsecTerminateResponse& a, IPsecTerminateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecTerminateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecTerminateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecTerminateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecTerminateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecTerminateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecTerminateResponse& from) {
    IPsecTerminateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecTerminateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecTerminateResponse";
  }
  protected:
  explicit IPsecTerminateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kMatchesFieldNumber = 2,
    kTerminatedFieldNumber = 3,
  };
  // string success = 1;
  void clear_success();
  const std::string& success() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success();
  PROTOBUF_NODISCARD std::string* release_success();
  void set_allocated_success(std::string* success);
  private:
  const std::string& _internal_success() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success(const std::string& value);
  std::string* _internal_mutable_success();
  public:

  // uint32 matches = 2;
  void clear_matches();
  uint32_t matches() const;
  void set_matches(uint32_t value);
  private:
  uint32_t _internal_matches() const;
  void _internal_set_matches(uint32_t value);
  public:

  // uint32 terminated = 3;
  void clear_terminated();
  uint32_t terminated() const;
  void set_terminated(uint32_t value);
  private:
  uint32_t _internal_terminated() const;
  void _internal_set_terminated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecTerminateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_;
    uint32_t matches_;
    uint32_t terminated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecRekeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecRekeyRequest) */ {
 public:
  inline IPsecRekeyRequest() : IPsecRekeyRequest(nullptr) {}
  ~IPsecRekeyRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecRekeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecRekeyRequest(const IPsecRekeyRequest& from);
  IPsecRekeyRequest(IPsecRekeyRequest&& from) noexcept
    : IPsecRekeyRequest() {
    *this = ::std::move(from);
  }

  inline IPsecRekeyRequest& operator=(const IPsecRekeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecRekeyRequest& operator=(IPsecRekeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecRekeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecRekeyRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecRekeyRequest*>(
               &_IPsecRekeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(IPsecRekeyRequest& a, IPsecRekeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecRekeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecRekeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecRekeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecRekeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecRekeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecRekeyRequest& from) {
    IPsecRekeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecRekeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecRekeyRequest";
  }
  protected:
  explicit IPsecRekeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kIkeFieldNumber = 2,
    kReauthFieldNumber = 5,
    kChildIdFieldNumber = 3,
    kIkeIdFieldNumber = 4,
  };
  // string child = 1;
  void clear_child();
  const std::string& child() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child();
  PROTOBUF_NODISCARD std::string* release_child();
  void set_allocated_child(std::string* child);
  private:
  const std::string& _internal_child() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child(const std::string& value);
  std::string* _internal_mutable_child();
  public:

  // string ike = 2;
  void clear_ike();
  const std::string& ike() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ike(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ike();
  PROTOBUF_NODISCARD std::string* release_ike();
  void set_allocated_ike(std::string* ike);
  private:
  const std::string& _internal_ike() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ike(const std::string& value);
  std::string* _internal_mutable_ike();
  public:

  // string reauth = 5;
  void clear_reauth();
  const std::string& reauth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reauth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reauth();
  PROTOBUF_NODISCARD std::string* release_reauth();
  void set_allocated_reauth(std::string* reauth);
  private:
  const std::string& _internal_reauth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reauth(const std::string& value);
  std::string* _internal_mutable_reauth();
  public:

  // uint64 child_id = 3;
  void clear_child_id();
  uint64_t child_id() const;
  void set_child_id(uint64_t value);
  private:
  uint64_t _internal_child_id() const;
  void _internal_set_child_id(uint64_t value);
  public:

  // uint64 ike_id = 4;
  void clear_ike_id();
  uint64_t ike_id() const;
  void set_ike_id(uint64_t value);
  private:
  uint64_t _internal_ike_id() const;
  void _internal_set_ike_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecRekeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ike_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reauth_;
    uint64_t child_id_;
    uint64_t ike_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecRekeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecRekeyResponse) */ {
 public:
  inline IPsecRekeyResponse() : IPsecRekeyResponse(nullptr) {}
  ~IPsecRekeyResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecRekeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecRekeyResponse(const IPsecRekeyResponse& from);
  IPsecRekeyResponse(IPsecRekeyResponse&& from) noexcept
    : IPsecRekeyResponse() {
    *this = ::std::move(from);
  }

  inline IPsecRekeyResponse& operator=(const IPsecRekeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecRekeyResponse& operator=(IPsecRekeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecRekeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecRekeyResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecRekeyResponse*>(
               &_IPsecRekeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(IPsecRekeyResponse& a, IPsecRekeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecRekeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecRekeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecRekeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecRekeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecRekeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecRekeyResponse& from) {
    IPsecRekeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecRekeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecRekeyResponse";
  }
  protected:
  explicit IPsecRekeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kMatchesFieldNumber = 2,
  };
  // string success = 1;
  void clear_success();
  const std::string& success() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success();
  PROTOBUF_NODISCARD std::string* release_success();
  void set_allocated_success(std::string* success);
  private:
  const std::string& _internal_success() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success(const std::string& value);
  std::string* _internal_mutable_success();
  public:

  // uint32 matches = 2;
  void clear_matches();
  uint32_t matches() const;
  void set_matches(uint32_t value);
  private:
  uint32_t _internal_matches() const;
  void _internal_set_matches(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecRekeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_;
    uint32_t matches_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecListSasRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecListSasRequest) */ {
 public:
  inline IPsecListSasRequest() : IPsecListSasRequest(nullptr) {}
  ~IPsecListSasRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecListSasRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecListSasRequest(const IPsecListSasRequest& from);
  IPsecListSasRequest(IPsecListSasRequest&& from) noexcept
    : IPsecListSasRequest() {
    *this = ::std::move(from);
  }

  inline IPsecListSasRequest& operator=(const IPsecListSasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecListSasRequest& operator=(IPsecListSasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecListSasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecListSasRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecListSasRequest*>(
               &_IPsecListSasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(IPsecListSasRequest& a, IPsecListSasRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecListSasRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecListSasRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecListSasRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecListSasRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecListSasRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecListSasRequest& from) {
    IPsecListSasRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecListSasRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecListSasRequest";
  }
  protected:
  explicit IPsecListSasRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoblockFieldNumber = 1,
    kIkeFieldNumber = 2,
    kChildFieldNumber = 4,
    kIkeIdFieldNumber = 3,
    kChildIdFieldNumber = 5,
  };
  // string noblock = 1;
  void clear_noblock();
  const std::string& noblock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_noblock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_noblock();
  PROTOBUF_NODISCARD std::string* release_noblock();
  void set_allocated_noblock(std::string* noblock);
  private:
  const std::string& _internal_noblock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_noblock(const std::string& value);
  std::string* _internal_mutable_noblock();
  public:

  // string ike = 2;
  void clear_ike();
  const std::string& ike() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ike(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ike();
  PROTOBUF_NODISCARD std::string* release_ike();
  void set_allocated_ike(std::string* ike);
  private:
  const std::string& _internal_ike() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ike(const std::string& value);
  std::string* _internal_mutable_ike();
  public:

  // string child = 4;
  void clear_child();
  const std::string& child() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child();
  PROTOBUF_NODISCARD std::string* release_child();
  void set_allocated_child(std::string* child);
  private:
  const std::string& _internal_child() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child(const std::string& value);
  std::string* _internal_mutable_child();
  public:

  // uint64 ike_id = 3;
  void clear_ike_id();
  uint64_t ike_id() const;
  void set_ike_id(uint64_t value);
  private:
  uint64_t _internal_ike_id() const;
  void _internal_set_ike_id(uint64_t value);
  public:

  // uint64 child_id = 5;
  void clear_child_id();
  uint64_t child_id() const;
  void set_child_id(uint64_t value);
  private:
  uint64_t _internal_child_id() const;
  void _internal_set_child_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecListSasRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr noblock_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ike_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_;
    uint64_t ike_id_;
    uint64_t child_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class ListChildSa final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.ListChildSa) */ {
 public:
  inline ListChildSa() : ListChildSa(nullptr) {}
  ~ListChildSa() override;
  explicit PROTOBUF_CONSTEXPR ListChildSa(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListChildSa(const ListChildSa& from);
  ListChildSa(ListChildSa&& from) noexcept
    : ListChildSa() {
    *this = ::std::move(from);
  }

  inline ListChildSa& operator=(const ListChildSa& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListChildSa& operator=(ListChildSa&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListChildSa& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListChildSa* internal_default_instance() {
    return reinterpret_cast<const ListChildSa*>(
               &_ListChildSa_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ListChildSa& a, ListChildSa& b) {
    a.Swap(&b);
  }
  inline void Swap(ListChildSa* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListChildSa* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListChildSa* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListChildSa>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListChildSa& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListChildSa& from) {
    ListChildSa::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListChildSa* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.ListChildSa";
  }
  protected:
  explicit ListChildSa(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kEncapFieldNumber = 3,
    kSpiInFieldNumber = 4,
    kSpiOutFieldNumber = 5,
    kCpiInFieldNumber = 6,
    kCpiOutFieldNumber = 7,
    kMarkInFieldNumber = 8,
    kMarkMaskInFieldNumber = 9,
    kMarkOutFieldNumber = 10,
    kMarkMaskOutFieldNumber = 11,
    kIfIdInFieldNumber = 12,
    kIfIdOutFieldNumber = 13,
    kEncrAlgFieldNumber = 14,
    kEncrKeysizeFieldNumber = 15,
    kIntegAlgFieldNumber = 16,
    kIntegKeysizeFieldNumber = 17,
    kDhGroupFieldNumber = 18,
    kEsnFieldNumber = 19,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string protocol = 2;
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // string encap = 3;
  void clear_encap();
  const std::string& encap() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encap(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encap();
  PROTOBUF_NODISCARD std::string* release_encap();
  void set_allocated_encap(std::string* encap);
  private:
  const std::string& _internal_encap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encap(const std::string& value);
  std::string* _internal_mutable_encap();
  public:

  // string spi_in = 4;
  void clear_spi_in();
  const std::string& spi_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spi_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spi_in();
  PROTOBUF_NODISCARD std::string* release_spi_in();
  void set_allocated_spi_in(std::string* spi_in);
  private:
  const std::string& _internal_spi_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spi_in(const std::string& value);
  std::string* _internal_mutable_spi_in();
  public:

  // string spi_out = 5;
  void clear_spi_out();
  const std::string& spi_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spi_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spi_out();
  PROTOBUF_NODISCARD std::string* release_spi_out();
  void set_allocated_spi_out(std::string* spi_out);
  private:
  const std::string& _internal_spi_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spi_out(const std::string& value);
  std::string* _internal_mutable_spi_out();
  public:

  // string cpi_in = 6;
  void clear_cpi_in();
  const std::string& cpi_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpi_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpi_in();
  PROTOBUF_NODISCARD std::string* release_cpi_in();
  void set_allocated_cpi_in(std::string* cpi_in);
  private:
  const std::string& _internal_cpi_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpi_in(const std::string& value);
  std::string* _internal_mutable_cpi_in();
  public:

  // string cpi_out = 7;
  void clear_cpi_out();
  const std::string& cpi_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpi_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpi_out();
  PROTOBUF_NODISCARD std::string* release_cpi_out();
  void set_allocated_cpi_out(std::string* cpi_out);
  private:
  const std::string& _internal_cpi_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpi_out(const std::string& value);
  std::string* _internal_mutable_cpi_out();
  public:

  // string mark_in = 8;
  void clear_mark_in();
  const std::string& mark_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mark_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mark_in();
  PROTOBUF_NODISCARD std::string* release_mark_in();
  void set_allocated_mark_in(std::string* mark_in);
  private:
  const std::string& _internal_mark_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_in(const std::string& value);
  std::string* _internal_mutable_mark_in();
  public:

  // string mark_mask_in = 9;
  void clear_mark_mask_in();
  const std::string& mark_mask_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mark_mask_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mark_mask_in();
  PROTOBUF_NODISCARD std::string* release_mark_mask_in();
  void set_allocated_mark_mask_in(std::string* mark_mask_in);
  private:
  const std::string& _internal_mark_mask_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_mask_in(const std::string& value);
  std::string* _internal_mutable_mark_mask_in();
  public:

  // string mark_out = 10;
  void clear_mark_out();
  const std::string& mark_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mark_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mark_out();
  PROTOBUF_NODISCARD std::string* release_mark_out();
  void set_allocated_mark_out(std::string* mark_out);
  private:
  const std::string& _internal_mark_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_out(const std::string& value);
  std::string* _internal_mutable_mark_out();
  public:

  // string mark_mask_out = 11;
  void clear_mark_mask_out();
  const std::string& mark_mask_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mark_mask_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mark_mask_out();
  PROTOBUF_NODISCARD std::string* release_mark_mask_out();
  void set_allocated_mark_mask_out(std::string* mark_mask_out);
  private:
  const std::string& _internal_mark_mask_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_mask_out(const std::string& value);
  std::string* _internal_mutable_mark_mask_out();
  public:

  // string if_id_in = 12;
  void clear_if_id_in();
  const std::string& if_id_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_if_id_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_if_id_in();
  PROTOBUF_NODISCARD std::string* release_if_id_in();
  void set_allocated_if_id_in(std::string* if_id_in);
  private:
  const std::string& _internal_if_id_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_if_id_in(const std::string& value);
  std::string* _internal_mutable_if_id_in();
  public:

  // string if_id_out = 13;
  void clear_if_id_out();
  const std::string& if_id_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_if_id_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_if_id_out();
  PROTOBUF_NODISCARD std::string* release_if_id_out();
  void set_allocated_if_id_out(std::string* if_id_out);
  private:
  const std::string& _internal_if_id_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_if_id_out(const std::string& value);
  std::string* _internal_mutable_if_id_out();
  public:

  // string encr_alg = 14;
  void clear_encr_alg();
  const std::string& encr_alg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encr_alg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encr_alg();
  PROTOBUF_NODISCARD std::string* release_encr_alg();
  void set_allocated_encr_alg(std::string* encr_alg);
  private:
  const std::string& _internal_encr_alg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encr_alg(const std::string& value);
  std::string* _internal_mutable_encr_alg();
  public:

  // string encr_keysize = 15;
  void clear_encr_keysize();
  const std::string& encr_keysize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encr_keysize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encr_keysize();
  PROTOBUF_NODISCARD std::string* release_encr_keysize();
  void set_allocated_encr_keysize(std::string* encr_keysize);
  private:
  const std::string& _internal_encr_keysize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encr_keysize(const std::string& value);
  std::string* _internal_mutable_encr_keysize();
  public:

  // string integ_alg = 16;
  void clear_integ_alg();
  const std::string& integ_alg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integ_alg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integ_alg();
  PROTOBUF_NODISCARD std::string* release_integ_alg();
  void set_allocated_integ_alg(std::string* integ_alg);
  private:
  const std::string& _internal_integ_alg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integ_alg(const std::string& value);
  std::string* _internal_mutable_integ_alg();
  public:

  // string integ_keysize = 17;
  void clear_integ_keysize();
  const std::string& integ_keysize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integ_keysize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integ_keysize();
  PROTOBUF_NODISCARD std::string* release_integ_keysize();
  void set_allocated_integ_keysize(std::string* integ_keysize);
  private:
  const std::string& _internal_integ_keysize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integ_keysize(const std::string& value);
  std::string* _internal_mutable_integ_keysize();
  public:

  // string dh_group = 18;
  void clear_dh_group();
  const std::string& dh_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dh_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dh_group();
  PROTOBUF_NODISCARD std::string* release_dh_group();
  void set_allocated_dh_group(std::string* dh_group);
  private:
  const std::string& _internal_dh_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dh_group(const std::string& value);
  std::string* _internal_mutable_dh_group();
  public:

  // string esn = 19;
  void clear_esn();
  const std::string& esn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_esn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_esn();
  PROTOBUF_NODISCARD std::string* release_esn();
  void set_allocated_esn(std::string* esn);
  private:
  const std::string& _internal_esn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_esn(const std::string& value);
  std::string* _internal_mutable_esn();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.ListChildSa)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spi_in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spi_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpi_in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpi_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_mask_in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_mask_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_id_in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_id_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encr_alg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encr_keysize_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integ_alg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integ_keysize_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dh_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr esn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class ListIkeSa final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.ListIkeSa) */ {
 public:
  inline ListIkeSa() : ListIkeSa(nullptr) {}
  ~ListIkeSa() override;
  explicit PROTOBUF_CONSTEXPR ListIkeSa(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIkeSa(const ListIkeSa& from);
  ListIkeSa(ListIkeSa&& from) noexcept
    : ListIkeSa() {
    *this = ::std::move(from);
  }

  inline ListIkeSa& operator=(const ListIkeSa& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIkeSa& operator=(ListIkeSa&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIkeSa& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIkeSa* internal_default_instance() {
    return reinterpret_cast<const ListIkeSa*>(
               &_ListIkeSa_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListIkeSa& a, ListIkeSa& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIkeSa* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIkeSa* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIkeSa* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIkeSa>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIkeSa& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListIkeSa& from) {
    ListIkeSa::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIkeSa* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.ListIkeSa";
  }
  protected:
  explicit ListIkeSa(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalVipsFieldNumber = 32,
    kRemoteVipsFieldNumber = 33,
    kTasksQueuedFieldNumber = 34,
    kTasksActiveFieldNumber = 35,
    kTasksPassiveFieldNumber = 36,
    kChildsasFieldNumber = 37,
    kNameFieldNumber = 1,
    kUniqueidFieldNumber = 2,
    kVersionFieldNumber = 3,
    kLocalHostFieldNumber = 5,
    kLocalPortFieldNumber = 6,
    kLocalIdFieldNumber = 7,
    kRemoteHostFieldNumber = 8,
    kRemotePortFieldNumber = 9,
    kRemoteIdFieldNumber = 10,
    kRemoteXauthIdFieldNumber = 11,
    kRemoteEapIdFieldNumber = 12,
    kInitiatorFieldNumber = 13,
    kInitiatorSpiFieldNumber = 14,
    kResponderSpiFieldNumber = 15,
    kNatLocalFieldNumber = 16,
    kNatRemoteFieldNumber = 17,
    kNatFakeFieldNumber = 18,
    kNatAnyFieldNumber = 19,
    kIfIdInFieldNumber = 20,
    kIfIdOutFieldNumber = 21,
    kEncrAlgFieldNumber = 22,
    kEncrKeysizeFieldNumber = 23,
    kIntegAlgFieldNumber = 24,
    kIntegKeysizeFieldNumber = 25,
    kPrfAlgFieldNumber = 26,
    kDhGroupFieldNumber = 27,
    kPpkFieldNumber = 28,
    kEstablishedFieldNumber = 29,
    kRekeyTimeFieldNumber = 30,
    kReauthTimeFieldNumber = 31,
    kIkestateFieldNumber = 4,
  };
  // repeated string local_vips = 32;
  int local_vips_size() const;
  private:
  int _internal_local_vips_size() const;
  public:
  void clear_local_vips();
  const std::string& local_vips(int index) const;
  std::string* mutable_local_vips(int index);
  void set_local_vips(int index, const std::string& value);
  void set_local_vips(int index, std::string&& value);
  void set_local_vips(int index, const char* value);
  void set_local_vips(int index, const char* value, size_t size);
  std::string* add_local_vips();
  void add_local_vips(const std::string& value);
  void add_local_vips(std::string&& value);
  void add_local_vips(const char* value);
  void add_local_vips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& local_vips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_local_vips();
  private:
  const std::string& _internal_local_vips(int index) const;
  std::string* _internal_add_local_vips();
  public:

  // repeated string remote_vips = 33;
  int remote_vips_size() const;
  private:
  int _internal_remote_vips_size() const;
  public:
  void clear_remote_vips();
  const std::string& remote_vips(int index) const;
  std::string* mutable_remote_vips(int index);
  void set_remote_vips(int index, const std::string& value);
  void set_remote_vips(int index, std::string&& value);
  void set_remote_vips(int index, const char* value);
  void set_remote_vips(int index, const char* value, size_t size);
  std::string* add_remote_vips();
  void add_remote_vips(const std::string& value);
  void add_remote_vips(std::string&& value);
  void add_remote_vips(const char* value);
  void add_remote_vips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& remote_vips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_remote_vips();
  private:
  const std::string& _internal_remote_vips(int index) const;
  std::string* _internal_add_remote_vips();
  public:

  // repeated string tasks_queued = 34;
  int tasks_queued_size() const;
  private:
  int _internal_tasks_queued_size() const;
  public:
  void clear_tasks_queued();
  const std::string& tasks_queued(int index) const;
  std::string* mutable_tasks_queued(int index);
  void set_tasks_queued(int index, const std::string& value);
  void set_tasks_queued(int index, std::string&& value);
  void set_tasks_queued(int index, const char* value);
  void set_tasks_queued(int index, const char* value, size_t size);
  std::string* add_tasks_queued();
  void add_tasks_queued(const std::string& value);
  void add_tasks_queued(std::string&& value);
  void add_tasks_queued(const char* value);
  void add_tasks_queued(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tasks_queued() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tasks_queued();
  private:
  const std::string& _internal_tasks_queued(int index) const;
  std::string* _internal_add_tasks_queued();
  public:

  // repeated string tasks_active = 35;
  int tasks_active_size() const;
  private:
  int _internal_tasks_active_size() const;
  public:
  void clear_tasks_active();
  const std::string& tasks_active(int index) const;
  std::string* mutable_tasks_active(int index);
  void set_tasks_active(int index, const std::string& value);
  void set_tasks_active(int index, std::string&& value);
  void set_tasks_active(int index, const char* value);
  void set_tasks_active(int index, const char* value, size_t size);
  std::string* add_tasks_active();
  void add_tasks_active(const std::string& value);
  void add_tasks_active(std::string&& value);
  void add_tasks_active(const char* value);
  void add_tasks_active(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tasks_active() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tasks_active();
  private:
  const std::string& _internal_tasks_active(int index) const;
  std::string* _internal_add_tasks_active();
  public:

  // repeated string tasks_passive = 36;
  int tasks_passive_size() const;
  private:
  int _internal_tasks_passive_size() const;
  public:
  void clear_tasks_passive();
  const std::string& tasks_passive(int index) const;
  std::string* mutable_tasks_passive(int index);
  void set_tasks_passive(int index, const std::string& value);
  void set_tasks_passive(int index, std::string&& value);
  void set_tasks_passive(int index, const char* value);
  void set_tasks_passive(int index, const char* value, size_t size);
  std::string* add_tasks_passive();
  void add_tasks_passive(const std::string& value);
  void add_tasks_passive(std::string&& value);
  void add_tasks_passive(const char* value);
  void add_tasks_passive(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tasks_passive() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tasks_passive();
  private:
  const std::string& _internal_tasks_passive(int index) const;
  std::string* _internal_add_tasks_passive();
  public:

  // repeated .opi_api.security.v1.ListChildSa childsas = 37;
  int childsas_size() const;
  private:
  int _internal_childsas_size() const;
  public:
  void clear_childsas();
  ::opi_api::security::v1::ListChildSa* mutable_childsas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChildSa >*
      mutable_childsas();
  private:
  const ::opi_api::security::v1::ListChildSa& _internal_childsas(int index) const;
  ::opi_api::security::v1::ListChildSa* _internal_add_childsas();
  public:
  const ::opi_api::security::v1::ListChildSa& childsas(int index) const;
  ::opi_api::security::v1::ListChildSa* add_childsas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChildSa >&
      childsas() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string uniqueid = 2;
  void clear_uniqueid();
  const std::string& uniqueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueid();
  PROTOBUF_NODISCARD std::string* release_uniqueid();
  void set_allocated_uniqueid(std::string* uniqueid);
  private:
  const std::string& _internal_uniqueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueid(const std::string& value);
  std::string* _internal_mutable_uniqueid();
  public:

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string local_host = 5;
  void clear_local_host();
  const std::string& local_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_host();
  PROTOBUF_NODISCARD std::string* release_local_host();
  void set_allocated_local_host(std::string* local_host);
  private:
  const std::string& _internal_local_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_host(const std::string& value);
  std::string* _internal_mutable_local_host();
  public:

  // string local_port = 6;
  void clear_local_port();
  const std::string& local_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_port();
  PROTOBUF_NODISCARD std::string* release_local_port();
  void set_allocated_local_port(std::string* local_port);
  private:
  const std::string& _internal_local_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_port(const std::string& value);
  std::string* _internal_mutable_local_port();
  public:

  // string local_id = 7;
  void clear_local_id();
  const std::string& local_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_id();
  PROTOBUF_NODISCARD std::string* release_local_id();
  void set_allocated_local_id(std::string* local_id);
  private:
  const std::string& _internal_local_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_id(const std::string& value);
  std::string* _internal_mutable_local_id();
  public:

  // string remote_host = 8;
  void clear_remote_host();
  const std::string& remote_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_host();
  PROTOBUF_NODISCARD std::string* release_remote_host();
  void set_allocated_remote_host(std::string* remote_host);
  private:
  const std::string& _internal_remote_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_host(const std::string& value);
  std::string* _internal_mutable_remote_host();
  public:

  // string remote_port = 9;
  void clear_remote_port();
  const std::string& remote_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_port();
  PROTOBUF_NODISCARD std::string* release_remote_port();
  void set_allocated_remote_port(std::string* remote_port);
  private:
  const std::string& _internal_remote_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_port(const std::string& value);
  std::string* _internal_mutable_remote_port();
  public:

  // string remote_id = 10;
  void clear_remote_id();
  const std::string& remote_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_id();
  PROTOBUF_NODISCARD std::string* release_remote_id();
  void set_allocated_remote_id(std::string* remote_id);
  private:
  const std::string& _internal_remote_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_id(const std::string& value);
  std::string* _internal_mutable_remote_id();
  public:

  // string remote_xauth_id = 11;
  void clear_remote_xauth_id();
  const std::string& remote_xauth_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_xauth_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_xauth_id();
  PROTOBUF_NODISCARD std::string* release_remote_xauth_id();
  void set_allocated_remote_xauth_id(std::string* remote_xauth_id);
  private:
  const std::string& _internal_remote_xauth_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_xauth_id(const std::string& value);
  std::string* _internal_mutable_remote_xauth_id();
  public:

  // string remote_eap_id = 12;
  void clear_remote_eap_id();
  const std::string& remote_eap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_eap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_eap_id();
  PROTOBUF_NODISCARD std::string* release_remote_eap_id();
  void set_allocated_remote_eap_id(std::string* remote_eap_id);
  private:
  const std::string& _internal_remote_eap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_eap_id(const std::string& value);
  std::string* _internal_mutable_remote_eap_id();
  public:

  // string initiator = 13;
  void clear_initiator();
  const std::string& initiator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initiator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initiator();
  PROTOBUF_NODISCARD std::string* release_initiator();
  void set_allocated_initiator(std::string* initiator);
  private:
  const std::string& _internal_initiator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiator(const std::string& value);
  std::string* _internal_mutable_initiator();
  public:

  // string initiator_spi = 14;
  void clear_initiator_spi();
  const std::string& initiator_spi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initiator_spi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initiator_spi();
  PROTOBUF_NODISCARD std::string* release_initiator_spi();
  void set_allocated_initiator_spi(std::string* initiator_spi);
  private:
  const std::string& _internal_initiator_spi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiator_spi(const std::string& value);
  std::string* _internal_mutable_initiator_spi();
  public:

  // string responder_spi = 15;
  void clear_responder_spi();
  const std::string& responder_spi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responder_spi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responder_spi();
  PROTOBUF_NODISCARD std::string* release_responder_spi();
  void set_allocated_responder_spi(std::string* responder_spi);
  private:
  const std::string& _internal_responder_spi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responder_spi(const std::string& value);
  std::string* _internal_mutable_responder_spi();
  public:

  // string nat_local = 16;
  void clear_nat_local();
  const std::string& nat_local() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nat_local(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nat_local();
  PROTOBUF_NODISCARD std::string* release_nat_local();
  void set_allocated_nat_local(std::string* nat_local);
  private:
  const std::string& _internal_nat_local() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nat_local(const std::string& value);
  std::string* _internal_mutable_nat_local();
  public:

  // string nat_remote = 17;
  void clear_nat_remote();
  const std::string& nat_remote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nat_remote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nat_remote();
  PROTOBUF_NODISCARD std::string* release_nat_remote();
  void set_allocated_nat_remote(std::string* nat_remote);
  private:
  const std::string& _internal_nat_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nat_remote(const std::string& value);
  std::string* _internal_mutable_nat_remote();
  public:

  // string nat_fake = 18;
  void clear_nat_fake();
  const std::string& nat_fake() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nat_fake(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nat_fake();
  PROTOBUF_NODISCARD std::string* release_nat_fake();
  void set_allocated_nat_fake(std::string* nat_fake);
  private:
  const std::string& _internal_nat_fake() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nat_fake(const std::string& value);
  std::string* _internal_mutable_nat_fake();
  public:

  // string nat_any = 19;
  void clear_nat_any();
  const std::string& nat_any() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nat_any(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nat_any();
  PROTOBUF_NODISCARD std::string* release_nat_any();
  void set_allocated_nat_any(std::string* nat_any);
  private:
  const std::string& _internal_nat_any() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nat_any(const std::string& value);
  std::string* _internal_mutable_nat_any();
  public:

  // string if_id_in = 20;
  void clear_if_id_in();
  const std::string& if_id_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_if_id_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_if_id_in();
  PROTOBUF_NODISCARD std::string* release_if_id_in();
  void set_allocated_if_id_in(std::string* if_id_in);
  private:
  const std::string& _internal_if_id_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_if_id_in(const std::string& value);
  std::string* _internal_mutable_if_id_in();
  public:

  // string if_id_out = 21;
  void clear_if_id_out();
  const std::string& if_id_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_if_id_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_if_id_out();
  PROTOBUF_NODISCARD std::string* release_if_id_out();
  void set_allocated_if_id_out(std::string* if_id_out);
  private:
  const std::string& _internal_if_id_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_if_id_out(const std::string& value);
  std::string* _internal_mutable_if_id_out();
  public:

  // string encr_alg = 22;
  void clear_encr_alg();
  const std::string& encr_alg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encr_alg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encr_alg();
  PROTOBUF_NODISCARD std::string* release_encr_alg();
  void set_allocated_encr_alg(std::string* encr_alg);
  private:
  const std::string& _internal_encr_alg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encr_alg(const std::string& value);
  std::string* _internal_mutable_encr_alg();
  public:

  // string encr_keysize = 23;
  void clear_encr_keysize();
  const std::string& encr_keysize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encr_keysize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encr_keysize();
  PROTOBUF_NODISCARD std::string* release_encr_keysize();
  void set_allocated_encr_keysize(std::string* encr_keysize);
  private:
  const std::string& _internal_encr_keysize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encr_keysize(const std::string& value);
  std::string* _internal_mutable_encr_keysize();
  public:

  // string integ_alg = 24;
  void clear_integ_alg();
  const std::string& integ_alg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integ_alg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integ_alg();
  PROTOBUF_NODISCARD std::string* release_integ_alg();
  void set_allocated_integ_alg(std::string* integ_alg);
  private:
  const std::string& _internal_integ_alg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integ_alg(const std::string& value);
  std::string* _internal_mutable_integ_alg();
  public:

  // string integ_keysize = 25;
  void clear_integ_keysize();
  const std::string& integ_keysize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integ_keysize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integ_keysize();
  PROTOBUF_NODISCARD std::string* release_integ_keysize();
  void set_allocated_integ_keysize(std::string* integ_keysize);
  private:
  const std::string& _internal_integ_keysize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integ_keysize(const std::string& value);
  std::string* _internal_mutable_integ_keysize();
  public:

  // string prf_alg = 26;
  void clear_prf_alg();
  const std::string& prf_alg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prf_alg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prf_alg();
  PROTOBUF_NODISCARD std::string* release_prf_alg();
  void set_allocated_prf_alg(std::string* prf_alg);
  private:
  const std::string& _internal_prf_alg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prf_alg(const std::string& value);
  std::string* _internal_mutable_prf_alg();
  public:

  // string dh_group = 27;
  void clear_dh_group();
  const std::string& dh_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dh_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dh_group();
  PROTOBUF_NODISCARD std::string* release_dh_group();
  void set_allocated_dh_group(std::string* dh_group);
  private:
  const std::string& _internal_dh_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dh_group(const std::string& value);
  std::string* _internal_mutable_dh_group();
  public:

  // string ppk = 28;
  void clear_ppk();
  const std::string& ppk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ppk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ppk();
  PROTOBUF_NODISCARD std::string* release_ppk();
  void set_allocated_ppk(std::string* ppk);
  private:
  const std::string& _internal_ppk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppk(const std::string& value);
  std::string* _internal_mutable_ppk();
  public:

  // string established = 29;
  void clear_established();
  const std::string& established() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_established(ArgT0&& arg0, ArgT... args);
  std::string* mutable_established();
  PROTOBUF_NODISCARD std::string* release_established();
  void set_allocated_established(std::string* established);
  private:
  const std::string& _internal_established() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_established(const std::string& value);
  std::string* _internal_mutable_established();
  public:

  // string rekey_time = 30;
  void clear_rekey_time();
  const std::string& rekey_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rekey_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rekey_time();
  PROTOBUF_NODISCARD std::string* release_rekey_time();
  void set_allocated_rekey_time(std::string* rekey_time);
  private:
  const std::string& _internal_rekey_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rekey_time(const std::string& value);
  std::string* _internal_mutable_rekey_time();
  public:

  // string reauth_time = 31;
  void clear_reauth_time();
  const std::string& reauth_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reauth_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reauth_time();
  PROTOBUF_NODISCARD std::string* release_reauth_time();
  void set_allocated_reauth_time(std::string* reauth_time);
  private:
  const std::string& _internal_reauth_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reauth_time(const std::string& value);
  std::string* _internal_mutable_reauth_time();
  public:

  // .opi_api.security.v1.IkeSaState ikestate = 4;
  void clear_ikestate();
  ::opi_api::security::v1::IkeSaState ikestate() const;
  void set_ikestate(::opi_api::security::v1::IkeSaState value);
  private:
  ::opi_api::security::v1::IkeSaState _internal_ikestate() const;
  void _internal_set_ikestate(::opi_api::security::v1::IkeSaState value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.ListIkeSa)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> local_vips_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> remote_vips_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tasks_queued_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tasks_active_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tasks_passive_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChildSa > childsas_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_xauth_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_eap_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initiator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initiator_spi_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responder_spi_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nat_local_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nat_remote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nat_fake_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nat_any_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_id_in_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr if_id_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encr_alg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encr_keysize_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integ_alg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integ_keysize_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prf_alg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dh_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ppk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr established_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rekey_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reauth_time_;
    int ikestate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecListSasResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecListSasResponse) */ {
 public:
  inline IPsecListSasResponse() : IPsecListSasResponse(nullptr) {}
  ~IPsecListSasResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecListSasResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecListSasResponse(const IPsecListSasResponse& from);
  IPsecListSasResponse(IPsecListSasResponse&& from) noexcept
    : IPsecListSasResponse() {
    *this = ::std::move(from);
  }

  inline IPsecListSasResponse& operator=(const IPsecListSasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecListSasResponse& operator=(IPsecListSasResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecListSasResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecListSasResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecListSasResponse*>(
               &_IPsecListSasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(IPsecListSasResponse& a, IPsecListSasResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecListSasResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecListSasResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecListSasResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecListSasResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecListSasResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecListSasResponse& from) {
    IPsecListSasResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecListSasResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecListSasResponse";
  }
  protected:
  explicit IPsecListSasResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIkesasFieldNumber = 1,
  };
  // repeated .opi_api.security.v1.ListIkeSa ikesas = 1;
  int ikesas_size() const;
  private:
  int _internal_ikesas_size() const;
  public:
  void clear_ikesas();
  ::opi_api::security::v1::ListIkeSa* mutable_ikesas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListIkeSa >*
      mutable_ikesas();
  private:
  const ::opi_api::security::v1::ListIkeSa& _internal_ikesas(int index) const;
  ::opi_api::security::v1::ListIkeSa* _internal_add_ikesas();
  public:
  const ::opi_api::security::v1::ListIkeSa& ikesas(int index) const;
  ::opi_api::security::v1::ListIkeSa* add_ikesas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListIkeSa >&
      ikesas() const;

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecListSasResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListIkeSa > ikesas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecListConnsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecListConnsRequest) */ {
 public:
  inline IPsecListConnsRequest() : IPsecListConnsRequest(nullptr) {}
  ~IPsecListConnsRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecListConnsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecListConnsRequest(const IPsecListConnsRequest& from);
  IPsecListConnsRequest(IPsecListConnsRequest&& from) noexcept
    : IPsecListConnsRequest() {
    *this = ::std::move(from);
  }

  inline IPsecListConnsRequest& operator=(const IPsecListConnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecListConnsRequest& operator=(IPsecListConnsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecListConnsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecListConnsRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecListConnsRequest*>(
               &_IPsecListConnsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(IPsecListConnsRequest& a, IPsecListConnsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecListConnsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecListConnsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecListConnsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecListConnsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecListConnsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecListConnsRequest& from) {
    IPsecListConnsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecListConnsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecListConnsRequest";
  }
  protected:
  explicit IPsecListConnsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIkeFieldNumber = 1,
  };
  // string ike = 1;
  void clear_ike();
  const std::string& ike() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ike(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ike();
  PROTOBUF_NODISCARD std::string* release_ike();
  void set_allocated_ike(std::string* ike);
  private:
  const std::string& _internal_ike() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ike(const std::string& value);
  std::string* _internal_mutable_ike();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecListConnsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ike_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class ListConnAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.ListConnAuth) */ {
 public:
  inline ListConnAuth() : ListConnAuth(nullptr) {}
  ~ListConnAuth() override;
  explicit PROTOBUF_CONSTEXPR ListConnAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListConnAuth(const ListConnAuth& from);
  ListConnAuth(ListConnAuth&& from) noexcept
    : ListConnAuth() {
    *this = ::std::move(from);
  }

  inline ListConnAuth& operator=(const ListConnAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListConnAuth& operator=(ListConnAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListConnAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListConnAuth* internal_default_instance() {
    return reinterpret_cast<const ListConnAuth*>(
               &_ListConnAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ListConnAuth& a, ListConnAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ListConnAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListConnAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListConnAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListConnAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListConnAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListConnAuth& from) {
    ListConnAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListConnAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.ListConnAuth";
  }
  protected:
  explicit ListConnAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
    kEaptypeFieldNumber = 2,
    kEapvendorFieldNumber = 3,
    kXauthFieldNumber = 4,
    kRevocationFieldNumber = 5,
    kIdFieldNumber = 6,
    kCaIdFieldNumber = 7,
    kAaaIdFieldNumber = 8,
    kEapIdFieldNumber = 9,
    kXauthIdFieldNumber = 10,
    kGroupFieldNumber = 11,
    kCertPolicyFieldNumber = 12,
    kCertsFieldNumber = 13,
    kCacertsFieldNumber = 14,
  };
  // string class = 1;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // string eaptype = 2;
  void clear_eaptype();
  const std::string& eaptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eaptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eaptype();
  PROTOBUF_NODISCARD std::string* release_eaptype();
  void set_allocated_eaptype(std::string* eaptype);
  private:
  const std::string& _internal_eaptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eaptype(const std::string& value);
  std::string* _internal_mutable_eaptype();
  public:

  // string eapvendor = 3;
  void clear_eapvendor();
  const std::string& eapvendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eapvendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eapvendor();
  PROTOBUF_NODISCARD std::string* release_eapvendor();
  void set_allocated_eapvendor(std::string* eapvendor);
  private:
  const std::string& _internal_eapvendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eapvendor(const std::string& value);
  std::string* _internal_mutable_eapvendor();
  public:

  // string xauth = 4;
  void clear_xauth();
  const std::string& xauth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xauth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xauth();
  PROTOBUF_NODISCARD std::string* release_xauth();
  void set_allocated_xauth(std::string* xauth);
  private:
  const std::string& _internal_xauth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xauth(const std::string& value);
  std::string* _internal_mutable_xauth();
  public:

  // string revocation = 5;
  void clear_revocation();
  const std::string& revocation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revocation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revocation();
  PROTOBUF_NODISCARD std::string* release_revocation();
  void set_allocated_revocation(std::string* revocation);
  private:
  const std::string& _internal_revocation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revocation(const std::string& value);
  std::string* _internal_mutable_revocation();
  public:

  // string id = 6;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string ca_id = 7;
  void clear_ca_id();
  const std::string& ca_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ca_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ca_id();
  PROTOBUF_NODISCARD std::string* release_ca_id();
  void set_allocated_ca_id(std::string* ca_id);
  private:
  const std::string& _internal_ca_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ca_id(const std::string& value);
  std::string* _internal_mutable_ca_id();
  public:

  // string aaa_id = 8;
  void clear_aaa_id();
  const std::string& aaa_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aaa_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aaa_id();
  PROTOBUF_NODISCARD std::string* release_aaa_id();
  void set_allocated_aaa_id(std::string* aaa_id);
  private:
  const std::string& _internal_aaa_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aaa_id(const std::string& value);
  std::string* _internal_mutable_aaa_id();
  public:

  // string eap_id = 9;
  void clear_eap_id();
  const std::string& eap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eap_id();
  PROTOBUF_NODISCARD std::string* release_eap_id();
  void set_allocated_eap_id(std::string* eap_id);
  private:
  const std::string& _internal_eap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eap_id(const std::string& value);
  std::string* _internal_mutable_eap_id();
  public:

  // string xauth_id = 10;
  void clear_xauth_id();
  const std::string& xauth_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xauth_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xauth_id();
  PROTOBUF_NODISCARD std::string* release_xauth_id();
  void set_allocated_xauth_id(std::string* xauth_id);
  private:
  const std::string& _internal_xauth_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xauth_id(const std::string& value);
  std::string* _internal_mutable_xauth_id();
  public:

  // .opi_api.security.v1.Groups group = 11;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::opi_api::security::v1::Groups& group() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Groups* release_group();
  ::opi_api::security::v1::Groups* mutable_group();
  void set_allocated_group(::opi_api::security::v1::Groups* group);
  private:
  const ::opi_api::security::v1::Groups& _internal_group() const;
  ::opi_api::security::v1::Groups* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::opi_api::security::v1::Groups* group);
  ::opi_api::security::v1::Groups* unsafe_arena_release_group();

  // .opi_api.security.v1.CertPolicy cert_policy = 12;
  bool has_cert_policy() const;
  private:
  bool _internal_has_cert_policy() const;
  public:
  void clear_cert_policy();
  const ::opi_api::security::v1::CertPolicy& cert_policy() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::CertPolicy* release_cert_policy();
  ::opi_api::security::v1::CertPolicy* mutable_cert_policy();
  void set_allocated_cert_policy(::opi_api::security::v1::CertPolicy* cert_policy);
  private:
  const ::opi_api::security::v1::CertPolicy& _internal_cert_policy() const;
  ::opi_api::security::v1::CertPolicy* _internal_mutable_cert_policy();
  public:
  void unsafe_arena_set_allocated_cert_policy(
      ::opi_api::security::v1::CertPolicy* cert_policy);
  ::opi_api::security::v1::CertPolicy* unsafe_arena_release_cert_policy();

  // .opi_api.security.v1.Certs certs = 13;
  bool has_certs() const;
  private:
  bool _internal_has_certs() const;
  public:
  void clear_certs();
  const ::opi_api::security::v1::Certs& certs() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Certs* release_certs();
  ::opi_api::security::v1::Certs* mutable_certs();
  void set_allocated_certs(::opi_api::security::v1::Certs* certs);
  private:
  const ::opi_api::security::v1::Certs& _internal_certs() const;
  ::opi_api::security::v1::Certs* _internal_mutable_certs();
  public:
  void unsafe_arena_set_allocated_certs(
      ::opi_api::security::v1::Certs* certs);
  ::opi_api::security::v1::Certs* unsafe_arena_release_certs();

  // .opi_api.security.v1.CaCerts cacerts = 14;
  bool has_cacerts() const;
  private:
  bool _internal_has_cacerts() const;
  public:
  void clear_cacerts();
  const ::opi_api::security::v1::CaCerts& cacerts() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::CaCerts* release_cacerts();
  ::opi_api::security::v1::CaCerts* mutable_cacerts();
  void set_allocated_cacerts(::opi_api::security::v1::CaCerts* cacerts);
  private:
  const ::opi_api::security::v1::CaCerts& _internal_cacerts() const;
  ::opi_api::security::v1::CaCerts* _internal_mutable_cacerts();
  public:
  void unsafe_arena_set_allocated_cacerts(
      ::opi_api::security::v1::CaCerts* cacerts);
  ::opi_api::security::v1::CaCerts* unsafe_arena_release_cacerts();

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.ListConnAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eaptype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eapvendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xauth_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revocation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ca_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aaa_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eap_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xauth_id_;
    ::opi_api::security::v1::Groups* group_;
    ::opi_api::security::v1::CertPolicy* cert_policy_;
    ::opi_api::security::v1::Certs* certs_;
    ::opi_api::security::v1::CaCerts* cacerts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class ListChild final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.ListChild) */ {
 public:
  inline ListChild() : ListChild(nullptr) {}
  ~ListChild() override;
  explicit PROTOBUF_CONSTEXPR ListChild(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListChild(const ListChild& from);
  ListChild(ListChild&& from) noexcept
    : ListChild() {
    *this = ::std::move(from);
  }

  inline ListChild& operator=(const ListChild& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListChild& operator=(ListChild&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListChild& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListChild* internal_default_instance() {
    return reinterpret_cast<const ListChild*>(
               &_ListChild_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ListChild& a, ListChild& b) {
    a.Swap(&b);
  }
  inline void Swap(ListChild* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListChild* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListChild* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListChild>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListChild& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListChild& from) {
    ListChild::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListChild* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.ListChild";
  }
  protected:
  explicit ListChild(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kModeFieldNumber = 2,
    kLabelFieldNumber = 3,
    kDpdActionFieldNumber = 7,
    kCloseActionFieldNumber = 8,
    kInterfaceFieldNumber = 11,
    kPriorityFieldNumber = 12,
    kLocalTsFieldNumber = 9,
    kRemoteTsFieldNumber = 10,
    kRekeyTimeFieldNumber = 4,
    kRekeyBytesFieldNumber = 5,
    kRekeyPacketsFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mode = 2;
  void clear_mode();
  const std::string& mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // string label = 3;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string dpd_action = 7;
  void clear_dpd_action();
  const std::string& dpd_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dpd_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dpd_action();
  PROTOBUF_NODISCARD std::string* release_dpd_action();
  void set_allocated_dpd_action(std::string* dpd_action);
  private:
  const std::string& _internal_dpd_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dpd_action(const std::string& value);
  std::string* _internal_mutable_dpd_action();
  public:

  // string close_action = 8;
  void clear_close_action();
  const std::string& close_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_close_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_close_action();
  PROTOBUF_NODISCARD std::string* release_close_action();
  void set_allocated_close_action(std::string* close_action);
  private:
  const std::string& _internal_close_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_close_action(const std::string& value);
  std::string* _internal_mutable_close_action();
  public:

  // string interface = 11;
  void clear_interface();
  const std::string& interface() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface();
  PROTOBUF_NODISCARD std::string* release_interface();
  void set_allocated_interface(std::string* interface);
  private:
  const std::string& _internal_interface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface(const std::string& value);
  std::string* _internal_mutable_interface();
  public:

  // string priority = 12;
  void clear_priority();
  const std::string& priority() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_priority(ArgT0&& arg0, ArgT... args);
  std::string* mutable_priority();
  PROTOBUF_NODISCARD std::string* release_priority();
  void set_allocated_priority(std::string* priority);
  private:
  const std::string& _internal_priority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priority(const std::string& value);
  std::string* _internal_mutable_priority();
  public:

  // .opi_api.security.v1.TrafficSelectors local_ts = 9;
  bool has_local_ts() const;
  private:
  bool _internal_has_local_ts() const;
  public:
  void clear_local_ts();
  const ::opi_api::security::v1::TrafficSelectors& local_ts() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::TrafficSelectors* release_local_ts();
  ::opi_api::security::v1::TrafficSelectors* mutable_local_ts();
  void set_allocated_local_ts(::opi_api::security::v1::TrafficSelectors* local_ts);
  private:
  const ::opi_api::security::v1::TrafficSelectors& _internal_local_ts() const;
  ::opi_api::security::v1::TrafficSelectors* _internal_mutable_local_ts();
  public:
  void unsafe_arena_set_allocated_local_ts(
      ::opi_api::security::v1::TrafficSelectors* local_ts);
  ::opi_api::security::v1::TrafficSelectors* unsafe_arena_release_local_ts();

  // .opi_api.security.v1.TrafficSelectors remote_ts = 10;
  bool has_remote_ts() const;
  private:
  bool _internal_has_remote_ts() const;
  public:
  void clear_remote_ts();
  const ::opi_api::security::v1::TrafficSelectors& remote_ts() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::TrafficSelectors* release_remote_ts();
  ::opi_api::security::v1::TrafficSelectors* mutable_remote_ts();
  void set_allocated_remote_ts(::opi_api::security::v1::TrafficSelectors* remote_ts);
  private:
  const ::opi_api::security::v1::TrafficSelectors& _internal_remote_ts() const;
  ::opi_api::security::v1::TrafficSelectors* _internal_mutable_remote_ts();
  public:
  void unsafe_arena_set_allocated_remote_ts(
      ::opi_api::security::v1::TrafficSelectors* remote_ts);
  ::opi_api::security::v1::TrafficSelectors* unsafe_arena_release_remote_ts();

  // uint32 rekey_time = 4;
  void clear_rekey_time();
  uint32_t rekey_time() const;
  void set_rekey_time(uint32_t value);
  private:
  uint32_t _internal_rekey_time() const;
  void _internal_set_rekey_time(uint32_t value);
  public:

  // uint32 rekey_bytes = 5;
  void clear_rekey_bytes();
  uint32_t rekey_bytes() const;
  void set_rekey_bytes(uint32_t value);
  private:
  uint32_t _internal_rekey_bytes() const;
  void _internal_set_rekey_bytes(uint32_t value);
  public:

  // uint32 rekey_packets = 6;
  void clear_rekey_packets();
  uint32_t rekey_packets() const;
  void set_rekey_packets(uint32_t value);
  private:
  uint32_t _internal_rekey_packets() const;
  void _internal_set_rekey_packets(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.ListChild)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dpd_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr close_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr priority_;
    ::opi_api::security::v1::TrafficSelectors* local_ts_;
    ::opi_api::security::v1::TrafficSelectors* remote_ts_;
    uint32_t rekey_time_;
    uint32_t rekey_bytes_;
    uint32_t rekey_packets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class ListConnResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.ListConnResp) */ {
 public:
  inline ListConnResp() : ListConnResp(nullptr) {}
  ~ListConnResp() override;
  explicit PROTOBUF_CONSTEXPR ListConnResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListConnResp(const ListConnResp& from);
  ListConnResp(ListConnResp&& from) noexcept
    : ListConnResp() {
    *this = ::std::move(from);
  }

  inline ListConnResp& operator=(const ListConnResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListConnResp& operator=(ListConnResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListConnResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListConnResp* internal_default_instance() {
    return reinterpret_cast<const ListConnResp*>(
               &_ListConnResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ListConnResp& a, ListConnResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListConnResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListConnResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListConnResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListConnResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListConnResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListConnResp& from) {
    ListConnResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListConnResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.ListConnResp";
  }
  protected:
  explicit ListConnResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalAddrsFieldNumber = 2,
    kRemoteAddrsFieldNumber = 3,
    kLocalAuthFieldNumber = 12,
    kRemoteAuthFieldNumber = 13,
    kChildrenFieldNumber = 14,
    kNameFieldNumber = 1,
    kVersionFieldNumber = 4,
    kUniqueFieldNumber = 7,
    kPpkFieldNumber = 10,
    kPpkRequiredFieldNumber = 11,
    kReauthTimeFieldNumber = 5,
    kRekeyTimeFieldNumber = 6,
    kDpdDelayFieldNumber = 8,
    kDpdTimeoutFieldNumber = 9,
  };
  // repeated .opi_api.security.v1.Addrs local_addrs = 2;
  int local_addrs_size() const;
  private:
  int _internal_local_addrs_size() const;
  public:
  void clear_local_addrs();
  ::opi_api::security::v1::Addrs* mutable_local_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
      mutable_local_addrs();
  private:
  const ::opi_api::security::v1::Addrs& _internal_local_addrs(int index) const;
  ::opi_api::security::v1::Addrs* _internal_add_local_addrs();
  public:
  const ::opi_api::security::v1::Addrs& local_addrs(int index) const;
  ::opi_api::security::v1::Addrs* add_local_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
      local_addrs() const;

  // repeated .opi_api.security.v1.Addrs remote_addrs = 3;
  int remote_addrs_size() const;
  private:
  int _internal_remote_addrs_size() const;
  public:
  void clear_remote_addrs();
  ::opi_api::security::v1::Addrs* mutable_remote_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
      mutable_remote_addrs();
  private:
  const ::opi_api::security::v1::Addrs& _internal_remote_addrs(int index) const;
  ::opi_api::security::v1::Addrs* _internal_add_remote_addrs();
  public:
  const ::opi_api::security::v1::Addrs& remote_addrs(int index) const;
  ::opi_api::security::v1::Addrs* add_remote_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
      remote_addrs() const;

  // repeated .opi_api.security.v1.ListConnAuth local_auth = 12;
  int local_auth_size() const;
  private:
  int _internal_local_auth_size() const;
  public:
  void clear_local_auth();
  ::opi_api::security::v1::ListConnAuth* mutable_local_auth(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >*
      mutable_local_auth();
  private:
  const ::opi_api::security::v1::ListConnAuth& _internal_local_auth(int index) const;
  ::opi_api::security::v1::ListConnAuth* _internal_add_local_auth();
  public:
  const ::opi_api::security::v1::ListConnAuth& local_auth(int index) const;
  ::opi_api::security::v1::ListConnAuth* add_local_auth();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >&
      local_auth() const;

  // repeated .opi_api.security.v1.ListConnAuth remote_auth = 13;
  int remote_auth_size() const;
  private:
  int _internal_remote_auth_size() const;
  public:
  void clear_remote_auth();
  ::opi_api::security::v1::ListConnAuth* mutable_remote_auth(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >*
      mutable_remote_auth();
  private:
  const ::opi_api::security::v1::ListConnAuth& _internal_remote_auth(int index) const;
  ::opi_api::security::v1::ListConnAuth* _internal_add_remote_auth();
  public:
  const ::opi_api::security::v1::ListConnAuth& remote_auth(int index) const;
  ::opi_api::security::v1::ListConnAuth* add_remote_auth();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >&
      remote_auth() const;

  // repeated .opi_api.security.v1.ListChild children = 14;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::opi_api::security::v1::ListChild* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChild >*
      mutable_children();
  private:
  const ::opi_api::security::v1::ListChild& _internal_children(int index) const;
  ::opi_api::security::v1::ListChild* _internal_add_children();
  public:
  const ::opi_api::security::v1::ListChild& children(int index) const;
  ::opi_api::security::v1::ListChild* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChild >&
      children() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 4;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string unique = 7;
  void clear_unique();
  const std::string& unique() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique();
  PROTOBUF_NODISCARD std::string* release_unique();
  void set_allocated_unique(std::string* unique);
  private:
  const std::string& _internal_unique() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique(const std::string& value);
  std::string* _internal_mutable_unique();
  public:

  // string ppk = 10;
  void clear_ppk();
  const std::string& ppk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ppk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ppk();
  PROTOBUF_NODISCARD std::string* release_ppk();
  void set_allocated_ppk(std::string* ppk);
  private:
  const std::string& _internal_ppk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppk(const std::string& value);
  std::string* _internal_mutable_ppk();
  public:

  // string ppk_required = 11;
  void clear_ppk_required();
  const std::string& ppk_required() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ppk_required(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ppk_required();
  PROTOBUF_NODISCARD std::string* release_ppk_required();
  void set_allocated_ppk_required(std::string* ppk_required);
  private:
  const std::string& _internal_ppk_required() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppk_required(const std::string& value);
  std::string* _internal_mutable_ppk_required();
  public:

  // uint32 reauth_time = 5;
  void clear_reauth_time();
  uint32_t reauth_time() const;
  void set_reauth_time(uint32_t value);
  private:
  uint32_t _internal_reauth_time() const;
  void _internal_set_reauth_time(uint32_t value);
  public:

  // uint32 rekey_time = 6;
  void clear_rekey_time();
  uint32_t rekey_time() const;
  void set_rekey_time(uint32_t value);
  private:
  uint32_t _internal_rekey_time() const;
  void _internal_set_rekey_time(uint32_t value);
  public:

  // uint32 dpd_delay = 8;
  void clear_dpd_delay();
  uint32_t dpd_delay() const;
  void set_dpd_delay(uint32_t value);
  private:
  uint32_t _internal_dpd_delay() const;
  void _internal_set_dpd_delay(uint32_t value);
  public:

  // uint32 dpd_timeout = 9;
  void clear_dpd_timeout();
  uint32_t dpd_timeout() const;
  void set_dpd_timeout(uint32_t value);
  private:
  uint32_t _internal_dpd_timeout() const;
  void _internal_set_dpd_timeout(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.ListConnResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs > local_addrs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs > remote_addrs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth > local_auth_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth > remote_auth_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChild > children_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ppk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ppk_required_;
    uint32_t reauth_time_;
    uint32_t rekey_time_;
    uint32_t dpd_delay_;
    uint32_t dpd_timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecListConnsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecListConnsResponse) */ {
 public:
  inline IPsecListConnsResponse() : IPsecListConnsResponse(nullptr) {}
  ~IPsecListConnsResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecListConnsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecListConnsResponse(const IPsecListConnsResponse& from);
  IPsecListConnsResponse(IPsecListConnsResponse&& from) noexcept
    : IPsecListConnsResponse() {
    *this = ::std::move(from);
  }

  inline IPsecListConnsResponse& operator=(const IPsecListConnsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecListConnsResponse& operator=(IPsecListConnsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecListConnsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecListConnsResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecListConnsResponse*>(
               &_IPsecListConnsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(IPsecListConnsResponse& a, IPsecListConnsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecListConnsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecListConnsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecListConnsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecListConnsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecListConnsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecListConnsResponse& from) {
    IPsecListConnsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecListConnsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecListConnsResponse";
  }
  protected:
  explicit IPsecListConnsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionFieldNumber = 1,
  };
  // repeated .opi_api.security.v1.ListConnResp connection = 1;
  int connection_size() const;
  private:
  int _internal_connection_size() const;
  public:
  void clear_connection();
  ::opi_api::security::v1::ListConnResp* mutable_connection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnResp >*
      mutable_connection();
  private:
  const ::opi_api::security::v1::ListConnResp& _internal_connection(int index) const;
  ::opi_api::security::v1::ListConnResp* _internal_add_connection();
  public:
  const ::opi_api::security::v1::ListConnResp& connection(int index) const;
  ::opi_api::security::v1::ListConnResp* add_connection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnResp >&
      connection() const;

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecListConnsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnResp > connection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecListCertsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecListCertsRequest) */ {
 public:
  inline IPsecListCertsRequest() : IPsecListCertsRequest(nullptr) {}
  ~IPsecListCertsRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecListCertsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecListCertsRequest(const IPsecListCertsRequest& from);
  IPsecListCertsRequest(IPsecListCertsRequest&& from) noexcept
    : IPsecListCertsRequest() {
    *this = ::std::move(from);
  }

  inline IPsecListCertsRequest& operator=(const IPsecListCertsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecListCertsRequest& operator=(IPsecListCertsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecListCertsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecListCertsRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecListCertsRequest*>(
               &_IPsecListCertsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(IPsecListCertsRequest& a, IPsecListCertsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecListCertsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecListCertsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecListCertsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecListCertsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecListCertsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecListCertsRequest& from) {
    IPsecListCertsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecListCertsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecListCertsRequest";
  }
  protected:
  explicit IPsecListCertsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kFlagFieldNumber = 2,
    kSubjectFieldNumber = 3,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string flag = 2;
  void clear_flag();
  const std::string& flag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flag();
  PROTOBUF_NODISCARD std::string* release_flag();
  void set_allocated_flag(std::string* flag);
  private:
  const std::string& _internal_flag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flag(const std::string& value);
  std::string* _internal_mutable_flag();
  public:

  // string subject = 3;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecListCertsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class ListCert final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.ListCert) */ {
 public:
  inline ListCert() : ListCert(nullptr) {}
  ~ListCert() override;
  explicit PROTOBUF_CONSTEXPR ListCert(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListCert(const ListCert& from);
  ListCert(ListCert&& from) noexcept
    : ListCert() {
    *this = ::std::move(from);
  }

  inline ListCert& operator=(const ListCert& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCert& operator=(ListCert&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCert& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListCert* internal_default_instance() {
    return reinterpret_cast<const ListCert*>(
               &_ListCert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ListCert& a, ListCert& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCert* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListCert>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListCert& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListCert& from) {
    ListCert::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCert* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.ListCert";
  }
  protected:
  explicit ListCert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasprivkeyFieldNumber = 3,
    kDataFieldNumber = 4,
    kSubjectFieldNumber = 5,
    kNotbeforeFieldNumber = 6,
    kNotafterFieldNumber = 7,
    kTypeFieldNumber = 1,
    kFlagFieldNumber = 2,
  };
  // string hasprivkey = 3;
  void clear_hasprivkey();
  const std::string& hasprivkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hasprivkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hasprivkey();
  PROTOBUF_NODISCARD std::string* release_hasprivkey();
  void set_allocated_hasprivkey(std::string* hasprivkey);
  private:
  const std::string& _internal_hasprivkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hasprivkey(const std::string& value);
  std::string* _internal_mutable_hasprivkey();
  public:

  // string data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string subject = 5;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string notbefore = 6;
  void clear_notbefore();
  const std::string& notbefore() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notbefore(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notbefore();
  PROTOBUF_NODISCARD std::string* release_notbefore();
  void set_allocated_notbefore(std::string* notbefore);
  private:
  const std::string& _internal_notbefore() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notbefore(const std::string& value);
  std::string* _internal_mutable_notbefore();
  public:

  // string notafter = 7;
  void clear_notafter();
  const std::string& notafter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notafter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notafter();
  PROTOBUF_NODISCARD std::string* release_notafter();
  void set_allocated_notafter(std::string* notafter);
  private:
  const std::string& _internal_notafter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notafter(const std::string& value);
  std::string* _internal_mutable_notafter();
  public:

  // .opi_api.security.v1.CertificateType type = 1;
  void clear_type();
  ::opi_api::security::v1::CertificateType type() const;
  void set_type(::opi_api::security::v1::CertificateType value);
  private:
  ::opi_api::security::v1::CertificateType _internal_type() const;
  void _internal_set_type(::opi_api::security::v1::CertificateType value);
  public:

  // .opi_api.security.v1.X509CertificateFlag flag = 2;
  void clear_flag();
  ::opi_api::security::v1::X509CertificateFlag flag() const;
  void set_flag(::opi_api::security::v1::X509CertificateFlag value);
  private:
  ::opi_api::security::v1::X509CertificateFlag _internal_flag() const;
  void _internal_set_flag(::opi_api::security::v1::X509CertificateFlag value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.ListCert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hasprivkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notbefore_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notafter_;
    int type_;
    int flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecListCertsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecListCertsResponse) */ {
 public:
  inline IPsecListCertsResponse() : IPsecListCertsResponse(nullptr) {}
  ~IPsecListCertsResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecListCertsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecListCertsResponse(const IPsecListCertsResponse& from);
  IPsecListCertsResponse(IPsecListCertsResponse&& from) noexcept
    : IPsecListCertsResponse() {
    *this = ::std::move(from);
  }

  inline IPsecListCertsResponse& operator=(const IPsecListCertsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecListCertsResponse& operator=(IPsecListCertsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecListCertsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecListCertsResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecListCertsResponse*>(
               &_IPsecListCertsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(IPsecListCertsResponse& a, IPsecListCertsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecListCertsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecListCertsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecListCertsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecListCertsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecListCertsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecListCertsResponse& from) {
    IPsecListCertsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecListCertsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecListCertsResponse";
  }
  protected:
  explicit IPsecListCertsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertsFieldNumber = 1,
  };
  // repeated .opi_api.security.v1.ListCert certs = 1;
  int certs_size() const;
  private:
  int _internal_certs_size() const;
  public:
  void clear_certs();
  ::opi_api::security::v1::ListCert* mutable_certs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListCert >*
      mutable_certs();
  private:
  const ::opi_api::security::v1::ListCert& _internal_certs(int index) const;
  ::opi_api::security::v1::ListCert* _internal_add_certs();
  public:
  const ::opi_api::security::v1::ListCert& certs(int index) const;
  ::opi_api::security::v1::ListCert* add_certs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListCert >&
      certs() const;

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecListCertsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListCert > certs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecLoadConnRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecLoadConnRequest) */ {
 public:
  inline IPsecLoadConnRequest() : IPsecLoadConnRequest(nullptr) {}
  ~IPsecLoadConnRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecLoadConnRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecLoadConnRequest(const IPsecLoadConnRequest& from);
  IPsecLoadConnRequest(IPsecLoadConnRequest&& from) noexcept
    : IPsecLoadConnRequest() {
    *this = ::std::move(from);
  }

  inline IPsecLoadConnRequest& operator=(const IPsecLoadConnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecLoadConnRequest& operator=(IPsecLoadConnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecLoadConnRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecLoadConnRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecLoadConnRequest*>(
               &_IPsecLoadConnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(IPsecLoadConnRequest& a, IPsecLoadConnRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecLoadConnRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecLoadConnRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecLoadConnRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecLoadConnRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecLoadConnRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecLoadConnRequest& from) {
    IPsecLoadConnRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecLoadConnRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecLoadConnRequest";
  }
  protected:
  explicit IPsecLoadConnRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionFieldNumber = 1,
  };
  // .opi_api.security.v1.Connection connection = 1;
  bool has_connection() const;
  private:
  bool _internal_has_connection() const;
  public:
  void clear_connection();
  const ::opi_api::security::v1::Connection& connection() const;
  PROTOBUF_NODISCARD ::opi_api::security::v1::Connection* release_connection();
  ::opi_api::security::v1::Connection* mutable_connection();
  void set_allocated_connection(::opi_api::security::v1::Connection* connection);
  private:
  const ::opi_api::security::v1::Connection& _internal_connection() const;
  ::opi_api::security::v1::Connection* _internal_mutable_connection();
  public:
  void unsafe_arena_set_allocated_connection(
      ::opi_api::security::v1::Connection* connection);
  ::opi_api::security::v1::Connection* unsafe_arena_release_connection();

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecLoadConnRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::security::v1::Connection* connection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecLoadConnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecLoadConnResponse) */ {
 public:
  inline IPsecLoadConnResponse() : IPsecLoadConnResponse(nullptr) {}
  ~IPsecLoadConnResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecLoadConnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecLoadConnResponse(const IPsecLoadConnResponse& from);
  IPsecLoadConnResponse(IPsecLoadConnResponse&& from) noexcept
    : IPsecLoadConnResponse() {
    *this = ::std::move(from);
  }

  inline IPsecLoadConnResponse& operator=(const IPsecLoadConnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecLoadConnResponse& operator=(IPsecLoadConnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecLoadConnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecLoadConnResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecLoadConnResponse*>(
               &_IPsecLoadConnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(IPsecLoadConnResponse& a, IPsecLoadConnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecLoadConnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecLoadConnResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecLoadConnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecLoadConnResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecLoadConnResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecLoadConnResponse& from) {
    IPsecLoadConnResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecLoadConnResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecLoadConnResponse";
  }
  protected:
  explicit IPsecLoadConnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // string success = 1;
  void clear_success();
  const std::string& success() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success();
  PROTOBUF_NODISCARD std::string* release_success();
  void set_allocated_success(std::string* success);
  private:
  const std::string& _internal_success() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success(const std::string& value);
  std::string* _internal_mutable_success();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecLoadConnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecUnloadConnRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecUnloadConnRequest) */ {
 public:
  inline IPsecUnloadConnRequest() : IPsecUnloadConnRequest(nullptr) {}
  ~IPsecUnloadConnRequest() override;
  explicit PROTOBUF_CONSTEXPR IPsecUnloadConnRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecUnloadConnRequest(const IPsecUnloadConnRequest& from);
  IPsecUnloadConnRequest(IPsecUnloadConnRequest&& from) noexcept
    : IPsecUnloadConnRequest() {
    *this = ::std::move(from);
  }

  inline IPsecUnloadConnRequest& operator=(const IPsecUnloadConnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecUnloadConnRequest& operator=(IPsecUnloadConnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecUnloadConnRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecUnloadConnRequest* internal_default_instance() {
    return reinterpret_cast<const IPsecUnloadConnRequest*>(
               &_IPsecUnloadConnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(IPsecUnloadConnRequest& a, IPsecUnloadConnRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecUnloadConnRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecUnloadConnRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecUnloadConnRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecUnloadConnRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecUnloadConnRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecUnloadConnRequest& from) {
    IPsecUnloadConnRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecUnloadConnRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecUnloadConnRequest";
  }
  protected:
  explicit IPsecUnloadConnRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecUnloadConnRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// -------------------------------------------------------------------

class IPsecUnloadConnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.v1.IPsecUnloadConnResponse) */ {
 public:
  inline IPsecUnloadConnResponse() : IPsecUnloadConnResponse(nullptr) {}
  ~IPsecUnloadConnResponse() override;
  explicit PROTOBUF_CONSTEXPR IPsecUnloadConnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPsecUnloadConnResponse(const IPsecUnloadConnResponse& from);
  IPsecUnloadConnResponse(IPsecUnloadConnResponse&& from) noexcept
    : IPsecUnloadConnResponse() {
    *this = ::std::move(from);
  }

  inline IPsecUnloadConnResponse& operator=(const IPsecUnloadConnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPsecUnloadConnResponse& operator=(IPsecUnloadConnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPsecUnloadConnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPsecUnloadConnResponse* internal_default_instance() {
    return reinterpret_cast<const IPsecUnloadConnResponse*>(
               &_IPsecUnloadConnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(IPsecUnloadConnResponse& a, IPsecUnloadConnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IPsecUnloadConnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPsecUnloadConnResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPsecUnloadConnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPsecUnloadConnResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPsecUnloadConnResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPsecUnloadConnResponse& from) {
    IPsecUnloadConnResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPsecUnloadConnResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.v1.IPsecUnloadConnResponse";
  }
  protected:
  explicit IPsecUnloadConnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // string success = 1;
  void clear_success();
  const std::string& success() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success();
  PROTOBUF_NODISCARD std::string* release_success();
  void set_allocated_success(std::string* success);
  private:
  const std::string& _internal_success() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success(const std::string& value);
  std::string* _internal_mutable_success();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.v1.IPsecUnloadConnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipsec_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Proposals

// repeated .opi_api.security.v1.CryptoAlgorithm crypto_alg = 1;
inline int Proposals::_internal_crypto_alg_size() const {
  return _impl_.crypto_alg_.size();
}
inline int Proposals::crypto_alg_size() const {
  return _internal_crypto_alg_size();
}
inline void Proposals::clear_crypto_alg() {
  _impl_.crypto_alg_.Clear();
}
inline ::opi_api::security::v1::CryptoAlgorithm Proposals::_internal_crypto_alg(int index) const {
  return static_cast< ::opi_api::security::v1::CryptoAlgorithm >(_impl_.crypto_alg_.Get(index));
}
inline ::opi_api::security::v1::CryptoAlgorithm Proposals::crypto_alg(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Proposals.crypto_alg)
  return _internal_crypto_alg(index);
}
inline void Proposals::set_crypto_alg(int index, ::opi_api::security::v1::CryptoAlgorithm value) {
  _impl_.crypto_alg_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Proposals.crypto_alg)
}
inline void Proposals::_internal_add_crypto_alg(::opi_api::security::v1::CryptoAlgorithm value) {
  _impl_.crypto_alg_.Add(value);
}
inline void Proposals::add_crypto_alg(::opi_api::security::v1::CryptoAlgorithm value) {
  _internal_add_crypto_alg(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Proposals.crypto_alg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Proposals::crypto_alg() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Proposals.crypto_alg)
  return _impl_.crypto_alg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::_internal_mutable_crypto_alg() {
  return &_impl_.crypto_alg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::mutable_crypto_alg() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Proposals.crypto_alg)
  return _internal_mutable_crypto_alg();
}

// repeated .opi_api.security.v1.IntegAlgorithm integ_alg = 2;
inline int Proposals::_internal_integ_alg_size() const {
  return _impl_.integ_alg_.size();
}
inline int Proposals::integ_alg_size() const {
  return _internal_integ_alg_size();
}
inline void Proposals::clear_integ_alg() {
  _impl_.integ_alg_.Clear();
}
inline ::opi_api::security::v1::IntegAlgorithm Proposals::_internal_integ_alg(int index) const {
  return static_cast< ::opi_api::security::v1::IntegAlgorithm >(_impl_.integ_alg_.Get(index));
}
inline ::opi_api::security::v1::IntegAlgorithm Proposals::integ_alg(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Proposals.integ_alg)
  return _internal_integ_alg(index);
}
inline void Proposals::set_integ_alg(int index, ::opi_api::security::v1::IntegAlgorithm value) {
  _impl_.integ_alg_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Proposals.integ_alg)
}
inline void Proposals::_internal_add_integ_alg(::opi_api::security::v1::IntegAlgorithm value) {
  _impl_.integ_alg_.Add(value);
}
inline void Proposals::add_integ_alg(::opi_api::security::v1::IntegAlgorithm value) {
  _internal_add_integ_alg(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Proposals.integ_alg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Proposals::integ_alg() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Proposals.integ_alg)
  return _impl_.integ_alg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::_internal_mutable_integ_alg() {
  return &_impl_.integ_alg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::mutable_integ_alg() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Proposals.integ_alg)
  return _internal_mutable_integ_alg();
}

// repeated .opi_api.security.v1.PRFunction prf = 3;
inline int Proposals::_internal_prf_size() const {
  return _impl_.prf_.size();
}
inline int Proposals::prf_size() const {
  return _internal_prf_size();
}
inline void Proposals::clear_prf() {
  _impl_.prf_.Clear();
}
inline ::opi_api::security::v1::PRFunction Proposals::_internal_prf(int index) const {
  return static_cast< ::opi_api::security::v1::PRFunction >(_impl_.prf_.Get(index));
}
inline ::opi_api::security::v1::PRFunction Proposals::prf(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Proposals.prf)
  return _internal_prf(index);
}
inline void Proposals::set_prf(int index, ::opi_api::security::v1::PRFunction value) {
  _impl_.prf_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Proposals.prf)
}
inline void Proposals::_internal_add_prf(::opi_api::security::v1::PRFunction value) {
  _impl_.prf_.Add(value);
}
inline void Proposals::add_prf(::opi_api::security::v1::PRFunction value) {
  _internal_add_prf(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Proposals.prf)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Proposals::prf() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Proposals.prf)
  return _impl_.prf_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::_internal_mutable_prf() {
  return &_impl_.prf_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::mutable_prf() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Proposals.prf)
  return _internal_mutable_prf();
}

// repeated .opi_api.security.v1.DHGroups dhgroups = 4;
inline int Proposals::_internal_dhgroups_size() const {
  return _impl_.dhgroups_.size();
}
inline int Proposals::dhgroups_size() const {
  return _internal_dhgroups_size();
}
inline void Proposals::clear_dhgroups() {
  _impl_.dhgroups_.Clear();
}
inline ::opi_api::security::v1::DHGroups Proposals::_internal_dhgroups(int index) const {
  return static_cast< ::opi_api::security::v1::DHGroups >(_impl_.dhgroups_.Get(index));
}
inline ::opi_api::security::v1::DHGroups Proposals::dhgroups(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Proposals.dhgroups)
  return _internal_dhgroups(index);
}
inline void Proposals::set_dhgroups(int index, ::opi_api::security::v1::DHGroups value) {
  _impl_.dhgroups_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Proposals.dhgroups)
}
inline void Proposals::_internal_add_dhgroups(::opi_api::security::v1::DHGroups value) {
  _impl_.dhgroups_.Add(value);
}
inline void Proposals::add_dhgroups(::opi_api::security::v1::DHGroups value) {
  _internal_add_dhgroups(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Proposals.dhgroups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Proposals::dhgroups() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Proposals.dhgroups)
  return _impl_.dhgroups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::_internal_mutable_dhgroups() {
  return &_impl_.dhgroups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Proposals::mutable_dhgroups() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Proposals.dhgroups)
  return _internal_mutable_dhgroups();
}

// -------------------------------------------------------------------

// Vips

// repeated string vip = 1;
inline int Vips::_internal_vip_size() const {
  return _impl_.vip_.size();
}
inline int Vips::vip_size() const {
  return _internal_vip_size();
}
inline void Vips::clear_vip() {
  _impl_.vip_.Clear();
}
inline std::string* Vips::add_vip() {
  std::string* _s = _internal_add_vip();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.Vips.vip)
  return _s;
}
inline const std::string& Vips::_internal_vip(int index) const {
  return _impl_.vip_.Get(index);
}
inline const std::string& Vips::vip(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Vips.vip)
  return _internal_vip(index);
}
inline std::string* Vips::mutable_vip(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Vips.vip)
  return _impl_.vip_.Mutable(index);
}
inline void Vips::set_vip(int index, const std::string& value) {
  _impl_.vip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Vips.vip)
}
inline void Vips::set_vip(int index, std::string&& value) {
  _impl_.vip_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Vips.vip)
}
inline void Vips::set_vip(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.Vips.vip)
}
inline void Vips::set_vip(int index, const char* value, size_t size) {
  _impl_.vip_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.Vips.vip)
}
inline std::string* Vips::_internal_add_vip() {
  return _impl_.vip_.Add();
}
inline void Vips::add_vip(const std::string& value) {
  _impl_.vip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Vips.vip)
}
inline void Vips::add_vip(std::string&& value) {
  _impl_.vip_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Vips.vip)
}
inline void Vips::add_vip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.Vips.vip)
}
inline void Vips::add_vip(const char* value, size_t size) {
  _impl_.vip_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.Vips.vip)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Vips::vip() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Vips.vip)
  return _impl_.vip_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Vips::mutable_vip() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Vips.vip)
  return &_impl_.vip_;
}

// -------------------------------------------------------------------

// Pools

// repeated string pool = 1;
inline int Pools::_internal_pool_size() const {
  return _impl_.pool_.size();
}
inline int Pools::pool_size() const {
  return _internal_pool_size();
}
inline void Pools::clear_pool() {
  _impl_.pool_.Clear();
}
inline std::string* Pools::add_pool() {
  std::string* _s = _internal_add_pool();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.Pools.pool)
  return _s;
}
inline const std::string& Pools::_internal_pool(int index) const {
  return _impl_.pool_.Get(index);
}
inline const std::string& Pools::pool(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Pools.pool)
  return _internal_pool(index);
}
inline std::string* Pools::mutable_pool(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Pools.pool)
  return _impl_.pool_.Mutable(index);
}
inline void Pools::set_pool(int index, const std::string& value) {
  _impl_.pool_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Pools.pool)
}
inline void Pools::set_pool(int index, std::string&& value) {
  _impl_.pool_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Pools.pool)
}
inline void Pools::set_pool(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pool_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.Pools.pool)
}
inline void Pools::set_pool(int index, const char* value, size_t size) {
  _impl_.pool_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.Pools.pool)
}
inline std::string* Pools::_internal_add_pool() {
  return _impl_.pool_.Add();
}
inline void Pools::add_pool(const std::string& value) {
  _impl_.pool_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Pools.pool)
}
inline void Pools::add_pool(std::string&& value) {
  _impl_.pool_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Pools.pool)
}
inline void Pools::add_pool(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pool_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.Pools.pool)
}
inline void Pools::add_pool(const char* value, size_t size) {
  _impl_.pool_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.Pools.pool)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Pools::pool() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Pools.pool)
  return _impl_.pool_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Pools::mutable_pool() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Pools.pool)
  return &_impl_.pool_;
}

// -------------------------------------------------------------------

// Certs

// repeated string cert = 1;
inline int Certs::_internal_cert_size() const {
  return _impl_.cert_.size();
}
inline int Certs::cert_size() const {
  return _internal_cert_size();
}
inline void Certs::clear_cert() {
  _impl_.cert_.Clear();
}
inline std::string* Certs::add_cert() {
  std::string* _s = _internal_add_cert();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.Certs.cert)
  return _s;
}
inline const std::string& Certs::_internal_cert(int index) const {
  return _impl_.cert_.Get(index);
}
inline const std::string& Certs::cert(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Certs.cert)
  return _internal_cert(index);
}
inline std::string* Certs::mutable_cert(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Certs.cert)
  return _impl_.cert_.Mutable(index);
}
inline void Certs::set_cert(int index, const std::string& value) {
  _impl_.cert_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Certs.cert)
}
inline void Certs::set_cert(int index, std::string&& value) {
  _impl_.cert_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Certs.cert)
}
inline void Certs::set_cert(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cert_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.Certs.cert)
}
inline void Certs::set_cert(int index, const char* value, size_t size) {
  _impl_.cert_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.Certs.cert)
}
inline std::string* Certs::_internal_add_cert() {
  return _impl_.cert_.Add();
}
inline void Certs::add_cert(const std::string& value) {
  _impl_.cert_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Certs.cert)
}
inline void Certs::add_cert(std::string&& value) {
  _impl_.cert_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Certs.cert)
}
inline void Certs::add_cert(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cert_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.Certs.cert)
}
inline void Certs::add_cert(const char* value, size_t size) {
  _impl_.cert_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.Certs.cert)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Certs::cert() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Certs.cert)
  return _impl_.cert_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Certs::mutable_cert() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Certs.cert)
  return &_impl_.cert_;
}

// -------------------------------------------------------------------

// PubKeys

// repeated string pubkey = 1;
inline int PubKeys::_internal_pubkey_size() const {
  return _impl_.pubkey_.size();
}
inline int PubKeys::pubkey_size() const {
  return _internal_pubkey_size();
}
inline void PubKeys::clear_pubkey() {
  _impl_.pubkey_.Clear();
}
inline std::string* PubKeys::add_pubkey() {
  std::string* _s = _internal_add_pubkey();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.PubKeys.pubkey)
  return _s;
}
inline const std::string& PubKeys::_internal_pubkey(int index) const {
  return _impl_.pubkey_.Get(index);
}
inline const std::string& PubKeys::pubkey(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.PubKeys.pubkey)
  return _internal_pubkey(index);
}
inline std::string* PubKeys::mutable_pubkey(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.PubKeys.pubkey)
  return _impl_.pubkey_.Mutable(index);
}
inline void PubKeys::set_pubkey(int index, const std::string& value) {
  _impl_.pubkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.PubKeys.pubkey)
}
inline void PubKeys::set_pubkey(int index, std::string&& value) {
  _impl_.pubkey_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.PubKeys.pubkey)
}
inline void PubKeys::set_pubkey(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pubkey_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.PubKeys.pubkey)
}
inline void PubKeys::set_pubkey(int index, const char* value, size_t size) {
  _impl_.pubkey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.PubKeys.pubkey)
}
inline std::string* PubKeys::_internal_add_pubkey() {
  return _impl_.pubkey_.Add();
}
inline void PubKeys::add_pubkey(const std::string& value) {
  _impl_.pubkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.PubKeys.pubkey)
}
inline void PubKeys::add_pubkey(std::string&& value) {
  _impl_.pubkey_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.PubKeys.pubkey)
}
inline void PubKeys::add_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pubkey_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.PubKeys.pubkey)
}
inline void PubKeys::add_pubkey(const char* value, size_t size) {
  _impl_.pubkey_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.PubKeys.pubkey)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PubKeys::pubkey() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.PubKeys.pubkey)
  return _impl_.pubkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PubKeys::mutable_pubkey() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.PubKeys.pubkey)
  return &_impl_.pubkey_;
}

// -------------------------------------------------------------------

// Groups

// repeated string group = 1;
inline int Groups::_internal_group_size() const {
  return _impl_.group_.size();
}
inline int Groups::group_size() const {
  return _internal_group_size();
}
inline void Groups::clear_group() {
  _impl_.group_.Clear();
}
inline std::string* Groups::add_group() {
  std::string* _s = _internal_add_group();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.Groups.group)
  return _s;
}
inline const std::string& Groups::_internal_group(int index) const {
  return _impl_.group_.Get(index);
}
inline const std::string& Groups::group(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Groups.group)
  return _internal_group(index);
}
inline std::string* Groups::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Groups.group)
  return _impl_.group_.Mutable(index);
}
inline void Groups::set_group(int index, const std::string& value) {
  _impl_.group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Groups.group)
}
inline void Groups::set_group(int index, std::string&& value) {
  _impl_.group_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Groups.group)
}
inline void Groups::set_group(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.Groups.group)
}
inline void Groups::set_group(int index, const char* value, size_t size) {
  _impl_.group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.Groups.group)
}
inline std::string* Groups::_internal_add_group() {
  return _impl_.group_.Add();
}
inline void Groups::add_group(const std::string& value) {
  _impl_.group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Groups.group)
}
inline void Groups::add_group(std::string&& value) {
  _impl_.group_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Groups.group)
}
inline void Groups::add_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.Groups.group)
}
inline void Groups::add_group(const char* value, size_t size) {
  _impl_.group_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.Groups.group)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Groups::group() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Groups.group)
  return _impl_.group_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Groups::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Groups.group)
  return &_impl_.group_;
}

// -------------------------------------------------------------------

// CertPolicy

// repeated string cert_policy = 1;
inline int CertPolicy::_internal_cert_policy_size() const {
  return _impl_.cert_policy_.size();
}
inline int CertPolicy::cert_policy_size() const {
  return _internal_cert_policy_size();
}
inline void CertPolicy::clear_cert_policy() {
  _impl_.cert_policy_.Clear();
}
inline std::string* CertPolicy::add_cert_policy() {
  std::string* _s = _internal_add_cert_policy();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.CertPolicy.cert_policy)
  return _s;
}
inline const std::string& CertPolicy::_internal_cert_policy(int index) const {
  return _impl_.cert_policy_.Get(index);
}
inline const std::string& CertPolicy::cert_policy(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.CertPolicy.cert_policy)
  return _internal_cert_policy(index);
}
inline std::string* CertPolicy::mutable_cert_policy(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.CertPolicy.cert_policy)
  return _impl_.cert_policy_.Mutable(index);
}
inline void CertPolicy::set_cert_policy(int index, const std::string& value) {
  _impl_.cert_policy_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.CertPolicy.cert_policy)
}
inline void CertPolicy::set_cert_policy(int index, std::string&& value) {
  _impl_.cert_policy_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.CertPolicy.cert_policy)
}
inline void CertPolicy::set_cert_policy(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cert_policy_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.CertPolicy.cert_policy)
}
inline void CertPolicy::set_cert_policy(int index, const char* value, size_t size) {
  _impl_.cert_policy_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.CertPolicy.cert_policy)
}
inline std::string* CertPolicy::_internal_add_cert_policy() {
  return _impl_.cert_policy_.Add();
}
inline void CertPolicy::add_cert_policy(const std::string& value) {
  _impl_.cert_policy_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.CertPolicy.cert_policy)
}
inline void CertPolicy::add_cert_policy(std::string&& value) {
  _impl_.cert_policy_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.CertPolicy.cert_policy)
}
inline void CertPolicy::add_cert_policy(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cert_policy_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.CertPolicy.cert_policy)
}
inline void CertPolicy::add_cert_policy(const char* value, size_t size) {
  _impl_.cert_policy_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.CertPolicy.cert_policy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CertPolicy::cert_policy() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.CertPolicy.cert_policy)
  return _impl_.cert_policy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CertPolicy::mutable_cert_policy() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.CertPolicy.cert_policy)
  return &_impl_.cert_policy_;
}

// -------------------------------------------------------------------

// CaCerts

// repeated string cacert = 1;
inline int CaCerts::_internal_cacert_size() const {
  return _impl_.cacert_.size();
}
inline int CaCerts::cacert_size() const {
  return _internal_cacert_size();
}
inline void CaCerts::clear_cacert() {
  _impl_.cacert_.Clear();
}
inline std::string* CaCerts::add_cacert() {
  std::string* _s = _internal_add_cacert();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.CaCerts.cacert)
  return _s;
}
inline const std::string& CaCerts::_internal_cacert(int index) const {
  return _impl_.cacert_.Get(index);
}
inline const std::string& CaCerts::cacert(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.CaCerts.cacert)
  return _internal_cacert(index);
}
inline std::string* CaCerts::mutable_cacert(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.CaCerts.cacert)
  return _impl_.cacert_.Mutable(index);
}
inline void CaCerts::set_cacert(int index, const std::string& value) {
  _impl_.cacert_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.CaCerts.cacert)
}
inline void CaCerts::set_cacert(int index, std::string&& value) {
  _impl_.cacert_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.CaCerts.cacert)
}
inline void CaCerts::set_cacert(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cacert_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.CaCerts.cacert)
}
inline void CaCerts::set_cacert(int index, const char* value, size_t size) {
  _impl_.cacert_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.CaCerts.cacert)
}
inline std::string* CaCerts::_internal_add_cacert() {
  return _impl_.cacert_.Add();
}
inline void CaCerts::add_cacert(const std::string& value) {
  _impl_.cacert_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.CaCerts.cacert)
}
inline void CaCerts::add_cacert(std::string&& value) {
  _impl_.cacert_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.CaCerts.cacert)
}
inline void CaCerts::add_cacert(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cacert_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.CaCerts.cacert)
}
inline void CaCerts::add_cacert(const char* value, size_t size) {
  _impl_.cacert_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.CaCerts.cacert)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CaCerts::cacert() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.CaCerts.cacert)
  return _impl_.cacert_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CaCerts::mutable_cacert() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.CaCerts.cacert)
  return &_impl_.cacert_;
}

// -------------------------------------------------------------------

// LocalAuth

// .opi_api.security.v1.AuthType auth = 1;
inline void LocalAuth::clear_auth() {
  _impl_.auth_ = 0;
}
inline ::opi_api::security::v1::AuthType LocalAuth::_internal_auth() const {
  return static_cast< ::opi_api::security::v1::AuthType >(_impl_.auth_);
}
inline ::opi_api::security::v1::AuthType LocalAuth::auth() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.auth)
  return _internal_auth();
}
inline void LocalAuth::_internal_set_auth(::opi_api::security::v1::AuthType value) {
  
  _impl_.auth_ = value;
}
inline void LocalAuth::set_auth(::opi_api::security::v1::AuthType value) {
  _internal_set_auth(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.LocalAuth.auth)
}

// string id = 2;
inline void LocalAuth::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& LocalAuth::id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalAuth::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.LocalAuth.id)
}
inline std::string* LocalAuth::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.LocalAuth.id)
  return _s;
}
inline const std::string& LocalAuth::_internal_id() const {
  return _impl_.id_.Get();
}
inline void LocalAuth::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalAuth::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalAuth::release_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.LocalAuth.id)
  return _impl_.id_.Release();
}
inline void LocalAuth::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.LocalAuth.id)
}

// string eap_id = 3;
inline void LocalAuth::clear_eap_id() {
  _impl_.eap_id_.ClearToEmpty();
}
inline const std::string& LocalAuth::eap_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.eap_id)
  return _internal_eap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalAuth::set_eap_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.LocalAuth.eap_id)
}
inline std::string* LocalAuth::mutable_eap_id() {
  std::string* _s = _internal_mutable_eap_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.LocalAuth.eap_id)
  return _s;
}
inline const std::string& LocalAuth::_internal_eap_id() const {
  return _impl_.eap_id_.Get();
}
inline void LocalAuth::_internal_set_eap_id(const std::string& value) {
  
  _impl_.eap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalAuth::_internal_mutable_eap_id() {
  
  return _impl_.eap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalAuth::release_eap_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.LocalAuth.eap_id)
  return _impl_.eap_id_.Release();
}
inline void LocalAuth::set_allocated_eap_id(std::string* eap_id) {
  if (eap_id != nullptr) {
    
  } else {
    
  }
  _impl_.eap_id_.SetAllocated(eap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eap_id_.IsDefault()) {
    _impl_.eap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.LocalAuth.eap_id)
}

// string aaa_id = 4;
inline void LocalAuth::clear_aaa_id() {
  _impl_.aaa_id_.ClearToEmpty();
}
inline const std::string& LocalAuth::aaa_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.aaa_id)
  return _internal_aaa_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalAuth::set_aaa_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aaa_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.LocalAuth.aaa_id)
}
inline std::string* LocalAuth::mutable_aaa_id() {
  std::string* _s = _internal_mutable_aaa_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.LocalAuth.aaa_id)
  return _s;
}
inline const std::string& LocalAuth::_internal_aaa_id() const {
  return _impl_.aaa_id_.Get();
}
inline void LocalAuth::_internal_set_aaa_id(const std::string& value) {
  
  _impl_.aaa_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalAuth::_internal_mutable_aaa_id() {
  
  return _impl_.aaa_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalAuth::release_aaa_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.LocalAuth.aaa_id)
  return _impl_.aaa_id_.Release();
}
inline void LocalAuth::set_allocated_aaa_id(std::string* aaa_id) {
  if (aaa_id != nullptr) {
    
  } else {
    
  }
  _impl_.aaa_id_.SetAllocated(aaa_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aaa_id_.IsDefault()) {
    _impl_.aaa_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.LocalAuth.aaa_id)
}

// string xauth_id = 5;
inline void LocalAuth::clear_xauth_id() {
  _impl_.xauth_id_.ClearToEmpty();
}
inline const std::string& LocalAuth::xauth_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.xauth_id)
  return _internal_xauth_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalAuth::set_xauth_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.xauth_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.LocalAuth.xauth_id)
}
inline std::string* LocalAuth::mutable_xauth_id() {
  std::string* _s = _internal_mutable_xauth_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.LocalAuth.xauth_id)
  return _s;
}
inline const std::string& LocalAuth::_internal_xauth_id() const {
  return _impl_.xauth_id_.Get();
}
inline void LocalAuth::_internal_set_xauth_id(const std::string& value) {
  
  _impl_.xauth_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalAuth::_internal_mutable_xauth_id() {
  
  return _impl_.xauth_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalAuth::release_xauth_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.LocalAuth.xauth_id)
  return _impl_.xauth_id_.Release();
}
inline void LocalAuth::set_allocated_xauth_id(std::string* xauth_id) {
  if (xauth_id != nullptr) {
    
  } else {
    
  }
  _impl_.xauth_id_.SetAllocated(xauth_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xauth_id_.IsDefault()) {
    _impl_.xauth_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.LocalAuth.xauth_id)
}

// .opi_api.security.v1.Certs certs = 6;
inline bool LocalAuth::_internal_has_certs() const {
  return this != internal_default_instance() && _impl_.certs_ != nullptr;
}
inline bool LocalAuth::has_certs() const {
  return _internal_has_certs();
}
inline void LocalAuth::clear_certs() {
  if (GetArenaForAllocation() == nullptr && _impl_.certs_ != nullptr) {
    delete _impl_.certs_;
  }
  _impl_.certs_ = nullptr;
}
inline const ::opi_api::security::v1::Certs& LocalAuth::_internal_certs() const {
  const ::opi_api::security::v1::Certs* p = _impl_.certs_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Certs&>(
      ::opi_api::security::v1::_Certs_default_instance_);
}
inline const ::opi_api::security::v1::Certs& LocalAuth::certs() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.certs)
  return _internal_certs();
}
inline void LocalAuth::unsafe_arena_set_allocated_certs(
    ::opi_api::security::v1::Certs* certs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.certs_);
  }
  _impl_.certs_ = certs;
  if (certs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.LocalAuth.certs)
}
inline ::opi_api::security::v1::Certs* LocalAuth::release_certs() {
  
  ::opi_api::security::v1::Certs* temp = _impl_.certs_;
  _impl_.certs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Certs* LocalAuth::unsafe_arena_release_certs() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.LocalAuth.certs)
  
  ::opi_api::security::v1::Certs* temp = _impl_.certs_;
  _impl_.certs_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Certs* LocalAuth::_internal_mutable_certs() {
  
  if (_impl_.certs_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Certs>(GetArenaForAllocation());
    _impl_.certs_ = p;
  }
  return _impl_.certs_;
}
inline ::opi_api::security::v1::Certs* LocalAuth::mutable_certs() {
  ::opi_api::security::v1::Certs* _msg = _internal_mutable_certs();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.LocalAuth.certs)
  return _msg;
}
inline void LocalAuth::set_allocated_certs(::opi_api::security::v1::Certs* certs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.certs_;
  }
  if (certs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(certs);
    if (message_arena != submessage_arena) {
      certs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.certs_ = certs;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.LocalAuth.certs)
}

// .opi_api.security.v1.PubKeys pubkeys = 7;
inline bool LocalAuth::_internal_has_pubkeys() const {
  return this != internal_default_instance() && _impl_.pubkeys_ != nullptr;
}
inline bool LocalAuth::has_pubkeys() const {
  return _internal_has_pubkeys();
}
inline void LocalAuth::clear_pubkeys() {
  if (GetArenaForAllocation() == nullptr && _impl_.pubkeys_ != nullptr) {
    delete _impl_.pubkeys_;
  }
  _impl_.pubkeys_ = nullptr;
}
inline const ::opi_api::security::v1::PubKeys& LocalAuth::_internal_pubkeys() const {
  const ::opi_api::security::v1::PubKeys* p = _impl_.pubkeys_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::PubKeys&>(
      ::opi_api::security::v1::_PubKeys_default_instance_);
}
inline const ::opi_api::security::v1::PubKeys& LocalAuth::pubkeys() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.LocalAuth.pubkeys)
  return _internal_pubkeys();
}
inline void LocalAuth::unsafe_arena_set_allocated_pubkeys(
    ::opi_api::security::v1::PubKeys* pubkeys) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pubkeys_);
  }
  _impl_.pubkeys_ = pubkeys;
  if (pubkeys) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.LocalAuth.pubkeys)
}
inline ::opi_api::security::v1::PubKeys* LocalAuth::release_pubkeys() {
  
  ::opi_api::security::v1::PubKeys* temp = _impl_.pubkeys_;
  _impl_.pubkeys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::PubKeys* LocalAuth::unsafe_arena_release_pubkeys() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.LocalAuth.pubkeys)
  
  ::opi_api::security::v1::PubKeys* temp = _impl_.pubkeys_;
  _impl_.pubkeys_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::PubKeys* LocalAuth::_internal_mutable_pubkeys() {
  
  if (_impl_.pubkeys_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::PubKeys>(GetArenaForAllocation());
    _impl_.pubkeys_ = p;
  }
  return _impl_.pubkeys_;
}
inline ::opi_api::security::v1::PubKeys* LocalAuth::mutable_pubkeys() {
  ::opi_api::security::v1::PubKeys* _msg = _internal_mutable_pubkeys();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.LocalAuth.pubkeys)
  return _msg;
}
inline void LocalAuth::set_allocated_pubkeys(::opi_api::security::v1::PubKeys* pubkeys) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pubkeys_;
  }
  if (pubkeys) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pubkeys);
    if (message_arena != submessage_arena) {
      pubkeys = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pubkeys, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pubkeys_ = pubkeys;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.LocalAuth.pubkeys)
}

// -------------------------------------------------------------------

// RemoteAuth

// .opi_api.security.v1.AuthType auth = 1;
inline void RemoteAuth::clear_auth() {
  _impl_.auth_ = 0;
}
inline ::opi_api::security::v1::AuthType RemoteAuth::_internal_auth() const {
  return static_cast< ::opi_api::security::v1::AuthType >(_impl_.auth_);
}
inline ::opi_api::security::v1::AuthType RemoteAuth::auth() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.auth)
  return _internal_auth();
}
inline void RemoteAuth::_internal_set_auth(::opi_api::security::v1::AuthType value) {
  
  _impl_.auth_ = value;
}
inline void RemoteAuth::set_auth(::opi_api::security::v1::AuthType value) {
  _internal_set_auth(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.RemoteAuth.auth)
}

// string id = 2;
inline void RemoteAuth::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RemoteAuth::id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteAuth::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.RemoteAuth.id)
}
inline std::string* RemoteAuth::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.id)
  return _s;
}
inline const std::string& RemoteAuth::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RemoteAuth::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteAuth::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteAuth::release_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.id)
  return _impl_.id_.Release();
}
inline void RemoteAuth::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.id)
}

// string eap_id = 3;
inline void RemoteAuth::clear_eap_id() {
  _impl_.eap_id_.ClearToEmpty();
}
inline const std::string& RemoteAuth::eap_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.eap_id)
  return _internal_eap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteAuth::set_eap_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.RemoteAuth.eap_id)
}
inline std::string* RemoteAuth::mutable_eap_id() {
  std::string* _s = _internal_mutable_eap_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.eap_id)
  return _s;
}
inline const std::string& RemoteAuth::_internal_eap_id() const {
  return _impl_.eap_id_.Get();
}
inline void RemoteAuth::_internal_set_eap_id(const std::string& value) {
  
  _impl_.eap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteAuth::_internal_mutable_eap_id() {
  
  return _impl_.eap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteAuth::release_eap_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.eap_id)
  return _impl_.eap_id_.Release();
}
inline void RemoteAuth::set_allocated_eap_id(std::string* eap_id) {
  if (eap_id != nullptr) {
    
  } else {
    
  }
  _impl_.eap_id_.SetAllocated(eap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eap_id_.IsDefault()) {
    _impl_.eap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.eap_id)
}

// .opi_api.security.v1.Groups groups = 4;
inline bool RemoteAuth::_internal_has_groups() const {
  return this != internal_default_instance() && _impl_.groups_ != nullptr;
}
inline bool RemoteAuth::has_groups() const {
  return _internal_has_groups();
}
inline void RemoteAuth::clear_groups() {
  if (GetArenaForAllocation() == nullptr && _impl_.groups_ != nullptr) {
    delete _impl_.groups_;
  }
  _impl_.groups_ = nullptr;
}
inline const ::opi_api::security::v1::Groups& RemoteAuth::_internal_groups() const {
  const ::opi_api::security::v1::Groups* p = _impl_.groups_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Groups&>(
      ::opi_api::security::v1::_Groups_default_instance_);
}
inline const ::opi_api::security::v1::Groups& RemoteAuth::groups() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.groups)
  return _internal_groups();
}
inline void RemoteAuth::unsafe_arena_set_allocated_groups(
    ::opi_api::security::v1::Groups* groups) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.groups_);
  }
  _impl_.groups_ = groups;
  if (groups) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.RemoteAuth.groups)
}
inline ::opi_api::security::v1::Groups* RemoteAuth::release_groups() {
  
  ::opi_api::security::v1::Groups* temp = _impl_.groups_;
  _impl_.groups_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Groups* RemoteAuth::unsafe_arena_release_groups() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.groups)
  
  ::opi_api::security::v1::Groups* temp = _impl_.groups_;
  _impl_.groups_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Groups* RemoteAuth::_internal_mutable_groups() {
  
  if (_impl_.groups_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Groups>(GetArenaForAllocation());
    _impl_.groups_ = p;
  }
  return _impl_.groups_;
}
inline ::opi_api::security::v1::Groups* RemoteAuth::mutable_groups() {
  ::opi_api::security::v1::Groups* _msg = _internal_mutable_groups();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.groups)
  return _msg;
}
inline void RemoteAuth::set_allocated_groups(::opi_api::security::v1::Groups* groups) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.groups_;
  }
  if (groups) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(groups);
    if (message_arena != submessage_arena) {
      groups = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, groups, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.groups_ = groups;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.groups)
}

// .opi_api.security.v1.CertPolicy cert_policy = 5;
inline bool RemoteAuth::_internal_has_cert_policy() const {
  return this != internal_default_instance() && _impl_.cert_policy_ != nullptr;
}
inline bool RemoteAuth::has_cert_policy() const {
  return _internal_has_cert_policy();
}
inline void RemoteAuth::clear_cert_policy() {
  if (GetArenaForAllocation() == nullptr && _impl_.cert_policy_ != nullptr) {
    delete _impl_.cert_policy_;
  }
  _impl_.cert_policy_ = nullptr;
}
inline const ::opi_api::security::v1::CertPolicy& RemoteAuth::_internal_cert_policy() const {
  const ::opi_api::security::v1::CertPolicy* p = _impl_.cert_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::CertPolicy&>(
      ::opi_api::security::v1::_CertPolicy_default_instance_);
}
inline const ::opi_api::security::v1::CertPolicy& RemoteAuth::cert_policy() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.cert_policy)
  return _internal_cert_policy();
}
inline void RemoteAuth::unsafe_arena_set_allocated_cert_policy(
    ::opi_api::security::v1::CertPolicy* cert_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cert_policy_);
  }
  _impl_.cert_policy_ = cert_policy;
  if (cert_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.RemoteAuth.cert_policy)
}
inline ::opi_api::security::v1::CertPolicy* RemoteAuth::release_cert_policy() {
  
  ::opi_api::security::v1::CertPolicy* temp = _impl_.cert_policy_;
  _impl_.cert_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::CertPolicy* RemoteAuth::unsafe_arena_release_cert_policy() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.cert_policy)
  
  ::opi_api::security::v1::CertPolicy* temp = _impl_.cert_policy_;
  _impl_.cert_policy_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::CertPolicy* RemoteAuth::_internal_mutable_cert_policy() {
  
  if (_impl_.cert_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::CertPolicy>(GetArenaForAllocation());
    _impl_.cert_policy_ = p;
  }
  return _impl_.cert_policy_;
}
inline ::opi_api::security::v1::CertPolicy* RemoteAuth::mutable_cert_policy() {
  ::opi_api::security::v1::CertPolicy* _msg = _internal_mutable_cert_policy();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.cert_policy)
  return _msg;
}
inline void RemoteAuth::set_allocated_cert_policy(::opi_api::security::v1::CertPolicy* cert_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cert_policy_;
  }
  if (cert_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cert_policy);
    if (message_arena != submessage_arena) {
      cert_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cert_policy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cert_policy_ = cert_policy;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.cert_policy)
}

// .opi_api.security.v1.Certs certs = 6;
inline bool RemoteAuth::_internal_has_certs() const {
  return this != internal_default_instance() && _impl_.certs_ != nullptr;
}
inline bool RemoteAuth::has_certs() const {
  return _internal_has_certs();
}
inline void RemoteAuth::clear_certs() {
  if (GetArenaForAllocation() == nullptr && _impl_.certs_ != nullptr) {
    delete _impl_.certs_;
  }
  _impl_.certs_ = nullptr;
}
inline const ::opi_api::security::v1::Certs& RemoteAuth::_internal_certs() const {
  const ::opi_api::security::v1::Certs* p = _impl_.certs_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Certs&>(
      ::opi_api::security::v1::_Certs_default_instance_);
}
inline const ::opi_api::security::v1::Certs& RemoteAuth::certs() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.certs)
  return _internal_certs();
}
inline void RemoteAuth::unsafe_arena_set_allocated_certs(
    ::opi_api::security::v1::Certs* certs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.certs_);
  }
  _impl_.certs_ = certs;
  if (certs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.RemoteAuth.certs)
}
inline ::opi_api::security::v1::Certs* RemoteAuth::release_certs() {
  
  ::opi_api::security::v1::Certs* temp = _impl_.certs_;
  _impl_.certs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Certs* RemoteAuth::unsafe_arena_release_certs() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.certs)
  
  ::opi_api::security::v1::Certs* temp = _impl_.certs_;
  _impl_.certs_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Certs* RemoteAuth::_internal_mutable_certs() {
  
  if (_impl_.certs_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Certs>(GetArenaForAllocation());
    _impl_.certs_ = p;
  }
  return _impl_.certs_;
}
inline ::opi_api::security::v1::Certs* RemoteAuth::mutable_certs() {
  ::opi_api::security::v1::Certs* _msg = _internal_mutable_certs();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.certs)
  return _msg;
}
inline void RemoteAuth::set_allocated_certs(::opi_api::security::v1::Certs* certs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.certs_;
  }
  if (certs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(certs);
    if (message_arena != submessage_arena) {
      certs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.certs_ = certs;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.certs)
}

// .opi_api.security.v1.CaCerts ca_certs = 7;
inline bool RemoteAuth::_internal_has_ca_certs() const {
  return this != internal_default_instance() && _impl_.ca_certs_ != nullptr;
}
inline bool RemoteAuth::has_ca_certs() const {
  return _internal_has_ca_certs();
}
inline void RemoteAuth::clear_ca_certs() {
  if (GetArenaForAllocation() == nullptr && _impl_.ca_certs_ != nullptr) {
    delete _impl_.ca_certs_;
  }
  _impl_.ca_certs_ = nullptr;
}
inline const ::opi_api::security::v1::CaCerts& RemoteAuth::_internal_ca_certs() const {
  const ::opi_api::security::v1::CaCerts* p = _impl_.ca_certs_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::CaCerts&>(
      ::opi_api::security::v1::_CaCerts_default_instance_);
}
inline const ::opi_api::security::v1::CaCerts& RemoteAuth::ca_certs() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.ca_certs)
  return _internal_ca_certs();
}
inline void RemoteAuth::unsafe_arena_set_allocated_ca_certs(
    ::opi_api::security::v1::CaCerts* ca_certs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ca_certs_);
  }
  _impl_.ca_certs_ = ca_certs;
  if (ca_certs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.RemoteAuth.ca_certs)
}
inline ::opi_api::security::v1::CaCerts* RemoteAuth::release_ca_certs() {
  
  ::opi_api::security::v1::CaCerts* temp = _impl_.ca_certs_;
  _impl_.ca_certs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::CaCerts* RemoteAuth::unsafe_arena_release_ca_certs() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.ca_certs)
  
  ::opi_api::security::v1::CaCerts* temp = _impl_.ca_certs_;
  _impl_.ca_certs_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::CaCerts* RemoteAuth::_internal_mutable_ca_certs() {
  
  if (_impl_.ca_certs_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::CaCerts>(GetArenaForAllocation());
    _impl_.ca_certs_ = p;
  }
  return _impl_.ca_certs_;
}
inline ::opi_api::security::v1::CaCerts* RemoteAuth::mutable_ca_certs() {
  ::opi_api::security::v1::CaCerts* _msg = _internal_mutable_ca_certs();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.ca_certs)
  return _msg;
}
inline void RemoteAuth::set_allocated_ca_certs(::opi_api::security::v1::CaCerts* ca_certs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ca_certs_;
  }
  if (ca_certs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ca_certs);
    if (message_arena != submessage_arena) {
      ca_certs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ca_certs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ca_certs_ = ca_certs;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.ca_certs)
}

// .opi_api.security.v1.PubKeys pubkeys = 8;
inline bool RemoteAuth::_internal_has_pubkeys() const {
  return this != internal_default_instance() && _impl_.pubkeys_ != nullptr;
}
inline bool RemoteAuth::has_pubkeys() const {
  return _internal_has_pubkeys();
}
inline void RemoteAuth::clear_pubkeys() {
  if (GetArenaForAllocation() == nullptr && _impl_.pubkeys_ != nullptr) {
    delete _impl_.pubkeys_;
  }
  _impl_.pubkeys_ = nullptr;
}
inline const ::opi_api::security::v1::PubKeys& RemoteAuth::_internal_pubkeys() const {
  const ::opi_api::security::v1::PubKeys* p = _impl_.pubkeys_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::PubKeys&>(
      ::opi_api::security::v1::_PubKeys_default_instance_);
}
inline const ::opi_api::security::v1::PubKeys& RemoteAuth::pubkeys() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.RemoteAuth.pubkeys)
  return _internal_pubkeys();
}
inline void RemoteAuth::unsafe_arena_set_allocated_pubkeys(
    ::opi_api::security::v1::PubKeys* pubkeys) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pubkeys_);
  }
  _impl_.pubkeys_ = pubkeys;
  if (pubkeys) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.RemoteAuth.pubkeys)
}
inline ::opi_api::security::v1::PubKeys* RemoteAuth::release_pubkeys() {
  
  ::opi_api::security::v1::PubKeys* temp = _impl_.pubkeys_;
  _impl_.pubkeys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::PubKeys* RemoteAuth::unsafe_arena_release_pubkeys() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.RemoteAuth.pubkeys)
  
  ::opi_api::security::v1::PubKeys* temp = _impl_.pubkeys_;
  _impl_.pubkeys_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::PubKeys* RemoteAuth::_internal_mutable_pubkeys() {
  
  if (_impl_.pubkeys_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::PubKeys>(GetArenaForAllocation());
    _impl_.pubkeys_ = p;
  }
  return _impl_.pubkeys_;
}
inline ::opi_api::security::v1::PubKeys* RemoteAuth::mutable_pubkeys() {
  ::opi_api::security::v1::PubKeys* _msg = _internal_mutable_pubkeys();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.RemoteAuth.pubkeys)
  return _msg;
}
inline void RemoteAuth::set_allocated_pubkeys(::opi_api::security::v1::PubKeys* pubkeys) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pubkeys_;
  }
  if (pubkeys) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pubkeys);
    if (message_arena != submessage_arena) {
      pubkeys = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pubkeys, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pubkeys_ = pubkeys;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.RemoteAuth.pubkeys)
}

// -------------------------------------------------------------------

// TrafficSelectors_TrafficSelector

// string cidr = 1;
inline void TrafficSelectors_TrafficSelector::clear_cidr() {
  _impl_.cidr_.ClearToEmpty();
}
inline const std::string& TrafficSelectors_TrafficSelector::cidr() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.TrafficSelectors.TrafficSelector.cidr)
  return _internal_cidr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficSelectors_TrafficSelector::set_cidr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cidr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.TrafficSelectors.TrafficSelector.cidr)
}
inline std::string* TrafficSelectors_TrafficSelector::mutable_cidr() {
  std::string* _s = _internal_mutable_cidr();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.TrafficSelectors.TrafficSelector.cidr)
  return _s;
}
inline const std::string& TrafficSelectors_TrafficSelector::_internal_cidr() const {
  return _impl_.cidr_.Get();
}
inline void TrafficSelectors_TrafficSelector::_internal_set_cidr(const std::string& value) {
  
  _impl_.cidr_.Set(value, GetArenaForAllocation());
}
inline std::string* TrafficSelectors_TrafficSelector::_internal_mutable_cidr() {
  
  return _impl_.cidr_.Mutable(GetArenaForAllocation());
}
inline std::string* TrafficSelectors_TrafficSelector::release_cidr() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.TrafficSelectors.TrafficSelector.cidr)
  return _impl_.cidr_.Release();
}
inline void TrafficSelectors_TrafficSelector::set_allocated_cidr(std::string* cidr) {
  if (cidr != nullptr) {
    
  } else {
    
  }
  _impl_.cidr_.SetAllocated(cidr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cidr_.IsDefault()) {
    _impl_.cidr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.TrafficSelectors.TrafficSelector.cidr)
}

// string proto = 2;
inline void TrafficSelectors_TrafficSelector::clear_proto() {
  _impl_.proto_.ClearToEmpty();
}
inline const std::string& TrafficSelectors_TrafficSelector::proto() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.TrafficSelectors.TrafficSelector.proto)
  return _internal_proto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficSelectors_TrafficSelector::set_proto(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proto_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.TrafficSelectors.TrafficSelector.proto)
}
inline std::string* TrafficSelectors_TrafficSelector::mutable_proto() {
  std::string* _s = _internal_mutable_proto();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.TrafficSelectors.TrafficSelector.proto)
  return _s;
}
inline const std::string& TrafficSelectors_TrafficSelector::_internal_proto() const {
  return _impl_.proto_.Get();
}
inline void TrafficSelectors_TrafficSelector::_internal_set_proto(const std::string& value) {
  
  _impl_.proto_.Set(value, GetArenaForAllocation());
}
inline std::string* TrafficSelectors_TrafficSelector::_internal_mutable_proto() {
  
  return _impl_.proto_.Mutable(GetArenaForAllocation());
}
inline std::string* TrafficSelectors_TrafficSelector::release_proto() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.TrafficSelectors.TrafficSelector.proto)
  return _impl_.proto_.Release();
}
inline void TrafficSelectors_TrafficSelector::set_allocated_proto(std::string* proto) {
  if (proto != nullptr) {
    
  } else {
    
  }
  _impl_.proto_.SetAllocated(proto, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proto_.IsDefault()) {
    _impl_.proto_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.TrafficSelectors.TrafficSelector.proto)
}

// string port = 3;
inline void TrafficSelectors_TrafficSelector::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& TrafficSelectors_TrafficSelector::port() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.TrafficSelectors.TrafficSelector.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficSelectors_TrafficSelector::set_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.TrafficSelectors.TrafficSelector.port)
}
inline std::string* TrafficSelectors_TrafficSelector::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.TrafficSelectors.TrafficSelector.port)
  return _s;
}
inline const std::string& TrafficSelectors_TrafficSelector::_internal_port() const {
  return _impl_.port_.Get();
}
inline void TrafficSelectors_TrafficSelector::_internal_set_port(const std::string& value) {
  
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* TrafficSelectors_TrafficSelector::_internal_mutable_port() {
  
  return _impl_.port_.Mutable(GetArenaForAllocation());
}
inline std::string* TrafficSelectors_TrafficSelector::release_port() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.TrafficSelectors.TrafficSelector.port)
  return _impl_.port_.Release();
}
inline void TrafficSelectors_TrafficSelector::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  _impl_.port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.TrafficSelectors.TrafficSelector.port)
}

// -------------------------------------------------------------------

// TrafficSelectors

// repeated .opi_api.security.v1.TrafficSelectors.TrafficSelector ts = 1;
inline int TrafficSelectors::_internal_ts_size() const {
  return _impl_.ts_.size();
}
inline int TrafficSelectors::ts_size() const {
  return _internal_ts_size();
}
inline void TrafficSelectors::clear_ts() {
  _impl_.ts_.Clear();
}
inline ::opi_api::security::v1::TrafficSelectors_TrafficSelector* TrafficSelectors::mutable_ts(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.TrafficSelectors.ts)
  return _impl_.ts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::TrafficSelectors_TrafficSelector >*
TrafficSelectors::mutable_ts() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.TrafficSelectors.ts)
  return &_impl_.ts_;
}
inline const ::opi_api::security::v1::TrafficSelectors_TrafficSelector& TrafficSelectors::_internal_ts(int index) const {
  return _impl_.ts_.Get(index);
}
inline const ::opi_api::security::v1::TrafficSelectors_TrafficSelector& TrafficSelectors::ts(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.TrafficSelectors.ts)
  return _internal_ts(index);
}
inline ::opi_api::security::v1::TrafficSelectors_TrafficSelector* TrafficSelectors::_internal_add_ts() {
  return _impl_.ts_.Add();
}
inline ::opi_api::security::v1::TrafficSelectors_TrafficSelector* TrafficSelectors::add_ts() {
  ::opi_api::security::v1::TrafficSelectors_TrafficSelector* _add = _internal_add_ts();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.TrafficSelectors.ts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::TrafficSelectors_TrafficSelector >&
TrafficSelectors::ts() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.TrafficSelectors.ts)
  return _impl_.ts_;
}

// -------------------------------------------------------------------

// Addrs

// string addr = 1;
inline void Addrs::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Addrs::addr() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Addrs.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Addrs::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Addrs.addr)
}
inline std::string* Addrs::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Addrs.addr)
  return _s;
}
inline const std::string& Addrs::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void Addrs::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Addrs::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* Addrs::release_addr() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Addrs.addr)
  return _impl_.addr_.Release();
}
inline void Addrs::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Addrs.addr)
}

// -------------------------------------------------------------------

// Child

// string name = 1;
inline void Child::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Child::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Child::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.name)
}
inline std::string* Child::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.name)
  return _s;
}
inline const std::string& Child::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Child::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Child::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Child::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.name)
  return _impl_.name_.Release();
}
inline void Child::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.name)
}

// .opi_api.security.v1.Proposals ag_proposals = 2;
inline bool Child::_internal_has_ag_proposals() const {
  return this != internal_default_instance() && _impl_.ag_proposals_ != nullptr;
}
inline bool Child::has_ag_proposals() const {
  return _internal_has_ag_proposals();
}
inline void Child::clear_ag_proposals() {
  if (GetArenaForAllocation() == nullptr && _impl_.ag_proposals_ != nullptr) {
    delete _impl_.ag_proposals_;
  }
  _impl_.ag_proposals_ = nullptr;
}
inline const ::opi_api::security::v1::Proposals& Child::_internal_ag_proposals() const {
  const ::opi_api::security::v1::Proposals* p = _impl_.ag_proposals_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Proposals&>(
      ::opi_api::security::v1::_Proposals_default_instance_);
}
inline const ::opi_api::security::v1::Proposals& Child::ag_proposals() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.ag_proposals)
  return _internal_ag_proposals();
}
inline void Child::unsafe_arena_set_allocated_ag_proposals(
    ::opi_api::security::v1::Proposals* ag_proposals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ag_proposals_);
  }
  _impl_.ag_proposals_ = ag_proposals;
  if (ag_proposals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Child.ag_proposals)
}
inline ::opi_api::security::v1::Proposals* Child::release_ag_proposals() {
  
  ::opi_api::security::v1::Proposals* temp = _impl_.ag_proposals_;
  _impl_.ag_proposals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Proposals* Child::unsafe_arena_release_ag_proposals() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.ag_proposals)
  
  ::opi_api::security::v1::Proposals* temp = _impl_.ag_proposals_;
  _impl_.ag_proposals_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Proposals* Child::_internal_mutable_ag_proposals() {
  
  if (_impl_.ag_proposals_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Proposals>(GetArenaForAllocation());
    _impl_.ag_proposals_ = p;
  }
  return _impl_.ag_proposals_;
}
inline ::opi_api::security::v1::Proposals* Child::mutable_ag_proposals() {
  ::opi_api::security::v1::Proposals* _msg = _internal_mutable_ag_proposals();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.ag_proposals)
  return _msg;
}
inline void Child::set_allocated_ag_proposals(::opi_api::security::v1::Proposals* ag_proposals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ag_proposals_;
  }
  if (ag_proposals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ag_proposals);
    if (message_arena != submessage_arena) {
      ag_proposals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ag_proposals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ag_proposals_ = ag_proposals;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.ag_proposals)
}

// .opi_api.security.v1.Proposals esp_proposals = 3;
inline bool Child::_internal_has_esp_proposals() const {
  return this != internal_default_instance() && _impl_.esp_proposals_ != nullptr;
}
inline bool Child::has_esp_proposals() const {
  return _internal_has_esp_proposals();
}
inline void Child::clear_esp_proposals() {
  if (GetArenaForAllocation() == nullptr && _impl_.esp_proposals_ != nullptr) {
    delete _impl_.esp_proposals_;
  }
  _impl_.esp_proposals_ = nullptr;
}
inline const ::opi_api::security::v1::Proposals& Child::_internal_esp_proposals() const {
  const ::opi_api::security::v1::Proposals* p = _impl_.esp_proposals_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Proposals&>(
      ::opi_api::security::v1::_Proposals_default_instance_);
}
inline const ::opi_api::security::v1::Proposals& Child::esp_proposals() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.esp_proposals)
  return _internal_esp_proposals();
}
inline void Child::unsafe_arena_set_allocated_esp_proposals(
    ::opi_api::security::v1::Proposals* esp_proposals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esp_proposals_);
  }
  _impl_.esp_proposals_ = esp_proposals;
  if (esp_proposals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Child.esp_proposals)
}
inline ::opi_api::security::v1::Proposals* Child::release_esp_proposals() {
  
  ::opi_api::security::v1::Proposals* temp = _impl_.esp_proposals_;
  _impl_.esp_proposals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Proposals* Child::unsafe_arena_release_esp_proposals() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.esp_proposals)
  
  ::opi_api::security::v1::Proposals* temp = _impl_.esp_proposals_;
  _impl_.esp_proposals_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Proposals* Child::_internal_mutable_esp_proposals() {
  
  if (_impl_.esp_proposals_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Proposals>(GetArenaForAllocation());
    _impl_.esp_proposals_ = p;
  }
  return _impl_.esp_proposals_;
}
inline ::opi_api::security::v1::Proposals* Child::mutable_esp_proposals() {
  ::opi_api::security::v1::Proposals* _msg = _internal_mutable_esp_proposals();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.esp_proposals)
  return _msg;
}
inline void Child::set_allocated_esp_proposals(::opi_api::security::v1::Proposals* esp_proposals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esp_proposals_;
  }
  if (esp_proposals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esp_proposals);
    if (message_arena != submessage_arena) {
      esp_proposals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esp_proposals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.esp_proposals_ = esp_proposals;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.esp_proposals)
}

// .opi_api.security.v1.TrafficSelectors local_ts = 4;
inline bool Child::_internal_has_local_ts() const {
  return this != internal_default_instance() && _impl_.local_ts_ != nullptr;
}
inline bool Child::has_local_ts() const {
  return _internal_has_local_ts();
}
inline void Child::clear_local_ts() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_ts_ != nullptr) {
    delete _impl_.local_ts_;
  }
  _impl_.local_ts_ = nullptr;
}
inline const ::opi_api::security::v1::TrafficSelectors& Child::_internal_local_ts() const {
  const ::opi_api::security::v1::TrafficSelectors* p = _impl_.local_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::TrafficSelectors&>(
      ::opi_api::security::v1::_TrafficSelectors_default_instance_);
}
inline const ::opi_api::security::v1::TrafficSelectors& Child::local_ts() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.local_ts)
  return _internal_local_ts();
}
inline void Child::unsafe_arena_set_allocated_local_ts(
    ::opi_api::security::v1::TrafficSelectors* local_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_ts_);
  }
  _impl_.local_ts_ = local_ts;
  if (local_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Child.local_ts)
}
inline ::opi_api::security::v1::TrafficSelectors* Child::release_local_ts() {
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.local_ts_;
  _impl_.local_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* Child::unsafe_arena_release_local_ts() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.local_ts)
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.local_ts_;
  _impl_.local_ts_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* Child::_internal_mutable_local_ts() {
  
  if (_impl_.local_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::TrafficSelectors>(GetArenaForAllocation());
    _impl_.local_ts_ = p;
  }
  return _impl_.local_ts_;
}
inline ::opi_api::security::v1::TrafficSelectors* Child::mutable_local_ts() {
  ::opi_api::security::v1::TrafficSelectors* _msg = _internal_mutable_local_ts();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.local_ts)
  return _msg;
}
inline void Child::set_allocated_local_ts(::opi_api::security::v1::TrafficSelectors* local_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_ts_;
  }
  if (local_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_ts);
    if (message_arena != submessage_arena) {
      local_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_ts_ = local_ts;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.local_ts)
}

// .opi_api.security.v1.TrafficSelectors remote_ts = 5;
inline bool Child::_internal_has_remote_ts() const {
  return this != internal_default_instance() && _impl_.remote_ts_ != nullptr;
}
inline bool Child::has_remote_ts() const {
  return _internal_has_remote_ts();
}
inline void Child::clear_remote_ts() {
  if (GetArenaForAllocation() == nullptr && _impl_.remote_ts_ != nullptr) {
    delete _impl_.remote_ts_;
  }
  _impl_.remote_ts_ = nullptr;
}
inline const ::opi_api::security::v1::TrafficSelectors& Child::_internal_remote_ts() const {
  const ::opi_api::security::v1::TrafficSelectors* p = _impl_.remote_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::TrafficSelectors&>(
      ::opi_api::security::v1::_TrafficSelectors_default_instance_);
}
inline const ::opi_api::security::v1::TrafficSelectors& Child::remote_ts() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.remote_ts)
  return _internal_remote_ts();
}
inline void Child::unsafe_arena_set_allocated_remote_ts(
    ::opi_api::security::v1::TrafficSelectors* remote_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_ts_);
  }
  _impl_.remote_ts_ = remote_ts;
  if (remote_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Child.remote_ts)
}
inline ::opi_api::security::v1::TrafficSelectors* Child::release_remote_ts() {
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.remote_ts_;
  _impl_.remote_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* Child::unsafe_arena_release_remote_ts() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.remote_ts)
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.remote_ts_;
  _impl_.remote_ts_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* Child::_internal_mutable_remote_ts() {
  
  if (_impl_.remote_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::TrafficSelectors>(GetArenaForAllocation());
    _impl_.remote_ts_ = p;
  }
  return _impl_.remote_ts_;
}
inline ::opi_api::security::v1::TrafficSelectors* Child::mutable_remote_ts() {
  ::opi_api::security::v1::TrafficSelectors* _msg = _internal_mutable_remote_ts();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.remote_ts)
  return _msg;
}
inline void Child::set_allocated_remote_ts(::opi_api::security::v1::TrafficSelectors* remote_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remote_ts_;
  }
  if (remote_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remote_ts);
    if (message_arena != submessage_arena) {
      remote_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remote_ts_ = remote_ts;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.remote_ts)
}

// uint32 rekey_time = 6;
inline void Child::clear_rekey_time() {
  _impl_.rekey_time_ = 0u;
}
inline uint32_t Child::_internal_rekey_time() const {
  return _impl_.rekey_time_;
}
inline uint32_t Child::rekey_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.rekey_time)
  return _internal_rekey_time();
}
inline void Child::_internal_set_rekey_time(uint32_t value) {
  
  _impl_.rekey_time_ = value;
}
inline void Child::set_rekey_time(uint32_t value) {
  _internal_set_rekey_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.rekey_time)
}

// uint32 life_time = 7;
inline void Child::clear_life_time() {
  _impl_.life_time_ = 0u;
}
inline uint32_t Child::_internal_life_time() const {
  return _impl_.life_time_;
}
inline uint32_t Child::life_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.life_time)
  return _internal_life_time();
}
inline void Child::_internal_set_life_time(uint32_t value) {
  
  _impl_.life_time_ = value;
}
inline void Child::set_life_time(uint32_t value) {
  _internal_set_life_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.life_time)
}

// uint32 rand_time = 8;
inline void Child::clear_rand_time() {
  _impl_.rand_time_ = 0u;
}
inline uint32_t Child::_internal_rand_time() const {
  return _impl_.rand_time_;
}
inline uint32_t Child::rand_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.rand_time)
  return _internal_rand_time();
}
inline void Child::_internal_set_rand_time(uint32_t value) {
  
  _impl_.rand_time_ = value;
}
inline void Child::set_rand_time(uint32_t value) {
  _internal_set_rand_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.rand_time)
}

// string updown = 9;
inline void Child::clear_updown() {
  _impl_.updown_.ClearToEmpty();
}
inline const std::string& Child::updown() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.updown)
  return _internal_updown();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Child::set_updown(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updown_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.updown)
}
inline std::string* Child::mutable_updown() {
  std::string* _s = _internal_mutable_updown();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.updown)
  return _s;
}
inline const std::string& Child::_internal_updown() const {
  return _impl_.updown_.Get();
}
inline void Child::_internal_set_updown(const std::string& value) {
  
  _impl_.updown_.Set(value, GetArenaForAllocation());
}
inline std::string* Child::_internal_mutable_updown() {
  
  return _impl_.updown_.Mutable(GetArenaForAllocation());
}
inline std::string* Child::release_updown() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.updown)
  return _impl_.updown_.Release();
}
inline void Child::set_allocated_updown(std::string* updown) {
  if (updown != nullptr) {
    
  } else {
    
  }
  _impl_.updown_.SetAllocated(updown, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updown_.IsDefault()) {
    _impl_.updown_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.updown)
}

// uint32 inactivity = 10;
inline void Child::clear_inactivity() {
  _impl_.inactivity_ = 0u;
}
inline uint32_t Child::_internal_inactivity() const {
  return _impl_.inactivity_;
}
inline uint32_t Child::inactivity() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.inactivity)
  return _internal_inactivity();
}
inline void Child::_internal_set_inactivity(uint32_t value) {
  
  _impl_.inactivity_ = value;
}
inline void Child::set_inactivity(uint32_t value) {
  _internal_set_inactivity(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.inactivity)
}

// uint32 mark_in = 11;
inline void Child::clear_mark_in() {
  _impl_.mark_in_ = 0u;
}
inline uint32_t Child::_internal_mark_in() const {
  return _impl_.mark_in_;
}
inline uint32_t Child::mark_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.mark_in)
  return _internal_mark_in();
}
inline void Child::_internal_set_mark_in(uint32_t value) {
  
  _impl_.mark_in_ = value;
}
inline void Child::set_mark_in(uint32_t value) {
  _internal_set_mark_in(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.mark_in)
}

// string mark_in_sa = 12;
inline void Child::clear_mark_in_sa() {
  _impl_.mark_in_sa_.ClearToEmpty();
}
inline const std::string& Child::mark_in_sa() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.mark_in_sa)
  return _internal_mark_in_sa();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Child::set_mark_in_sa(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mark_in_sa_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.mark_in_sa)
}
inline std::string* Child::mutable_mark_in_sa() {
  std::string* _s = _internal_mutable_mark_in_sa();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.mark_in_sa)
  return _s;
}
inline const std::string& Child::_internal_mark_in_sa() const {
  return _impl_.mark_in_sa_.Get();
}
inline void Child::_internal_set_mark_in_sa(const std::string& value) {
  
  _impl_.mark_in_sa_.Set(value, GetArenaForAllocation());
}
inline std::string* Child::_internal_mutable_mark_in_sa() {
  
  return _impl_.mark_in_sa_.Mutable(GetArenaForAllocation());
}
inline std::string* Child::release_mark_in_sa() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.mark_in_sa)
  return _impl_.mark_in_sa_.Release();
}
inline void Child::set_allocated_mark_in_sa(std::string* mark_in_sa) {
  if (mark_in_sa != nullptr) {
    
  } else {
    
  }
  _impl_.mark_in_sa_.SetAllocated(mark_in_sa, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mark_in_sa_.IsDefault()) {
    _impl_.mark_in_sa_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.mark_in_sa)
}

// uint32 mark_out = 13;
inline void Child::clear_mark_out() {
  _impl_.mark_out_ = 0u;
}
inline uint32_t Child::_internal_mark_out() const {
  return _impl_.mark_out_;
}
inline uint32_t Child::mark_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.mark_out)
  return _internal_mark_out();
}
inline void Child::_internal_set_mark_out(uint32_t value) {
  
  _impl_.mark_out_ = value;
}
inline void Child::set_mark_out(uint32_t value) {
  _internal_set_mark_out(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.mark_out)
}

// uint32 set_mark_in = 14;
inline void Child::clear_set_mark_in() {
  _impl_.set_mark_in_ = 0u;
}
inline uint32_t Child::_internal_set_mark_in() const {
  return _impl_.set_mark_in_;
}
inline uint32_t Child::set_mark_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.set_mark_in)
  return _internal_set_mark_in();
}
inline void Child::_internal_set_set_mark_in(uint32_t value) {
  
  _impl_.set_mark_in_ = value;
}
inline void Child::set_set_mark_in(uint32_t value) {
  _internal_set_set_mark_in(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.set_mark_in)
}

// uint32 set_mark_out = 15;
inline void Child::clear_set_mark_out() {
  _impl_.set_mark_out_ = 0u;
}
inline uint32_t Child::_internal_set_mark_out() const {
  return _impl_.set_mark_out_;
}
inline uint32_t Child::set_mark_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.set_mark_out)
  return _internal_set_mark_out();
}
inline void Child::_internal_set_set_mark_out(uint32_t value) {
  
  _impl_.set_mark_out_ = value;
}
inline void Child::set_set_mark_out(uint32_t value) {
  _internal_set_set_mark_out(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.set_mark_out)
}

// string hw_offload = 16;
inline void Child::clear_hw_offload() {
  _impl_.hw_offload_.ClearToEmpty();
}
inline const std::string& Child::hw_offload() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Child.hw_offload)
  return _internal_hw_offload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Child::set_hw_offload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hw_offload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Child.hw_offload)
}
inline std::string* Child::mutable_hw_offload() {
  std::string* _s = _internal_mutable_hw_offload();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Child.hw_offload)
  return _s;
}
inline const std::string& Child::_internal_hw_offload() const {
  return _impl_.hw_offload_.Get();
}
inline void Child::_internal_set_hw_offload(const std::string& value) {
  
  _impl_.hw_offload_.Set(value, GetArenaForAllocation());
}
inline std::string* Child::_internal_mutable_hw_offload() {
  
  return _impl_.hw_offload_.Mutable(GetArenaForAllocation());
}
inline std::string* Child::release_hw_offload() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Child.hw_offload)
  return _impl_.hw_offload_.Release();
}
inline void Child::set_allocated_hw_offload(std::string* hw_offload) {
  if (hw_offload != nullptr) {
    
  } else {
    
  }
  _impl_.hw_offload_.SetAllocated(hw_offload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hw_offload_.IsDefault()) {
    _impl_.hw_offload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Child.hw_offload)
}

// -------------------------------------------------------------------

// Connection

// string name = 1;
inline void Connection::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Connection::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.name)
}
inline std::string* Connection::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.name)
  return _s;
}
inline const std::string& Connection::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Connection::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Connection::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.name)
  return _impl_.name_.Release();
}
inline void Connection::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.name)
}

// string version = 2;
inline void Connection::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Connection::version() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.version)
}
inline std::string* Connection::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.version)
  return _s;
}
inline const std::string& Connection::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Connection::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Connection::release_version() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.version)
  return _impl_.version_.Release();
}
inline void Connection::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.version)
}

// repeated .opi_api.security.v1.Addrs local_addrs = 3;
inline int Connection::_internal_local_addrs_size() const {
  return _impl_.local_addrs_.size();
}
inline int Connection::local_addrs_size() const {
  return _internal_local_addrs_size();
}
inline void Connection::clear_local_addrs() {
  _impl_.local_addrs_.Clear();
}
inline ::opi_api::security::v1::Addrs* Connection::mutable_local_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.local_addrs)
  return _impl_.local_addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
Connection::mutable_local_addrs() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Connection.local_addrs)
  return &_impl_.local_addrs_;
}
inline const ::opi_api::security::v1::Addrs& Connection::_internal_local_addrs(int index) const {
  return _impl_.local_addrs_.Get(index);
}
inline const ::opi_api::security::v1::Addrs& Connection::local_addrs(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.local_addrs)
  return _internal_local_addrs(index);
}
inline ::opi_api::security::v1::Addrs* Connection::_internal_add_local_addrs() {
  return _impl_.local_addrs_.Add();
}
inline ::opi_api::security::v1::Addrs* Connection::add_local_addrs() {
  ::opi_api::security::v1::Addrs* _add = _internal_add_local_addrs();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Connection.local_addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
Connection::local_addrs() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Connection.local_addrs)
  return _impl_.local_addrs_;
}

// repeated .opi_api.security.v1.Addrs remote_addrs = 4;
inline int Connection::_internal_remote_addrs_size() const {
  return _impl_.remote_addrs_.size();
}
inline int Connection::remote_addrs_size() const {
  return _internal_remote_addrs_size();
}
inline void Connection::clear_remote_addrs() {
  _impl_.remote_addrs_.Clear();
}
inline ::opi_api::security::v1::Addrs* Connection::mutable_remote_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.remote_addrs)
  return _impl_.remote_addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
Connection::mutable_remote_addrs() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Connection.remote_addrs)
  return &_impl_.remote_addrs_;
}
inline const ::opi_api::security::v1::Addrs& Connection::_internal_remote_addrs(int index) const {
  return _impl_.remote_addrs_.Get(index);
}
inline const ::opi_api::security::v1::Addrs& Connection::remote_addrs(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.remote_addrs)
  return _internal_remote_addrs(index);
}
inline ::opi_api::security::v1::Addrs* Connection::_internal_add_remote_addrs() {
  return _impl_.remote_addrs_.Add();
}
inline ::opi_api::security::v1::Addrs* Connection::add_remote_addrs() {
  ::opi_api::security::v1::Addrs* _add = _internal_add_remote_addrs();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Connection.remote_addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
Connection::remote_addrs() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Connection.remote_addrs)
  return _impl_.remote_addrs_;
}

// uint32 local_port = 5;
inline void Connection::clear_local_port() {
  _impl_.local_port_ = 0u;
}
inline uint32_t Connection::_internal_local_port() const {
  return _impl_.local_port_;
}
inline uint32_t Connection::local_port() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.local_port)
  return _internal_local_port();
}
inline void Connection::_internal_set_local_port(uint32_t value) {
  
  _impl_.local_port_ = value;
}
inline void Connection::set_local_port(uint32_t value) {
  _internal_set_local_port(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.local_port)
}

// uint32 remote_port = 6;
inline void Connection::clear_remote_port() {
  _impl_.remote_port_ = 0u;
}
inline uint32_t Connection::_internal_remote_port() const {
  return _impl_.remote_port_;
}
inline uint32_t Connection::remote_port() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.remote_port)
  return _internal_remote_port();
}
inline void Connection::_internal_set_remote_port(uint32_t value) {
  
  _impl_.remote_port_ = value;
}
inline void Connection::set_remote_port(uint32_t value) {
  _internal_set_remote_port(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.remote_port)
}

// .opi_api.security.v1.Proposals proposals = 7;
inline bool Connection::_internal_has_proposals() const {
  return this != internal_default_instance() && _impl_.proposals_ != nullptr;
}
inline bool Connection::has_proposals() const {
  return _internal_has_proposals();
}
inline void Connection::clear_proposals() {
  if (GetArenaForAllocation() == nullptr && _impl_.proposals_ != nullptr) {
    delete _impl_.proposals_;
  }
  _impl_.proposals_ = nullptr;
}
inline const ::opi_api::security::v1::Proposals& Connection::_internal_proposals() const {
  const ::opi_api::security::v1::Proposals* p = _impl_.proposals_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Proposals&>(
      ::opi_api::security::v1::_Proposals_default_instance_);
}
inline const ::opi_api::security::v1::Proposals& Connection::proposals() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.proposals)
  return _internal_proposals();
}
inline void Connection::unsafe_arena_set_allocated_proposals(
    ::opi_api::security::v1::Proposals* proposals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proposals_);
  }
  _impl_.proposals_ = proposals;
  if (proposals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Connection.proposals)
}
inline ::opi_api::security::v1::Proposals* Connection::release_proposals() {
  
  ::opi_api::security::v1::Proposals* temp = _impl_.proposals_;
  _impl_.proposals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Proposals* Connection::unsafe_arena_release_proposals() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.proposals)
  
  ::opi_api::security::v1::Proposals* temp = _impl_.proposals_;
  _impl_.proposals_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Proposals* Connection::_internal_mutable_proposals() {
  
  if (_impl_.proposals_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Proposals>(GetArenaForAllocation());
    _impl_.proposals_ = p;
  }
  return _impl_.proposals_;
}
inline ::opi_api::security::v1::Proposals* Connection::mutable_proposals() {
  ::opi_api::security::v1::Proposals* _msg = _internal_mutable_proposals();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.proposals)
  return _msg;
}
inline void Connection::set_allocated_proposals(::opi_api::security::v1::Proposals* proposals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.proposals_;
  }
  if (proposals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(proposals);
    if (message_arena != submessage_arena) {
      proposals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.proposals_ = proposals;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.proposals)
}

// .opi_api.security.v1.Vips vips = 8;
inline bool Connection::_internal_has_vips() const {
  return this != internal_default_instance() && _impl_.vips_ != nullptr;
}
inline bool Connection::has_vips() const {
  return _internal_has_vips();
}
inline void Connection::clear_vips() {
  if (GetArenaForAllocation() == nullptr && _impl_.vips_ != nullptr) {
    delete _impl_.vips_;
  }
  _impl_.vips_ = nullptr;
}
inline const ::opi_api::security::v1::Vips& Connection::_internal_vips() const {
  const ::opi_api::security::v1::Vips* p = _impl_.vips_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Vips&>(
      ::opi_api::security::v1::_Vips_default_instance_);
}
inline const ::opi_api::security::v1::Vips& Connection::vips() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.vips)
  return _internal_vips();
}
inline void Connection::unsafe_arena_set_allocated_vips(
    ::opi_api::security::v1::Vips* vips) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vips_);
  }
  _impl_.vips_ = vips;
  if (vips) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Connection.vips)
}
inline ::opi_api::security::v1::Vips* Connection::release_vips() {
  
  ::opi_api::security::v1::Vips* temp = _impl_.vips_;
  _impl_.vips_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Vips* Connection::unsafe_arena_release_vips() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.vips)
  
  ::opi_api::security::v1::Vips* temp = _impl_.vips_;
  _impl_.vips_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Vips* Connection::_internal_mutable_vips() {
  
  if (_impl_.vips_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Vips>(GetArenaForAllocation());
    _impl_.vips_ = p;
  }
  return _impl_.vips_;
}
inline ::opi_api::security::v1::Vips* Connection::mutable_vips() {
  ::opi_api::security::v1::Vips* _msg = _internal_mutable_vips();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.vips)
  return _msg;
}
inline void Connection::set_allocated_vips(::opi_api::security::v1::Vips* vips) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vips_;
  }
  if (vips) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vips);
    if (message_arena != submessage_arena) {
      vips = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vips, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vips_ = vips;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.vips)
}

// uint64 dscp = 9;
inline void Connection::clear_dscp() {
  _impl_.dscp_ = uint64_t{0u};
}
inline uint64_t Connection::_internal_dscp() const {
  return _impl_.dscp_;
}
inline uint64_t Connection::dscp() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.dscp)
  return _internal_dscp();
}
inline void Connection::_internal_set_dscp(uint64_t value) {
  
  _impl_.dscp_ = value;
}
inline void Connection::set_dscp(uint64_t value) {
  _internal_set_dscp(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.dscp)
}

// string encap = 10;
inline void Connection::clear_encap() {
  _impl_.encap_.ClearToEmpty();
}
inline const std::string& Connection::encap() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.encap)
  return _internal_encap();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_encap(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encap_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.encap)
}
inline std::string* Connection::mutable_encap() {
  std::string* _s = _internal_mutable_encap();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.encap)
  return _s;
}
inline const std::string& Connection::_internal_encap() const {
  return _impl_.encap_.Get();
}
inline void Connection::_internal_set_encap(const std::string& value) {
  
  _impl_.encap_.Set(value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_encap() {
  
  return _impl_.encap_.Mutable(GetArenaForAllocation());
}
inline std::string* Connection::release_encap() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.encap)
  return _impl_.encap_.Release();
}
inline void Connection::set_allocated_encap(std::string* encap) {
  if (encap != nullptr) {
    
  } else {
    
  }
  _impl_.encap_.SetAllocated(encap, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encap_.IsDefault()) {
    _impl_.encap_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.encap)
}

// string mobike = 11;
inline void Connection::clear_mobike() {
  _impl_.mobike_.ClearToEmpty();
}
inline const std::string& Connection::mobike() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.mobike)
  return _internal_mobike();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connection::set_mobike(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mobike_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.mobike)
}
inline std::string* Connection::mutable_mobike() {
  std::string* _s = _internal_mutable_mobike();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.mobike)
  return _s;
}
inline const std::string& Connection::_internal_mobike() const {
  return _impl_.mobike_.Get();
}
inline void Connection::_internal_set_mobike(const std::string& value) {
  
  _impl_.mobike_.Set(value, GetArenaForAllocation());
}
inline std::string* Connection::_internal_mutable_mobike() {
  
  return _impl_.mobike_.Mutable(GetArenaForAllocation());
}
inline std::string* Connection::release_mobike() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.mobike)
  return _impl_.mobike_.Release();
}
inline void Connection::set_allocated_mobike(std::string* mobike) {
  if (mobike != nullptr) {
    
  } else {
    
  }
  _impl_.mobike_.SetAllocated(mobike, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mobike_.IsDefault()) {
    _impl_.mobike_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.mobike)
}

// uint32 dpd_delay = 12;
inline void Connection::clear_dpd_delay() {
  _impl_.dpd_delay_ = 0u;
}
inline uint32_t Connection::_internal_dpd_delay() const {
  return _impl_.dpd_delay_;
}
inline uint32_t Connection::dpd_delay() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.dpd_delay)
  return _internal_dpd_delay();
}
inline void Connection::_internal_set_dpd_delay(uint32_t value) {
  
  _impl_.dpd_delay_ = value;
}
inline void Connection::set_dpd_delay(uint32_t value) {
  _internal_set_dpd_delay(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.dpd_delay)
}

// uint32 dpd_timeout = 13;
inline void Connection::clear_dpd_timeout() {
  _impl_.dpd_timeout_ = 0u;
}
inline uint32_t Connection::_internal_dpd_timeout() const {
  return _impl_.dpd_timeout_;
}
inline uint32_t Connection::dpd_timeout() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.dpd_timeout)
  return _internal_dpd_timeout();
}
inline void Connection::_internal_set_dpd_timeout(uint32_t value) {
  
  _impl_.dpd_timeout_ = value;
}
inline void Connection::set_dpd_timeout(uint32_t value) {
  _internal_set_dpd_timeout(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.dpd_timeout)
}

// uint32 reauth_time = 14;
inline void Connection::clear_reauth_time() {
  _impl_.reauth_time_ = 0u;
}
inline uint32_t Connection::_internal_reauth_time() const {
  return _impl_.reauth_time_;
}
inline uint32_t Connection::reauth_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.reauth_time)
  return _internal_reauth_time();
}
inline void Connection::_internal_set_reauth_time(uint32_t value) {
  
  _impl_.reauth_time_ = value;
}
inline void Connection::set_reauth_time(uint32_t value) {
  _internal_set_reauth_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.reauth_time)
}

// uint32 rekey_time = 15;
inline void Connection::clear_rekey_time() {
  _impl_.rekey_time_ = 0u;
}
inline uint32_t Connection::_internal_rekey_time() const {
  return _impl_.rekey_time_;
}
inline uint32_t Connection::rekey_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.rekey_time)
  return _internal_rekey_time();
}
inline void Connection::_internal_set_rekey_time(uint32_t value) {
  
  _impl_.rekey_time_ = value;
}
inline void Connection::set_rekey_time(uint32_t value) {
  _internal_set_rekey_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.Connection.rekey_time)
}

// .opi_api.security.v1.Pools pools = 16;
inline bool Connection::_internal_has_pools() const {
  return this != internal_default_instance() && _impl_.pools_ != nullptr;
}
inline bool Connection::has_pools() const {
  return _internal_has_pools();
}
inline void Connection::clear_pools() {
  if (GetArenaForAllocation() == nullptr && _impl_.pools_ != nullptr) {
    delete _impl_.pools_;
  }
  _impl_.pools_ = nullptr;
}
inline const ::opi_api::security::v1::Pools& Connection::_internal_pools() const {
  const ::opi_api::security::v1::Pools* p = _impl_.pools_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Pools&>(
      ::opi_api::security::v1::_Pools_default_instance_);
}
inline const ::opi_api::security::v1::Pools& Connection::pools() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.pools)
  return _internal_pools();
}
inline void Connection::unsafe_arena_set_allocated_pools(
    ::opi_api::security::v1::Pools* pools) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pools_);
  }
  _impl_.pools_ = pools;
  if (pools) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Connection.pools)
}
inline ::opi_api::security::v1::Pools* Connection::release_pools() {
  
  ::opi_api::security::v1::Pools* temp = _impl_.pools_;
  _impl_.pools_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Pools* Connection::unsafe_arena_release_pools() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.pools)
  
  ::opi_api::security::v1::Pools* temp = _impl_.pools_;
  _impl_.pools_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Pools* Connection::_internal_mutable_pools() {
  
  if (_impl_.pools_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Pools>(GetArenaForAllocation());
    _impl_.pools_ = p;
  }
  return _impl_.pools_;
}
inline ::opi_api::security::v1::Pools* Connection::mutable_pools() {
  ::opi_api::security::v1::Pools* _msg = _internal_mutable_pools();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.pools)
  return _msg;
}
inline void Connection::set_allocated_pools(::opi_api::security::v1::Pools* pools) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pools_;
  }
  if (pools) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pools);
    if (message_arena != submessage_arena) {
      pools = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pools, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pools_ = pools;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.pools)
}

// .opi_api.security.v1.LocalAuth local_auth = 17;
inline bool Connection::_internal_has_local_auth() const {
  return this != internal_default_instance() && _impl_.local_auth_ != nullptr;
}
inline bool Connection::has_local_auth() const {
  return _internal_has_local_auth();
}
inline void Connection::clear_local_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_auth_ != nullptr) {
    delete _impl_.local_auth_;
  }
  _impl_.local_auth_ = nullptr;
}
inline const ::opi_api::security::v1::LocalAuth& Connection::_internal_local_auth() const {
  const ::opi_api::security::v1::LocalAuth* p = _impl_.local_auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::LocalAuth&>(
      ::opi_api::security::v1::_LocalAuth_default_instance_);
}
inline const ::opi_api::security::v1::LocalAuth& Connection::local_auth() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.local_auth)
  return _internal_local_auth();
}
inline void Connection::unsafe_arena_set_allocated_local_auth(
    ::opi_api::security::v1::LocalAuth* local_auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_auth_);
  }
  _impl_.local_auth_ = local_auth;
  if (local_auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Connection.local_auth)
}
inline ::opi_api::security::v1::LocalAuth* Connection::release_local_auth() {
  
  ::opi_api::security::v1::LocalAuth* temp = _impl_.local_auth_;
  _impl_.local_auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::LocalAuth* Connection::unsafe_arena_release_local_auth() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.local_auth)
  
  ::opi_api::security::v1::LocalAuth* temp = _impl_.local_auth_;
  _impl_.local_auth_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::LocalAuth* Connection::_internal_mutable_local_auth() {
  
  if (_impl_.local_auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::LocalAuth>(GetArenaForAllocation());
    _impl_.local_auth_ = p;
  }
  return _impl_.local_auth_;
}
inline ::opi_api::security::v1::LocalAuth* Connection::mutable_local_auth() {
  ::opi_api::security::v1::LocalAuth* _msg = _internal_mutable_local_auth();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.local_auth)
  return _msg;
}
inline void Connection::set_allocated_local_auth(::opi_api::security::v1::LocalAuth* local_auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_auth_;
  }
  if (local_auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_auth);
    if (message_arena != submessage_arena) {
      local_auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_auth_ = local_auth;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.local_auth)
}

// .opi_api.security.v1.RemoteAuth remote_auth = 18;
inline bool Connection::_internal_has_remote_auth() const {
  return this != internal_default_instance() && _impl_.remote_auth_ != nullptr;
}
inline bool Connection::has_remote_auth() const {
  return _internal_has_remote_auth();
}
inline void Connection::clear_remote_auth() {
  if (GetArenaForAllocation() == nullptr && _impl_.remote_auth_ != nullptr) {
    delete _impl_.remote_auth_;
  }
  _impl_.remote_auth_ = nullptr;
}
inline const ::opi_api::security::v1::RemoteAuth& Connection::_internal_remote_auth() const {
  const ::opi_api::security::v1::RemoteAuth* p = _impl_.remote_auth_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::RemoteAuth&>(
      ::opi_api::security::v1::_RemoteAuth_default_instance_);
}
inline const ::opi_api::security::v1::RemoteAuth& Connection::remote_auth() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.remote_auth)
  return _internal_remote_auth();
}
inline void Connection::unsafe_arena_set_allocated_remote_auth(
    ::opi_api::security::v1::RemoteAuth* remote_auth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_auth_);
  }
  _impl_.remote_auth_ = remote_auth;
  if (remote_auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.Connection.remote_auth)
}
inline ::opi_api::security::v1::RemoteAuth* Connection::release_remote_auth() {
  
  ::opi_api::security::v1::RemoteAuth* temp = _impl_.remote_auth_;
  _impl_.remote_auth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::RemoteAuth* Connection::unsafe_arena_release_remote_auth() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.Connection.remote_auth)
  
  ::opi_api::security::v1::RemoteAuth* temp = _impl_.remote_auth_;
  _impl_.remote_auth_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::RemoteAuth* Connection::_internal_mutable_remote_auth() {
  
  if (_impl_.remote_auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::RemoteAuth>(GetArenaForAllocation());
    _impl_.remote_auth_ = p;
  }
  return _impl_.remote_auth_;
}
inline ::opi_api::security::v1::RemoteAuth* Connection::mutable_remote_auth() {
  ::opi_api::security::v1::RemoteAuth* _msg = _internal_mutable_remote_auth();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.remote_auth)
  return _msg;
}
inline void Connection::set_allocated_remote_auth(::opi_api::security::v1::RemoteAuth* remote_auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remote_auth_;
  }
  if (remote_auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remote_auth);
    if (message_arena != submessage_arena) {
      remote_auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_auth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remote_auth_ = remote_auth;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.Connection.remote_auth)
}

// repeated .opi_api.security.v1.Child children = 19;
inline int Connection::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int Connection::children_size() const {
  return _internal_children_size();
}
inline void Connection::clear_children() {
  _impl_.children_.Clear();
}
inline ::opi_api::security::v1::Child* Connection::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.Connection.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Child >*
Connection::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.Connection.children)
  return &_impl_.children_;
}
inline const ::opi_api::security::v1::Child& Connection::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::opi_api::security::v1::Child& Connection::children(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.Connection.children)
  return _internal_children(index);
}
inline ::opi_api::security::v1::Child* Connection::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::opi_api::security::v1::Child* Connection::add_children() {
  ::opi_api::security::v1::Child* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.Connection.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Child >&
Connection::children() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.Connection.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// IPsecVersionRequest

// -------------------------------------------------------------------

// IPsecVersionResponse

// string daemon = 1;
inline void IPsecVersionResponse::clear_daemon() {
  _impl_.daemon_.ClearToEmpty();
}
inline const std::string& IPsecVersionResponse::daemon() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecVersionResponse.daemon)
  return _internal_daemon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecVersionResponse::set_daemon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.daemon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecVersionResponse.daemon)
}
inline std::string* IPsecVersionResponse::mutable_daemon() {
  std::string* _s = _internal_mutable_daemon();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecVersionResponse.daemon)
  return _s;
}
inline const std::string& IPsecVersionResponse::_internal_daemon() const {
  return _impl_.daemon_.Get();
}
inline void IPsecVersionResponse::_internal_set_daemon(const std::string& value) {
  
  _impl_.daemon_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::_internal_mutable_daemon() {
  
  return _impl_.daemon_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::release_daemon() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecVersionResponse.daemon)
  return _impl_.daemon_.Release();
}
inline void IPsecVersionResponse::set_allocated_daemon(std::string* daemon) {
  if (daemon != nullptr) {
    
  } else {
    
  }
  _impl_.daemon_.SetAllocated(daemon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.daemon_.IsDefault()) {
    _impl_.daemon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecVersionResponse.daemon)
}

// string version = 2;
inline void IPsecVersionResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& IPsecVersionResponse::version() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecVersionResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecVersionResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecVersionResponse.version)
}
inline std::string* IPsecVersionResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecVersionResponse.version)
  return _s;
}
inline const std::string& IPsecVersionResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void IPsecVersionResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::release_version() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecVersionResponse.version)
  return _impl_.version_.Release();
}
inline void IPsecVersionResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecVersionResponse.version)
}

// string sysname = 3;
inline void IPsecVersionResponse::clear_sysname() {
  _impl_.sysname_.ClearToEmpty();
}
inline const std::string& IPsecVersionResponse::sysname() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecVersionResponse.sysname)
  return _internal_sysname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecVersionResponse::set_sysname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sysname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecVersionResponse.sysname)
}
inline std::string* IPsecVersionResponse::mutable_sysname() {
  std::string* _s = _internal_mutable_sysname();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecVersionResponse.sysname)
  return _s;
}
inline const std::string& IPsecVersionResponse::_internal_sysname() const {
  return _impl_.sysname_.Get();
}
inline void IPsecVersionResponse::_internal_set_sysname(const std::string& value) {
  
  _impl_.sysname_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::_internal_mutable_sysname() {
  
  return _impl_.sysname_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::release_sysname() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecVersionResponse.sysname)
  return _impl_.sysname_.Release();
}
inline void IPsecVersionResponse::set_allocated_sysname(std::string* sysname) {
  if (sysname != nullptr) {
    
  } else {
    
  }
  _impl_.sysname_.SetAllocated(sysname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sysname_.IsDefault()) {
    _impl_.sysname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecVersionResponse.sysname)
}

// string release = 4;
inline void IPsecVersionResponse::clear_release() {
  _impl_.release_.ClearToEmpty();
}
inline const std::string& IPsecVersionResponse::release() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecVersionResponse.release)
  return _internal_release();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecVersionResponse::set_release(ArgT0&& arg0, ArgT... args) {
 
 _impl_.release_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecVersionResponse.release)
}
inline std::string* IPsecVersionResponse::mutable_release() {
  std::string* _s = _internal_mutable_release();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecVersionResponse.release)
  return _s;
}
inline const std::string& IPsecVersionResponse::_internal_release() const {
  return _impl_.release_.Get();
}
inline void IPsecVersionResponse::_internal_set_release(const std::string& value) {
  
  _impl_.release_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::_internal_mutable_release() {
  
  return _impl_.release_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::release_release() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecVersionResponse.release)
  return _impl_.release_.Release();
}
inline void IPsecVersionResponse::set_allocated_release(std::string* release) {
  if (release != nullptr) {
    
  } else {
    
  }
  _impl_.release_.SetAllocated(release, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.release_.IsDefault()) {
    _impl_.release_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecVersionResponse.release)
}

// string machine = 5;
inline void IPsecVersionResponse::clear_machine() {
  _impl_.machine_.ClearToEmpty();
}
inline const std::string& IPsecVersionResponse::machine() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecVersionResponse.machine)
  return _internal_machine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecVersionResponse::set_machine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.machine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecVersionResponse.machine)
}
inline std::string* IPsecVersionResponse::mutable_machine() {
  std::string* _s = _internal_mutable_machine();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecVersionResponse.machine)
  return _s;
}
inline const std::string& IPsecVersionResponse::_internal_machine() const {
  return _impl_.machine_.Get();
}
inline void IPsecVersionResponse::_internal_set_machine(const std::string& value) {
  
  _impl_.machine_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::_internal_mutable_machine() {
  
  return _impl_.machine_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecVersionResponse::release_machine() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecVersionResponse.machine)
  return _impl_.machine_.Release();
}
inline void IPsecVersionResponse::set_allocated_machine(std::string* machine) {
  if (machine != nullptr) {
    
  } else {
    
  }
  _impl_.machine_.SetAllocated(machine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_.IsDefault()) {
    _impl_.machine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecVersionResponse.machine)
}

// -------------------------------------------------------------------

// IPsecStatsRequest

// -------------------------------------------------------------------

// IPsecStatsResponse

// string status = 1;
inline void IPsecStatsResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& IPsecStatsResponse::status() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecStatsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecStatsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecStatsResponse.status)
}
inline std::string* IPsecStatsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecStatsResponse.status)
  return _s;
}
inline const std::string& IPsecStatsResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void IPsecStatsResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecStatsResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecStatsResponse::release_status() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecStatsResponse.status)
  return _impl_.status_.Release();
}
inline void IPsecStatsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecStatsResponse.status)
}

// -------------------------------------------------------------------

// IPsecInitiateRequest

// string child = 1;
inline void IPsecInitiateRequest::clear_child() {
  _impl_.child_.ClearToEmpty();
}
inline const std::string& IPsecInitiateRequest::child() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecInitiateRequest.child)
  return _internal_child();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecInitiateRequest::set_child(ArgT0&& arg0, ArgT... args) {
 
 _impl_.child_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecInitiateRequest.child)
}
inline std::string* IPsecInitiateRequest::mutable_child() {
  std::string* _s = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecInitiateRequest.child)
  return _s;
}
inline const std::string& IPsecInitiateRequest::_internal_child() const {
  return _impl_.child_.Get();
}
inline void IPsecInitiateRequest::_internal_set_child(const std::string& value) {
  
  _impl_.child_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::_internal_mutable_child() {
  
  return _impl_.child_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::release_child() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecInitiateRequest.child)
  return _impl_.child_.Release();
}
inline void IPsecInitiateRequest::set_allocated_child(std::string* child) {
  if (child != nullptr) {
    
  } else {
    
  }
  _impl_.child_.SetAllocated(child, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.child_.IsDefault()) {
    _impl_.child_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecInitiateRequest.child)
}

// string ike = 2;
inline void IPsecInitiateRequest::clear_ike() {
  _impl_.ike_.ClearToEmpty();
}
inline const std::string& IPsecInitiateRequest::ike() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecInitiateRequest.ike)
  return _internal_ike();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecInitiateRequest::set_ike(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ike_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecInitiateRequest.ike)
}
inline std::string* IPsecInitiateRequest::mutable_ike() {
  std::string* _s = _internal_mutable_ike();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecInitiateRequest.ike)
  return _s;
}
inline const std::string& IPsecInitiateRequest::_internal_ike() const {
  return _impl_.ike_.Get();
}
inline void IPsecInitiateRequest::_internal_set_ike(const std::string& value) {
  
  _impl_.ike_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::_internal_mutable_ike() {
  
  return _impl_.ike_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::release_ike() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecInitiateRequest.ike)
  return _impl_.ike_.Release();
}
inline void IPsecInitiateRequest::set_allocated_ike(std::string* ike) {
  if (ike != nullptr) {
    
  } else {
    
  }
  _impl_.ike_.SetAllocated(ike, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ike_.IsDefault()) {
    _impl_.ike_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecInitiateRequest.ike)
}

// string timeout = 3;
inline void IPsecInitiateRequest::clear_timeout() {
  _impl_.timeout_.ClearToEmpty();
}
inline const std::string& IPsecInitiateRequest::timeout() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecInitiateRequest.timeout)
  return _internal_timeout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecInitiateRequest::set_timeout(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timeout_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecInitiateRequest.timeout)
}
inline std::string* IPsecInitiateRequest::mutable_timeout() {
  std::string* _s = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecInitiateRequest.timeout)
  return _s;
}
inline const std::string& IPsecInitiateRequest::_internal_timeout() const {
  return _impl_.timeout_.Get();
}
inline void IPsecInitiateRequest::_internal_set_timeout(const std::string& value) {
  
  _impl_.timeout_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::_internal_mutable_timeout() {
  
  return _impl_.timeout_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::release_timeout() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecInitiateRequest.timeout)
  return _impl_.timeout_.Release();
}
inline void IPsecInitiateRequest::set_allocated_timeout(std::string* timeout) {
  if (timeout != nullptr) {
    
  } else {
    
  }
  _impl_.timeout_.SetAllocated(timeout, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timeout_.IsDefault()) {
    _impl_.timeout_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecInitiateRequest.timeout)
}

// string loglevel = 4;
inline void IPsecInitiateRequest::clear_loglevel() {
  _impl_.loglevel_.ClearToEmpty();
}
inline const std::string& IPsecInitiateRequest::loglevel() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecInitiateRequest.loglevel)
  return _internal_loglevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecInitiateRequest::set_loglevel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loglevel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecInitiateRequest.loglevel)
}
inline std::string* IPsecInitiateRequest::mutable_loglevel() {
  std::string* _s = _internal_mutable_loglevel();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecInitiateRequest.loglevel)
  return _s;
}
inline const std::string& IPsecInitiateRequest::_internal_loglevel() const {
  return _impl_.loglevel_.Get();
}
inline void IPsecInitiateRequest::_internal_set_loglevel(const std::string& value) {
  
  _impl_.loglevel_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::_internal_mutable_loglevel() {
  
  return _impl_.loglevel_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecInitiateRequest::release_loglevel() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecInitiateRequest.loglevel)
  return _impl_.loglevel_.Release();
}
inline void IPsecInitiateRequest::set_allocated_loglevel(std::string* loglevel) {
  if (loglevel != nullptr) {
    
  } else {
    
  }
  _impl_.loglevel_.SetAllocated(loglevel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loglevel_.IsDefault()) {
    _impl_.loglevel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecInitiateRequest.loglevel)
}

// -------------------------------------------------------------------

// IPsecInitiateResponse

// -------------------------------------------------------------------

// IPsecTerminateRequest

// string child = 1;
inline void IPsecTerminateRequest::clear_child() {
  _impl_.child_.ClearToEmpty();
}
inline const std::string& IPsecTerminateRequest::child() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.child)
  return _internal_child();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecTerminateRequest::set_child(ArgT0&& arg0, ArgT... args) {
 
 _impl_.child_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.child)
}
inline std::string* IPsecTerminateRequest::mutable_child() {
  std::string* _s = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecTerminateRequest.child)
  return _s;
}
inline const std::string& IPsecTerminateRequest::_internal_child() const {
  return _impl_.child_.Get();
}
inline void IPsecTerminateRequest::_internal_set_child(const std::string& value) {
  
  _impl_.child_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::_internal_mutable_child() {
  
  return _impl_.child_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::release_child() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecTerminateRequest.child)
  return _impl_.child_.Release();
}
inline void IPsecTerminateRequest::set_allocated_child(std::string* child) {
  if (child != nullptr) {
    
  } else {
    
  }
  _impl_.child_.SetAllocated(child, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.child_.IsDefault()) {
    _impl_.child_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecTerminateRequest.child)
}

// string ike = 2;
inline void IPsecTerminateRequest::clear_ike() {
  _impl_.ike_.ClearToEmpty();
}
inline const std::string& IPsecTerminateRequest::ike() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.ike)
  return _internal_ike();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecTerminateRequest::set_ike(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ike_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.ike)
}
inline std::string* IPsecTerminateRequest::mutable_ike() {
  std::string* _s = _internal_mutable_ike();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecTerminateRequest.ike)
  return _s;
}
inline const std::string& IPsecTerminateRequest::_internal_ike() const {
  return _impl_.ike_.Get();
}
inline void IPsecTerminateRequest::_internal_set_ike(const std::string& value) {
  
  _impl_.ike_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::_internal_mutable_ike() {
  
  return _impl_.ike_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::release_ike() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecTerminateRequest.ike)
  return _impl_.ike_.Release();
}
inline void IPsecTerminateRequest::set_allocated_ike(std::string* ike) {
  if (ike != nullptr) {
    
  } else {
    
  }
  _impl_.ike_.SetAllocated(ike, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ike_.IsDefault()) {
    _impl_.ike_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecTerminateRequest.ike)
}

// uint64 child_id = 3;
inline void IPsecTerminateRequest::clear_child_id() {
  _impl_.child_id_ = uint64_t{0u};
}
inline uint64_t IPsecTerminateRequest::_internal_child_id() const {
  return _impl_.child_id_;
}
inline uint64_t IPsecTerminateRequest::child_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.child_id)
  return _internal_child_id();
}
inline void IPsecTerminateRequest::_internal_set_child_id(uint64_t value) {
  
  _impl_.child_id_ = value;
}
inline void IPsecTerminateRequest::set_child_id(uint64_t value) {
  _internal_set_child_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.child_id)
}

// uint64 ike_id = 4;
inline void IPsecTerminateRequest::clear_ike_id() {
  _impl_.ike_id_ = uint64_t{0u};
}
inline uint64_t IPsecTerminateRequest::_internal_ike_id() const {
  return _impl_.ike_id_;
}
inline uint64_t IPsecTerminateRequest::ike_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.ike_id)
  return _internal_ike_id();
}
inline void IPsecTerminateRequest::_internal_set_ike_id(uint64_t value) {
  
  _impl_.ike_id_ = value;
}
inline void IPsecTerminateRequest::set_ike_id(uint64_t value) {
  _internal_set_ike_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.ike_id)
}

// string force = 5;
inline void IPsecTerminateRequest::clear_force() {
  _impl_.force_.ClearToEmpty();
}
inline const std::string& IPsecTerminateRequest::force() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.force)
  return _internal_force();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecTerminateRequest::set_force(ArgT0&& arg0, ArgT... args) {
 
 _impl_.force_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.force)
}
inline std::string* IPsecTerminateRequest::mutable_force() {
  std::string* _s = _internal_mutable_force();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecTerminateRequest.force)
  return _s;
}
inline const std::string& IPsecTerminateRequest::_internal_force() const {
  return _impl_.force_.Get();
}
inline void IPsecTerminateRequest::_internal_set_force(const std::string& value) {
  
  _impl_.force_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::_internal_mutable_force() {
  
  return _impl_.force_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::release_force() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecTerminateRequest.force)
  return _impl_.force_.Release();
}
inline void IPsecTerminateRequest::set_allocated_force(std::string* force) {
  if (force != nullptr) {
    
  } else {
    
  }
  _impl_.force_.SetAllocated(force, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.force_.IsDefault()) {
    _impl_.force_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecTerminateRequest.force)
}

// string timeout = 6;
inline void IPsecTerminateRequest::clear_timeout() {
  _impl_.timeout_.ClearToEmpty();
}
inline const std::string& IPsecTerminateRequest::timeout() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.timeout)
  return _internal_timeout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecTerminateRequest::set_timeout(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timeout_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.timeout)
}
inline std::string* IPsecTerminateRequest::mutable_timeout() {
  std::string* _s = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecTerminateRequest.timeout)
  return _s;
}
inline const std::string& IPsecTerminateRequest::_internal_timeout() const {
  return _impl_.timeout_.Get();
}
inline void IPsecTerminateRequest::_internal_set_timeout(const std::string& value) {
  
  _impl_.timeout_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::_internal_mutable_timeout() {
  
  return _impl_.timeout_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::release_timeout() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecTerminateRequest.timeout)
  return _impl_.timeout_.Release();
}
inline void IPsecTerminateRequest::set_allocated_timeout(std::string* timeout) {
  if (timeout != nullptr) {
    
  } else {
    
  }
  _impl_.timeout_.SetAllocated(timeout, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timeout_.IsDefault()) {
    _impl_.timeout_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecTerminateRequest.timeout)
}

// string loglevel = 7;
inline void IPsecTerminateRequest::clear_loglevel() {
  _impl_.loglevel_.ClearToEmpty();
}
inline const std::string& IPsecTerminateRequest::loglevel() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateRequest.loglevel)
  return _internal_loglevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecTerminateRequest::set_loglevel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loglevel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateRequest.loglevel)
}
inline std::string* IPsecTerminateRequest::mutable_loglevel() {
  std::string* _s = _internal_mutable_loglevel();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecTerminateRequest.loglevel)
  return _s;
}
inline const std::string& IPsecTerminateRequest::_internal_loglevel() const {
  return _impl_.loglevel_.Get();
}
inline void IPsecTerminateRequest::_internal_set_loglevel(const std::string& value) {
  
  _impl_.loglevel_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::_internal_mutable_loglevel() {
  
  return _impl_.loglevel_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecTerminateRequest::release_loglevel() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecTerminateRequest.loglevel)
  return _impl_.loglevel_.Release();
}
inline void IPsecTerminateRequest::set_allocated_loglevel(std::string* loglevel) {
  if (loglevel != nullptr) {
    
  } else {
    
  }
  _impl_.loglevel_.SetAllocated(loglevel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loglevel_.IsDefault()) {
    _impl_.loglevel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecTerminateRequest.loglevel)
}

// -------------------------------------------------------------------

// IPsecTerminateResponse

// string success = 1;
inline void IPsecTerminateResponse::clear_success() {
  _impl_.success_.ClearToEmpty();
}
inline const std::string& IPsecTerminateResponse::success() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateResponse.success)
  return _internal_success();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecTerminateResponse::set_success(ArgT0&& arg0, ArgT... args) {
 
 _impl_.success_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateResponse.success)
}
inline std::string* IPsecTerminateResponse::mutable_success() {
  std::string* _s = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecTerminateResponse.success)
  return _s;
}
inline const std::string& IPsecTerminateResponse::_internal_success() const {
  return _impl_.success_.Get();
}
inline void IPsecTerminateResponse::_internal_set_success(const std::string& value) {
  
  _impl_.success_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecTerminateResponse::_internal_mutable_success() {
  
  return _impl_.success_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecTerminateResponse::release_success() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecTerminateResponse.success)
  return _impl_.success_.Release();
}
inline void IPsecTerminateResponse::set_allocated_success(std::string* success) {
  if (success != nullptr) {
    
  } else {
    
  }
  _impl_.success_.SetAllocated(success, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.success_.IsDefault()) {
    _impl_.success_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecTerminateResponse.success)
}

// uint32 matches = 2;
inline void IPsecTerminateResponse::clear_matches() {
  _impl_.matches_ = 0u;
}
inline uint32_t IPsecTerminateResponse::_internal_matches() const {
  return _impl_.matches_;
}
inline uint32_t IPsecTerminateResponse::matches() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateResponse.matches)
  return _internal_matches();
}
inline void IPsecTerminateResponse::_internal_set_matches(uint32_t value) {
  
  _impl_.matches_ = value;
}
inline void IPsecTerminateResponse::set_matches(uint32_t value) {
  _internal_set_matches(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateResponse.matches)
}

// uint32 terminated = 3;
inline void IPsecTerminateResponse::clear_terminated() {
  _impl_.terminated_ = 0u;
}
inline uint32_t IPsecTerminateResponse::_internal_terminated() const {
  return _impl_.terminated_;
}
inline uint32_t IPsecTerminateResponse::terminated() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecTerminateResponse.terminated)
  return _internal_terminated();
}
inline void IPsecTerminateResponse::_internal_set_terminated(uint32_t value) {
  
  _impl_.terminated_ = value;
}
inline void IPsecTerminateResponse::set_terminated(uint32_t value) {
  _internal_set_terminated(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecTerminateResponse.terminated)
}

// -------------------------------------------------------------------

// IPsecRekeyRequest

// string child = 1;
inline void IPsecRekeyRequest::clear_child() {
  _impl_.child_.ClearToEmpty();
}
inline const std::string& IPsecRekeyRequest::child() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyRequest.child)
  return _internal_child();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecRekeyRequest::set_child(ArgT0&& arg0, ArgT... args) {
 
 _impl_.child_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyRequest.child)
}
inline std::string* IPsecRekeyRequest::mutable_child() {
  std::string* _s = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecRekeyRequest.child)
  return _s;
}
inline const std::string& IPsecRekeyRequest::_internal_child() const {
  return _impl_.child_.Get();
}
inline void IPsecRekeyRequest::_internal_set_child(const std::string& value) {
  
  _impl_.child_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecRekeyRequest::_internal_mutable_child() {
  
  return _impl_.child_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecRekeyRequest::release_child() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecRekeyRequest.child)
  return _impl_.child_.Release();
}
inline void IPsecRekeyRequest::set_allocated_child(std::string* child) {
  if (child != nullptr) {
    
  } else {
    
  }
  _impl_.child_.SetAllocated(child, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.child_.IsDefault()) {
    _impl_.child_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecRekeyRequest.child)
}

// string ike = 2;
inline void IPsecRekeyRequest::clear_ike() {
  _impl_.ike_.ClearToEmpty();
}
inline const std::string& IPsecRekeyRequest::ike() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyRequest.ike)
  return _internal_ike();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecRekeyRequest::set_ike(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ike_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyRequest.ike)
}
inline std::string* IPsecRekeyRequest::mutable_ike() {
  std::string* _s = _internal_mutable_ike();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecRekeyRequest.ike)
  return _s;
}
inline const std::string& IPsecRekeyRequest::_internal_ike() const {
  return _impl_.ike_.Get();
}
inline void IPsecRekeyRequest::_internal_set_ike(const std::string& value) {
  
  _impl_.ike_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecRekeyRequest::_internal_mutable_ike() {
  
  return _impl_.ike_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecRekeyRequest::release_ike() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecRekeyRequest.ike)
  return _impl_.ike_.Release();
}
inline void IPsecRekeyRequest::set_allocated_ike(std::string* ike) {
  if (ike != nullptr) {
    
  } else {
    
  }
  _impl_.ike_.SetAllocated(ike, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ike_.IsDefault()) {
    _impl_.ike_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecRekeyRequest.ike)
}

// uint64 child_id = 3;
inline void IPsecRekeyRequest::clear_child_id() {
  _impl_.child_id_ = uint64_t{0u};
}
inline uint64_t IPsecRekeyRequest::_internal_child_id() const {
  return _impl_.child_id_;
}
inline uint64_t IPsecRekeyRequest::child_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyRequest.child_id)
  return _internal_child_id();
}
inline void IPsecRekeyRequest::_internal_set_child_id(uint64_t value) {
  
  _impl_.child_id_ = value;
}
inline void IPsecRekeyRequest::set_child_id(uint64_t value) {
  _internal_set_child_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyRequest.child_id)
}

// uint64 ike_id = 4;
inline void IPsecRekeyRequest::clear_ike_id() {
  _impl_.ike_id_ = uint64_t{0u};
}
inline uint64_t IPsecRekeyRequest::_internal_ike_id() const {
  return _impl_.ike_id_;
}
inline uint64_t IPsecRekeyRequest::ike_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyRequest.ike_id)
  return _internal_ike_id();
}
inline void IPsecRekeyRequest::_internal_set_ike_id(uint64_t value) {
  
  _impl_.ike_id_ = value;
}
inline void IPsecRekeyRequest::set_ike_id(uint64_t value) {
  _internal_set_ike_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyRequest.ike_id)
}

// string reauth = 5;
inline void IPsecRekeyRequest::clear_reauth() {
  _impl_.reauth_.ClearToEmpty();
}
inline const std::string& IPsecRekeyRequest::reauth() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyRequest.reauth)
  return _internal_reauth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecRekeyRequest::set_reauth(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reauth_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyRequest.reauth)
}
inline std::string* IPsecRekeyRequest::mutable_reauth() {
  std::string* _s = _internal_mutable_reauth();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecRekeyRequest.reauth)
  return _s;
}
inline const std::string& IPsecRekeyRequest::_internal_reauth() const {
  return _impl_.reauth_.Get();
}
inline void IPsecRekeyRequest::_internal_set_reauth(const std::string& value) {
  
  _impl_.reauth_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecRekeyRequest::_internal_mutable_reauth() {
  
  return _impl_.reauth_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecRekeyRequest::release_reauth() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecRekeyRequest.reauth)
  return _impl_.reauth_.Release();
}
inline void IPsecRekeyRequest::set_allocated_reauth(std::string* reauth) {
  if (reauth != nullptr) {
    
  } else {
    
  }
  _impl_.reauth_.SetAllocated(reauth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reauth_.IsDefault()) {
    _impl_.reauth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecRekeyRequest.reauth)
}

// -------------------------------------------------------------------

// IPsecRekeyResponse

// string success = 1;
inline void IPsecRekeyResponse::clear_success() {
  _impl_.success_.ClearToEmpty();
}
inline const std::string& IPsecRekeyResponse::success() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyResponse.success)
  return _internal_success();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecRekeyResponse::set_success(ArgT0&& arg0, ArgT... args) {
 
 _impl_.success_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyResponse.success)
}
inline std::string* IPsecRekeyResponse::mutable_success() {
  std::string* _s = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecRekeyResponse.success)
  return _s;
}
inline const std::string& IPsecRekeyResponse::_internal_success() const {
  return _impl_.success_.Get();
}
inline void IPsecRekeyResponse::_internal_set_success(const std::string& value) {
  
  _impl_.success_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecRekeyResponse::_internal_mutable_success() {
  
  return _impl_.success_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecRekeyResponse::release_success() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecRekeyResponse.success)
  return _impl_.success_.Release();
}
inline void IPsecRekeyResponse::set_allocated_success(std::string* success) {
  if (success != nullptr) {
    
  } else {
    
  }
  _impl_.success_.SetAllocated(success, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.success_.IsDefault()) {
    _impl_.success_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecRekeyResponse.success)
}

// uint32 matches = 2;
inline void IPsecRekeyResponse::clear_matches() {
  _impl_.matches_ = 0u;
}
inline uint32_t IPsecRekeyResponse::_internal_matches() const {
  return _impl_.matches_;
}
inline uint32_t IPsecRekeyResponse::matches() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecRekeyResponse.matches)
  return _internal_matches();
}
inline void IPsecRekeyResponse::_internal_set_matches(uint32_t value) {
  
  _impl_.matches_ = value;
}
inline void IPsecRekeyResponse::set_matches(uint32_t value) {
  _internal_set_matches(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecRekeyResponse.matches)
}

// -------------------------------------------------------------------

// IPsecListSasRequest

// string noblock = 1;
inline void IPsecListSasRequest::clear_noblock() {
  _impl_.noblock_.ClearToEmpty();
}
inline const std::string& IPsecListSasRequest::noblock() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListSasRequest.noblock)
  return _internal_noblock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListSasRequest::set_noblock(ArgT0&& arg0, ArgT... args) {
 
 _impl_.noblock_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListSasRequest.noblock)
}
inline std::string* IPsecListSasRequest::mutable_noblock() {
  std::string* _s = _internal_mutable_noblock();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListSasRequest.noblock)
  return _s;
}
inline const std::string& IPsecListSasRequest::_internal_noblock() const {
  return _impl_.noblock_.Get();
}
inline void IPsecListSasRequest::_internal_set_noblock(const std::string& value) {
  
  _impl_.noblock_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListSasRequest::_internal_mutable_noblock() {
  
  return _impl_.noblock_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListSasRequest::release_noblock() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListSasRequest.noblock)
  return _impl_.noblock_.Release();
}
inline void IPsecListSasRequest::set_allocated_noblock(std::string* noblock) {
  if (noblock != nullptr) {
    
  } else {
    
  }
  _impl_.noblock_.SetAllocated(noblock, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.noblock_.IsDefault()) {
    _impl_.noblock_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListSasRequest.noblock)
}

// string ike = 2;
inline void IPsecListSasRequest::clear_ike() {
  _impl_.ike_.ClearToEmpty();
}
inline const std::string& IPsecListSasRequest::ike() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListSasRequest.ike)
  return _internal_ike();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListSasRequest::set_ike(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ike_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListSasRequest.ike)
}
inline std::string* IPsecListSasRequest::mutable_ike() {
  std::string* _s = _internal_mutable_ike();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListSasRequest.ike)
  return _s;
}
inline const std::string& IPsecListSasRequest::_internal_ike() const {
  return _impl_.ike_.Get();
}
inline void IPsecListSasRequest::_internal_set_ike(const std::string& value) {
  
  _impl_.ike_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListSasRequest::_internal_mutable_ike() {
  
  return _impl_.ike_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListSasRequest::release_ike() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListSasRequest.ike)
  return _impl_.ike_.Release();
}
inline void IPsecListSasRequest::set_allocated_ike(std::string* ike) {
  if (ike != nullptr) {
    
  } else {
    
  }
  _impl_.ike_.SetAllocated(ike, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ike_.IsDefault()) {
    _impl_.ike_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListSasRequest.ike)
}

// uint64 ike_id = 3;
inline void IPsecListSasRequest::clear_ike_id() {
  _impl_.ike_id_ = uint64_t{0u};
}
inline uint64_t IPsecListSasRequest::_internal_ike_id() const {
  return _impl_.ike_id_;
}
inline uint64_t IPsecListSasRequest::ike_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListSasRequest.ike_id)
  return _internal_ike_id();
}
inline void IPsecListSasRequest::_internal_set_ike_id(uint64_t value) {
  
  _impl_.ike_id_ = value;
}
inline void IPsecListSasRequest::set_ike_id(uint64_t value) {
  _internal_set_ike_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListSasRequest.ike_id)
}

// string child = 4;
inline void IPsecListSasRequest::clear_child() {
  _impl_.child_.ClearToEmpty();
}
inline const std::string& IPsecListSasRequest::child() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListSasRequest.child)
  return _internal_child();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListSasRequest::set_child(ArgT0&& arg0, ArgT... args) {
 
 _impl_.child_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListSasRequest.child)
}
inline std::string* IPsecListSasRequest::mutable_child() {
  std::string* _s = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListSasRequest.child)
  return _s;
}
inline const std::string& IPsecListSasRequest::_internal_child() const {
  return _impl_.child_.Get();
}
inline void IPsecListSasRequest::_internal_set_child(const std::string& value) {
  
  _impl_.child_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListSasRequest::_internal_mutable_child() {
  
  return _impl_.child_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListSasRequest::release_child() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListSasRequest.child)
  return _impl_.child_.Release();
}
inline void IPsecListSasRequest::set_allocated_child(std::string* child) {
  if (child != nullptr) {
    
  } else {
    
  }
  _impl_.child_.SetAllocated(child, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.child_.IsDefault()) {
    _impl_.child_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListSasRequest.child)
}

// uint64 child_id = 5;
inline void IPsecListSasRequest::clear_child_id() {
  _impl_.child_id_ = uint64_t{0u};
}
inline uint64_t IPsecListSasRequest::_internal_child_id() const {
  return _impl_.child_id_;
}
inline uint64_t IPsecListSasRequest::child_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListSasRequest.child_id)
  return _internal_child_id();
}
inline void IPsecListSasRequest::_internal_set_child_id(uint64_t value) {
  
  _impl_.child_id_ = value;
}
inline void IPsecListSasRequest::set_child_id(uint64_t value) {
  _internal_set_child_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListSasRequest.child_id)
}

// -------------------------------------------------------------------

// ListChildSa

// string name = 1;
inline void ListChildSa::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListChildSa::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.name)
}
inline std::string* ListChildSa::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.name)
  return _s;
}
inline const std::string& ListChildSa::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListChildSa::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.name)
  return _impl_.name_.Release();
}
inline void ListChildSa::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.name)
}

// string protocol = 2;
inline void ListChildSa::clear_protocol() {
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& ListChildSa::protocol() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_protocol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.protocol)
}
inline std::string* ListChildSa::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.protocol)
  return _s;
}
inline const std::string& ListChildSa::_internal_protocol() const {
  return _impl_.protocol_.Get();
}
inline void ListChildSa::_internal_set_protocol(const std::string& value) {
  
  _impl_.protocol_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_protocol() {
  
  return _impl_.protocol_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_protocol() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.protocol)
  return _impl_.protocol_.Release();
}
inline void ListChildSa::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    
  } else {
    
  }
  _impl_.protocol_.SetAllocated(protocol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocol_.IsDefault()) {
    _impl_.protocol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.protocol)
}

// string encap = 3;
inline void ListChildSa::clear_encap() {
  _impl_.encap_.ClearToEmpty();
}
inline const std::string& ListChildSa::encap() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.encap)
  return _internal_encap();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_encap(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encap_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.encap)
}
inline std::string* ListChildSa::mutable_encap() {
  std::string* _s = _internal_mutable_encap();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.encap)
  return _s;
}
inline const std::string& ListChildSa::_internal_encap() const {
  return _impl_.encap_.Get();
}
inline void ListChildSa::_internal_set_encap(const std::string& value) {
  
  _impl_.encap_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_encap() {
  
  return _impl_.encap_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_encap() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.encap)
  return _impl_.encap_.Release();
}
inline void ListChildSa::set_allocated_encap(std::string* encap) {
  if (encap != nullptr) {
    
  } else {
    
  }
  _impl_.encap_.SetAllocated(encap, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encap_.IsDefault()) {
    _impl_.encap_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.encap)
}

// string spi_in = 4;
inline void ListChildSa::clear_spi_in() {
  _impl_.spi_in_.ClearToEmpty();
}
inline const std::string& ListChildSa::spi_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.spi_in)
  return _internal_spi_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_spi_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spi_in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.spi_in)
}
inline std::string* ListChildSa::mutable_spi_in() {
  std::string* _s = _internal_mutable_spi_in();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.spi_in)
  return _s;
}
inline const std::string& ListChildSa::_internal_spi_in() const {
  return _impl_.spi_in_.Get();
}
inline void ListChildSa::_internal_set_spi_in(const std::string& value) {
  
  _impl_.spi_in_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_spi_in() {
  
  return _impl_.spi_in_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_spi_in() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.spi_in)
  return _impl_.spi_in_.Release();
}
inline void ListChildSa::set_allocated_spi_in(std::string* spi_in) {
  if (spi_in != nullptr) {
    
  } else {
    
  }
  _impl_.spi_in_.SetAllocated(spi_in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spi_in_.IsDefault()) {
    _impl_.spi_in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.spi_in)
}

// string spi_out = 5;
inline void ListChildSa::clear_spi_out() {
  _impl_.spi_out_.ClearToEmpty();
}
inline const std::string& ListChildSa::spi_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.spi_out)
  return _internal_spi_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_spi_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spi_out_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.spi_out)
}
inline std::string* ListChildSa::mutable_spi_out() {
  std::string* _s = _internal_mutable_spi_out();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.spi_out)
  return _s;
}
inline const std::string& ListChildSa::_internal_spi_out() const {
  return _impl_.spi_out_.Get();
}
inline void ListChildSa::_internal_set_spi_out(const std::string& value) {
  
  _impl_.spi_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_spi_out() {
  
  return _impl_.spi_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_spi_out() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.spi_out)
  return _impl_.spi_out_.Release();
}
inline void ListChildSa::set_allocated_spi_out(std::string* spi_out) {
  if (spi_out != nullptr) {
    
  } else {
    
  }
  _impl_.spi_out_.SetAllocated(spi_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spi_out_.IsDefault()) {
    _impl_.spi_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.spi_out)
}

// string cpi_in = 6;
inline void ListChildSa::clear_cpi_in() {
  _impl_.cpi_in_.ClearToEmpty();
}
inline const std::string& ListChildSa::cpi_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.cpi_in)
  return _internal_cpi_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_cpi_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cpi_in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.cpi_in)
}
inline std::string* ListChildSa::mutable_cpi_in() {
  std::string* _s = _internal_mutable_cpi_in();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.cpi_in)
  return _s;
}
inline const std::string& ListChildSa::_internal_cpi_in() const {
  return _impl_.cpi_in_.Get();
}
inline void ListChildSa::_internal_set_cpi_in(const std::string& value) {
  
  _impl_.cpi_in_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_cpi_in() {
  
  return _impl_.cpi_in_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_cpi_in() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.cpi_in)
  return _impl_.cpi_in_.Release();
}
inline void ListChildSa::set_allocated_cpi_in(std::string* cpi_in) {
  if (cpi_in != nullptr) {
    
  } else {
    
  }
  _impl_.cpi_in_.SetAllocated(cpi_in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpi_in_.IsDefault()) {
    _impl_.cpi_in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.cpi_in)
}

// string cpi_out = 7;
inline void ListChildSa::clear_cpi_out() {
  _impl_.cpi_out_.ClearToEmpty();
}
inline const std::string& ListChildSa::cpi_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.cpi_out)
  return _internal_cpi_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_cpi_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cpi_out_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.cpi_out)
}
inline std::string* ListChildSa::mutable_cpi_out() {
  std::string* _s = _internal_mutable_cpi_out();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.cpi_out)
  return _s;
}
inline const std::string& ListChildSa::_internal_cpi_out() const {
  return _impl_.cpi_out_.Get();
}
inline void ListChildSa::_internal_set_cpi_out(const std::string& value) {
  
  _impl_.cpi_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_cpi_out() {
  
  return _impl_.cpi_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_cpi_out() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.cpi_out)
  return _impl_.cpi_out_.Release();
}
inline void ListChildSa::set_allocated_cpi_out(std::string* cpi_out) {
  if (cpi_out != nullptr) {
    
  } else {
    
  }
  _impl_.cpi_out_.SetAllocated(cpi_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpi_out_.IsDefault()) {
    _impl_.cpi_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.cpi_out)
}

// string mark_in = 8;
inline void ListChildSa::clear_mark_in() {
  _impl_.mark_in_.ClearToEmpty();
}
inline const std::string& ListChildSa::mark_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.mark_in)
  return _internal_mark_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_mark_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mark_in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.mark_in)
}
inline std::string* ListChildSa::mutable_mark_in() {
  std::string* _s = _internal_mutable_mark_in();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.mark_in)
  return _s;
}
inline const std::string& ListChildSa::_internal_mark_in() const {
  return _impl_.mark_in_.Get();
}
inline void ListChildSa::_internal_set_mark_in(const std::string& value) {
  
  _impl_.mark_in_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_mark_in() {
  
  return _impl_.mark_in_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_mark_in() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.mark_in)
  return _impl_.mark_in_.Release();
}
inline void ListChildSa::set_allocated_mark_in(std::string* mark_in) {
  if (mark_in != nullptr) {
    
  } else {
    
  }
  _impl_.mark_in_.SetAllocated(mark_in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mark_in_.IsDefault()) {
    _impl_.mark_in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.mark_in)
}

// string mark_mask_in = 9;
inline void ListChildSa::clear_mark_mask_in() {
  _impl_.mark_mask_in_.ClearToEmpty();
}
inline const std::string& ListChildSa::mark_mask_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.mark_mask_in)
  return _internal_mark_mask_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_mark_mask_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mark_mask_in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.mark_mask_in)
}
inline std::string* ListChildSa::mutable_mark_mask_in() {
  std::string* _s = _internal_mutable_mark_mask_in();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.mark_mask_in)
  return _s;
}
inline const std::string& ListChildSa::_internal_mark_mask_in() const {
  return _impl_.mark_mask_in_.Get();
}
inline void ListChildSa::_internal_set_mark_mask_in(const std::string& value) {
  
  _impl_.mark_mask_in_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_mark_mask_in() {
  
  return _impl_.mark_mask_in_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_mark_mask_in() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.mark_mask_in)
  return _impl_.mark_mask_in_.Release();
}
inline void ListChildSa::set_allocated_mark_mask_in(std::string* mark_mask_in) {
  if (mark_mask_in != nullptr) {
    
  } else {
    
  }
  _impl_.mark_mask_in_.SetAllocated(mark_mask_in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mark_mask_in_.IsDefault()) {
    _impl_.mark_mask_in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.mark_mask_in)
}

// string mark_out = 10;
inline void ListChildSa::clear_mark_out() {
  _impl_.mark_out_.ClearToEmpty();
}
inline const std::string& ListChildSa::mark_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.mark_out)
  return _internal_mark_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_mark_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mark_out_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.mark_out)
}
inline std::string* ListChildSa::mutable_mark_out() {
  std::string* _s = _internal_mutable_mark_out();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.mark_out)
  return _s;
}
inline const std::string& ListChildSa::_internal_mark_out() const {
  return _impl_.mark_out_.Get();
}
inline void ListChildSa::_internal_set_mark_out(const std::string& value) {
  
  _impl_.mark_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_mark_out() {
  
  return _impl_.mark_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_mark_out() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.mark_out)
  return _impl_.mark_out_.Release();
}
inline void ListChildSa::set_allocated_mark_out(std::string* mark_out) {
  if (mark_out != nullptr) {
    
  } else {
    
  }
  _impl_.mark_out_.SetAllocated(mark_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mark_out_.IsDefault()) {
    _impl_.mark_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.mark_out)
}

// string mark_mask_out = 11;
inline void ListChildSa::clear_mark_mask_out() {
  _impl_.mark_mask_out_.ClearToEmpty();
}
inline const std::string& ListChildSa::mark_mask_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.mark_mask_out)
  return _internal_mark_mask_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_mark_mask_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mark_mask_out_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.mark_mask_out)
}
inline std::string* ListChildSa::mutable_mark_mask_out() {
  std::string* _s = _internal_mutable_mark_mask_out();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.mark_mask_out)
  return _s;
}
inline const std::string& ListChildSa::_internal_mark_mask_out() const {
  return _impl_.mark_mask_out_.Get();
}
inline void ListChildSa::_internal_set_mark_mask_out(const std::string& value) {
  
  _impl_.mark_mask_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_mark_mask_out() {
  
  return _impl_.mark_mask_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_mark_mask_out() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.mark_mask_out)
  return _impl_.mark_mask_out_.Release();
}
inline void ListChildSa::set_allocated_mark_mask_out(std::string* mark_mask_out) {
  if (mark_mask_out != nullptr) {
    
  } else {
    
  }
  _impl_.mark_mask_out_.SetAllocated(mark_mask_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mark_mask_out_.IsDefault()) {
    _impl_.mark_mask_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.mark_mask_out)
}

// string if_id_in = 12;
inline void ListChildSa::clear_if_id_in() {
  _impl_.if_id_in_.ClearToEmpty();
}
inline const std::string& ListChildSa::if_id_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.if_id_in)
  return _internal_if_id_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_if_id_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.if_id_in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.if_id_in)
}
inline std::string* ListChildSa::mutable_if_id_in() {
  std::string* _s = _internal_mutable_if_id_in();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.if_id_in)
  return _s;
}
inline const std::string& ListChildSa::_internal_if_id_in() const {
  return _impl_.if_id_in_.Get();
}
inline void ListChildSa::_internal_set_if_id_in(const std::string& value) {
  
  _impl_.if_id_in_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_if_id_in() {
  
  return _impl_.if_id_in_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_if_id_in() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.if_id_in)
  return _impl_.if_id_in_.Release();
}
inline void ListChildSa::set_allocated_if_id_in(std::string* if_id_in) {
  if (if_id_in != nullptr) {
    
  } else {
    
  }
  _impl_.if_id_in_.SetAllocated(if_id_in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.if_id_in_.IsDefault()) {
    _impl_.if_id_in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.if_id_in)
}

// string if_id_out = 13;
inline void ListChildSa::clear_if_id_out() {
  _impl_.if_id_out_.ClearToEmpty();
}
inline const std::string& ListChildSa::if_id_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.if_id_out)
  return _internal_if_id_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_if_id_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.if_id_out_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.if_id_out)
}
inline std::string* ListChildSa::mutable_if_id_out() {
  std::string* _s = _internal_mutable_if_id_out();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.if_id_out)
  return _s;
}
inline const std::string& ListChildSa::_internal_if_id_out() const {
  return _impl_.if_id_out_.Get();
}
inline void ListChildSa::_internal_set_if_id_out(const std::string& value) {
  
  _impl_.if_id_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_if_id_out() {
  
  return _impl_.if_id_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_if_id_out() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.if_id_out)
  return _impl_.if_id_out_.Release();
}
inline void ListChildSa::set_allocated_if_id_out(std::string* if_id_out) {
  if (if_id_out != nullptr) {
    
  } else {
    
  }
  _impl_.if_id_out_.SetAllocated(if_id_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.if_id_out_.IsDefault()) {
    _impl_.if_id_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.if_id_out)
}

// string encr_alg = 14;
inline void ListChildSa::clear_encr_alg() {
  _impl_.encr_alg_.ClearToEmpty();
}
inline const std::string& ListChildSa::encr_alg() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.encr_alg)
  return _internal_encr_alg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_encr_alg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encr_alg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.encr_alg)
}
inline std::string* ListChildSa::mutable_encr_alg() {
  std::string* _s = _internal_mutable_encr_alg();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.encr_alg)
  return _s;
}
inline const std::string& ListChildSa::_internal_encr_alg() const {
  return _impl_.encr_alg_.Get();
}
inline void ListChildSa::_internal_set_encr_alg(const std::string& value) {
  
  _impl_.encr_alg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_encr_alg() {
  
  return _impl_.encr_alg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_encr_alg() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.encr_alg)
  return _impl_.encr_alg_.Release();
}
inline void ListChildSa::set_allocated_encr_alg(std::string* encr_alg) {
  if (encr_alg != nullptr) {
    
  } else {
    
  }
  _impl_.encr_alg_.SetAllocated(encr_alg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encr_alg_.IsDefault()) {
    _impl_.encr_alg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.encr_alg)
}

// string encr_keysize = 15;
inline void ListChildSa::clear_encr_keysize() {
  _impl_.encr_keysize_.ClearToEmpty();
}
inline const std::string& ListChildSa::encr_keysize() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.encr_keysize)
  return _internal_encr_keysize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_encr_keysize(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encr_keysize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.encr_keysize)
}
inline std::string* ListChildSa::mutable_encr_keysize() {
  std::string* _s = _internal_mutable_encr_keysize();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.encr_keysize)
  return _s;
}
inline const std::string& ListChildSa::_internal_encr_keysize() const {
  return _impl_.encr_keysize_.Get();
}
inline void ListChildSa::_internal_set_encr_keysize(const std::string& value) {
  
  _impl_.encr_keysize_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_encr_keysize() {
  
  return _impl_.encr_keysize_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_encr_keysize() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.encr_keysize)
  return _impl_.encr_keysize_.Release();
}
inline void ListChildSa::set_allocated_encr_keysize(std::string* encr_keysize) {
  if (encr_keysize != nullptr) {
    
  } else {
    
  }
  _impl_.encr_keysize_.SetAllocated(encr_keysize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encr_keysize_.IsDefault()) {
    _impl_.encr_keysize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.encr_keysize)
}

// string integ_alg = 16;
inline void ListChildSa::clear_integ_alg() {
  _impl_.integ_alg_.ClearToEmpty();
}
inline const std::string& ListChildSa::integ_alg() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.integ_alg)
  return _internal_integ_alg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_integ_alg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.integ_alg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.integ_alg)
}
inline std::string* ListChildSa::mutable_integ_alg() {
  std::string* _s = _internal_mutable_integ_alg();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.integ_alg)
  return _s;
}
inline const std::string& ListChildSa::_internal_integ_alg() const {
  return _impl_.integ_alg_.Get();
}
inline void ListChildSa::_internal_set_integ_alg(const std::string& value) {
  
  _impl_.integ_alg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_integ_alg() {
  
  return _impl_.integ_alg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_integ_alg() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.integ_alg)
  return _impl_.integ_alg_.Release();
}
inline void ListChildSa::set_allocated_integ_alg(std::string* integ_alg) {
  if (integ_alg != nullptr) {
    
  } else {
    
  }
  _impl_.integ_alg_.SetAllocated(integ_alg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.integ_alg_.IsDefault()) {
    _impl_.integ_alg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.integ_alg)
}

// string integ_keysize = 17;
inline void ListChildSa::clear_integ_keysize() {
  _impl_.integ_keysize_.ClearToEmpty();
}
inline const std::string& ListChildSa::integ_keysize() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.integ_keysize)
  return _internal_integ_keysize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_integ_keysize(ArgT0&& arg0, ArgT... args) {
 
 _impl_.integ_keysize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.integ_keysize)
}
inline std::string* ListChildSa::mutable_integ_keysize() {
  std::string* _s = _internal_mutable_integ_keysize();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.integ_keysize)
  return _s;
}
inline const std::string& ListChildSa::_internal_integ_keysize() const {
  return _impl_.integ_keysize_.Get();
}
inline void ListChildSa::_internal_set_integ_keysize(const std::string& value) {
  
  _impl_.integ_keysize_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_integ_keysize() {
  
  return _impl_.integ_keysize_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_integ_keysize() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.integ_keysize)
  return _impl_.integ_keysize_.Release();
}
inline void ListChildSa::set_allocated_integ_keysize(std::string* integ_keysize) {
  if (integ_keysize != nullptr) {
    
  } else {
    
  }
  _impl_.integ_keysize_.SetAllocated(integ_keysize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.integ_keysize_.IsDefault()) {
    _impl_.integ_keysize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.integ_keysize)
}

// string dh_group = 18;
inline void ListChildSa::clear_dh_group() {
  _impl_.dh_group_.ClearToEmpty();
}
inline const std::string& ListChildSa::dh_group() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.dh_group)
  return _internal_dh_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_dh_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dh_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.dh_group)
}
inline std::string* ListChildSa::mutable_dh_group() {
  std::string* _s = _internal_mutable_dh_group();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.dh_group)
  return _s;
}
inline const std::string& ListChildSa::_internal_dh_group() const {
  return _impl_.dh_group_.Get();
}
inline void ListChildSa::_internal_set_dh_group(const std::string& value) {
  
  _impl_.dh_group_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_dh_group() {
  
  return _impl_.dh_group_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_dh_group() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.dh_group)
  return _impl_.dh_group_.Release();
}
inline void ListChildSa::set_allocated_dh_group(std::string* dh_group) {
  if (dh_group != nullptr) {
    
  } else {
    
  }
  _impl_.dh_group_.SetAllocated(dh_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dh_group_.IsDefault()) {
    _impl_.dh_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.dh_group)
}

// string esn = 19;
inline void ListChildSa::clear_esn() {
  _impl_.esn_.ClearToEmpty();
}
inline const std::string& ListChildSa::esn() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChildSa.esn)
  return _internal_esn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChildSa::set_esn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.esn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChildSa.esn)
}
inline std::string* ListChildSa::mutable_esn() {
  std::string* _s = _internal_mutable_esn();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChildSa.esn)
  return _s;
}
inline const std::string& ListChildSa::_internal_esn() const {
  return _impl_.esn_.Get();
}
inline void ListChildSa::_internal_set_esn(const std::string& value) {
  
  _impl_.esn_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChildSa::_internal_mutable_esn() {
  
  return _impl_.esn_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChildSa::release_esn() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChildSa.esn)
  return _impl_.esn_.Release();
}
inline void ListChildSa::set_allocated_esn(std::string* esn) {
  if (esn != nullptr) {
    
  } else {
    
  }
  _impl_.esn_.SetAllocated(esn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.esn_.IsDefault()) {
    _impl_.esn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChildSa.esn)
}

// -------------------------------------------------------------------

// ListIkeSa

// string name = 1;
inline void ListIkeSa::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListIkeSa::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.name)
}
inline std::string* ListIkeSa::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.name)
  return _s;
}
inline const std::string& ListIkeSa::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListIkeSa::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.name)
  return _impl_.name_.Release();
}
inline void ListIkeSa::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.name)
}

// string uniqueid = 2;
inline void ListIkeSa::clear_uniqueid() {
  _impl_.uniqueid_.ClearToEmpty();
}
inline const std::string& ListIkeSa::uniqueid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.uniqueid)
  return _internal_uniqueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_uniqueid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uniqueid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.uniqueid)
}
inline std::string* ListIkeSa::mutable_uniqueid() {
  std::string* _s = _internal_mutable_uniqueid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.uniqueid)
  return _s;
}
inline const std::string& ListIkeSa::_internal_uniqueid() const {
  return _impl_.uniqueid_.Get();
}
inline void ListIkeSa::_internal_set_uniqueid(const std::string& value) {
  
  _impl_.uniqueid_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_uniqueid() {
  
  return _impl_.uniqueid_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_uniqueid() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.uniqueid)
  return _impl_.uniqueid_.Release();
}
inline void ListIkeSa::set_allocated_uniqueid(std::string* uniqueid) {
  if (uniqueid != nullptr) {
    
  } else {
    
  }
  _impl_.uniqueid_.SetAllocated(uniqueid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueid_.IsDefault()) {
    _impl_.uniqueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.uniqueid)
}

// string version = 3;
inline void ListIkeSa::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ListIkeSa::version() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.version)
}
inline std::string* ListIkeSa::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.version)
  return _s;
}
inline const std::string& ListIkeSa::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ListIkeSa::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_version() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.version)
  return _impl_.version_.Release();
}
inline void ListIkeSa::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.version)
}

// .opi_api.security.v1.IkeSaState ikestate = 4;
inline void ListIkeSa::clear_ikestate() {
  _impl_.ikestate_ = 0;
}
inline ::opi_api::security::v1::IkeSaState ListIkeSa::_internal_ikestate() const {
  return static_cast< ::opi_api::security::v1::IkeSaState >(_impl_.ikestate_);
}
inline ::opi_api::security::v1::IkeSaState ListIkeSa::ikestate() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.ikestate)
  return _internal_ikestate();
}
inline void ListIkeSa::_internal_set_ikestate(::opi_api::security::v1::IkeSaState value) {
  
  _impl_.ikestate_ = value;
}
inline void ListIkeSa::set_ikestate(::opi_api::security::v1::IkeSaState value) {
  _internal_set_ikestate(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.ikestate)
}

// string local_host = 5;
inline void ListIkeSa::clear_local_host() {
  _impl_.local_host_.ClearToEmpty();
}
inline const std::string& ListIkeSa::local_host() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.local_host)
  return _internal_local_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_local_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.local_host)
}
inline std::string* ListIkeSa::mutable_local_host() {
  std::string* _s = _internal_mutable_local_host();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.local_host)
  return _s;
}
inline const std::string& ListIkeSa::_internal_local_host() const {
  return _impl_.local_host_.Get();
}
inline void ListIkeSa::_internal_set_local_host(const std::string& value) {
  
  _impl_.local_host_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_local_host() {
  
  return _impl_.local_host_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_local_host() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.local_host)
  return _impl_.local_host_.Release();
}
inline void ListIkeSa::set_allocated_local_host(std::string* local_host) {
  if (local_host != nullptr) {
    
  } else {
    
  }
  _impl_.local_host_.SetAllocated(local_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_host_.IsDefault()) {
    _impl_.local_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.local_host)
}

// string local_port = 6;
inline void ListIkeSa::clear_local_port() {
  _impl_.local_port_.ClearToEmpty();
}
inline const std::string& ListIkeSa::local_port() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.local_port)
  return _internal_local_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_local_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.local_port)
}
inline std::string* ListIkeSa::mutable_local_port() {
  std::string* _s = _internal_mutable_local_port();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.local_port)
  return _s;
}
inline const std::string& ListIkeSa::_internal_local_port() const {
  return _impl_.local_port_.Get();
}
inline void ListIkeSa::_internal_set_local_port(const std::string& value) {
  
  _impl_.local_port_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_local_port() {
  
  return _impl_.local_port_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_local_port() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.local_port)
  return _impl_.local_port_.Release();
}
inline void ListIkeSa::set_allocated_local_port(std::string* local_port) {
  if (local_port != nullptr) {
    
  } else {
    
  }
  _impl_.local_port_.SetAllocated(local_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_port_.IsDefault()) {
    _impl_.local_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.local_port)
}

// string local_id = 7;
inline void ListIkeSa::clear_local_id() {
  _impl_.local_id_.ClearToEmpty();
}
inline const std::string& ListIkeSa::local_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.local_id)
  return _internal_local_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_local_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.local_id)
}
inline std::string* ListIkeSa::mutable_local_id() {
  std::string* _s = _internal_mutable_local_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.local_id)
  return _s;
}
inline const std::string& ListIkeSa::_internal_local_id() const {
  return _impl_.local_id_.Get();
}
inline void ListIkeSa::_internal_set_local_id(const std::string& value) {
  
  _impl_.local_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_local_id() {
  
  return _impl_.local_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_local_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.local_id)
  return _impl_.local_id_.Release();
}
inline void ListIkeSa::set_allocated_local_id(std::string* local_id) {
  if (local_id != nullptr) {
    
  } else {
    
  }
  _impl_.local_id_.SetAllocated(local_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_id_.IsDefault()) {
    _impl_.local_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.local_id)
}

// string remote_host = 8;
inline void ListIkeSa::clear_remote_host() {
  _impl_.remote_host_.ClearToEmpty();
}
inline const std::string& ListIkeSa::remote_host() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.remote_host)
  return _internal_remote_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_remote_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_host)
}
inline std::string* ListIkeSa::mutable_remote_host() {
  std::string* _s = _internal_mutable_remote_host();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.remote_host)
  return _s;
}
inline const std::string& ListIkeSa::_internal_remote_host() const {
  return _impl_.remote_host_.Get();
}
inline void ListIkeSa::_internal_set_remote_host(const std::string& value) {
  
  _impl_.remote_host_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_remote_host() {
  
  return _impl_.remote_host_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_remote_host() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.remote_host)
  return _impl_.remote_host_.Release();
}
inline void ListIkeSa::set_allocated_remote_host(std::string* remote_host) {
  if (remote_host != nullptr) {
    
  } else {
    
  }
  _impl_.remote_host_.SetAllocated(remote_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_host_.IsDefault()) {
    _impl_.remote_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.remote_host)
}

// string remote_port = 9;
inline void ListIkeSa::clear_remote_port() {
  _impl_.remote_port_.ClearToEmpty();
}
inline const std::string& ListIkeSa::remote_port() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.remote_port)
  return _internal_remote_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_remote_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_port)
}
inline std::string* ListIkeSa::mutable_remote_port() {
  std::string* _s = _internal_mutable_remote_port();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.remote_port)
  return _s;
}
inline const std::string& ListIkeSa::_internal_remote_port() const {
  return _impl_.remote_port_.Get();
}
inline void ListIkeSa::_internal_set_remote_port(const std::string& value) {
  
  _impl_.remote_port_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_remote_port() {
  
  return _impl_.remote_port_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_remote_port() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.remote_port)
  return _impl_.remote_port_.Release();
}
inline void ListIkeSa::set_allocated_remote_port(std::string* remote_port) {
  if (remote_port != nullptr) {
    
  } else {
    
  }
  _impl_.remote_port_.SetAllocated(remote_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_port_.IsDefault()) {
    _impl_.remote_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.remote_port)
}

// string remote_id = 10;
inline void ListIkeSa::clear_remote_id() {
  _impl_.remote_id_.ClearToEmpty();
}
inline const std::string& ListIkeSa::remote_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.remote_id)
  return _internal_remote_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_remote_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_id)
}
inline std::string* ListIkeSa::mutable_remote_id() {
  std::string* _s = _internal_mutable_remote_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.remote_id)
  return _s;
}
inline const std::string& ListIkeSa::_internal_remote_id() const {
  return _impl_.remote_id_.Get();
}
inline void ListIkeSa::_internal_set_remote_id(const std::string& value) {
  
  _impl_.remote_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_remote_id() {
  
  return _impl_.remote_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_remote_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.remote_id)
  return _impl_.remote_id_.Release();
}
inline void ListIkeSa::set_allocated_remote_id(std::string* remote_id) {
  if (remote_id != nullptr) {
    
  } else {
    
  }
  _impl_.remote_id_.SetAllocated(remote_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_id_.IsDefault()) {
    _impl_.remote_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.remote_id)
}

// string remote_xauth_id = 11;
inline void ListIkeSa::clear_remote_xauth_id() {
  _impl_.remote_xauth_id_.ClearToEmpty();
}
inline const std::string& ListIkeSa::remote_xauth_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.remote_xauth_id)
  return _internal_remote_xauth_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_remote_xauth_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_xauth_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_xauth_id)
}
inline std::string* ListIkeSa::mutable_remote_xauth_id() {
  std::string* _s = _internal_mutable_remote_xauth_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.remote_xauth_id)
  return _s;
}
inline const std::string& ListIkeSa::_internal_remote_xauth_id() const {
  return _impl_.remote_xauth_id_.Get();
}
inline void ListIkeSa::_internal_set_remote_xauth_id(const std::string& value) {
  
  _impl_.remote_xauth_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_remote_xauth_id() {
  
  return _impl_.remote_xauth_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_remote_xauth_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.remote_xauth_id)
  return _impl_.remote_xauth_id_.Release();
}
inline void ListIkeSa::set_allocated_remote_xauth_id(std::string* remote_xauth_id) {
  if (remote_xauth_id != nullptr) {
    
  } else {
    
  }
  _impl_.remote_xauth_id_.SetAllocated(remote_xauth_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_xauth_id_.IsDefault()) {
    _impl_.remote_xauth_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.remote_xauth_id)
}

// string remote_eap_id = 12;
inline void ListIkeSa::clear_remote_eap_id() {
  _impl_.remote_eap_id_.ClearToEmpty();
}
inline const std::string& ListIkeSa::remote_eap_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.remote_eap_id)
  return _internal_remote_eap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_remote_eap_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_eap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_eap_id)
}
inline std::string* ListIkeSa::mutable_remote_eap_id() {
  std::string* _s = _internal_mutable_remote_eap_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.remote_eap_id)
  return _s;
}
inline const std::string& ListIkeSa::_internal_remote_eap_id() const {
  return _impl_.remote_eap_id_.Get();
}
inline void ListIkeSa::_internal_set_remote_eap_id(const std::string& value) {
  
  _impl_.remote_eap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_remote_eap_id() {
  
  return _impl_.remote_eap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_remote_eap_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.remote_eap_id)
  return _impl_.remote_eap_id_.Release();
}
inline void ListIkeSa::set_allocated_remote_eap_id(std::string* remote_eap_id) {
  if (remote_eap_id != nullptr) {
    
  } else {
    
  }
  _impl_.remote_eap_id_.SetAllocated(remote_eap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_eap_id_.IsDefault()) {
    _impl_.remote_eap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.remote_eap_id)
}

// string initiator = 13;
inline void ListIkeSa::clear_initiator() {
  _impl_.initiator_.ClearToEmpty();
}
inline const std::string& ListIkeSa::initiator() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.initiator)
  return _internal_initiator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_initiator(ArgT0&& arg0, ArgT... args) {
 
 _impl_.initiator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.initiator)
}
inline std::string* ListIkeSa::mutable_initiator() {
  std::string* _s = _internal_mutable_initiator();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.initiator)
  return _s;
}
inline const std::string& ListIkeSa::_internal_initiator() const {
  return _impl_.initiator_.Get();
}
inline void ListIkeSa::_internal_set_initiator(const std::string& value) {
  
  _impl_.initiator_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_initiator() {
  
  return _impl_.initiator_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_initiator() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.initiator)
  return _impl_.initiator_.Release();
}
inline void ListIkeSa::set_allocated_initiator(std::string* initiator) {
  if (initiator != nullptr) {
    
  } else {
    
  }
  _impl_.initiator_.SetAllocated(initiator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initiator_.IsDefault()) {
    _impl_.initiator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.initiator)
}

// string initiator_spi = 14;
inline void ListIkeSa::clear_initiator_spi() {
  _impl_.initiator_spi_.ClearToEmpty();
}
inline const std::string& ListIkeSa::initiator_spi() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.initiator_spi)
  return _internal_initiator_spi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_initiator_spi(ArgT0&& arg0, ArgT... args) {
 
 _impl_.initiator_spi_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.initiator_spi)
}
inline std::string* ListIkeSa::mutable_initiator_spi() {
  std::string* _s = _internal_mutable_initiator_spi();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.initiator_spi)
  return _s;
}
inline const std::string& ListIkeSa::_internal_initiator_spi() const {
  return _impl_.initiator_spi_.Get();
}
inline void ListIkeSa::_internal_set_initiator_spi(const std::string& value) {
  
  _impl_.initiator_spi_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_initiator_spi() {
  
  return _impl_.initiator_spi_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_initiator_spi() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.initiator_spi)
  return _impl_.initiator_spi_.Release();
}
inline void ListIkeSa::set_allocated_initiator_spi(std::string* initiator_spi) {
  if (initiator_spi != nullptr) {
    
  } else {
    
  }
  _impl_.initiator_spi_.SetAllocated(initiator_spi, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initiator_spi_.IsDefault()) {
    _impl_.initiator_spi_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.initiator_spi)
}

// string responder_spi = 15;
inline void ListIkeSa::clear_responder_spi() {
  _impl_.responder_spi_.ClearToEmpty();
}
inline const std::string& ListIkeSa::responder_spi() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.responder_spi)
  return _internal_responder_spi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_responder_spi(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responder_spi_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.responder_spi)
}
inline std::string* ListIkeSa::mutable_responder_spi() {
  std::string* _s = _internal_mutable_responder_spi();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.responder_spi)
  return _s;
}
inline const std::string& ListIkeSa::_internal_responder_spi() const {
  return _impl_.responder_spi_.Get();
}
inline void ListIkeSa::_internal_set_responder_spi(const std::string& value) {
  
  _impl_.responder_spi_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_responder_spi() {
  
  return _impl_.responder_spi_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_responder_spi() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.responder_spi)
  return _impl_.responder_spi_.Release();
}
inline void ListIkeSa::set_allocated_responder_spi(std::string* responder_spi) {
  if (responder_spi != nullptr) {
    
  } else {
    
  }
  _impl_.responder_spi_.SetAllocated(responder_spi, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responder_spi_.IsDefault()) {
    _impl_.responder_spi_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.responder_spi)
}

// string nat_local = 16;
inline void ListIkeSa::clear_nat_local() {
  _impl_.nat_local_.ClearToEmpty();
}
inline const std::string& ListIkeSa::nat_local() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.nat_local)
  return _internal_nat_local();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_nat_local(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nat_local_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.nat_local)
}
inline std::string* ListIkeSa::mutable_nat_local() {
  std::string* _s = _internal_mutable_nat_local();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.nat_local)
  return _s;
}
inline const std::string& ListIkeSa::_internal_nat_local() const {
  return _impl_.nat_local_.Get();
}
inline void ListIkeSa::_internal_set_nat_local(const std::string& value) {
  
  _impl_.nat_local_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_nat_local() {
  
  return _impl_.nat_local_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_nat_local() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.nat_local)
  return _impl_.nat_local_.Release();
}
inline void ListIkeSa::set_allocated_nat_local(std::string* nat_local) {
  if (nat_local != nullptr) {
    
  } else {
    
  }
  _impl_.nat_local_.SetAllocated(nat_local, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nat_local_.IsDefault()) {
    _impl_.nat_local_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.nat_local)
}

// string nat_remote = 17;
inline void ListIkeSa::clear_nat_remote() {
  _impl_.nat_remote_.ClearToEmpty();
}
inline const std::string& ListIkeSa::nat_remote() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.nat_remote)
  return _internal_nat_remote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_nat_remote(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nat_remote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.nat_remote)
}
inline std::string* ListIkeSa::mutable_nat_remote() {
  std::string* _s = _internal_mutable_nat_remote();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.nat_remote)
  return _s;
}
inline const std::string& ListIkeSa::_internal_nat_remote() const {
  return _impl_.nat_remote_.Get();
}
inline void ListIkeSa::_internal_set_nat_remote(const std::string& value) {
  
  _impl_.nat_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_nat_remote() {
  
  return _impl_.nat_remote_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_nat_remote() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.nat_remote)
  return _impl_.nat_remote_.Release();
}
inline void ListIkeSa::set_allocated_nat_remote(std::string* nat_remote) {
  if (nat_remote != nullptr) {
    
  } else {
    
  }
  _impl_.nat_remote_.SetAllocated(nat_remote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nat_remote_.IsDefault()) {
    _impl_.nat_remote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.nat_remote)
}

// string nat_fake = 18;
inline void ListIkeSa::clear_nat_fake() {
  _impl_.nat_fake_.ClearToEmpty();
}
inline const std::string& ListIkeSa::nat_fake() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.nat_fake)
  return _internal_nat_fake();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_nat_fake(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nat_fake_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.nat_fake)
}
inline std::string* ListIkeSa::mutable_nat_fake() {
  std::string* _s = _internal_mutable_nat_fake();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.nat_fake)
  return _s;
}
inline const std::string& ListIkeSa::_internal_nat_fake() const {
  return _impl_.nat_fake_.Get();
}
inline void ListIkeSa::_internal_set_nat_fake(const std::string& value) {
  
  _impl_.nat_fake_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_nat_fake() {
  
  return _impl_.nat_fake_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_nat_fake() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.nat_fake)
  return _impl_.nat_fake_.Release();
}
inline void ListIkeSa::set_allocated_nat_fake(std::string* nat_fake) {
  if (nat_fake != nullptr) {
    
  } else {
    
  }
  _impl_.nat_fake_.SetAllocated(nat_fake, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nat_fake_.IsDefault()) {
    _impl_.nat_fake_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.nat_fake)
}

// string nat_any = 19;
inline void ListIkeSa::clear_nat_any() {
  _impl_.nat_any_.ClearToEmpty();
}
inline const std::string& ListIkeSa::nat_any() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.nat_any)
  return _internal_nat_any();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_nat_any(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nat_any_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.nat_any)
}
inline std::string* ListIkeSa::mutable_nat_any() {
  std::string* _s = _internal_mutable_nat_any();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.nat_any)
  return _s;
}
inline const std::string& ListIkeSa::_internal_nat_any() const {
  return _impl_.nat_any_.Get();
}
inline void ListIkeSa::_internal_set_nat_any(const std::string& value) {
  
  _impl_.nat_any_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_nat_any() {
  
  return _impl_.nat_any_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_nat_any() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.nat_any)
  return _impl_.nat_any_.Release();
}
inline void ListIkeSa::set_allocated_nat_any(std::string* nat_any) {
  if (nat_any != nullptr) {
    
  } else {
    
  }
  _impl_.nat_any_.SetAllocated(nat_any, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nat_any_.IsDefault()) {
    _impl_.nat_any_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.nat_any)
}

// string if_id_in = 20;
inline void ListIkeSa::clear_if_id_in() {
  _impl_.if_id_in_.ClearToEmpty();
}
inline const std::string& ListIkeSa::if_id_in() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.if_id_in)
  return _internal_if_id_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_if_id_in(ArgT0&& arg0, ArgT... args) {
 
 _impl_.if_id_in_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.if_id_in)
}
inline std::string* ListIkeSa::mutable_if_id_in() {
  std::string* _s = _internal_mutable_if_id_in();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.if_id_in)
  return _s;
}
inline const std::string& ListIkeSa::_internal_if_id_in() const {
  return _impl_.if_id_in_.Get();
}
inline void ListIkeSa::_internal_set_if_id_in(const std::string& value) {
  
  _impl_.if_id_in_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_if_id_in() {
  
  return _impl_.if_id_in_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_if_id_in() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.if_id_in)
  return _impl_.if_id_in_.Release();
}
inline void ListIkeSa::set_allocated_if_id_in(std::string* if_id_in) {
  if (if_id_in != nullptr) {
    
  } else {
    
  }
  _impl_.if_id_in_.SetAllocated(if_id_in, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.if_id_in_.IsDefault()) {
    _impl_.if_id_in_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.if_id_in)
}

// string if_id_out = 21;
inline void ListIkeSa::clear_if_id_out() {
  _impl_.if_id_out_.ClearToEmpty();
}
inline const std::string& ListIkeSa::if_id_out() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.if_id_out)
  return _internal_if_id_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_if_id_out(ArgT0&& arg0, ArgT... args) {
 
 _impl_.if_id_out_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.if_id_out)
}
inline std::string* ListIkeSa::mutable_if_id_out() {
  std::string* _s = _internal_mutable_if_id_out();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.if_id_out)
  return _s;
}
inline const std::string& ListIkeSa::_internal_if_id_out() const {
  return _impl_.if_id_out_.Get();
}
inline void ListIkeSa::_internal_set_if_id_out(const std::string& value) {
  
  _impl_.if_id_out_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_if_id_out() {
  
  return _impl_.if_id_out_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_if_id_out() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.if_id_out)
  return _impl_.if_id_out_.Release();
}
inline void ListIkeSa::set_allocated_if_id_out(std::string* if_id_out) {
  if (if_id_out != nullptr) {
    
  } else {
    
  }
  _impl_.if_id_out_.SetAllocated(if_id_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.if_id_out_.IsDefault()) {
    _impl_.if_id_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.if_id_out)
}

// string encr_alg = 22;
inline void ListIkeSa::clear_encr_alg() {
  _impl_.encr_alg_.ClearToEmpty();
}
inline const std::string& ListIkeSa::encr_alg() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.encr_alg)
  return _internal_encr_alg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_encr_alg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encr_alg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.encr_alg)
}
inline std::string* ListIkeSa::mutable_encr_alg() {
  std::string* _s = _internal_mutable_encr_alg();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.encr_alg)
  return _s;
}
inline const std::string& ListIkeSa::_internal_encr_alg() const {
  return _impl_.encr_alg_.Get();
}
inline void ListIkeSa::_internal_set_encr_alg(const std::string& value) {
  
  _impl_.encr_alg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_encr_alg() {
  
  return _impl_.encr_alg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_encr_alg() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.encr_alg)
  return _impl_.encr_alg_.Release();
}
inline void ListIkeSa::set_allocated_encr_alg(std::string* encr_alg) {
  if (encr_alg != nullptr) {
    
  } else {
    
  }
  _impl_.encr_alg_.SetAllocated(encr_alg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encr_alg_.IsDefault()) {
    _impl_.encr_alg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.encr_alg)
}

// string encr_keysize = 23;
inline void ListIkeSa::clear_encr_keysize() {
  _impl_.encr_keysize_.ClearToEmpty();
}
inline const std::string& ListIkeSa::encr_keysize() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.encr_keysize)
  return _internal_encr_keysize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_encr_keysize(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encr_keysize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.encr_keysize)
}
inline std::string* ListIkeSa::mutable_encr_keysize() {
  std::string* _s = _internal_mutable_encr_keysize();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.encr_keysize)
  return _s;
}
inline const std::string& ListIkeSa::_internal_encr_keysize() const {
  return _impl_.encr_keysize_.Get();
}
inline void ListIkeSa::_internal_set_encr_keysize(const std::string& value) {
  
  _impl_.encr_keysize_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_encr_keysize() {
  
  return _impl_.encr_keysize_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_encr_keysize() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.encr_keysize)
  return _impl_.encr_keysize_.Release();
}
inline void ListIkeSa::set_allocated_encr_keysize(std::string* encr_keysize) {
  if (encr_keysize != nullptr) {
    
  } else {
    
  }
  _impl_.encr_keysize_.SetAllocated(encr_keysize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encr_keysize_.IsDefault()) {
    _impl_.encr_keysize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.encr_keysize)
}

// string integ_alg = 24;
inline void ListIkeSa::clear_integ_alg() {
  _impl_.integ_alg_.ClearToEmpty();
}
inline const std::string& ListIkeSa::integ_alg() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.integ_alg)
  return _internal_integ_alg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_integ_alg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.integ_alg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.integ_alg)
}
inline std::string* ListIkeSa::mutable_integ_alg() {
  std::string* _s = _internal_mutable_integ_alg();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.integ_alg)
  return _s;
}
inline const std::string& ListIkeSa::_internal_integ_alg() const {
  return _impl_.integ_alg_.Get();
}
inline void ListIkeSa::_internal_set_integ_alg(const std::string& value) {
  
  _impl_.integ_alg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_integ_alg() {
  
  return _impl_.integ_alg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_integ_alg() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.integ_alg)
  return _impl_.integ_alg_.Release();
}
inline void ListIkeSa::set_allocated_integ_alg(std::string* integ_alg) {
  if (integ_alg != nullptr) {
    
  } else {
    
  }
  _impl_.integ_alg_.SetAllocated(integ_alg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.integ_alg_.IsDefault()) {
    _impl_.integ_alg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.integ_alg)
}

// string integ_keysize = 25;
inline void ListIkeSa::clear_integ_keysize() {
  _impl_.integ_keysize_.ClearToEmpty();
}
inline const std::string& ListIkeSa::integ_keysize() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.integ_keysize)
  return _internal_integ_keysize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_integ_keysize(ArgT0&& arg0, ArgT... args) {
 
 _impl_.integ_keysize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.integ_keysize)
}
inline std::string* ListIkeSa::mutable_integ_keysize() {
  std::string* _s = _internal_mutable_integ_keysize();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.integ_keysize)
  return _s;
}
inline const std::string& ListIkeSa::_internal_integ_keysize() const {
  return _impl_.integ_keysize_.Get();
}
inline void ListIkeSa::_internal_set_integ_keysize(const std::string& value) {
  
  _impl_.integ_keysize_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_integ_keysize() {
  
  return _impl_.integ_keysize_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_integ_keysize() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.integ_keysize)
  return _impl_.integ_keysize_.Release();
}
inline void ListIkeSa::set_allocated_integ_keysize(std::string* integ_keysize) {
  if (integ_keysize != nullptr) {
    
  } else {
    
  }
  _impl_.integ_keysize_.SetAllocated(integ_keysize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.integ_keysize_.IsDefault()) {
    _impl_.integ_keysize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.integ_keysize)
}

// string prf_alg = 26;
inline void ListIkeSa::clear_prf_alg() {
  _impl_.prf_alg_.ClearToEmpty();
}
inline const std::string& ListIkeSa::prf_alg() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.prf_alg)
  return _internal_prf_alg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_prf_alg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prf_alg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.prf_alg)
}
inline std::string* ListIkeSa::mutable_prf_alg() {
  std::string* _s = _internal_mutable_prf_alg();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.prf_alg)
  return _s;
}
inline const std::string& ListIkeSa::_internal_prf_alg() const {
  return _impl_.prf_alg_.Get();
}
inline void ListIkeSa::_internal_set_prf_alg(const std::string& value) {
  
  _impl_.prf_alg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_prf_alg() {
  
  return _impl_.prf_alg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_prf_alg() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.prf_alg)
  return _impl_.prf_alg_.Release();
}
inline void ListIkeSa::set_allocated_prf_alg(std::string* prf_alg) {
  if (prf_alg != nullptr) {
    
  } else {
    
  }
  _impl_.prf_alg_.SetAllocated(prf_alg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prf_alg_.IsDefault()) {
    _impl_.prf_alg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.prf_alg)
}

// string dh_group = 27;
inline void ListIkeSa::clear_dh_group() {
  _impl_.dh_group_.ClearToEmpty();
}
inline const std::string& ListIkeSa::dh_group() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.dh_group)
  return _internal_dh_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_dh_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dh_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.dh_group)
}
inline std::string* ListIkeSa::mutable_dh_group() {
  std::string* _s = _internal_mutable_dh_group();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.dh_group)
  return _s;
}
inline const std::string& ListIkeSa::_internal_dh_group() const {
  return _impl_.dh_group_.Get();
}
inline void ListIkeSa::_internal_set_dh_group(const std::string& value) {
  
  _impl_.dh_group_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_dh_group() {
  
  return _impl_.dh_group_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_dh_group() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.dh_group)
  return _impl_.dh_group_.Release();
}
inline void ListIkeSa::set_allocated_dh_group(std::string* dh_group) {
  if (dh_group != nullptr) {
    
  } else {
    
  }
  _impl_.dh_group_.SetAllocated(dh_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dh_group_.IsDefault()) {
    _impl_.dh_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.dh_group)
}

// string ppk = 28;
inline void ListIkeSa::clear_ppk() {
  _impl_.ppk_.ClearToEmpty();
}
inline const std::string& ListIkeSa::ppk() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.ppk)
  return _internal_ppk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_ppk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ppk_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.ppk)
}
inline std::string* ListIkeSa::mutable_ppk() {
  std::string* _s = _internal_mutable_ppk();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.ppk)
  return _s;
}
inline const std::string& ListIkeSa::_internal_ppk() const {
  return _impl_.ppk_.Get();
}
inline void ListIkeSa::_internal_set_ppk(const std::string& value) {
  
  _impl_.ppk_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_ppk() {
  
  return _impl_.ppk_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_ppk() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.ppk)
  return _impl_.ppk_.Release();
}
inline void ListIkeSa::set_allocated_ppk(std::string* ppk) {
  if (ppk != nullptr) {
    
  } else {
    
  }
  _impl_.ppk_.SetAllocated(ppk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ppk_.IsDefault()) {
    _impl_.ppk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.ppk)
}

// string established = 29;
inline void ListIkeSa::clear_established() {
  _impl_.established_.ClearToEmpty();
}
inline const std::string& ListIkeSa::established() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.established)
  return _internal_established();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_established(ArgT0&& arg0, ArgT... args) {
 
 _impl_.established_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.established)
}
inline std::string* ListIkeSa::mutable_established() {
  std::string* _s = _internal_mutable_established();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.established)
  return _s;
}
inline const std::string& ListIkeSa::_internal_established() const {
  return _impl_.established_.Get();
}
inline void ListIkeSa::_internal_set_established(const std::string& value) {
  
  _impl_.established_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_established() {
  
  return _impl_.established_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_established() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.established)
  return _impl_.established_.Release();
}
inline void ListIkeSa::set_allocated_established(std::string* established) {
  if (established != nullptr) {
    
  } else {
    
  }
  _impl_.established_.SetAllocated(established, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.established_.IsDefault()) {
    _impl_.established_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.established)
}

// string rekey_time = 30;
inline void ListIkeSa::clear_rekey_time() {
  _impl_.rekey_time_.ClearToEmpty();
}
inline const std::string& ListIkeSa::rekey_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.rekey_time)
  return _internal_rekey_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_rekey_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rekey_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.rekey_time)
}
inline std::string* ListIkeSa::mutable_rekey_time() {
  std::string* _s = _internal_mutable_rekey_time();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.rekey_time)
  return _s;
}
inline const std::string& ListIkeSa::_internal_rekey_time() const {
  return _impl_.rekey_time_.Get();
}
inline void ListIkeSa::_internal_set_rekey_time(const std::string& value) {
  
  _impl_.rekey_time_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_rekey_time() {
  
  return _impl_.rekey_time_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_rekey_time() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.rekey_time)
  return _impl_.rekey_time_.Release();
}
inline void ListIkeSa::set_allocated_rekey_time(std::string* rekey_time) {
  if (rekey_time != nullptr) {
    
  } else {
    
  }
  _impl_.rekey_time_.SetAllocated(rekey_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rekey_time_.IsDefault()) {
    _impl_.rekey_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.rekey_time)
}

// string reauth_time = 31;
inline void ListIkeSa::clear_reauth_time() {
  _impl_.reauth_time_.ClearToEmpty();
}
inline const std::string& ListIkeSa::reauth_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.reauth_time)
  return _internal_reauth_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIkeSa::set_reauth_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reauth_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.reauth_time)
}
inline std::string* ListIkeSa::mutable_reauth_time() {
  std::string* _s = _internal_mutable_reauth_time();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.reauth_time)
  return _s;
}
inline const std::string& ListIkeSa::_internal_reauth_time() const {
  return _impl_.reauth_time_.Get();
}
inline void ListIkeSa::_internal_set_reauth_time(const std::string& value) {
  
  _impl_.reauth_time_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIkeSa::_internal_mutable_reauth_time() {
  
  return _impl_.reauth_time_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIkeSa::release_reauth_time() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListIkeSa.reauth_time)
  return _impl_.reauth_time_.Release();
}
inline void ListIkeSa::set_allocated_reauth_time(std::string* reauth_time) {
  if (reauth_time != nullptr) {
    
  } else {
    
  }
  _impl_.reauth_time_.SetAllocated(reauth_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reauth_time_.IsDefault()) {
    _impl_.reauth_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListIkeSa.reauth_time)
}

// repeated string local_vips = 32;
inline int ListIkeSa::_internal_local_vips_size() const {
  return _impl_.local_vips_.size();
}
inline int ListIkeSa::local_vips_size() const {
  return _internal_local_vips_size();
}
inline void ListIkeSa::clear_local_vips() {
  _impl_.local_vips_.Clear();
}
inline std::string* ListIkeSa::add_local_vips() {
  std::string* _s = _internal_add_local_vips();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.ListIkeSa.local_vips)
  return _s;
}
inline const std::string& ListIkeSa::_internal_local_vips(int index) const {
  return _impl_.local_vips_.Get(index);
}
inline const std::string& ListIkeSa::local_vips(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.local_vips)
  return _internal_local_vips(index);
}
inline std::string* ListIkeSa::mutable_local_vips(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.local_vips)
  return _impl_.local_vips_.Mutable(index);
}
inline void ListIkeSa::set_local_vips(int index, const std::string& value) {
  _impl_.local_vips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.local_vips)
}
inline void ListIkeSa::set_local_vips(int index, std::string&& value) {
  _impl_.local_vips_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.local_vips)
}
inline void ListIkeSa::set_local_vips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.local_vips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.ListIkeSa.local_vips)
}
inline void ListIkeSa::set_local_vips(int index, const char* value, size_t size) {
  _impl_.local_vips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.ListIkeSa.local_vips)
}
inline std::string* ListIkeSa::_internal_add_local_vips() {
  return _impl_.local_vips_.Add();
}
inline void ListIkeSa::add_local_vips(const std::string& value) {
  _impl_.local_vips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.local_vips)
}
inline void ListIkeSa::add_local_vips(std::string&& value) {
  _impl_.local_vips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.local_vips)
}
inline void ListIkeSa::add_local_vips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.local_vips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.ListIkeSa.local_vips)
}
inline void ListIkeSa::add_local_vips(const char* value, size_t size) {
  _impl_.local_vips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.ListIkeSa.local_vips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListIkeSa::local_vips() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListIkeSa.local_vips)
  return _impl_.local_vips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListIkeSa::mutable_local_vips() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListIkeSa.local_vips)
  return &_impl_.local_vips_;
}

// repeated string remote_vips = 33;
inline int ListIkeSa::_internal_remote_vips_size() const {
  return _impl_.remote_vips_.size();
}
inline int ListIkeSa::remote_vips_size() const {
  return _internal_remote_vips_size();
}
inline void ListIkeSa::clear_remote_vips() {
  _impl_.remote_vips_.Clear();
}
inline std::string* ListIkeSa::add_remote_vips() {
  std::string* _s = _internal_add_remote_vips();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.ListIkeSa.remote_vips)
  return _s;
}
inline const std::string& ListIkeSa::_internal_remote_vips(int index) const {
  return _impl_.remote_vips_.Get(index);
}
inline const std::string& ListIkeSa::remote_vips(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.remote_vips)
  return _internal_remote_vips(index);
}
inline std::string* ListIkeSa::mutable_remote_vips(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.remote_vips)
  return _impl_.remote_vips_.Mutable(index);
}
inline void ListIkeSa::set_remote_vips(int index, const std::string& value) {
  _impl_.remote_vips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline void ListIkeSa::set_remote_vips(int index, std::string&& value) {
  _impl_.remote_vips_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline void ListIkeSa::set_remote_vips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.remote_vips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline void ListIkeSa::set_remote_vips(int index, const char* value, size_t size) {
  _impl_.remote_vips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline std::string* ListIkeSa::_internal_add_remote_vips() {
  return _impl_.remote_vips_.Add();
}
inline void ListIkeSa::add_remote_vips(const std::string& value) {
  _impl_.remote_vips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline void ListIkeSa::add_remote_vips(std::string&& value) {
  _impl_.remote_vips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline void ListIkeSa::add_remote_vips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.remote_vips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline void ListIkeSa::add_remote_vips(const char* value, size_t size) {
  _impl_.remote_vips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.ListIkeSa.remote_vips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListIkeSa::remote_vips() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListIkeSa.remote_vips)
  return _impl_.remote_vips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListIkeSa::mutable_remote_vips() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListIkeSa.remote_vips)
  return &_impl_.remote_vips_;
}

// repeated string tasks_queued = 34;
inline int ListIkeSa::_internal_tasks_queued_size() const {
  return _impl_.tasks_queued_.size();
}
inline int ListIkeSa::tasks_queued_size() const {
  return _internal_tasks_queued_size();
}
inline void ListIkeSa::clear_tasks_queued() {
  _impl_.tasks_queued_.Clear();
}
inline std::string* ListIkeSa::add_tasks_queued() {
  std::string* _s = _internal_add_tasks_queued();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.ListIkeSa.tasks_queued)
  return _s;
}
inline const std::string& ListIkeSa::_internal_tasks_queued(int index) const {
  return _impl_.tasks_queued_.Get(index);
}
inline const std::string& ListIkeSa::tasks_queued(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.tasks_queued)
  return _internal_tasks_queued(index);
}
inline std::string* ListIkeSa::mutable_tasks_queued(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.tasks_queued)
  return _impl_.tasks_queued_.Mutable(index);
}
inline void ListIkeSa::set_tasks_queued(int index, const std::string& value) {
  _impl_.tasks_queued_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline void ListIkeSa::set_tasks_queued(int index, std::string&& value) {
  _impl_.tasks_queued_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline void ListIkeSa::set_tasks_queued(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tasks_queued_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline void ListIkeSa::set_tasks_queued(int index, const char* value, size_t size) {
  _impl_.tasks_queued_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline std::string* ListIkeSa::_internal_add_tasks_queued() {
  return _impl_.tasks_queued_.Add();
}
inline void ListIkeSa::add_tasks_queued(const std::string& value) {
  _impl_.tasks_queued_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline void ListIkeSa::add_tasks_queued(std::string&& value) {
  _impl_.tasks_queued_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline void ListIkeSa::add_tasks_queued(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tasks_queued_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline void ListIkeSa::add_tasks_queued(const char* value, size_t size) {
  _impl_.tasks_queued_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.ListIkeSa.tasks_queued)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListIkeSa::tasks_queued() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListIkeSa.tasks_queued)
  return _impl_.tasks_queued_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListIkeSa::mutable_tasks_queued() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListIkeSa.tasks_queued)
  return &_impl_.tasks_queued_;
}

// repeated string tasks_active = 35;
inline int ListIkeSa::_internal_tasks_active_size() const {
  return _impl_.tasks_active_.size();
}
inline int ListIkeSa::tasks_active_size() const {
  return _internal_tasks_active_size();
}
inline void ListIkeSa::clear_tasks_active() {
  _impl_.tasks_active_.Clear();
}
inline std::string* ListIkeSa::add_tasks_active() {
  std::string* _s = _internal_add_tasks_active();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.ListIkeSa.tasks_active)
  return _s;
}
inline const std::string& ListIkeSa::_internal_tasks_active(int index) const {
  return _impl_.tasks_active_.Get(index);
}
inline const std::string& ListIkeSa::tasks_active(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.tasks_active)
  return _internal_tasks_active(index);
}
inline std::string* ListIkeSa::mutable_tasks_active(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.tasks_active)
  return _impl_.tasks_active_.Mutable(index);
}
inline void ListIkeSa::set_tasks_active(int index, const std::string& value) {
  _impl_.tasks_active_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline void ListIkeSa::set_tasks_active(int index, std::string&& value) {
  _impl_.tasks_active_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline void ListIkeSa::set_tasks_active(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tasks_active_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline void ListIkeSa::set_tasks_active(int index, const char* value, size_t size) {
  _impl_.tasks_active_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline std::string* ListIkeSa::_internal_add_tasks_active() {
  return _impl_.tasks_active_.Add();
}
inline void ListIkeSa::add_tasks_active(const std::string& value) {
  _impl_.tasks_active_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline void ListIkeSa::add_tasks_active(std::string&& value) {
  _impl_.tasks_active_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline void ListIkeSa::add_tasks_active(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tasks_active_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline void ListIkeSa::add_tasks_active(const char* value, size_t size) {
  _impl_.tasks_active_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.ListIkeSa.tasks_active)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListIkeSa::tasks_active() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListIkeSa.tasks_active)
  return _impl_.tasks_active_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListIkeSa::mutable_tasks_active() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListIkeSa.tasks_active)
  return &_impl_.tasks_active_;
}

// repeated string tasks_passive = 36;
inline int ListIkeSa::_internal_tasks_passive_size() const {
  return _impl_.tasks_passive_.size();
}
inline int ListIkeSa::tasks_passive_size() const {
  return _internal_tasks_passive_size();
}
inline void ListIkeSa::clear_tasks_passive() {
  _impl_.tasks_passive_.Clear();
}
inline std::string* ListIkeSa::add_tasks_passive() {
  std::string* _s = _internal_add_tasks_passive();
  // @@protoc_insertion_point(field_add_mutable:opi_api.security.v1.ListIkeSa.tasks_passive)
  return _s;
}
inline const std::string& ListIkeSa::_internal_tasks_passive(int index) const {
  return _impl_.tasks_passive_.Get(index);
}
inline const std::string& ListIkeSa::tasks_passive(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.tasks_passive)
  return _internal_tasks_passive(index);
}
inline std::string* ListIkeSa::mutable_tasks_passive(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.tasks_passive)
  return _impl_.tasks_passive_.Mutable(index);
}
inline void ListIkeSa::set_tasks_passive(int index, const std::string& value) {
  _impl_.tasks_passive_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline void ListIkeSa::set_tasks_passive(int index, std::string&& value) {
  _impl_.tasks_passive_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline void ListIkeSa::set_tasks_passive(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tasks_passive_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline void ListIkeSa::set_tasks_passive(int index, const char* value, size_t size) {
  _impl_.tasks_passive_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline std::string* ListIkeSa::_internal_add_tasks_passive() {
  return _impl_.tasks_passive_.Add();
}
inline void ListIkeSa::add_tasks_passive(const std::string& value) {
  _impl_.tasks_passive_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline void ListIkeSa::add_tasks_passive(std::string&& value) {
  _impl_.tasks_passive_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline void ListIkeSa::add_tasks_passive(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tasks_passive_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline void ListIkeSa::add_tasks_passive(const char* value, size_t size) {
  _impl_.tasks_passive_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.security.v1.ListIkeSa.tasks_passive)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListIkeSa::tasks_passive() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListIkeSa.tasks_passive)
  return _impl_.tasks_passive_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListIkeSa::mutable_tasks_passive() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListIkeSa.tasks_passive)
  return &_impl_.tasks_passive_;
}

// repeated .opi_api.security.v1.ListChildSa childsas = 37;
inline int ListIkeSa::_internal_childsas_size() const {
  return _impl_.childsas_.size();
}
inline int ListIkeSa::childsas_size() const {
  return _internal_childsas_size();
}
inline void ListIkeSa::clear_childsas() {
  _impl_.childsas_.Clear();
}
inline ::opi_api::security::v1::ListChildSa* ListIkeSa::mutable_childsas(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListIkeSa.childsas)
  return _impl_.childsas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChildSa >*
ListIkeSa::mutable_childsas() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListIkeSa.childsas)
  return &_impl_.childsas_;
}
inline const ::opi_api::security::v1::ListChildSa& ListIkeSa::_internal_childsas(int index) const {
  return _impl_.childsas_.Get(index);
}
inline const ::opi_api::security::v1::ListChildSa& ListIkeSa::childsas(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListIkeSa.childsas)
  return _internal_childsas(index);
}
inline ::opi_api::security::v1::ListChildSa* ListIkeSa::_internal_add_childsas() {
  return _impl_.childsas_.Add();
}
inline ::opi_api::security::v1::ListChildSa* ListIkeSa::add_childsas() {
  ::opi_api::security::v1::ListChildSa* _add = _internal_add_childsas();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListIkeSa.childsas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChildSa >&
ListIkeSa::childsas() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListIkeSa.childsas)
  return _impl_.childsas_;
}

// -------------------------------------------------------------------

// IPsecListSasResponse

// repeated .opi_api.security.v1.ListIkeSa ikesas = 1;
inline int IPsecListSasResponse::_internal_ikesas_size() const {
  return _impl_.ikesas_.size();
}
inline int IPsecListSasResponse::ikesas_size() const {
  return _internal_ikesas_size();
}
inline void IPsecListSasResponse::clear_ikesas() {
  _impl_.ikesas_.Clear();
}
inline ::opi_api::security::v1::ListIkeSa* IPsecListSasResponse::mutable_ikesas(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListSasResponse.ikesas)
  return _impl_.ikesas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListIkeSa >*
IPsecListSasResponse::mutable_ikesas() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.IPsecListSasResponse.ikesas)
  return &_impl_.ikesas_;
}
inline const ::opi_api::security::v1::ListIkeSa& IPsecListSasResponse::_internal_ikesas(int index) const {
  return _impl_.ikesas_.Get(index);
}
inline const ::opi_api::security::v1::ListIkeSa& IPsecListSasResponse::ikesas(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListSasResponse.ikesas)
  return _internal_ikesas(index);
}
inline ::opi_api::security::v1::ListIkeSa* IPsecListSasResponse::_internal_add_ikesas() {
  return _impl_.ikesas_.Add();
}
inline ::opi_api::security::v1::ListIkeSa* IPsecListSasResponse::add_ikesas() {
  ::opi_api::security::v1::ListIkeSa* _add = _internal_add_ikesas();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.IPsecListSasResponse.ikesas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListIkeSa >&
IPsecListSasResponse::ikesas() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.IPsecListSasResponse.ikesas)
  return _impl_.ikesas_;
}

// -------------------------------------------------------------------

// IPsecListConnsRequest

// string ike = 1;
inline void IPsecListConnsRequest::clear_ike() {
  _impl_.ike_.ClearToEmpty();
}
inline const std::string& IPsecListConnsRequest::ike() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListConnsRequest.ike)
  return _internal_ike();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListConnsRequest::set_ike(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ike_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListConnsRequest.ike)
}
inline std::string* IPsecListConnsRequest::mutable_ike() {
  std::string* _s = _internal_mutable_ike();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListConnsRequest.ike)
  return _s;
}
inline const std::string& IPsecListConnsRequest::_internal_ike() const {
  return _impl_.ike_.Get();
}
inline void IPsecListConnsRequest::_internal_set_ike(const std::string& value) {
  
  _impl_.ike_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListConnsRequest::_internal_mutable_ike() {
  
  return _impl_.ike_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListConnsRequest::release_ike() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListConnsRequest.ike)
  return _impl_.ike_.Release();
}
inline void IPsecListConnsRequest::set_allocated_ike(std::string* ike) {
  if (ike != nullptr) {
    
  } else {
    
  }
  _impl_.ike_.SetAllocated(ike, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ike_.IsDefault()) {
    _impl_.ike_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListConnsRequest.ike)
}

// -------------------------------------------------------------------

// ListConnAuth

// string class = 1;
inline void ListConnAuth::clear_class_() {
  _impl_.class__.ClearToEmpty();
}
inline const std::string& ListConnAuth::class_() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_class_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.class)
}
inline std::string* ListConnAuth::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.class)
  return _s;
}
inline const std::string& ListConnAuth::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void ListConnAuth::_internal_set_class_(const std::string& value) {
  
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_class_() {
  
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_class_() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.class)
  return _impl_.class__.Release();
}
inline void ListConnAuth::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.class)
}

// string eaptype = 2;
inline void ListConnAuth::clear_eaptype() {
  _impl_.eaptype_.ClearToEmpty();
}
inline const std::string& ListConnAuth::eaptype() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.eaptype)
  return _internal_eaptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_eaptype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eaptype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.eaptype)
}
inline std::string* ListConnAuth::mutable_eaptype() {
  std::string* _s = _internal_mutable_eaptype();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.eaptype)
  return _s;
}
inline const std::string& ListConnAuth::_internal_eaptype() const {
  return _impl_.eaptype_.Get();
}
inline void ListConnAuth::_internal_set_eaptype(const std::string& value) {
  
  _impl_.eaptype_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_eaptype() {
  
  return _impl_.eaptype_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_eaptype() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.eaptype)
  return _impl_.eaptype_.Release();
}
inline void ListConnAuth::set_allocated_eaptype(std::string* eaptype) {
  if (eaptype != nullptr) {
    
  } else {
    
  }
  _impl_.eaptype_.SetAllocated(eaptype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eaptype_.IsDefault()) {
    _impl_.eaptype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.eaptype)
}

// string eapvendor = 3;
inline void ListConnAuth::clear_eapvendor() {
  _impl_.eapvendor_.ClearToEmpty();
}
inline const std::string& ListConnAuth::eapvendor() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.eapvendor)
  return _internal_eapvendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_eapvendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eapvendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.eapvendor)
}
inline std::string* ListConnAuth::mutable_eapvendor() {
  std::string* _s = _internal_mutable_eapvendor();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.eapvendor)
  return _s;
}
inline const std::string& ListConnAuth::_internal_eapvendor() const {
  return _impl_.eapvendor_.Get();
}
inline void ListConnAuth::_internal_set_eapvendor(const std::string& value) {
  
  _impl_.eapvendor_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_eapvendor() {
  
  return _impl_.eapvendor_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_eapvendor() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.eapvendor)
  return _impl_.eapvendor_.Release();
}
inline void ListConnAuth::set_allocated_eapvendor(std::string* eapvendor) {
  if (eapvendor != nullptr) {
    
  } else {
    
  }
  _impl_.eapvendor_.SetAllocated(eapvendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eapvendor_.IsDefault()) {
    _impl_.eapvendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.eapvendor)
}

// string xauth = 4;
inline void ListConnAuth::clear_xauth() {
  _impl_.xauth_.ClearToEmpty();
}
inline const std::string& ListConnAuth::xauth() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.xauth)
  return _internal_xauth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_xauth(ArgT0&& arg0, ArgT... args) {
 
 _impl_.xauth_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.xauth)
}
inline std::string* ListConnAuth::mutable_xauth() {
  std::string* _s = _internal_mutable_xauth();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.xauth)
  return _s;
}
inline const std::string& ListConnAuth::_internal_xauth() const {
  return _impl_.xauth_.Get();
}
inline void ListConnAuth::_internal_set_xauth(const std::string& value) {
  
  _impl_.xauth_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_xauth() {
  
  return _impl_.xauth_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_xauth() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.xauth)
  return _impl_.xauth_.Release();
}
inline void ListConnAuth::set_allocated_xauth(std::string* xauth) {
  if (xauth != nullptr) {
    
  } else {
    
  }
  _impl_.xauth_.SetAllocated(xauth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xauth_.IsDefault()) {
    _impl_.xauth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.xauth)
}

// string revocation = 5;
inline void ListConnAuth::clear_revocation() {
  _impl_.revocation_.ClearToEmpty();
}
inline const std::string& ListConnAuth::revocation() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.revocation)
  return _internal_revocation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_revocation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.revocation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.revocation)
}
inline std::string* ListConnAuth::mutable_revocation() {
  std::string* _s = _internal_mutable_revocation();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.revocation)
  return _s;
}
inline const std::string& ListConnAuth::_internal_revocation() const {
  return _impl_.revocation_.Get();
}
inline void ListConnAuth::_internal_set_revocation(const std::string& value) {
  
  _impl_.revocation_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_revocation() {
  
  return _impl_.revocation_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_revocation() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.revocation)
  return _impl_.revocation_.Release();
}
inline void ListConnAuth::set_allocated_revocation(std::string* revocation) {
  if (revocation != nullptr) {
    
  } else {
    
  }
  _impl_.revocation_.SetAllocated(revocation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.revocation_.IsDefault()) {
    _impl_.revocation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.revocation)
}

// string id = 6;
inline void ListConnAuth::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ListConnAuth::id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.id)
}
inline std::string* ListConnAuth::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.id)
  return _s;
}
inline const std::string& ListConnAuth::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ListConnAuth::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.id)
  return _impl_.id_.Release();
}
inline void ListConnAuth::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.id)
}

// string ca_id = 7;
inline void ListConnAuth::clear_ca_id() {
  _impl_.ca_id_.ClearToEmpty();
}
inline const std::string& ListConnAuth::ca_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.ca_id)
  return _internal_ca_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_ca_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ca_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.ca_id)
}
inline std::string* ListConnAuth::mutable_ca_id() {
  std::string* _s = _internal_mutable_ca_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.ca_id)
  return _s;
}
inline const std::string& ListConnAuth::_internal_ca_id() const {
  return _impl_.ca_id_.Get();
}
inline void ListConnAuth::_internal_set_ca_id(const std::string& value) {
  
  _impl_.ca_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_ca_id() {
  
  return _impl_.ca_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_ca_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.ca_id)
  return _impl_.ca_id_.Release();
}
inline void ListConnAuth::set_allocated_ca_id(std::string* ca_id) {
  if (ca_id != nullptr) {
    
  } else {
    
  }
  _impl_.ca_id_.SetAllocated(ca_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ca_id_.IsDefault()) {
    _impl_.ca_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.ca_id)
}

// string aaa_id = 8;
inline void ListConnAuth::clear_aaa_id() {
  _impl_.aaa_id_.ClearToEmpty();
}
inline const std::string& ListConnAuth::aaa_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.aaa_id)
  return _internal_aaa_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_aaa_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aaa_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.aaa_id)
}
inline std::string* ListConnAuth::mutable_aaa_id() {
  std::string* _s = _internal_mutable_aaa_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.aaa_id)
  return _s;
}
inline const std::string& ListConnAuth::_internal_aaa_id() const {
  return _impl_.aaa_id_.Get();
}
inline void ListConnAuth::_internal_set_aaa_id(const std::string& value) {
  
  _impl_.aaa_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_aaa_id() {
  
  return _impl_.aaa_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_aaa_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.aaa_id)
  return _impl_.aaa_id_.Release();
}
inline void ListConnAuth::set_allocated_aaa_id(std::string* aaa_id) {
  if (aaa_id != nullptr) {
    
  } else {
    
  }
  _impl_.aaa_id_.SetAllocated(aaa_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aaa_id_.IsDefault()) {
    _impl_.aaa_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.aaa_id)
}

// string eap_id = 9;
inline void ListConnAuth::clear_eap_id() {
  _impl_.eap_id_.ClearToEmpty();
}
inline const std::string& ListConnAuth::eap_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.eap_id)
  return _internal_eap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_eap_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.eap_id)
}
inline std::string* ListConnAuth::mutable_eap_id() {
  std::string* _s = _internal_mutable_eap_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.eap_id)
  return _s;
}
inline const std::string& ListConnAuth::_internal_eap_id() const {
  return _impl_.eap_id_.Get();
}
inline void ListConnAuth::_internal_set_eap_id(const std::string& value) {
  
  _impl_.eap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_eap_id() {
  
  return _impl_.eap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_eap_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.eap_id)
  return _impl_.eap_id_.Release();
}
inline void ListConnAuth::set_allocated_eap_id(std::string* eap_id) {
  if (eap_id != nullptr) {
    
  } else {
    
  }
  _impl_.eap_id_.SetAllocated(eap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eap_id_.IsDefault()) {
    _impl_.eap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.eap_id)
}

// string xauth_id = 10;
inline void ListConnAuth::clear_xauth_id() {
  _impl_.xauth_id_.ClearToEmpty();
}
inline const std::string& ListConnAuth::xauth_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.xauth_id)
  return _internal_xauth_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnAuth::set_xauth_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.xauth_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnAuth.xauth_id)
}
inline std::string* ListConnAuth::mutable_xauth_id() {
  std::string* _s = _internal_mutable_xauth_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.xauth_id)
  return _s;
}
inline const std::string& ListConnAuth::_internal_xauth_id() const {
  return _impl_.xauth_id_.Get();
}
inline void ListConnAuth::_internal_set_xauth_id(const std::string& value) {
  
  _impl_.xauth_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnAuth::_internal_mutable_xauth_id() {
  
  return _impl_.xauth_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnAuth::release_xauth_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.xauth_id)
  return _impl_.xauth_id_.Release();
}
inline void ListConnAuth::set_allocated_xauth_id(std::string* xauth_id) {
  if (xauth_id != nullptr) {
    
  } else {
    
  }
  _impl_.xauth_id_.SetAllocated(xauth_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xauth_id_.IsDefault()) {
    _impl_.xauth_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.xauth_id)
}

// .opi_api.security.v1.Groups group = 11;
inline bool ListConnAuth::_internal_has_group() const {
  return this != internal_default_instance() && _impl_.group_ != nullptr;
}
inline bool ListConnAuth::has_group() const {
  return _internal_has_group();
}
inline void ListConnAuth::clear_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_ != nullptr) {
    delete _impl_.group_;
  }
  _impl_.group_ = nullptr;
}
inline const ::opi_api::security::v1::Groups& ListConnAuth::_internal_group() const {
  const ::opi_api::security::v1::Groups* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Groups&>(
      ::opi_api::security::v1::_Groups_default_instance_);
}
inline const ::opi_api::security::v1::Groups& ListConnAuth::group() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.group)
  return _internal_group();
}
inline void ListConnAuth::unsafe_arena_set_allocated_group(
    ::opi_api::security::v1::Groups* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.ListConnAuth.group)
}
inline ::opi_api::security::v1::Groups* ListConnAuth::release_group() {
  
  ::opi_api::security::v1::Groups* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Groups* ListConnAuth::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.group)
  
  ::opi_api::security::v1::Groups* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Groups* ListConnAuth::_internal_mutable_group() {
  
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Groups>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::opi_api::security::v1::Groups* ListConnAuth::mutable_group() {
  ::opi_api::security::v1::Groups* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.group)
  return _msg;
}
inline void ListConnAuth::set_allocated_group(::opi_api::security::v1::Groups* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.group)
}

// .opi_api.security.v1.CertPolicy cert_policy = 12;
inline bool ListConnAuth::_internal_has_cert_policy() const {
  return this != internal_default_instance() && _impl_.cert_policy_ != nullptr;
}
inline bool ListConnAuth::has_cert_policy() const {
  return _internal_has_cert_policy();
}
inline void ListConnAuth::clear_cert_policy() {
  if (GetArenaForAllocation() == nullptr && _impl_.cert_policy_ != nullptr) {
    delete _impl_.cert_policy_;
  }
  _impl_.cert_policy_ = nullptr;
}
inline const ::opi_api::security::v1::CertPolicy& ListConnAuth::_internal_cert_policy() const {
  const ::opi_api::security::v1::CertPolicy* p = _impl_.cert_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::CertPolicy&>(
      ::opi_api::security::v1::_CertPolicy_default_instance_);
}
inline const ::opi_api::security::v1::CertPolicy& ListConnAuth::cert_policy() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.cert_policy)
  return _internal_cert_policy();
}
inline void ListConnAuth::unsafe_arena_set_allocated_cert_policy(
    ::opi_api::security::v1::CertPolicy* cert_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cert_policy_);
  }
  _impl_.cert_policy_ = cert_policy;
  if (cert_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.ListConnAuth.cert_policy)
}
inline ::opi_api::security::v1::CertPolicy* ListConnAuth::release_cert_policy() {
  
  ::opi_api::security::v1::CertPolicy* temp = _impl_.cert_policy_;
  _impl_.cert_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::CertPolicy* ListConnAuth::unsafe_arena_release_cert_policy() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.cert_policy)
  
  ::opi_api::security::v1::CertPolicy* temp = _impl_.cert_policy_;
  _impl_.cert_policy_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::CertPolicy* ListConnAuth::_internal_mutable_cert_policy() {
  
  if (_impl_.cert_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::CertPolicy>(GetArenaForAllocation());
    _impl_.cert_policy_ = p;
  }
  return _impl_.cert_policy_;
}
inline ::opi_api::security::v1::CertPolicy* ListConnAuth::mutable_cert_policy() {
  ::opi_api::security::v1::CertPolicy* _msg = _internal_mutable_cert_policy();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.cert_policy)
  return _msg;
}
inline void ListConnAuth::set_allocated_cert_policy(::opi_api::security::v1::CertPolicy* cert_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cert_policy_;
  }
  if (cert_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cert_policy);
    if (message_arena != submessage_arena) {
      cert_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cert_policy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cert_policy_ = cert_policy;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.cert_policy)
}

// .opi_api.security.v1.Certs certs = 13;
inline bool ListConnAuth::_internal_has_certs() const {
  return this != internal_default_instance() && _impl_.certs_ != nullptr;
}
inline bool ListConnAuth::has_certs() const {
  return _internal_has_certs();
}
inline void ListConnAuth::clear_certs() {
  if (GetArenaForAllocation() == nullptr && _impl_.certs_ != nullptr) {
    delete _impl_.certs_;
  }
  _impl_.certs_ = nullptr;
}
inline const ::opi_api::security::v1::Certs& ListConnAuth::_internal_certs() const {
  const ::opi_api::security::v1::Certs* p = _impl_.certs_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Certs&>(
      ::opi_api::security::v1::_Certs_default_instance_);
}
inline const ::opi_api::security::v1::Certs& ListConnAuth::certs() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.certs)
  return _internal_certs();
}
inline void ListConnAuth::unsafe_arena_set_allocated_certs(
    ::opi_api::security::v1::Certs* certs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.certs_);
  }
  _impl_.certs_ = certs;
  if (certs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.ListConnAuth.certs)
}
inline ::opi_api::security::v1::Certs* ListConnAuth::release_certs() {
  
  ::opi_api::security::v1::Certs* temp = _impl_.certs_;
  _impl_.certs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Certs* ListConnAuth::unsafe_arena_release_certs() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.certs)
  
  ::opi_api::security::v1::Certs* temp = _impl_.certs_;
  _impl_.certs_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Certs* ListConnAuth::_internal_mutable_certs() {
  
  if (_impl_.certs_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Certs>(GetArenaForAllocation());
    _impl_.certs_ = p;
  }
  return _impl_.certs_;
}
inline ::opi_api::security::v1::Certs* ListConnAuth::mutable_certs() {
  ::opi_api::security::v1::Certs* _msg = _internal_mutable_certs();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.certs)
  return _msg;
}
inline void ListConnAuth::set_allocated_certs(::opi_api::security::v1::Certs* certs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.certs_;
  }
  if (certs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(certs);
    if (message_arena != submessage_arena) {
      certs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.certs_ = certs;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.certs)
}

// .opi_api.security.v1.CaCerts cacerts = 14;
inline bool ListConnAuth::_internal_has_cacerts() const {
  return this != internal_default_instance() && _impl_.cacerts_ != nullptr;
}
inline bool ListConnAuth::has_cacerts() const {
  return _internal_has_cacerts();
}
inline void ListConnAuth::clear_cacerts() {
  if (GetArenaForAllocation() == nullptr && _impl_.cacerts_ != nullptr) {
    delete _impl_.cacerts_;
  }
  _impl_.cacerts_ = nullptr;
}
inline const ::opi_api::security::v1::CaCerts& ListConnAuth::_internal_cacerts() const {
  const ::opi_api::security::v1::CaCerts* p = _impl_.cacerts_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::CaCerts&>(
      ::opi_api::security::v1::_CaCerts_default_instance_);
}
inline const ::opi_api::security::v1::CaCerts& ListConnAuth::cacerts() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnAuth.cacerts)
  return _internal_cacerts();
}
inline void ListConnAuth::unsafe_arena_set_allocated_cacerts(
    ::opi_api::security::v1::CaCerts* cacerts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cacerts_);
  }
  _impl_.cacerts_ = cacerts;
  if (cacerts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.ListConnAuth.cacerts)
}
inline ::opi_api::security::v1::CaCerts* ListConnAuth::release_cacerts() {
  
  ::opi_api::security::v1::CaCerts* temp = _impl_.cacerts_;
  _impl_.cacerts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::CaCerts* ListConnAuth::unsafe_arena_release_cacerts() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnAuth.cacerts)
  
  ::opi_api::security::v1::CaCerts* temp = _impl_.cacerts_;
  _impl_.cacerts_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::CaCerts* ListConnAuth::_internal_mutable_cacerts() {
  
  if (_impl_.cacerts_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::CaCerts>(GetArenaForAllocation());
    _impl_.cacerts_ = p;
  }
  return _impl_.cacerts_;
}
inline ::opi_api::security::v1::CaCerts* ListConnAuth::mutable_cacerts() {
  ::opi_api::security::v1::CaCerts* _msg = _internal_mutable_cacerts();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnAuth.cacerts)
  return _msg;
}
inline void ListConnAuth::set_allocated_cacerts(::opi_api::security::v1::CaCerts* cacerts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cacerts_;
  }
  if (cacerts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cacerts);
    if (message_arena != submessage_arena) {
      cacerts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cacerts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cacerts_ = cacerts;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnAuth.cacerts)
}

// -------------------------------------------------------------------

// ListChild

// string name = 1;
inline void ListChild::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListChild::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.name)
}
inline std::string* ListChild::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.name)
  return _s;
}
inline const std::string& ListChild::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListChild::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.name)
  return _impl_.name_.Release();
}
inline void ListChild::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.name)
}

// string mode = 2;
inline void ListChild::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& ListChild::mode() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.mode)
  return _internal_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.mode)
}
inline std::string* ListChild::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.mode)
  return _s;
}
inline const std::string& ListChild::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void ListChild::_internal_set_mode(const std::string& value) {
  
  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_mode() {
  
  return _impl_.mode_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_mode() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.mode)
  return _impl_.mode_.Release();
}
inline void ListChild::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  _impl_.mode_.SetAllocated(mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.mode)
}

// string label = 3;
inline void ListChild::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& ListChild::label() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.label)
}
inline std::string* ListChild::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.label)
  return _s;
}
inline const std::string& ListChild::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ListChild::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_label() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.label)
  return _impl_.label_.Release();
}
inline void ListChild::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.label)
}

// uint32 rekey_time = 4;
inline void ListChild::clear_rekey_time() {
  _impl_.rekey_time_ = 0u;
}
inline uint32_t ListChild::_internal_rekey_time() const {
  return _impl_.rekey_time_;
}
inline uint32_t ListChild::rekey_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.rekey_time)
  return _internal_rekey_time();
}
inline void ListChild::_internal_set_rekey_time(uint32_t value) {
  
  _impl_.rekey_time_ = value;
}
inline void ListChild::set_rekey_time(uint32_t value) {
  _internal_set_rekey_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.rekey_time)
}

// uint32 rekey_bytes = 5;
inline void ListChild::clear_rekey_bytes() {
  _impl_.rekey_bytes_ = 0u;
}
inline uint32_t ListChild::_internal_rekey_bytes() const {
  return _impl_.rekey_bytes_;
}
inline uint32_t ListChild::rekey_bytes() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.rekey_bytes)
  return _internal_rekey_bytes();
}
inline void ListChild::_internal_set_rekey_bytes(uint32_t value) {
  
  _impl_.rekey_bytes_ = value;
}
inline void ListChild::set_rekey_bytes(uint32_t value) {
  _internal_set_rekey_bytes(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.rekey_bytes)
}

// uint32 rekey_packets = 6;
inline void ListChild::clear_rekey_packets() {
  _impl_.rekey_packets_ = 0u;
}
inline uint32_t ListChild::_internal_rekey_packets() const {
  return _impl_.rekey_packets_;
}
inline uint32_t ListChild::rekey_packets() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.rekey_packets)
  return _internal_rekey_packets();
}
inline void ListChild::_internal_set_rekey_packets(uint32_t value) {
  
  _impl_.rekey_packets_ = value;
}
inline void ListChild::set_rekey_packets(uint32_t value) {
  _internal_set_rekey_packets(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.rekey_packets)
}

// string dpd_action = 7;
inline void ListChild::clear_dpd_action() {
  _impl_.dpd_action_.ClearToEmpty();
}
inline const std::string& ListChild::dpd_action() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.dpd_action)
  return _internal_dpd_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_dpd_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dpd_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.dpd_action)
}
inline std::string* ListChild::mutable_dpd_action() {
  std::string* _s = _internal_mutable_dpd_action();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.dpd_action)
  return _s;
}
inline const std::string& ListChild::_internal_dpd_action() const {
  return _impl_.dpd_action_.Get();
}
inline void ListChild::_internal_set_dpd_action(const std::string& value) {
  
  _impl_.dpd_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_dpd_action() {
  
  return _impl_.dpd_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_dpd_action() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.dpd_action)
  return _impl_.dpd_action_.Release();
}
inline void ListChild::set_allocated_dpd_action(std::string* dpd_action) {
  if (dpd_action != nullptr) {
    
  } else {
    
  }
  _impl_.dpd_action_.SetAllocated(dpd_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dpd_action_.IsDefault()) {
    _impl_.dpd_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.dpd_action)
}

// string close_action = 8;
inline void ListChild::clear_close_action() {
  _impl_.close_action_.ClearToEmpty();
}
inline const std::string& ListChild::close_action() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.close_action)
  return _internal_close_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_close_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.close_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.close_action)
}
inline std::string* ListChild::mutable_close_action() {
  std::string* _s = _internal_mutable_close_action();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.close_action)
  return _s;
}
inline const std::string& ListChild::_internal_close_action() const {
  return _impl_.close_action_.Get();
}
inline void ListChild::_internal_set_close_action(const std::string& value) {
  
  _impl_.close_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_close_action() {
  
  return _impl_.close_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_close_action() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.close_action)
  return _impl_.close_action_.Release();
}
inline void ListChild::set_allocated_close_action(std::string* close_action) {
  if (close_action != nullptr) {
    
  } else {
    
  }
  _impl_.close_action_.SetAllocated(close_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.close_action_.IsDefault()) {
    _impl_.close_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.close_action)
}

// .opi_api.security.v1.TrafficSelectors local_ts = 9;
inline bool ListChild::_internal_has_local_ts() const {
  return this != internal_default_instance() && _impl_.local_ts_ != nullptr;
}
inline bool ListChild::has_local_ts() const {
  return _internal_has_local_ts();
}
inline void ListChild::clear_local_ts() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_ts_ != nullptr) {
    delete _impl_.local_ts_;
  }
  _impl_.local_ts_ = nullptr;
}
inline const ::opi_api::security::v1::TrafficSelectors& ListChild::_internal_local_ts() const {
  const ::opi_api::security::v1::TrafficSelectors* p = _impl_.local_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::TrafficSelectors&>(
      ::opi_api::security::v1::_TrafficSelectors_default_instance_);
}
inline const ::opi_api::security::v1::TrafficSelectors& ListChild::local_ts() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.local_ts)
  return _internal_local_ts();
}
inline void ListChild::unsafe_arena_set_allocated_local_ts(
    ::opi_api::security::v1::TrafficSelectors* local_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_ts_);
  }
  _impl_.local_ts_ = local_ts;
  if (local_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.ListChild.local_ts)
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::release_local_ts() {
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.local_ts_;
  _impl_.local_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::unsafe_arena_release_local_ts() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.local_ts)
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.local_ts_;
  _impl_.local_ts_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::_internal_mutable_local_ts() {
  
  if (_impl_.local_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::TrafficSelectors>(GetArenaForAllocation());
    _impl_.local_ts_ = p;
  }
  return _impl_.local_ts_;
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::mutable_local_ts() {
  ::opi_api::security::v1::TrafficSelectors* _msg = _internal_mutable_local_ts();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.local_ts)
  return _msg;
}
inline void ListChild::set_allocated_local_ts(::opi_api::security::v1::TrafficSelectors* local_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_ts_;
  }
  if (local_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_ts);
    if (message_arena != submessage_arena) {
      local_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_ts_ = local_ts;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.local_ts)
}

// .opi_api.security.v1.TrafficSelectors remote_ts = 10;
inline bool ListChild::_internal_has_remote_ts() const {
  return this != internal_default_instance() && _impl_.remote_ts_ != nullptr;
}
inline bool ListChild::has_remote_ts() const {
  return _internal_has_remote_ts();
}
inline void ListChild::clear_remote_ts() {
  if (GetArenaForAllocation() == nullptr && _impl_.remote_ts_ != nullptr) {
    delete _impl_.remote_ts_;
  }
  _impl_.remote_ts_ = nullptr;
}
inline const ::opi_api::security::v1::TrafficSelectors& ListChild::_internal_remote_ts() const {
  const ::opi_api::security::v1::TrafficSelectors* p = _impl_.remote_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::TrafficSelectors&>(
      ::opi_api::security::v1::_TrafficSelectors_default_instance_);
}
inline const ::opi_api::security::v1::TrafficSelectors& ListChild::remote_ts() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.remote_ts)
  return _internal_remote_ts();
}
inline void ListChild::unsafe_arena_set_allocated_remote_ts(
    ::opi_api::security::v1::TrafficSelectors* remote_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_ts_);
  }
  _impl_.remote_ts_ = remote_ts;
  if (remote_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.ListChild.remote_ts)
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::release_remote_ts() {
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.remote_ts_;
  _impl_.remote_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::unsafe_arena_release_remote_ts() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.remote_ts)
  
  ::opi_api::security::v1::TrafficSelectors* temp = _impl_.remote_ts_;
  _impl_.remote_ts_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::_internal_mutable_remote_ts() {
  
  if (_impl_.remote_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::TrafficSelectors>(GetArenaForAllocation());
    _impl_.remote_ts_ = p;
  }
  return _impl_.remote_ts_;
}
inline ::opi_api::security::v1::TrafficSelectors* ListChild::mutable_remote_ts() {
  ::opi_api::security::v1::TrafficSelectors* _msg = _internal_mutable_remote_ts();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.remote_ts)
  return _msg;
}
inline void ListChild::set_allocated_remote_ts(::opi_api::security::v1::TrafficSelectors* remote_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remote_ts_;
  }
  if (remote_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remote_ts);
    if (message_arena != submessage_arena) {
      remote_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remote_ts_ = remote_ts;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.remote_ts)
}

// string interface = 11;
inline void ListChild::clear_interface() {
  _impl_.interface_.ClearToEmpty();
}
inline const std::string& ListChild::interface() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.interface)
  return _internal_interface();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_interface(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interface_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.interface)
}
inline std::string* ListChild::mutable_interface() {
  std::string* _s = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.interface)
  return _s;
}
inline const std::string& ListChild::_internal_interface() const {
  return _impl_.interface_.Get();
}
inline void ListChild::_internal_set_interface(const std::string& value) {
  
  _impl_.interface_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_interface() {
  
  return _impl_.interface_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_interface() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.interface)
  return _impl_.interface_.Release();
}
inline void ListChild::set_allocated_interface(std::string* interface) {
  if (interface != nullptr) {
    
  } else {
    
  }
  _impl_.interface_.SetAllocated(interface, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_.IsDefault()) {
    _impl_.interface_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.interface)
}

// string priority = 12;
inline void ListChild::clear_priority() {
  _impl_.priority_.ClearToEmpty();
}
inline const std::string& ListChild::priority() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListChild.priority)
  return _internal_priority();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListChild::set_priority(ArgT0&& arg0, ArgT... args) {
 
 _impl_.priority_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListChild.priority)
}
inline std::string* ListChild::mutable_priority() {
  std::string* _s = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListChild.priority)
  return _s;
}
inline const std::string& ListChild::_internal_priority() const {
  return _impl_.priority_.Get();
}
inline void ListChild::_internal_set_priority(const std::string& value) {
  
  _impl_.priority_.Set(value, GetArenaForAllocation());
}
inline std::string* ListChild::_internal_mutable_priority() {
  
  return _impl_.priority_.Mutable(GetArenaForAllocation());
}
inline std::string* ListChild::release_priority() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListChild.priority)
  return _impl_.priority_.Release();
}
inline void ListChild::set_allocated_priority(std::string* priority) {
  if (priority != nullptr) {
    
  } else {
    
  }
  _impl_.priority_.SetAllocated(priority, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.priority_.IsDefault()) {
    _impl_.priority_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListChild.priority)
}

// -------------------------------------------------------------------

// ListConnResp

// string name = 1;
inline void ListConnResp::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListConnResp::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnResp::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.name)
}
inline std::string* ListConnResp::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.name)
  return _s;
}
inline const std::string& ListConnResp::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListConnResp::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnResp::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnResp::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnResp.name)
  return _impl_.name_.Release();
}
inline void ListConnResp::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnResp.name)
}

// repeated .opi_api.security.v1.Addrs local_addrs = 2;
inline int ListConnResp::_internal_local_addrs_size() const {
  return _impl_.local_addrs_.size();
}
inline int ListConnResp::local_addrs_size() const {
  return _internal_local_addrs_size();
}
inline void ListConnResp::clear_local_addrs() {
  _impl_.local_addrs_.Clear();
}
inline ::opi_api::security::v1::Addrs* ListConnResp::mutable_local_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.local_addrs)
  return _impl_.local_addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
ListConnResp::mutable_local_addrs() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListConnResp.local_addrs)
  return &_impl_.local_addrs_;
}
inline const ::opi_api::security::v1::Addrs& ListConnResp::_internal_local_addrs(int index) const {
  return _impl_.local_addrs_.Get(index);
}
inline const ::opi_api::security::v1::Addrs& ListConnResp::local_addrs(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.local_addrs)
  return _internal_local_addrs(index);
}
inline ::opi_api::security::v1::Addrs* ListConnResp::_internal_add_local_addrs() {
  return _impl_.local_addrs_.Add();
}
inline ::opi_api::security::v1::Addrs* ListConnResp::add_local_addrs() {
  ::opi_api::security::v1::Addrs* _add = _internal_add_local_addrs();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListConnResp.local_addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
ListConnResp::local_addrs() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListConnResp.local_addrs)
  return _impl_.local_addrs_;
}

// repeated .opi_api.security.v1.Addrs remote_addrs = 3;
inline int ListConnResp::_internal_remote_addrs_size() const {
  return _impl_.remote_addrs_.size();
}
inline int ListConnResp::remote_addrs_size() const {
  return _internal_remote_addrs_size();
}
inline void ListConnResp::clear_remote_addrs() {
  _impl_.remote_addrs_.Clear();
}
inline ::opi_api::security::v1::Addrs* ListConnResp::mutable_remote_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.remote_addrs)
  return _impl_.remote_addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >*
ListConnResp::mutable_remote_addrs() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListConnResp.remote_addrs)
  return &_impl_.remote_addrs_;
}
inline const ::opi_api::security::v1::Addrs& ListConnResp::_internal_remote_addrs(int index) const {
  return _impl_.remote_addrs_.Get(index);
}
inline const ::opi_api::security::v1::Addrs& ListConnResp::remote_addrs(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.remote_addrs)
  return _internal_remote_addrs(index);
}
inline ::opi_api::security::v1::Addrs* ListConnResp::_internal_add_remote_addrs() {
  return _impl_.remote_addrs_.Add();
}
inline ::opi_api::security::v1::Addrs* ListConnResp::add_remote_addrs() {
  ::opi_api::security::v1::Addrs* _add = _internal_add_remote_addrs();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListConnResp.remote_addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::Addrs >&
ListConnResp::remote_addrs() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListConnResp.remote_addrs)
  return _impl_.remote_addrs_;
}

// string version = 4;
inline void ListConnResp::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ListConnResp::version() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnResp::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.version)
}
inline std::string* ListConnResp::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.version)
  return _s;
}
inline const std::string& ListConnResp::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ListConnResp::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnResp::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnResp::release_version() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnResp.version)
  return _impl_.version_.Release();
}
inline void ListConnResp::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnResp.version)
}

// uint32 reauth_time = 5;
inline void ListConnResp::clear_reauth_time() {
  _impl_.reauth_time_ = 0u;
}
inline uint32_t ListConnResp::_internal_reauth_time() const {
  return _impl_.reauth_time_;
}
inline uint32_t ListConnResp::reauth_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.reauth_time)
  return _internal_reauth_time();
}
inline void ListConnResp::_internal_set_reauth_time(uint32_t value) {
  
  _impl_.reauth_time_ = value;
}
inline void ListConnResp::set_reauth_time(uint32_t value) {
  _internal_set_reauth_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.reauth_time)
}

// uint32 rekey_time = 6;
inline void ListConnResp::clear_rekey_time() {
  _impl_.rekey_time_ = 0u;
}
inline uint32_t ListConnResp::_internal_rekey_time() const {
  return _impl_.rekey_time_;
}
inline uint32_t ListConnResp::rekey_time() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.rekey_time)
  return _internal_rekey_time();
}
inline void ListConnResp::_internal_set_rekey_time(uint32_t value) {
  
  _impl_.rekey_time_ = value;
}
inline void ListConnResp::set_rekey_time(uint32_t value) {
  _internal_set_rekey_time(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.rekey_time)
}

// string unique = 7;
inline void ListConnResp::clear_unique() {
  _impl_.unique_.ClearToEmpty();
}
inline const std::string& ListConnResp::unique() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.unique)
  return _internal_unique();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnResp::set_unique(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.unique)
}
inline std::string* ListConnResp::mutable_unique() {
  std::string* _s = _internal_mutable_unique();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.unique)
  return _s;
}
inline const std::string& ListConnResp::_internal_unique() const {
  return _impl_.unique_.Get();
}
inline void ListConnResp::_internal_set_unique(const std::string& value) {
  
  _impl_.unique_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnResp::_internal_mutable_unique() {
  
  return _impl_.unique_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnResp::release_unique() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnResp.unique)
  return _impl_.unique_.Release();
}
inline void ListConnResp::set_allocated_unique(std::string* unique) {
  if (unique != nullptr) {
    
  } else {
    
  }
  _impl_.unique_.SetAllocated(unique, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_.IsDefault()) {
    _impl_.unique_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnResp.unique)
}

// uint32 dpd_delay = 8;
inline void ListConnResp::clear_dpd_delay() {
  _impl_.dpd_delay_ = 0u;
}
inline uint32_t ListConnResp::_internal_dpd_delay() const {
  return _impl_.dpd_delay_;
}
inline uint32_t ListConnResp::dpd_delay() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.dpd_delay)
  return _internal_dpd_delay();
}
inline void ListConnResp::_internal_set_dpd_delay(uint32_t value) {
  
  _impl_.dpd_delay_ = value;
}
inline void ListConnResp::set_dpd_delay(uint32_t value) {
  _internal_set_dpd_delay(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.dpd_delay)
}

// uint32 dpd_timeout = 9;
inline void ListConnResp::clear_dpd_timeout() {
  _impl_.dpd_timeout_ = 0u;
}
inline uint32_t ListConnResp::_internal_dpd_timeout() const {
  return _impl_.dpd_timeout_;
}
inline uint32_t ListConnResp::dpd_timeout() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.dpd_timeout)
  return _internal_dpd_timeout();
}
inline void ListConnResp::_internal_set_dpd_timeout(uint32_t value) {
  
  _impl_.dpd_timeout_ = value;
}
inline void ListConnResp::set_dpd_timeout(uint32_t value) {
  _internal_set_dpd_timeout(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.dpd_timeout)
}

// string ppk = 10;
inline void ListConnResp::clear_ppk() {
  _impl_.ppk_.ClearToEmpty();
}
inline const std::string& ListConnResp::ppk() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.ppk)
  return _internal_ppk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnResp::set_ppk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ppk_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.ppk)
}
inline std::string* ListConnResp::mutable_ppk() {
  std::string* _s = _internal_mutable_ppk();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.ppk)
  return _s;
}
inline const std::string& ListConnResp::_internal_ppk() const {
  return _impl_.ppk_.Get();
}
inline void ListConnResp::_internal_set_ppk(const std::string& value) {
  
  _impl_.ppk_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnResp::_internal_mutable_ppk() {
  
  return _impl_.ppk_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnResp::release_ppk() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnResp.ppk)
  return _impl_.ppk_.Release();
}
inline void ListConnResp::set_allocated_ppk(std::string* ppk) {
  if (ppk != nullptr) {
    
  } else {
    
  }
  _impl_.ppk_.SetAllocated(ppk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ppk_.IsDefault()) {
    _impl_.ppk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnResp.ppk)
}

// string ppk_required = 11;
inline void ListConnResp::clear_ppk_required() {
  _impl_.ppk_required_.ClearToEmpty();
}
inline const std::string& ListConnResp::ppk_required() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.ppk_required)
  return _internal_ppk_required();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConnResp::set_ppk_required(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ppk_required_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListConnResp.ppk_required)
}
inline std::string* ListConnResp::mutable_ppk_required() {
  std::string* _s = _internal_mutable_ppk_required();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.ppk_required)
  return _s;
}
inline const std::string& ListConnResp::_internal_ppk_required() const {
  return _impl_.ppk_required_.Get();
}
inline void ListConnResp::_internal_set_ppk_required(const std::string& value) {
  
  _impl_.ppk_required_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConnResp::_internal_mutable_ppk_required() {
  
  return _impl_.ppk_required_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConnResp::release_ppk_required() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListConnResp.ppk_required)
  return _impl_.ppk_required_.Release();
}
inline void ListConnResp::set_allocated_ppk_required(std::string* ppk_required) {
  if (ppk_required != nullptr) {
    
  } else {
    
  }
  _impl_.ppk_required_.SetAllocated(ppk_required, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ppk_required_.IsDefault()) {
    _impl_.ppk_required_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListConnResp.ppk_required)
}

// repeated .opi_api.security.v1.ListConnAuth local_auth = 12;
inline int ListConnResp::_internal_local_auth_size() const {
  return _impl_.local_auth_.size();
}
inline int ListConnResp::local_auth_size() const {
  return _internal_local_auth_size();
}
inline void ListConnResp::clear_local_auth() {
  _impl_.local_auth_.Clear();
}
inline ::opi_api::security::v1::ListConnAuth* ListConnResp::mutable_local_auth(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.local_auth)
  return _impl_.local_auth_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >*
ListConnResp::mutable_local_auth() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListConnResp.local_auth)
  return &_impl_.local_auth_;
}
inline const ::opi_api::security::v1::ListConnAuth& ListConnResp::_internal_local_auth(int index) const {
  return _impl_.local_auth_.Get(index);
}
inline const ::opi_api::security::v1::ListConnAuth& ListConnResp::local_auth(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.local_auth)
  return _internal_local_auth(index);
}
inline ::opi_api::security::v1::ListConnAuth* ListConnResp::_internal_add_local_auth() {
  return _impl_.local_auth_.Add();
}
inline ::opi_api::security::v1::ListConnAuth* ListConnResp::add_local_auth() {
  ::opi_api::security::v1::ListConnAuth* _add = _internal_add_local_auth();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListConnResp.local_auth)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >&
ListConnResp::local_auth() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListConnResp.local_auth)
  return _impl_.local_auth_;
}

// repeated .opi_api.security.v1.ListConnAuth remote_auth = 13;
inline int ListConnResp::_internal_remote_auth_size() const {
  return _impl_.remote_auth_.size();
}
inline int ListConnResp::remote_auth_size() const {
  return _internal_remote_auth_size();
}
inline void ListConnResp::clear_remote_auth() {
  _impl_.remote_auth_.Clear();
}
inline ::opi_api::security::v1::ListConnAuth* ListConnResp::mutable_remote_auth(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.remote_auth)
  return _impl_.remote_auth_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >*
ListConnResp::mutable_remote_auth() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListConnResp.remote_auth)
  return &_impl_.remote_auth_;
}
inline const ::opi_api::security::v1::ListConnAuth& ListConnResp::_internal_remote_auth(int index) const {
  return _impl_.remote_auth_.Get(index);
}
inline const ::opi_api::security::v1::ListConnAuth& ListConnResp::remote_auth(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.remote_auth)
  return _internal_remote_auth(index);
}
inline ::opi_api::security::v1::ListConnAuth* ListConnResp::_internal_add_remote_auth() {
  return _impl_.remote_auth_.Add();
}
inline ::opi_api::security::v1::ListConnAuth* ListConnResp::add_remote_auth() {
  ::opi_api::security::v1::ListConnAuth* _add = _internal_add_remote_auth();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListConnResp.remote_auth)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnAuth >&
ListConnResp::remote_auth() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListConnResp.remote_auth)
  return _impl_.remote_auth_;
}

// repeated .opi_api.security.v1.ListChild children = 14;
inline int ListConnResp::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int ListConnResp::children_size() const {
  return _internal_children_size();
}
inline void ListConnResp::clear_children() {
  _impl_.children_.Clear();
}
inline ::opi_api::security::v1::ListChild* ListConnResp::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListConnResp.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChild >*
ListConnResp::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.ListConnResp.children)
  return &_impl_.children_;
}
inline const ::opi_api::security::v1::ListChild& ListConnResp::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::opi_api::security::v1::ListChild& ListConnResp::children(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListConnResp.children)
  return _internal_children(index);
}
inline ::opi_api::security::v1::ListChild* ListConnResp::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::opi_api::security::v1::ListChild* ListConnResp::add_children() {
  ::opi_api::security::v1::ListChild* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.ListConnResp.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListChild >&
ListConnResp::children() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.ListConnResp.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// IPsecListConnsResponse

// repeated .opi_api.security.v1.ListConnResp connection = 1;
inline int IPsecListConnsResponse::_internal_connection_size() const {
  return _impl_.connection_.size();
}
inline int IPsecListConnsResponse::connection_size() const {
  return _internal_connection_size();
}
inline void IPsecListConnsResponse::clear_connection() {
  _impl_.connection_.Clear();
}
inline ::opi_api::security::v1::ListConnResp* IPsecListConnsResponse::mutable_connection(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListConnsResponse.connection)
  return _impl_.connection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnResp >*
IPsecListConnsResponse::mutable_connection() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.IPsecListConnsResponse.connection)
  return &_impl_.connection_;
}
inline const ::opi_api::security::v1::ListConnResp& IPsecListConnsResponse::_internal_connection(int index) const {
  return _impl_.connection_.Get(index);
}
inline const ::opi_api::security::v1::ListConnResp& IPsecListConnsResponse::connection(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListConnsResponse.connection)
  return _internal_connection(index);
}
inline ::opi_api::security::v1::ListConnResp* IPsecListConnsResponse::_internal_add_connection() {
  return _impl_.connection_.Add();
}
inline ::opi_api::security::v1::ListConnResp* IPsecListConnsResponse::add_connection() {
  ::opi_api::security::v1::ListConnResp* _add = _internal_add_connection();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.IPsecListConnsResponse.connection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListConnResp >&
IPsecListConnsResponse::connection() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.IPsecListConnsResponse.connection)
  return _impl_.connection_;
}

// -------------------------------------------------------------------

// IPsecListCertsRequest

// string type = 1;
inline void IPsecListCertsRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& IPsecListCertsRequest::type() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListCertsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListCertsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListCertsRequest.type)
}
inline std::string* IPsecListCertsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListCertsRequest.type)
  return _s;
}
inline const std::string& IPsecListCertsRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void IPsecListCertsRequest::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListCertsRequest::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListCertsRequest::release_type() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListCertsRequest.type)
  return _impl_.type_.Release();
}
inline void IPsecListCertsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListCertsRequest.type)
}

// string flag = 2;
inline void IPsecListCertsRequest::clear_flag() {
  _impl_.flag_.ClearToEmpty();
}
inline const std::string& IPsecListCertsRequest::flag() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListCertsRequest.flag)
  return _internal_flag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListCertsRequest::set_flag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListCertsRequest.flag)
}
inline std::string* IPsecListCertsRequest::mutable_flag() {
  std::string* _s = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListCertsRequest.flag)
  return _s;
}
inline const std::string& IPsecListCertsRequest::_internal_flag() const {
  return _impl_.flag_.Get();
}
inline void IPsecListCertsRequest::_internal_set_flag(const std::string& value) {
  
  _impl_.flag_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListCertsRequest::_internal_mutable_flag() {
  
  return _impl_.flag_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListCertsRequest::release_flag() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListCertsRequest.flag)
  return _impl_.flag_.Release();
}
inline void IPsecListCertsRequest::set_allocated_flag(std::string* flag) {
  if (flag != nullptr) {
    
  } else {
    
  }
  _impl_.flag_.SetAllocated(flag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flag_.IsDefault()) {
    _impl_.flag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListCertsRequest.flag)
}

// string subject = 3;
inline void IPsecListCertsRequest::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& IPsecListCertsRequest::subject() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListCertsRequest.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecListCertsRequest::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecListCertsRequest.subject)
}
inline std::string* IPsecListCertsRequest::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListCertsRequest.subject)
  return _s;
}
inline const std::string& IPsecListCertsRequest::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void IPsecListCertsRequest::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecListCertsRequest::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecListCertsRequest::release_subject() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecListCertsRequest.subject)
  return _impl_.subject_.Release();
}
inline void IPsecListCertsRequest::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecListCertsRequest.subject)
}

// -------------------------------------------------------------------

// ListCert

// .opi_api.security.v1.CertificateType type = 1;
inline void ListCert::clear_type() {
  _impl_.type_ = 0;
}
inline ::opi_api::security::v1::CertificateType ListCert::_internal_type() const {
  return static_cast< ::opi_api::security::v1::CertificateType >(_impl_.type_);
}
inline ::opi_api::security::v1::CertificateType ListCert::type() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.type)
  return _internal_type();
}
inline void ListCert::_internal_set_type(::opi_api::security::v1::CertificateType value) {
  
  _impl_.type_ = value;
}
inline void ListCert::set_type(::opi_api::security::v1::CertificateType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.type)
}

// .opi_api.security.v1.X509CertificateFlag flag = 2;
inline void ListCert::clear_flag() {
  _impl_.flag_ = 0;
}
inline ::opi_api::security::v1::X509CertificateFlag ListCert::_internal_flag() const {
  return static_cast< ::opi_api::security::v1::X509CertificateFlag >(_impl_.flag_);
}
inline ::opi_api::security::v1::X509CertificateFlag ListCert::flag() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.flag)
  return _internal_flag();
}
inline void ListCert::_internal_set_flag(::opi_api::security::v1::X509CertificateFlag value) {
  
  _impl_.flag_ = value;
}
inline void ListCert::set_flag(::opi_api::security::v1::X509CertificateFlag value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.flag)
}

// string hasprivkey = 3;
inline void ListCert::clear_hasprivkey() {
  _impl_.hasprivkey_.ClearToEmpty();
}
inline const std::string& ListCert::hasprivkey() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.hasprivkey)
  return _internal_hasprivkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListCert::set_hasprivkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hasprivkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.hasprivkey)
}
inline std::string* ListCert::mutable_hasprivkey() {
  std::string* _s = _internal_mutable_hasprivkey();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListCert.hasprivkey)
  return _s;
}
inline const std::string& ListCert::_internal_hasprivkey() const {
  return _impl_.hasprivkey_.Get();
}
inline void ListCert::_internal_set_hasprivkey(const std::string& value) {
  
  _impl_.hasprivkey_.Set(value, GetArenaForAllocation());
}
inline std::string* ListCert::_internal_mutable_hasprivkey() {
  
  return _impl_.hasprivkey_.Mutable(GetArenaForAllocation());
}
inline std::string* ListCert::release_hasprivkey() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListCert.hasprivkey)
  return _impl_.hasprivkey_.Release();
}
inline void ListCert::set_allocated_hasprivkey(std::string* hasprivkey) {
  if (hasprivkey != nullptr) {
    
  } else {
    
  }
  _impl_.hasprivkey_.SetAllocated(hasprivkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hasprivkey_.IsDefault()) {
    _impl_.hasprivkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListCert.hasprivkey)
}

// string data = 4;
inline void ListCert::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ListCert::data() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListCert::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.data)
}
inline std::string* ListCert::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListCert.data)
  return _s;
}
inline const std::string& ListCert::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ListCert::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ListCert::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ListCert::release_data() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListCert.data)
  return _impl_.data_.Release();
}
inline void ListCert::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListCert.data)
}

// string subject = 5;
inline void ListCert::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& ListCert::subject() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListCert::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.subject)
}
inline std::string* ListCert::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListCert.subject)
  return _s;
}
inline const std::string& ListCert::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void ListCert::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* ListCert::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* ListCert::release_subject() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListCert.subject)
  return _impl_.subject_.Release();
}
inline void ListCert::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListCert.subject)
}

// string notbefore = 6;
inline void ListCert::clear_notbefore() {
  _impl_.notbefore_.ClearToEmpty();
}
inline const std::string& ListCert::notbefore() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.notbefore)
  return _internal_notbefore();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListCert::set_notbefore(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notbefore_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.notbefore)
}
inline std::string* ListCert::mutable_notbefore() {
  std::string* _s = _internal_mutable_notbefore();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListCert.notbefore)
  return _s;
}
inline const std::string& ListCert::_internal_notbefore() const {
  return _impl_.notbefore_.Get();
}
inline void ListCert::_internal_set_notbefore(const std::string& value) {
  
  _impl_.notbefore_.Set(value, GetArenaForAllocation());
}
inline std::string* ListCert::_internal_mutable_notbefore() {
  
  return _impl_.notbefore_.Mutable(GetArenaForAllocation());
}
inline std::string* ListCert::release_notbefore() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListCert.notbefore)
  return _impl_.notbefore_.Release();
}
inline void ListCert::set_allocated_notbefore(std::string* notbefore) {
  if (notbefore != nullptr) {
    
  } else {
    
  }
  _impl_.notbefore_.SetAllocated(notbefore, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notbefore_.IsDefault()) {
    _impl_.notbefore_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListCert.notbefore)
}

// string notafter = 7;
inline void ListCert::clear_notafter() {
  _impl_.notafter_.ClearToEmpty();
}
inline const std::string& ListCert::notafter() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.ListCert.notafter)
  return _internal_notafter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListCert::set_notafter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notafter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.ListCert.notafter)
}
inline std::string* ListCert::mutable_notafter() {
  std::string* _s = _internal_mutable_notafter();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.ListCert.notafter)
  return _s;
}
inline const std::string& ListCert::_internal_notafter() const {
  return _impl_.notafter_.Get();
}
inline void ListCert::_internal_set_notafter(const std::string& value) {
  
  _impl_.notafter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListCert::_internal_mutable_notafter() {
  
  return _impl_.notafter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListCert::release_notafter() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.ListCert.notafter)
  return _impl_.notafter_.Release();
}
inline void ListCert::set_allocated_notafter(std::string* notafter) {
  if (notafter != nullptr) {
    
  } else {
    
  }
  _impl_.notafter_.SetAllocated(notafter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notafter_.IsDefault()) {
    _impl_.notafter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.ListCert.notafter)
}

// -------------------------------------------------------------------

// IPsecListCertsResponse

// repeated .opi_api.security.v1.ListCert certs = 1;
inline int IPsecListCertsResponse::_internal_certs_size() const {
  return _impl_.certs_.size();
}
inline int IPsecListCertsResponse::certs_size() const {
  return _internal_certs_size();
}
inline void IPsecListCertsResponse::clear_certs() {
  _impl_.certs_.Clear();
}
inline ::opi_api::security::v1::ListCert* IPsecListCertsResponse::mutable_certs(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecListCertsResponse.certs)
  return _impl_.certs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListCert >*
IPsecListCertsResponse::mutable_certs() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.v1.IPsecListCertsResponse.certs)
  return &_impl_.certs_;
}
inline const ::opi_api::security::v1::ListCert& IPsecListCertsResponse::_internal_certs(int index) const {
  return _impl_.certs_.Get(index);
}
inline const ::opi_api::security::v1::ListCert& IPsecListCertsResponse::certs(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecListCertsResponse.certs)
  return _internal_certs(index);
}
inline ::opi_api::security::v1::ListCert* IPsecListCertsResponse::_internal_add_certs() {
  return _impl_.certs_.Add();
}
inline ::opi_api::security::v1::ListCert* IPsecListCertsResponse::add_certs() {
  ::opi_api::security::v1::ListCert* _add = _internal_add_certs();
  // @@protoc_insertion_point(field_add:opi_api.security.v1.IPsecListCertsResponse.certs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::v1::ListCert >&
IPsecListCertsResponse::certs() const {
  // @@protoc_insertion_point(field_list:opi_api.security.v1.IPsecListCertsResponse.certs)
  return _impl_.certs_;
}

// -------------------------------------------------------------------

// IPsecLoadConnRequest

// .opi_api.security.v1.Connection connection = 1;
inline bool IPsecLoadConnRequest::_internal_has_connection() const {
  return this != internal_default_instance() && _impl_.connection_ != nullptr;
}
inline bool IPsecLoadConnRequest::has_connection() const {
  return _internal_has_connection();
}
inline void IPsecLoadConnRequest::clear_connection() {
  if (GetArenaForAllocation() == nullptr && _impl_.connection_ != nullptr) {
    delete _impl_.connection_;
  }
  _impl_.connection_ = nullptr;
}
inline const ::opi_api::security::v1::Connection& IPsecLoadConnRequest::_internal_connection() const {
  const ::opi_api::security::v1::Connection* p = _impl_.connection_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::v1::Connection&>(
      ::opi_api::security::v1::_Connection_default_instance_);
}
inline const ::opi_api::security::v1::Connection& IPsecLoadConnRequest::connection() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecLoadConnRequest.connection)
  return _internal_connection();
}
inline void IPsecLoadConnRequest::unsafe_arena_set_allocated_connection(
    ::opi_api::security::v1::Connection* connection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_);
  }
  _impl_.connection_ = connection;
  if (connection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.v1.IPsecLoadConnRequest.connection)
}
inline ::opi_api::security::v1::Connection* IPsecLoadConnRequest::release_connection() {
  
  ::opi_api::security::v1::Connection* temp = _impl_.connection_;
  _impl_.connection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::v1::Connection* IPsecLoadConnRequest::unsafe_arena_release_connection() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecLoadConnRequest.connection)
  
  ::opi_api::security::v1::Connection* temp = _impl_.connection_;
  _impl_.connection_ = nullptr;
  return temp;
}
inline ::opi_api::security::v1::Connection* IPsecLoadConnRequest::_internal_mutable_connection() {
  
  if (_impl_.connection_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::v1::Connection>(GetArenaForAllocation());
    _impl_.connection_ = p;
  }
  return _impl_.connection_;
}
inline ::opi_api::security::v1::Connection* IPsecLoadConnRequest::mutable_connection() {
  ::opi_api::security::v1::Connection* _msg = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecLoadConnRequest.connection)
  return _msg;
}
inline void IPsecLoadConnRequest::set_allocated_connection(::opi_api::security::v1::Connection* connection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_;
  }
  if (connection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection);
    if (message_arena != submessage_arena) {
      connection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecLoadConnRequest.connection)
}

// -------------------------------------------------------------------

// IPsecLoadConnResponse

// string success = 1;
inline void IPsecLoadConnResponse::clear_success() {
  _impl_.success_.ClearToEmpty();
}
inline const std::string& IPsecLoadConnResponse::success() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecLoadConnResponse.success)
  return _internal_success();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecLoadConnResponse::set_success(ArgT0&& arg0, ArgT... args) {
 
 _impl_.success_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecLoadConnResponse.success)
}
inline std::string* IPsecLoadConnResponse::mutable_success() {
  std::string* _s = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecLoadConnResponse.success)
  return _s;
}
inline const std::string& IPsecLoadConnResponse::_internal_success() const {
  return _impl_.success_.Get();
}
inline void IPsecLoadConnResponse::_internal_set_success(const std::string& value) {
  
  _impl_.success_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecLoadConnResponse::_internal_mutable_success() {
  
  return _impl_.success_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecLoadConnResponse::release_success() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecLoadConnResponse.success)
  return _impl_.success_.Release();
}
inline void IPsecLoadConnResponse::set_allocated_success(std::string* success) {
  if (success != nullptr) {
    
  } else {
    
  }
  _impl_.success_.SetAllocated(success, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.success_.IsDefault()) {
    _impl_.success_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecLoadConnResponse.success)
}

// -------------------------------------------------------------------

// IPsecUnloadConnRequest

// string name = 1;
inline void IPsecUnloadConnRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IPsecUnloadConnRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecUnloadConnRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecUnloadConnRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecUnloadConnRequest.name)
}
inline std::string* IPsecUnloadConnRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecUnloadConnRequest.name)
  return _s;
}
inline const std::string& IPsecUnloadConnRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IPsecUnloadConnRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecUnloadConnRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecUnloadConnRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecUnloadConnRequest.name)
  return _impl_.name_.Release();
}
inline void IPsecUnloadConnRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecUnloadConnRequest.name)
}

// -------------------------------------------------------------------

// IPsecUnloadConnResponse

// string success = 1;
inline void IPsecUnloadConnResponse::clear_success() {
  _impl_.success_.ClearToEmpty();
}
inline const std::string& IPsecUnloadConnResponse::success() const {
  // @@protoc_insertion_point(field_get:opi_api.security.v1.IPsecUnloadConnResponse.success)
  return _internal_success();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPsecUnloadConnResponse::set_success(ArgT0&& arg0, ArgT... args) {
 
 _impl_.success_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.v1.IPsecUnloadConnResponse.success)
}
inline std::string* IPsecUnloadConnResponse::mutable_success() {
  std::string* _s = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:opi_api.security.v1.IPsecUnloadConnResponse.success)
  return _s;
}
inline const std::string& IPsecUnloadConnResponse::_internal_success() const {
  return _impl_.success_.Get();
}
inline void IPsecUnloadConnResponse::_internal_set_success(const std::string& value) {
  
  _impl_.success_.Set(value, GetArenaForAllocation());
}
inline std::string* IPsecUnloadConnResponse::_internal_mutable_success() {
  
  return _impl_.success_.Mutable(GetArenaForAllocation());
}
inline std::string* IPsecUnloadConnResponse::release_success() {
  // @@protoc_insertion_point(field_release:opi_api.security.v1.IPsecUnloadConnResponse.success)
  return _impl_.success_.Release();
}
inline void IPsecUnloadConnResponse::set_allocated_success(std::string* success) {
  if (success != nullptr) {
    
  } else {
    
  }
  _impl_.success_.SetAllocated(success, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.success_.IsDefault()) {
    _impl_.success_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.v1.IPsecUnloadConnResponse.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace security
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::security::v1::CryptoAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::CryptoAlgorithm>() {
  return ::opi_api::security::v1::CryptoAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::IntegAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::IntegAlgorithm>() {
  return ::opi_api::security::v1::IntegAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::DHGroups> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::DHGroups>() {
  return ::opi_api::security::v1::DHGroups_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::PRFunction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::PRFunction>() {
  return ::opi_api::security::v1::PRFunction_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::IpsecMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::IpsecMode>() {
  return ::opi_api::security::v1::IpsecMode_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::AuthType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::AuthType>() {
  return ::opi_api::security::v1::AuthType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::IkeSaState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::IkeSaState>() {
  return ::opi_api::security::v1::IkeSaState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::ChildSaState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::ChildSaState>() {
  return ::opi_api::security::v1::ChildSaState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::CertificateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::CertificateType>() {
  return ::opi_api::security::v1::CertificateType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::v1::X509CertificateFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::v1::X509CertificateFlag>() {
  return ::opi_api::security::v1::X509CertificateFlag_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ipsec_2eproto
