// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openoffload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openoffload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openoffload_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openoffload_2eproto;
namespace opi_api {
namespace security {
namespace firewall {
namespace v1 {
class ActionParameters;
struct ActionParametersDefaultTypeInternal;
extern ActionParametersDefaultTypeInternal _ActionParameters_default_instance_;
class AddSessionResponse;
struct AddSessionResponseDefaultTypeInternal;
extern AddSessionResponseDefaultTypeInternal _AddSessionResponse_default_instance_;
class SessionId;
struct SessionIdDefaultTypeInternal;
extern SessionIdDefaultTypeInternal _SessionId_default_instance_;
class SessionRequest;
struct SessionRequestDefaultTypeInternal;
extern SessionRequestDefaultTypeInternal _SessionRequest_default_instance_;
class SessionRequestArgs;
struct SessionRequestArgsDefaultTypeInternal;
extern SessionRequestArgsDefaultTypeInternal _SessionRequestArgs_default_instance_;
class SessionResponse;
struct SessionResponseDefaultTypeInternal;
extern SessionResponseDefaultTypeInternal _SessionResponse_default_instance_;
class SessionResponseError;
struct SessionResponseErrorDefaultTypeInternal;
extern SessionResponseErrorDefaultTypeInternal _SessionResponseError_default_instance_;
class SessionResponses;
struct SessionResponsesDefaultTypeInternal;
extern SessionResponsesDefaultTypeInternal _SessionResponses_default_instance_;
class Uuid;
struct UuidDefaultTypeInternal;
extern UuidDefaultTypeInternal _Uuid_default_instance_;
}  // namespace v1
}  // namespace firewall
}  // namespace security
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::security::firewall::v1::ActionParameters* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::ActionParameters>(Arena*);
template<> ::opi_api::security::firewall::v1::AddSessionResponse* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::AddSessionResponse>(Arena*);
template<> ::opi_api::security::firewall::v1::SessionId* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::SessionId>(Arena*);
template<> ::opi_api::security::firewall::v1::SessionRequest* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::SessionRequest>(Arena*);
template<> ::opi_api::security::firewall::v1::SessionRequestArgs* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::SessionRequestArgs>(Arena*);
template<> ::opi_api::security::firewall::v1::SessionResponse* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::SessionResponse>(Arena*);
template<> ::opi_api::security::firewall::v1::SessionResponseError* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::SessionResponseError>(Arena*);
template<> ::opi_api::security::firewall::v1::SessionResponses* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::SessionResponses>(Arena*);
template<> ::opi_api::security::firewall::v1::Uuid* Arena::CreateMaybeMessage<::opi_api::security::firewall::v1::Uuid>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace security {
namespace firewall {
namespace v1 {

enum IpVersion : int {
  _IPV4 = 0,
  _IPV6 = 1,
  IpVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IpVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IpVersion_IsValid(int value);
constexpr IpVersion IpVersion_MIN = _IPV4;
constexpr IpVersion IpVersion_MAX = _IPV6;
constexpr int IpVersion_ARRAYSIZE = IpVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IpVersion_descriptor();
template<typename T>
inline const std::string& IpVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IpVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IpVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IpVersion_descriptor(), enum_t_value);
}
inline bool IpVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IpVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IpVersion>(
    IpVersion_descriptor(), name, value);
}
enum ProtocolId : int {
  _HOPOPT = 0,
  _TCP = 6,
  _UDP = 17,
  ProtocolId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProtocolId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProtocolId_IsValid(int value);
constexpr ProtocolId ProtocolId_MIN = _HOPOPT;
constexpr ProtocolId ProtocolId_MAX = _UDP;
constexpr int ProtocolId_ARRAYSIZE = ProtocolId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtocolId_descriptor();
template<typename T>
inline const std::string& ProtocolId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtocolId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtocolId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtocolId_descriptor(), enum_t_value);
}
inline bool ProtocolId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtocolId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtocolId>(
    ProtocolId_descriptor(), name, value);
}
enum SessionState : int {
  _ESTABLISHED = 0,
  _CLOSING_1 = 1,
  _CLOSING_2 = 2,
  _CLOSED = 3,
  _UNKNOWN_STATE = 4,
  SessionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionState_IsValid(int value);
constexpr SessionState SessionState_MIN = _ESTABLISHED;
constexpr SessionState SessionState_MAX = _UNKNOWN_STATE;
constexpr int SessionState_ARRAYSIZE = SessionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionState_descriptor();
template<typename T>
inline const std::string& SessionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionState_descriptor(), enum_t_value);
}
inline bool SessionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionState>(
    SessionState_descriptor(), name, value);
}
enum SessionCloseCode : int {
  _NOT_CLOSED = 0,
  _FINACK = 1,
  _RST = 2,
  _TIMEOUT = 3,
  _UNKNOWN_CLOSE_CODE = 4,
  SessionCloseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionCloseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionCloseCode_IsValid(int value);
constexpr SessionCloseCode SessionCloseCode_MIN = _NOT_CLOSED;
constexpr SessionCloseCode SessionCloseCode_MAX = _UNKNOWN_CLOSE_CODE;
constexpr int SessionCloseCode_ARRAYSIZE = SessionCloseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionCloseCode_descriptor();
template<typename T>
inline const std::string& SessionCloseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionCloseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionCloseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionCloseCode_descriptor(), enum_t_value);
}
inline bool SessionCloseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionCloseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionCloseCode>(
    SessionCloseCode_descriptor(), name, value);
}
enum AddSessionStatus : int {
  _SESSION_ACCEPTED = 0,
  _SESSION_REJECTED = 1,
  _SESSION_TABLE_FULL = 2,
  _SESSION_TABLE_UNAVAILABLE = 3,
  _SESSION_ALREADY_EXISTS = 4,
  AddSessionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddSessionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddSessionStatus_IsValid(int value);
constexpr AddSessionStatus AddSessionStatus_MIN = _SESSION_ACCEPTED;
constexpr AddSessionStatus AddSessionStatus_MAX = _SESSION_ALREADY_EXISTS;
constexpr int AddSessionStatus_ARRAYSIZE = AddSessionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddSessionStatus_descriptor();
template<typename T>
inline const std::string& AddSessionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddSessionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddSessionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddSessionStatus_descriptor(), enum_t_value);
}
inline bool AddSessionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddSessionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddSessionStatus>(
    AddSessionStatus_descriptor(), name, value);
}
enum RequestStatus : int {
  _ACCEPTED = 0,
  _REJECTED = 1,
  _REJECTED_SESSION_NONEXISTENT = 2,
  _REJECTED_SESSION_TABLE_FULL = 3,
  _REJECTED_SESSION_ALREADY_EXISTS = 4,
  _NO_CLOSED_SESSIONS = 5,
  _REJECTED_INTERNAL_ERROR = 6,
  RequestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestStatus_IsValid(int value);
constexpr RequestStatus RequestStatus_MIN = _ACCEPTED;
constexpr RequestStatus RequestStatus_MAX = _REJECTED_INTERNAL_ERROR;
constexpr int RequestStatus_ARRAYSIZE = RequestStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestStatus_descriptor();
template<typename T>
inline const std::string& RequestStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestStatus_descriptor(), enum_t_value);
}
inline bool RequestStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestStatus>(
    RequestStatus_descriptor(), name, value);
}
enum ActionType : int {
  _DROP = 0,
  _FORWARD = 1,
  _MIRROR = 2,
  _SNOOP = 3,
  _PROXY = 4,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = _DROP;
constexpr ActionType ActionType_MAX = _PROXY;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
// ===================================================================

class Uuid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.Uuid) */ {
 public:
  inline Uuid() : Uuid(nullptr) {}
  ~Uuid() override;
  explicit constexpr Uuid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uuid(const Uuid& from);
  Uuid(Uuid&& from) noexcept
    : Uuid() {
    *this = ::std::move(from);
  }

  inline Uuid& operator=(const Uuid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uuid& operator=(Uuid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uuid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uuid* internal_default_instance() {
    return reinterpret_cast<const Uuid*>(
               &_Uuid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Uuid& a, Uuid& b) {
    a.Swap(&b);
  }
  inline void Swap(Uuid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uuid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uuid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uuid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uuid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uuid& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uuid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.Uuid";
  }
  protected:
  explicit Uuid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.Uuid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.SessionId) */ {
 public:
  inline SessionId() : SessionId(nullptr) {}
  ~SessionId() override;
  explicit constexpr SessionId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionId(const SessionId& from);
  SessionId(SessionId&& from) noexcept
    : SessionId() {
    *this = ::std::move(from);
  }

  inline SessionId& operator=(const SessionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionId& operator=(SessionId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionId& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionId* internal_default_instance() {
    return reinterpret_cast<const SessionId*>(
               &_SessionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SessionId& a, SessionId& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.SessionId";
  }
  protected:
  explicit SessionId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.SessionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class ActionParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.ActionParameters) */ {
 public:
  inline ActionParameters() : ActionParameters(nullptr) {}
  ~ActionParameters() override;
  explicit constexpr ActionParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionParameters(const ActionParameters& from);
  ActionParameters(ActionParameters&& from) noexcept
    : ActionParameters() {
    *this = ::std::move(from);
  }

  inline ActionParameters& operator=(const ActionParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionParameters& operator=(ActionParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionParameters* internal_default_instance() {
    return reinterpret_cast<const ActionParameters*>(
               &_ActionParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionParameters& a, ActionParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.ActionParameters";
  }
  protected:
  explicit ActionParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionnexthopv6FieldNumber = 3,
    kProxysrcv6FieldNumber = 6,
    kProxydstv6FieldNumber = 7,
    kSrcconnidFieldNumber = 8,
    kDstconnidFieldNumber = 9,
    kActiontypeFieldNumber = 1,
    kActionnexthopFieldNumber = 2,
    kProxysrcv4FieldNumber = 4,
    kProxydstv4FieldNumber = 5,
  };
  // bytes actionnexthopv6 = 3;
  void clear_actionnexthopv6();
  const std::string& actionnexthopv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actionnexthopv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actionnexthopv6();
  PROTOBUF_NODISCARD std::string* release_actionnexthopv6();
  void set_allocated_actionnexthopv6(std::string* actionnexthopv6);
  private:
  const std::string& _internal_actionnexthopv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actionnexthopv6(const std::string& value);
  std::string* _internal_mutable_actionnexthopv6();
  public:

  // bytes proxysrcv6 = 6;
  void clear_proxysrcv6();
  const std::string& proxysrcv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proxysrcv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proxysrcv6();
  PROTOBUF_NODISCARD std::string* release_proxysrcv6();
  void set_allocated_proxysrcv6(std::string* proxysrcv6);
  private:
  const std::string& _internal_proxysrcv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxysrcv6(const std::string& value);
  std::string* _internal_mutable_proxysrcv6();
  public:

  // bytes proxydstv6 = 7;
  void clear_proxydstv6();
  const std::string& proxydstv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proxydstv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proxydstv6();
  PROTOBUF_NODISCARD std::string* release_proxydstv6();
  void set_allocated_proxydstv6(std::string* proxydstv6);
  private:
  const std::string& _internal_proxydstv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxydstv6(const std::string& value);
  std::string* _internal_mutable_proxydstv6();
  public:

  // bytes srcconnid = 8;
  void clear_srcconnid();
  const std::string& srcconnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcconnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcconnid();
  PROTOBUF_NODISCARD std::string* release_srcconnid();
  void set_allocated_srcconnid(std::string* srcconnid);
  private:
  const std::string& _internal_srcconnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcconnid(const std::string& value);
  std::string* _internal_mutable_srcconnid();
  public:

  // bytes dstconnid = 9;
  void clear_dstconnid();
  const std::string& dstconnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dstconnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dstconnid();
  PROTOBUF_NODISCARD std::string* release_dstconnid();
  void set_allocated_dstconnid(std::string* dstconnid);
  private:
  const std::string& _internal_dstconnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dstconnid(const std::string& value);
  std::string* _internal_mutable_dstconnid();
  public:

  // .opi_api.security.firewall.v1.ActionType actiontype = 1;
  void clear_actiontype();
  ::opi_api::security::firewall::v1::ActionType actiontype() const;
  void set_actiontype(::opi_api::security::firewall::v1::ActionType value);
  private:
  ::opi_api::security::firewall::v1::ActionType _internal_actiontype() const;
  void _internal_set_actiontype(::opi_api::security::firewall::v1::ActionType value);
  public:

  // uint32 actionnexthop = 2;
  void clear_actionnexthop();
  uint32_t actionnexthop() const;
  void set_actionnexthop(uint32_t value);
  private:
  uint32_t _internal_actionnexthop() const;
  void _internal_set_actionnexthop(uint32_t value);
  public:

  // uint32 proxysrcv4 = 4;
  void clear_proxysrcv4();
  uint32_t proxysrcv4() const;
  void set_proxysrcv4(uint32_t value);
  private:
  uint32_t _internal_proxysrcv4() const;
  void _internal_set_proxysrcv4(uint32_t value);
  public:

  // uint32 proxydstv4 = 5;
  void clear_proxydstv4();
  uint32_t proxydstv4() const;
  void set_proxydstv4(uint32_t value);
  private:
  uint32_t _internal_proxydstv4() const;
  void _internal_set_proxydstv4(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.ActionParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionnexthopv6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proxysrcv6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proxydstv6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcconnid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dstconnid_;
  int actiontype_;
  uint32_t actionnexthop_;
  uint32_t proxysrcv4_;
  uint32_t proxydstv4_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.SessionRequest) */ {
 public:
  inline SessionRequest() : SessionRequest(nullptr) {}
  ~SessionRequest() override;
  explicit constexpr SessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionRequest(const SessionRequest& from);
  SessionRequest(SessionRequest&& from) noexcept
    : SessionRequest() {
    *this = ::std::move(from);
  }

  inline SessionRequest& operator=(const SessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRequest& operator=(SessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionRequest* internal_default_instance() {
    return reinterpret_cast<const SessionRequest*>(
               &_SessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionRequest& a, SessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.SessionRequest";
  }
  protected:
  explicit SessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceipv6FieldNumber = 6,
    kDestinationipv6FieldNumber = 9,
    kSrcconnidFieldNumber = 14,
    kDstconnidFieldNumber = 15,
    kSessionIdFieldNumber = 1,
    kActionFieldNumber = 12,
    kInlifFieldNumber = 2,
    kOutlifFieldNumber = 3,
    kIpversionFieldNumber = 4,
    kSourceipFieldNumber = 5,
    kSourceportFieldNumber = 7,
    kDestinationipFieldNumber = 8,
    kDestinationportFieldNumber = 10,
    kProtocolidFieldNumber = 11,
    kCachetimeoutFieldNumber = 13,
  };
  // bytes sourceipv6 = 6;
  void clear_sourceipv6();
  const std::string& sourceipv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceipv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceipv6();
  PROTOBUF_NODISCARD std::string* release_sourceipv6();
  void set_allocated_sourceipv6(std::string* sourceipv6);
  private:
  const std::string& _internal_sourceipv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceipv6(const std::string& value);
  std::string* _internal_mutable_sourceipv6();
  public:

  // bytes destinationipv6 = 9;
  void clear_destinationipv6();
  const std::string& destinationipv6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destinationipv6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destinationipv6();
  PROTOBUF_NODISCARD std::string* release_destinationipv6();
  void set_allocated_destinationipv6(std::string* destinationipv6);
  private:
  const std::string& _internal_destinationipv6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destinationipv6(const std::string& value);
  std::string* _internal_mutable_destinationipv6();
  public:

  // bytes srcconnid = 14;
  void clear_srcconnid();
  const std::string& srcconnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_srcconnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_srcconnid();
  PROTOBUF_NODISCARD std::string* release_srcconnid();
  void set_allocated_srcconnid(std::string* srcconnid);
  private:
  const std::string& _internal_srcconnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_srcconnid(const std::string& value);
  std::string* _internal_mutable_srcconnid();
  public:

  // bytes dstconnid = 15;
  void clear_dstconnid();
  const std::string& dstconnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dstconnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dstconnid();
  PROTOBUF_NODISCARD std::string* release_dstconnid();
  void set_allocated_dstconnid(std::string* dstconnid);
  private:
  const std::string& _internal_dstconnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dstconnid(const std::string& value);
  std::string* _internal_mutable_dstconnid();
  public:

  // .opi_api.security.firewall.v1.Uuid session_id = 1;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  const ::opi_api::security::firewall::v1::Uuid& session_id() const;
  PROTOBUF_NODISCARD ::opi_api::security::firewall::v1::Uuid* release_session_id();
  ::opi_api::security::firewall::v1::Uuid* mutable_session_id();
  void set_allocated_session_id(::opi_api::security::firewall::v1::Uuid* session_id);
  private:
  const ::opi_api::security::firewall::v1::Uuid& _internal_session_id() const;
  ::opi_api::security::firewall::v1::Uuid* _internal_mutable_session_id();
  public:
  void unsafe_arena_set_allocated_session_id(
      ::opi_api::security::firewall::v1::Uuid* session_id);
  ::opi_api::security::firewall::v1::Uuid* unsafe_arena_release_session_id();

  // .opi_api.security.firewall.v1.ActionParameters action = 12;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::opi_api::security::firewall::v1::ActionParameters& action() const;
  PROTOBUF_NODISCARD ::opi_api::security::firewall::v1::ActionParameters* release_action();
  ::opi_api::security::firewall::v1::ActionParameters* mutable_action();
  void set_allocated_action(::opi_api::security::firewall::v1::ActionParameters* action);
  private:
  const ::opi_api::security::firewall::v1::ActionParameters& _internal_action() const;
  ::opi_api::security::firewall::v1::ActionParameters* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::opi_api::security::firewall::v1::ActionParameters* action);
  ::opi_api::security::firewall::v1::ActionParameters* unsafe_arena_release_action();

  // int32 inlif = 2;
  void clear_inlif();
  int32_t inlif() const;
  void set_inlif(int32_t value);
  private:
  int32_t _internal_inlif() const;
  void _internal_set_inlif(int32_t value);
  public:

  // int32 outlif = 3;
  void clear_outlif();
  int32_t outlif() const;
  void set_outlif(int32_t value);
  private:
  int32_t _internal_outlif() const;
  void _internal_set_outlif(int32_t value);
  public:

  // .opi_api.security.firewall.v1.IpVersion ipversion = 4;
  void clear_ipversion();
  ::opi_api::security::firewall::v1::IpVersion ipversion() const;
  void set_ipversion(::opi_api::security::firewall::v1::IpVersion value);
  private:
  ::opi_api::security::firewall::v1::IpVersion _internal_ipversion() const;
  void _internal_set_ipversion(::opi_api::security::firewall::v1::IpVersion value);
  public:

  // uint32 sourceip = 5;
  void clear_sourceip();
  uint32_t sourceip() const;
  void set_sourceip(uint32_t value);
  private:
  uint32_t _internal_sourceip() const;
  void _internal_set_sourceip(uint32_t value);
  public:

  // uint32 sourceport = 7;
  void clear_sourceport();
  uint32_t sourceport() const;
  void set_sourceport(uint32_t value);
  private:
  uint32_t _internal_sourceport() const;
  void _internal_set_sourceport(uint32_t value);
  public:

  // uint32 destinationip = 8;
  void clear_destinationip();
  uint32_t destinationip() const;
  void set_destinationip(uint32_t value);
  private:
  uint32_t _internal_destinationip() const;
  void _internal_set_destinationip(uint32_t value);
  public:

  // uint32 destinationport = 10;
  void clear_destinationport();
  uint32_t destinationport() const;
  void set_destinationport(uint32_t value);
  private:
  uint32_t _internal_destinationport() const;
  void _internal_set_destinationport(uint32_t value);
  public:

  // .opi_api.security.firewall.v1.ProtocolId protocolid = 11;
  void clear_protocolid();
  ::opi_api::security::firewall::v1::ProtocolId protocolid() const;
  void set_protocolid(::opi_api::security::firewall::v1::ProtocolId value);
  private:
  ::opi_api::security::firewall::v1::ProtocolId _internal_protocolid() const;
  void _internal_set_protocolid(::opi_api::security::firewall::v1::ProtocolId value);
  public:

  // uint32 cachetimeout = 13;
  void clear_cachetimeout();
  uint32_t cachetimeout() const;
  void set_cachetimeout(uint32_t value);
  private:
  uint32_t _internal_cachetimeout() const;
  void _internal_set_cachetimeout(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.SessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceipv6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destinationipv6_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcconnid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dstconnid_;
  ::opi_api::security::firewall::v1::Uuid* session_id_;
  ::opi_api::security::firewall::v1::ActionParameters* action_;
  int32_t inlif_;
  int32_t outlif_;
  int ipversion_;
  uint32_t sourceip_;
  uint32_t sourceport_;
  uint32_t destinationip_;
  uint32_t destinationport_;
  int protocolid_;
  uint32_t cachetimeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionResponseError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.SessionResponseError) */ {
 public:
  inline SessionResponseError() : SessionResponseError(nullptr) {}
  ~SessionResponseError() override;
  explicit constexpr SessionResponseError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponseError(const SessionResponseError& from);
  SessionResponseError(SessionResponseError&& from) noexcept
    : SessionResponseError() {
    *this = ::std::move(from);
  }

  inline SessionResponseError& operator=(const SessionResponseError& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponseError& operator=(SessionResponseError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionResponseError& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponseError* internal_default_instance() {
    return reinterpret_cast<const SessionResponseError*>(
               &_SessionResponseError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SessionResponseError& a, SessionResponseError& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponseError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponseError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponseError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponseError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionResponseError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionResponseError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponseError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.SessionResponseError";
  }
  protected:
  explicit SessionResponseError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionidFieldNumber = 1,
    kErrorstatusFieldNumber = 2,
  };
  // .opi_api.security.firewall.v1.Uuid sessionid = 1;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  const ::opi_api::security::firewall::v1::Uuid& sessionid() const;
  PROTOBUF_NODISCARD ::opi_api::security::firewall::v1::Uuid* release_sessionid();
  ::opi_api::security::firewall::v1::Uuid* mutable_sessionid();
  void set_allocated_sessionid(::opi_api::security::firewall::v1::Uuid* sessionid);
  private:
  const ::opi_api::security::firewall::v1::Uuid& _internal_sessionid() const;
  ::opi_api::security::firewall::v1::Uuid* _internal_mutable_sessionid();
  public:
  void unsafe_arena_set_allocated_sessionid(
      ::opi_api::security::firewall::v1::Uuid* sessionid);
  ::opi_api::security::firewall::v1::Uuid* unsafe_arena_release_sessionid();

  // int32 errorstatus = 2;
  void clear_errorstatus();
  int32_t errorstatus() const;
  void set_errorstatus(int32_t value);
  private:
  int32_t _internal_errorstatus() const;
  void _internal_set_errorstatus(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.SessionResponseError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::security::firewall::v1::Uuid* sessionid_;
  int32_t errorstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.SessionResponses) */ {
 public:
  inline SessionResponses() : SessionResponses(nullptr) {}
  ~SessionResponses() override;
  explicit constexpr SessionResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponses(const SessionResponses& from);
  SessionResponses(SessionResponses&& from) noexcept
    : SessionResponses() {
    *this = ::std::move(from);
  }

  inline SessionResponses& operator=(const SessionResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponses& operator=(SessionResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponses* internal_default_instance() {
    return reinterpret_cast<const SessionResponses*>(
               &_SessionResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SessionResponses& a, SessionResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionResponses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.SessionResponses";
  }
  protected:
  explicit SessionResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessioninfoFieldNumber = 1,
    kNextkeyFieldNumber = 2,
  };
  // repeated .opi_api.security.firewall.v1.SessionResponse sessioninfo = 1;
  int sessioninfo_size() const;
  private:
  int _internal_sessioninfo_size() const;
  public:
  void clear_sessioninfo();
  ::opi_api::security::firewall::v1::SessionResponse* mutable_sessioninfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponse >*
      mutable_sessioninfo();
  private:
  const ::opi_api::security::firewall::v1::SessionResponse& _internal_sessioninfo(int index) const;
  ::opi_api::security::firewall::v1::SessionResponse* _internal_add_sessioninfo();
  public:
  const ::opi_api::security::firewall::v1::SessionResponse& sessioninfo(int index) const;
  ::opi_api::security::firewall::v1::SessionResponse* add_sessioninfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponse >&
      sessioninfo() const;

  // uint64 nextkey = 2;
  void clear_nextkey();
  uint64_t nextkey() const;
  void set_nextkey(uint64_t value);
  private:
  uint64_t _internal_nextkey() const;
  void _internal_set_nextkey(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.SessionResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponse > sessioninfo_;
  uint64_t nextkey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class AddSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.AddSessionResponse) */ {
 public:
  inline AddSessionResponse() : AddSessionResponse(nullptr) {}
  ~AddSessionResponse() override;
  explicit constexpr AddSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSessionResponse(const AddSessionResponse& from);
  AddSessionResponse(AddSessionResponse&& from) noexcept
    : AddSessionResponse() {
    *this = ::std::move(from);
  }

  inline AddSessionResponse& operator=(const AddSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSessionResponse& operator=(AddSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSessionResponse* internal_default_instance() {
    return reinterpret_cast<const AddSessionResponse*>(
               &_AddSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AddSessionResponse& a, AddSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddSessionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.AddSessionResponse";
  }
  protected:
  explicit AddSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseerrorFieldNumber = 4,
    kStarttimeFieldNumber = 3,
    kErrorstatusFieldNumber = 2,
    kRequeststatusFieldNumber = 1,
  };
  // repeated .opi_api.security.firewall.v1.SessionResponseError responseerror = 4;
  int responseerror_size() const;
  private:
  int _internal_responseerror_size() const;
  public:
  void clear_responseerror();
  ::opi_api::security::firewall::v1::SessionResponseError* mutable_responseerror(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponseError >*
      mutable_responseerror();
  private:
  const ::opi_api::security::firewall::v1::SessionResponseError& _internal_responseerror(int index) const;
  ::opi_api::security::firewall::v1::SessionResponseError* _internal_add_responseerror();
  public:
  const ::opi_api::security::firewall::v1::SessionResponseError& responseerror(int index) const;
  ::opi_api::security::firewall::v1::SessionResponseError* add_responseerror();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponseError >&
      responseerror() const;

  // .google.protobuf.Timestamp starttime = 3;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& starttime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_starttime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_starttime();
  void set_allocated_starttime(::PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_starttime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_starttime();

  // uint64 errorstatus = 2;
  void clear_errorstatus();
  uint64_t errorstatus() const;
  void set_errorstatus(uint64_t value);
  private:
  uint64_t _internal_errorstatus() const;
  void _internal_set_errorstatus(uint64_t value);
  public:

  // .opi_api.security.firewall.v1.AddSessionStatus requeststatus = 1;
  void clear_requeststatus();
  ::opi_api::security::firewall::v1::AddSessionStatus requeststatus() const;
  void set_requeststatus(::opi_api::security::firewall::v1::AddSessionStatus value);
  private:
  ::opi_api::security::firewall::v1::AddSessionStatus _internal_requeststatus() const;
  void _internal_set_requeststatus(::opi_api::security::firewall::v1::AddSessionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.AddSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponseError > responseerror_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* starttime_;
  uint64_t errorstatus_;
  int requeststatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.SessionResponse) */ {
 public:
  inline SessionResponse() : SessionResponse(nullptr) {}
  ~SessionResponse() override;
  explicit constexpr SessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionResponse(const SessionResponse& from);
  SessionResponse(SessionResponse&& from) noexcept
    : SessionResponse() {
    *this = ::std::move(from);
  }

  inline SessionResponse& operator=(const SessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponse& operator=(SessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionResponse* internal_default_instance() {
    return reinterpret_cast<const SessionResponse*>(
               &_SessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SessionResponse& a, SessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.SessionResponse";
  }
  protected:
  explicit SessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionidFieldNumber = 1,
    kStarttimeFieldNumber = 9,
    kEndtimeFieldNumber = 10,
    kInpacketsFieldNumber = 2,
    kOutpacketsFieldNumber = 3,
    kInbytesFieldNumber = 4,
    kOutbytesFieldNumber = 5,
    kSessionstateFieldNumber = 6,
    kSessionclosecodeFieldNumber = 7,
    kRequeststatusFieldNumber = 8,
  };
  // .opi_api.security.firewall.v1.Uuid sessionid = 1;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  const ::opi_api::security::firewall::v1::Uuid& sessionid() const;
  PROTOBUF_NODISCARD ::opi_api::security::firewall::v1::Uuid* release_sessionid();
  ::opi_api::security::firewall::v1::Uuid* mutable_sessionid();
  void set_allocated_sessionid(::opi_api::security::firewall::v1::Uuid* sessionid);
  private:
  const ::opi_api::security::firewall::v1::Uuid& _internal_sessionid() const;
  ::opi_api::security::firewall::v1::Uuid* _internal_mutable_sessionid();
  public:
  void unsafe_arena_set_allocated_sessionid(
      ::opi_api::security::firewall::v1::Uuid* sessionid);
  ::opi_api::security::firewall::v1::Uuid* unsafe_arena_release_sessionid();

  // .google.protobuf.Timestamp starttime = 9;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& starttime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_starttime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_starttime();
  void set_allocated_starttime(::PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_starttime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_starttime();

  // .google.protobuf.Timestamp endtime = 10;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& endtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_endtime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_endtime();
  void set_allocated_endtime(::PROTOBUF_NAMESPACE_ID::Timestamp* endtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_endtime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_endtime();
  public:
  void unsafe_arena_set_allocated_endtime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* endtime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_endtime();

  // uint64 inpackets = 2;
  void clear_inpackets();
  uint64_t inpackets() const;
  void set_inpackets(uint64_t value);
  private:
  uint64_t _internal_inpackets() const;
  void _internal_set_inpackets(uint64_t value);
  public:

  // uint64 outpackets = 3;
  void clear_outpackets();
  uint64_t outpackets() const;
  void set_outpackets(uint64_t value);
  private:
  uint64_t _internal_outpackets() const;
  void _internal_set_outpackets(uint64_t value);
  public:

  // uint64 inbytes = 4;
  void clear_inbytes();
  uint64_t inbytes() const;
  void set_inbytes(uint64_t value);
  private:
  uint64_t _internal_inbytes() const;
  void _internal_set_inbytes(uint64_t value);
  public:

  // uint64 outbytes = 5;
  void clear_outbytes();
  uint64_t outbytes() const;
  void set_outbytes(uint64_t value);
  private:
  uint64_t _internal_outbytes() const;
  void _internal_set_outbytes(uint64_t value);
  public:

  // .opi_api.security.firewall.v1.SessionState sessionstate = 6;
  void clear_sessionstate();
  ::opi_api::security::firewall::v1::SessionState sessionstate() const;
  void set_sessionstate(::opi_api::security::firewall::v1::SessionState value);
  private:
  ::opi_api::security::firewall::v1::SessionState _internal_sessionstate() const;
  void _internal_set_sessionstate(::opi_api::security::firewall::v1::SessionState value);
  public:

  // .opi_api.security.firewall.v1.SessionCloseCode sessionclosecode = 7;
  void clear_sessionclosecode();
  ::opi_api::security::firewall::v1::SessionCloseCode sessionclosecode() const;
  void set_sessionclosecode(::opi_api::security::firewall::v1::SessionCloseCode value);
  private:
  ::opi_api::security::firewall::v1::SessionCloseCode _internal_sessionclosecode() const;
  void _internal_set_sessionclosecode(::opi_api::security::firewall::v1::SessionCloseCode value);
  public:

  // .opi_api.security.firewall.v1.RequestStatus requeststatus = 8;
  void clear_requeststatus();
  ::opi_api::security::firewall::v1::RequestStatus requeststatus() const;
  void set_requeststatus(::opi_api::security::firewall::v1::RequestStatus value);
  private:
  ::opi_api::security::firewall::v1::RequestStatus _internal_requeststatus() const;
  void _internal_set_requeststatus(::opi_api::security::firewall::v1::RequestStatus value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.SessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::security::firewall::v1::Uuid* sessionid_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* starttime_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* endtime_;
  uint64_t inpackets_;
  uint64_t outpackets_;
  uint64_t inbytes_;
  uint64_t outbytes_;
  int sessionstate_;
  int sessionclosecode_;
  int requeststatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class SessionRequestArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.security.firewall.v1.SessionRequestArgs) */ {
 public:
  inline SessionRequestArgs() : SessionRequestArgs(nullptr) {}
  ~SessionRequestArgs() override;
  explicit constexpr SessionRequestArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionRequestArgs(const SessionRequestArgs& from);
  SessionRequestArgs(SessionRequestArgs&& from) noexcept
    : SessionRequestArgs() {
    *this = ::std::move(from);
  }

  inline SessionRequestArgs& operator=(const SessionRequestArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRequestArgs& operator=(SessionRequestArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionRequestArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionRequestArgs* internal_default_instance() {
    return reinterpret_cast<const SessionRequestArgs*>(
               &_SessionRequestArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SessionRequestArgs& a, SessionRequestArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRequestArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionRequestArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionRequestArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionRequestArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionRequestArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionRequestArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionRequestArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.security.firewall.v1.SessionRequestArgs";
  }
  protected:
  explicit SessionRequestArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionidFieldNumber = 1,
    kSessionstateFieldNumber = 2,
  };
  // .opi_api.security.firewall.v1.Uuid sessionid = 1;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  const ::opi_api::security::firewall::v1::Uuid& sessionid() const;
  PROTOBUF_NODISCARD ::opi_api::security::firewall::v1::Uuid* release_sessionid();
  ::opi_api::security::firewall::v1::Uuid* mutable_sessionid();
  void set_allocated_sessionid(::opi_api::security::firewall::v1::Uuid* sessionid);
  private:
  const ::opi_api::security::firewall::v1::Uuid& _internal_sessionid() const;
  ::opi_api::security::firewall::v1::Uuid* _internal_mutable_sessionid();
  public:
  void unsafe_arena_set_allocated_sessionid(
      ::opi_api::security::firewall::v1::Uuid* sessionid);
  ::opi_api::security::firewall::v1::Uuid* unsafe_arena_release_sessionid();

  // .opi_api.security.firewall.v1.SessionState sessionstate = 2;
  void clear_sessionstate();
  ::opi_api::security::firewall::v1::SessionState sessionstate() const;
  void set_sessionstate(::opi_api::security::firewall::v1::SessionState value);
  private:
  ::opi_api::security::firewall::v1::SessionState _internal_sessionstate() const;
  void _internal_set_sessionstate(::opi_api::security::firewall::v1::SessionState value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.security.firewall.v1.SessionRequestArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::security::firewall::v1::Uuid* sessionid_;
  int sessionstate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Uuid

// string value = 1;
inline void Uuid::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Uuid::value() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.Uuid.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Uuid::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.Uuid.value)
}
inline std::string* Uuid::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.Uuid.value)
  return _s;
}
inline const std::string& Uuid::_internal_value() const {
  return value_.Get();
}
inline void Uuid::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Uuid::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Uuid::release_value() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.Uuid.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Uuid::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.Uuid.value)
}

// -------------------------------------------------------------------

// SessionId

// uint64 session_id = 1;
inline void SessionId::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t SessionId::_internal_session_id() const {
  return session_id_;
}
inline uint64_t SessionId::session_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionId.session_id)
  return _internal_session_id();
}
inline void SessionId::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void SessionId::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionId.session_id)
}

// -------------------------------------------------------------------

// ActionParameters

// .opi_api.security.firewall.v1.ActionType actiontype = 1;
inline void ActionParameters::clear_actiontype() {
  actiontype_ = 0;
}
inline ::opi_api::security::firewall::v1::ActionType ActionParameters::_internal_actiontype() const {
  return static_cast< ::opi_api::security::firewall::v1::ActionType >(actiontype_);
}
inline ::opi_api::security::firewall::v1::ActionType ActionParameters::actiontype() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.actiontype)
  return _internal_actiontype();
}
inline void ActionParameters::_internal_set_actiontype(::opi_api::security::firewall::v1::ActionType value) {
  
  actiontype_ = value;
}
inline void ActionParameters::set_actiontype(::opi_api::security::firewall::v1::ActionType value) {
  _internal_set_actiontype(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.actiontype)
}

// uint32 actionnexthop = 2;
inline void ActionParameters::clear_actionnexthop() {
  actionnexthop_ = 0u;
}
inline uint32_t ActionParameters::_internal_actionnexthop() const {
  return actionnexthop_;
}
inline uint32_t ActionParameters::actionnexthop() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.actionnexthop)
  return _internal_actionnexthop();
}
inline void ActionParameters::_internal_set_actionnexthop(uint32_t value) {
  
  actionnexthop_ = value;
}
inline void ActionParameters::set_actionnexthop(uint32_t value) {
  _internal_set_actionnexthop(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.actionnexthop)
}

// bytes actionnexthopv6 = 3;
inline void ActionParameters::clear_actionnexthopv6() {
  actionnexthopv6_.ClearToEmpty();
}
inline const std::string& ActionParameters::actionnexthopv6() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.actionnexthopv6)
  return _internal_actionnexthopv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionParameters::set_actionnexthopv6(ArgT0&& arg0, ArgT... args) {
 
 actionnexthopv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.actionnexthopv6)
}
inline std::string* ActionParameters::mutable_actionnexthopv6() {
  std::string* _s = _internal_mutable_actionnexthopv6();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.ActionParameters.actionnexthopv6)
  return _s;
}
inline const std::string& ActionParameters::_internal_actionnexthopv6() const {
  return actionnexthopv6_.Get();
}
inline void ActionParameters::_internal_set_actionnexthopv6(const std::string& value) {
  
  actionnexthopv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionParameters::_internal_mutable_actionnexthopv6() {
  
  return actionnexthopv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionParameters::release_actionnexthopv6() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.ActionParameters.actionnexthopv6)
  return actionnexthopv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionParameters::set_allocated_actionnexthopv6(std::string* actionnexthopv6) {
  if (actionnexthopv6 != nullptr) {
    
  } else {
    
  }
  actionnexthopv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionnexthopv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (actionnexthopv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    actionnexthopv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.ActionParameters.actionnexthopv6)
}

// uint32 proxysrcv4 = 4;
inline void ActionParameters::clear_proxysrcv4() {
  proxysrcv4_ = 0u;
}
inline uint32_t ActionParameters::_internal_proxysrcv4() const {
  return proxysrcv4_;
}
inline uint32_t ActionParameters::proxysrcv4() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.proxysrcv4)
  return _internal_proxysrcv4();
}
inline void ActionParameters::_internal_set_proxysrcv4(uint32_t value) {
  
  proxysrcv4_ = value;
}
inline void ActionParameters::set_proxysrcv4(uint32_t value) {
  _internal_set_proxysrcv4(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.proxysrcv4)
}

// uint32 proxydstv4 = 5;
inline void ActionParameters::clear_proxydstv4() {
  proxydstv4_ = 0u;
}
inline uint32_t ActionParameters::_internal_proxydstv4() const {
  return proxydstv4_;
}
inline uint32_t ActionParameters::proxydstv4() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.proxydstv4)
  return _internal_proxydstv4();
}
inline void ActionParameters::_internal_set_proxydstv4(uint32_t value) {
  
  proxydstv4_ = value;
}
inline void ActionParameters::set_proxydstv4(uint32_t value) {
  _internal_set_proxydstv4(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.proxydstv4)
}

// bytes proxysrcv6 = 6;
inline void ActionParameters::clear_proxysrcv6() {
  proxysrcv6_.ClearToEmpty();
}
inline const std::string& ActionParameters::proxysrcv6() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.proxysrcv6)
  return _internal_proxysrcv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionParameters::set_proxysrcv6(ArgT0&& arg0, ArgT... args) {
 
 proxysrcv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.proxysrcv6)
}
inline std::string* ActionParameters::mutable_proxysrcv6() {
  std::string* _s = _internal_mutable_proxysrcv6();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.ActionParameters.proxysrcv6)
  return _s;
}
inline const std::string& ActionParameters::_internal_proxysrcv6() const {
  return proxysrcv6_.Get();
}
inline void ActionParameters::_internal_set_proxysrcv6(const std::string& value) {
  
  proxysrcv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionParameters::_internal_mutable_proxysrcv6() {
  
  return proxysrcv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionParameters::release_proxysrcv6() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.ActionParameters.proxysrcv6)
  return proxysrcv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionParameters::set_allocated_proxysrcv6(std::string* proxysrcv6) {
  if (proxysrcv6 != nullptr) {
    
  } else {
    
  }
  proxysrcv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proxysrcv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proxysrcv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proxysrcv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.ActionParameters.proxysrcv6)
}

// bytes proxydstv6 = 7;
inline void ActionParameters::clear_proxydstv6() {
  proxydstv6_.ClearToEmpty();
}
inline const std::string& ActionParameters::proxydstv6() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.proxydstv6)
  return _internal_proxydstv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionParameters::set_proxydstv6(ArgT0&& arg0, ArgT... args) {
 
 proxydstv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.proxydstv6)
}
inline std::string* ActionParameters::mutable_proxydstv6() {
  std::string* _s = _internal_mutable_proxydstv6();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.ActionParameters.proxydstv6)
  return _s;
}
inline const std::string& ActionParameters::_internal_proxydstv6() const {
  return proxydstv6_.Get();
}
inline void ActionParameters::_internal_set_proxydstv6(const std::string& value) {
  
  proxydstv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionParameters::_internal_mutable_proxydstv6() {
  
  return proxydstv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionParameters::release_proxydstv6() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.ActionParameters.proxydstv6)
  return proxydstv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionParameters::set_allocated_proxydstv6(std::string* proxydstv6) {
  if (proxydstv6 != nullptr) {
    
  } else {
    
  }
  proxydstv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proxydstv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proxydstv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proxydstv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.ActionParameters.proxydstv6)
}

// bytes srcconnid = 8;
inline void ActionParameters::clear_srcconnid() {
  srcconnid_.ClearToEmpty();
}
inline const std::string& ActionParameters::srcconnid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.srcconnid)
  return _internal_srcconnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionParameters::set_srcconnid(ArgT0&& arg0, ArgT... args) {
 
 srcconnid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.srcconnid)
}
inline std::string* ActionParameters::mutable_srcconnid() {
  std::string* _s = _internal_mutable_srcconnid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.ActionParameters.srcconnid)
  return _s;
}
inline const std::string& ActionParameters::_internal_srcconnid() const {
  return srcconnid_.Get();
}
inline void ActionParameters::_internal_set_srcconnid(const std::string& value) {
  
  srcconnid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionParameters::_internal_mutable_srcconnid() {
  
  return srcconnid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionParameters::release_srcconnid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.ActionParameters.srcconnid)
  return srcconnid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionParameters::set_allocated_srcconnid(std::string* srcconnid) {
  if (srcconnid != nullptr) {
    
  } else {
    
  }
  srcconnid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcconnid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcconnid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcconnid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.ActionParameters.srcconnid)
}

// bytes dstconnid = 9;
inline void ActionParameters::clear_dstconnid() {
  dstconnid_.ClearToEmpty();
}
inline const std::string& ActionParameters::dstconnid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.ActionParameters.dstconnid)
  return _internal_dstconnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionParameters::set_dstconnid(ArgT0&& arg0, ArgT... args) {
 
 dstconnid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.ActionParameters.dstconnid)
}
inline std::string* ActionParameters::mutable_dstconnid() {
  std::string* _s = _internal_mutable_dstconnid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.ActionParameters.dstconnid)
  return _s;
}
inline const std::string& ActionParameters::_internal_dstconnid() const {
  return dstconnid_.Get();
}
inline void ActionParameters::_internal_set_dstconnid(const std::string& value) {
  
  dstconnid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionParameters::_internal_mutable_dstconnid() {
  
  return dstconnid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionParameters::release_dstconnid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.ActionParameters.dstconnid)
  return dstconnid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionParameters::set_allocated_dstconnid(std::string* dstconnid) {
  if (dstconnid != nullptr) {
    
  } else {
    
  }
  dstconnid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dstconnid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dstconnid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dstconnid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.ActionParameters.dstconnid)
}

// -------------------------------------------------------------------

// SessionRequest

// .opi_api.security.firewall.v1.Uuid session_id = 1;
inline bool SessionRequest::_internal_has_session_id() const {
  return this != internal_default_instance() && session_id_ != nullptr;
}
inline bool SessionRequest::has_session_id() const {
  return _internal_has_session_id();
}
inline void SessionRequest::clear_session_id() {
  if (GetArenaForAllocation() == nullptr && session_id_ != nullptr) {
    delete session_id_;
  }
  session_id_ = nullptr;
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionRequest::_internal_session_id() const {
  const ::opi_api::security::firewall::v1::Uuid* p = session_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::firewall::v1::Uuid&>(
      ::opi_api::security::firewall::v1::_Uuid_default_instance_);
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.session_id)
  return _internal_session_id();
}
inline void SessionRequest::unsafe_arena_set_allocated_session_id(
    ::opi_api::security::firewall::v1::Uuid* session_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_id_);
  }
  session_id_ = session_id;
  if (session_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionRequest.session_id)
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequest::release_session_id() {
  
  ::opi_api::security::firewall::v1::Uuid* temp = session_id_;
  session_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequest::unsafe_arena_release_session_id() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequest.session_id)
  
  ::opi_api::security::firewall::v1::Uuid* temp = session_id_;
  session_id_ = nullptr;
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequest::_internal_mutable_session_id() {
  
  if (session_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::firewall::v1::Uuid>(GetArenaForAllocation());
    session_id_ = p;
  }
  return session_id_;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequest::mutable_session_id() {
  ::opi_api::security::firewall::v1::Uuid* _msg = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequest.session_id)
  return _msg;
}
inline void SessionRequest::set_allocated_session_id(::opi_api::security::firewall::v1::Uuid* session_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_id_;
  }
  if (session_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::security::firewall::v1::Uuid>::GetOwningArena(session_id);
    if (message_arena != submessage_arena) {
      session_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_id, submessage_arena);
    }
    
  } else {
    
  }
  session_id_ = session_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequest.session_id)
}

// int32 inlif = 2;
inline void SessionRequest::clear_inlif() {
  inlif_ = 0;
}
inline int32_t SessionRequest::_internal_inlif() const {
  return inlif_;
}
inline int32_t SessionRequest::inlif() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.inlif)
  return _internal_inlif();
}
inline void SessionRequest::_internal_set_inlif(int32_t value) {
  
  inlif_ = value;
}
inline void SessionRequest::set_inlif(int32_t value) {
  _internal_set_inlif(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.inlif)
}

// int32 outlif = 3;
inline void SessionRequest::clear_outlif() {
  outlif_ = 0;
}
inline int32_t SessionRequest::_internal_outlif() const {
  return outlif_;
}
inline int32_t SessionRequest::outlif() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.outlif)
  return _internal_outlif();
}
inline void SessionRequest::_internal_set_outlif(int32_t value) {
  
  outlif_ = value;
}
inline void SessionRequest::set_outlif(int32_t value) {
  _internal_set_outlif(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.outlif)
}

// .opi_api.security.firewall.v1.IpVersion ipversion = 4;
inline void SessionRequest::clear_ipversion() {
  ipversion_ = 0;
}
inline ::opi_api::security::firewall::v1::IpVersion SessionRequest::_internal_ipversion() const {
  return static_cast< ::opi_api::security::firewall::v1::IpVersion >(ipversion_);
}
inline ::opi_api::security::firewall::v1::IpVersion SessionRequest::ipversion() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.ipversion)
  return _internal_ipversion();
}
inline void SessionRequest::_internal_set_ipversion(::opi_api::security::firewall::v1::IpVersion value) {
  
  ipversion_ = value;
}
inline void SessionRequest::set_ipversion(::opi_api::security::firewall::v1::IpVersion value) {
  _internal_set_ipversion(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.ipversion)
}

// uint32 sourceip = 5;
inline void SessionRequest::clear_sourceip() {
  sourceip_ = 0u;
}
inline uint32_t SessionRequest::_internal_sourceip() const {
  return sourceip_;
}
inline uint32_t SessionRequest::sourceip() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.sourceip)
  return _internal_sourceip();
}
inline void SessionRequest::_internal_set_sourceip(uint32_t value) {
  
  sourceip_ = value;
}
inline void SessionRequest::set_sourceip(uint32_t value) {
  _internal_set_sourceip(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.sourceip)
}

// bytes sourceipv6 = 6;
inline void SessionRequest::clear_sourceipv6() {
  sourceipv6_.ClearToEmpty();
}
inline const std::string& SessionRequest::sourceipv6() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.sourceipv6)
  return _internal_sourceipv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRequest::set_sourceipv6(ArgT0&& arg0, ArgT... args) {
 
 sourceipv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.sourceipv6)
}
inline std::string* SessionRequest::mutable_sourceipv6() {
  std::string* _s = _internal_mutable_sourceipv6();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequest.sourceipv6)
  return _s;
}
inline const std::string& SessionRequest::_internal_sourceipv6() const {
  return sourceipv6_.Get();
}
inline void SessionRequest::_internal_set_sourceipv6(const std::string& value) {
  
  sourceipv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionRequest::_internal_mutable_sourceipv6() {
  
  return sourceipv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionRequest::release_sourceipv6() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequest.sourceipv6)
  return sourceipv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionRequest::set_allocated_sourceipv6(std::string* sourceipv6) {
  if (sourceipv6 != nullptr) {
    
  } else {
    
  }
  sourceipv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourceipv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceipv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sourceipv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequest.sourceipv6)
}

// uint32 sourceport = 7;
inline void SessionRequest::clear_sourceport() {
  sourceport_ = 0u;
}
inline uint32_t SessionRequest::_internal_sourceport() const {
  return sourceport_;
}
inline uint32_t SessionRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.sourceport)
  return _internal_sourceport();
}
inline void SessionRequest::_internal_set_sourceport(uint32_t value) {
  
  sourceport_ = value;
}
inline void SessionRequest::set_sourceport(uint32_t value) {
  _internal_set_sourceport(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.sourceport)
}

// uint32 destinationip = 8;
inline void SessionRequest::clear_destinationip() {
  destinationip_ = 0u;
}
inline uint32_t SessionRequest::_internal_destinationip() const {
  return destinationip_;
}
inline uint32_t SessionRequest::destinationip() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.destinationip)
  return _internal_destinationip();
}
inline void SessionRequest::_internal_set_destinationip(uint32_t value) {
  
  destinationip_ = value;
}
inline void SessionRequest::set_destinationip(uint32_t value) {
  _internal_set_destinationip(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.destinationip)
}

// bytes destinationipv6 = 9;
inline void SessionRequest::clear_destinationipv6() {
  destinationipv6_.ClearToEmpty();
}
inline const std::string& SessionRequest::destinationipv6() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.destinationipv6)
  return _internal_destinationipv6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRequest::set_destinationipv6(ArgT0&& arg0, ArgT... args) {
 
 destinationipv6_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.destinationipv6)
}
inline std::string* SessionRequest::mutable_destinationipv6() {
  std::string* _s = _internal_mutable_destinationipv6();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequest.destinationipv6)
  return _s;
}
inline const std::string& SessionRequest::_internal_destinationipv6() const {
  return destinationipv6_.Get();
}
inline void SessionRequest::_internal_set_destinationipv6(const std::string& value) {
  
  destinationipv6_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionRequest::_internal_mutable_destinationipv6() {
  
  return destinationipv6_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionRequest::release_destinationipv6() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequest.destinationipv6)
  return destinationipv6_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionRequest::set_allocated_destinationipv6(std::string* destinationipv6) {
  if (destinationipv6 != nullptr) {
    
  } else {
    
  }
  destinationipv6_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destinationipv6,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destinationipv6_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destinationipv6_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequest.destinationipv6)
}

// uint32 destinationport = 10;
inline void SessionRequest::clear_destinationport() {
  destinationport_ = 0u;
}
inline uint32_t SessionRequest::_internal_destinationport() const {
  return destinationport_;
}
inline uint32_t SessionRequest::destinationport() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.destinationport)
  return _internal_destinationport();
}
inline void SessionRequest::_internal_set_destinationport(uint32_t value) {
  
  destinationport_ = value;
}
inline void SessionRequest::set_destinationport(uint32_t value) {
  _internal_set_destinationport(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.destinationport)
}

// .opi_api.security.firewall.v1.ProtocolId protocolid = 11;
inline void SessionRequest::clear_protocolid() {
  protocolid_ = 0;
}
inline ::opi_api::security::firewall::v1::ProtocolId SessionRequest::_internal_protocolid() const {
  return static_cast< ::opi_api::security::firewall::v1::ProtocolId >(protocolid_);
}
inline ::opi_api::security::firewall::v1::ProtocolId SessionRequest::protocolid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.protocolid)
  return _internal_protocolid();
}
inline void SessionRequest::_internal_set_protocolid(::opi_api::security::firewall::v1::ProtocolId value) {
  
  protocolid_ = value;
}
inline void SessionRequest::set_protocolid(::opi_api::security::firewall::v1::ProtocolId value) {
  _internal_set_protocolid(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.protocolid)
}

// .opi_api.security.firewall.v1.ActionParameters action = 12;
inline bool SessionRequest::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool SessionRequest::has_action() const {
  return _internal_has_action();
}
inline void SessionRequest::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::opi_api::security::firewall::v1::ActionParameters& SessionRequest::_internal_action() const {
  const ::opi_api::security::firewall::v1::ActionParameters* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::firewall::v1::ActionParameters&>(
      ::opi_api::security::firewall::v1::_ActionParameters_default_instance_);
}
inline const ::opi_api::security::firewall::v1::ActionParameters& SessionRequest::action() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.action)
  return _internal_action();
}
inline void SessionRequest::unsafe_arena_set_allocated_action(
    ::opi_api::security::firewall::v1::ActionParameters* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionRequest.action)
}
inline ::opi_api::security::firewall::v1::ActionParameters* SessionRequest::release_action() {
  
  ::opi_api::security::firewall::v1::ActionParameters* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::firewall::v1::ActionParameters* SessionRequest::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequest.action)
  
  ::opi_api::security::firewall::v1::ActionParameters* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::opi_api::security::firewall::v1::ActionParameters* SessionRequest::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::firewall::v1::ActionParameters>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::opi_api::security::firewall::v1::ActionParameters* SessionRequest::mutable_action() {
  ::opi_api::security::firewall::v1::ActionParameters* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequest.action)
  return _msg;
}
inline void SessionRequest::set_allocated_action(::opi_api::security::firewall::v1::ActionParameters* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::security::firewall::v1::ActionParameters>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequest.action)
}

// uint32 cachetimeout = 13;
inline void SessionRequest::clear_cachetimeout() {
  cachetimeout_ = 0u;
}
inline uint32_t SessionRequest::_internal_cachetimeout() const {
  return cachetimeout_;
}
inline uint32_t SessionRequest::cachetimeout() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.cachetimeout)
  return _internal_cachetimeout();
}
inline void SessionRequest::_internal_set_cachetimeout(uint32_t value) {
  
  cachetimeout_ = value;
}
inline void SessionRequest::set_cachetimeout(uint32_t value) {
  _internal_set_cachetimeout(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.cachetimeout)
}

// bytes srcconnid = 14;
inline void SessionRequest::clear_srcconnid() {
  srcconnid_.ClearToEmpty();
}
inline const std::string& SessionRequest::srcconnid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.srcconnid)
  return _internal_srcconnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRequest::set_srcconnid(ArgT0&& arg0, ArgT... args) {
 
 srcconnid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.srcconnid)
}
inline std::string* SessionRequest::mutable_srcconnid() {
  std::string* _s = _internal_mutable_srcconnid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequest.srcconnid)
  return _s;
}
inline const std::string& SessionRequest::_internal_srcconnid() const {
  return srcconnid_.Get();
}
inline void SessionRequest::_internal_set_srcconnid(const std::string& value) {
  
  srcconnid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionRequest::_internal_mutable_srcconnid() {
  
  return srcconnid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionRequest::release_srcconnid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequest.srcconnid)
  return srcconnid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionRequest::set_allocated_srcconnid(std::string* srcconnid) {
  if (srcconnid != nullptr) {
    
  } else {
    
  }
  srcconnid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcconnid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (srcconnid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    srcconnid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequest.srcconnid)
}

// bytes dstconnid = 15;
inline void SessionRequest::clear_dstconnid() {
  dstconnid_.ClearToEmpty();
}
inline const std::string& SessionRequest::dstconnid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequest.dstconnid)
  return _internal_dstconnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionRequest::set_dstconnid(ArgT0&& arg0, ArgT... args) {
 
 dstconnid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequest.dstconnid)
}
inline std::string* SessionRequest::mutable_dstconnid() {
  std::string* _s = _internal_mutable_dstconnid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequest.dstconnid)
  return _s;
}
inline const std::string& SessionRequest::_internal_dstconnid() const {
  return dstconnid_.Get();
}
inline void SessionRequest::_internal_set_dstconnid(const std::string& value) {
  
  dstconnid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionRequest::_internal_mutable_dstconnid() {
  
  return dstconnid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionRequest::release_dstconnid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequest.dstconnid)
  return dstconnid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionRequest::set_allocated_dstconnid(std::string* dstconnid) {
  if (dstconnid != nullptr) {
    
  } else {
    
  }
  dstconnid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dstconnid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dstconnid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dstconnid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequest.dstconnid)
}

// -------------------------------------------------------------------

// SessionResponseError

// .opi_api.security.firewall.v1.Uuid sessionid = 1;
inline bool SessionResponseError::_internal_has_sessionid() const {
  return this != internal_default_instance() && sessionid_ != nullptr;
}
inline bool SessionResponseError::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void SessionResponseError::clear_sessionid() {
  if (GetArenaForAllocation() == nullptr && sessionid_ != nullptr) {
    delete sessionid_;
  }
  sessionid_ = nullptr;
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionResponseError::_internal_sessionid() const {
  const ::opi_api::security::firewall::v1::Uuid* p = sessionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::firewall::v1::Uuid&>(
      ::opi_api::security::firewall::v1::_Uuid_default_instance_);
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionResponseError::sessionid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponseError.sessionid)
  return _internal_sessionid();
}
inline void SessionResponseError::unsafe_arena_set_allocated_sessionid(
    ::opi_api::security::firewall::v1::Uuid* sessionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sessionid_);
  }
  sessionid_ = sessionid;
  if (sessionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionResponseError.sessionid)
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponseError::release_sessionid() {
  
  ::opi_api::security::firewall::v1::Uuid* temp = sessionid_;
  sessionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponseError::unsafe_arena_release_sessionid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionResponseError.sessionid)
  
  ::opi_api::security::firewall::v1::Uuid* temp = sessionid_;
  sessionid_ = nullptr;
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponseError::_internal_mutable_sessionid() {
  
  if (sessionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::firewall::v1::Uuid>(GetArenaForAllocation());
    sessionid_ = p;
  }
  return sessionid_;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponseError::mutable_sessionid() {
  ::opi_api::security::firewall::v1::Uuid* _msg = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionResponseError.sessionid)
  return _msg;
}
inline void SessionResponseError::set_allocated_sessionid(::opi_api::security::firewall::v1::Uuid* sessionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sessionid_;
  }
  if (sessionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::security::firewall::v1::Uuid>::GetOwningArena(sessionid);
    if (message_arena != submessage_arena) {
      sessionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sessionid, submessage_arena);
    }
    
  } else {
    
  }
  sessionid_ = sessionid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionResponseError.sessionid)
}

// int32 errorstatus = 2;
inline void SessionResponseError::clear_errorstatus() {
  errorstatus_ = 0;
}
inline int32_t SessionResponseError::_internal_errorstatus() const {
  return errorstatus_;
}
inline int32_t SessionResponseError::errorstatus() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponseError.errorstatus)
  return _internal_errorstatus();
}
inline void SessionResponseError::_internal_set_errorstatus(int32_t value) {
  
  errorstatus_ = value;
}
inline void SessionResponseError::set_errorstatus(int32_t value) {
  _internal_set_errorstatus(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponseError.errorstatus)
}

// -------------------------------------------------------------------

// SessionResponses

// repeated .opi_api.security.firewall.v1.SessionResponse sessioninfo = 1;
inline int SessionResponses::_internal_sessioninfo_size() const {
  return sessioninfo_.size();
}
inline int SessionResponses::sessioninfo_size() const {
  return _internal_sessioninfo_size();
}
inline void SessionResponses::clear_sessioninfo() {
  sessioninfo_.Clear();
}
inline ::opi_api::security::firewall::v1::SessionResponse* SessionResponses::mutable_sessioninfo(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionResponses.sessioninfo)
  return sessioninfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponse >*
SessionResponses::mutable_sessioninfo() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.firewall.v1.SessionResponses.sessioninfo)
  return &sessioninfo_;
}
inline const ::opi_api::security::firewall::v1::SessionResponse& SessionResponses::_internal_sessioninfo(int index) const {
  return sessioninfo_.Get(index);
}
inline const ::opi_api::security::firewall::v1::SessionResponse& SessionResponses::sessioninfo(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponses.sessioninfo)
  return _internal_sessioninfo(index);
}
inline ::opi_api::security::firewall::v1::SessionResponse* SessionResponses::_internal_add_sessioninfo() {
  return sessioninfo_.Add();
}
inline ::opi_api::security::firewall::v1::SessionResponse* SessionResponses::add_sessioninfo() {
  ::opi_api::security::firewall::v1::SessionResponse* _add = _internal_add_sessioninfo();
  // @@protoc_insertion_point(field_add:opi_api.security.firewall.v1.SessionResponses.sessioninfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponse >&
SessionResponses::sessioninfo() const {
  // @@protoc_insertion_point(field_list:opi_api.security.firewall.v1.SessionResponses.sessioninfo)
  return sessioninfo_;
}

// uint64 nextkey = 2;
inline void SessionResponses::clear_nextkey() {
  nextkey_ = uint64_t{0u};
}
inline uint64_t SessionResponses::_internal_nextkey() const {
  return nextkey_;
}
inline uint64_t SessionResponses::nextkey() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponses.nextkey)
  return _internal_nextkey();
}
inline void SessionResponses::_internal_set_nextkey(uint64_t value) {
  
  nextkey_ = value;
}
inline void SessionResponses::set_nextkey(uint64_t value) {
  _internal_set_nextkey(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponses.nextkey)
}

// -------------------------------------------------------------------

// AddSessionResponse

// .opi_api.security.firewall.v1.AddSessionStatus requeststatus = 1;
inline void AddSessionResponse::clear_requeststatus() {
  requeststatus_ = 0;
}
inline ::opi_api::security::firewall::v1::AddSessionStatus AddSessionResponse::_internal_requeststatus() const {
  return static_cast< ::opi_api::security::firewall::v1::AddSessionStatus >(requeststatus_);
}
inline ::opi_api::security::firewall::v1::AddSessionStatus AddSessionResponse::requeststatus() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.AddSessionResponse.requeststatus)
  return _internal_requeststatus();
}
inline void AddSessionResponse::_internal_set_requeststatus(::opi_api::security::firewall::v1::AddSessionStatus value) {
  
  requeststatus_ = value;
}
inline void AddSessionResponse::set_requeststatus(::opi_api::security::firewall::v1::AddSessionStatus value) {
  _internal_set_requeststatus(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.AddSessionResponse.requeststatus)
}

// uint64 errorstatus = 2;
inline void AddSessionResponse::clear_errorstatus() {
  errorstatus_ = uint64_t{0u};
}
inline uint64_t AddSessionResponse::_internal_errorstatus() const {
  return errorstatus_;
}
inline uint64_t AddSessionResponse::errorstatus() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.AddSessionResponse.errorstatus)
  return _internal_errorstatus();
}
inline void AddSessionResponse::_internal_set_errorstatus(uint64_t value) {
  
  errorstatus_ = value;
}
inline void AddSessionResponse::set_errorstatus(uint64_t value) {
  _internal_set_errorstatus(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.AddSessionResponse.errorstatus)
}

// .google.protobuf.Timestamp starttime = 3;
inline bool AddSessionResponse::_internal_has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline bool AddSessionResponse::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AddSessionResponse::_internal_starttime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AddSessionResponse::starttime() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.AddSessionResponse.starttime)
  return _internal_starttime();
}
inline void AddSessionResponse::unsafe_arena_set_allocated_starttime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.AddSessionResponse.starttime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::release_starttime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.AddSessionResponse.starttime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::_internal_mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    starttime_ = p;
  }
  return starttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AddSessionResponse::mutable_starttime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.AddSessionResponse.starttime)
  return _msg;
}
inline void AddSessionResponse::set_allocated_starttime(::PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.AddSessionResponse.starttime)
}

// repeated .opi_api.security.firewall.v1.SessionResponseError responseerror = 4;
inline int AddSessionResponse::_internal_responseerror_size() const {
  return responseerror_.size();
}
inline int AddSessionResponse::responseerror_size() const {
  return _internal_responseerror_size();
}
inline void AddSessionResponse::clear_responseerror() {
  responseerror_.Clear();
}
inline ::opi_api::security::firewall::v1::SessionResponseError* AddSessionResponse::mutable_responseerror(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.AddSessionResponse.responseerror)
  return responseerror_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponseError >*
AddSessionResponse::mutable_responseerror() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.security.firewall.v1.AddSessionResponse.responseerror)
  return &responseerror_;
}
inline const ::opi_api::security::firewall::v1::SessionResponseError& AddSessionResponse::_internal_responseerror(int index) const {
  return responseerror_.Get(index);
}
inline const ::opi_api::security::firewall::v1::SessionResponseError& AddSessionResponse::responseerror(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.AddSessionResponse.responseerror)
  return _internal_responseerror(index);
}
inline ::opi_api::security::firewall::v1::SessionResponseError* AddSessionResponse::_internal_add_responseerror() {
  return responseerror_.Add();
}
inline ::opi_api::security::firewall::v1::SessionResponseError* AddSessionResponse::add_responseerror() {
  ::opi_api::security::firewall::v1::SessionResponseError* _add = _internal_add_responseerror();
  // @@protoc_insertion_point(field_add:opi_api.security.firewall.v1.AddSessionResponse.responseerror)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::security::firewall::v1::SessionResponseError >&
AddSessionResponse::responseerror() const {
  // @@protoc_insertion_point(field_list:opi_api.security.firewall.v1.AddSessionResponse.responseerror)
  return responseerror_;
}

// -------------------------------------------------------------------

// SessionResponse

// .opi_api.security.firewall.v1.Uuid sessionid = 1;
inline bool SessionResponse::_internal_has_sessionid() const {
  return this != internal_default_instance() && sessionid_ != nullptr;
}
inline bool SessionResponse::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void SessionResponse::clear_sessionid() {
  if (GetArenaForAllocation() == nullptr && sessionid_ != nullptr) {
    delete sessionid_;
  }
  sessionid_ = nullptr;
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionResponse::_internal_sessionid() const {
  const ::opi_api::security::firewall::v1::Uuid* p = sessionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::firewall::v1::Uuid&>(
      ::opi_api::security::firewall::v1::_Uuid_default_instance_);
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.sessionid)
  return _internal_sessionid();
}
inline void SessionResponse::unsafe_arena_set_allocated_sessionid(
    ::opi_api::security::firewall::v1::Uuid* sessionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sessionid_);
  }
  sessionid_ = sessionid;
  if (sessionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionResponse.sessionid)
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponse::release_sessionid() {
  
  ::opi_api::security::firewall::v1::Uuid* temp = sessionid_;
  sessionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponse::unsafe_arena_release_sessionid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionResponse.sessionid)
  
  ::opi_api::security::firewall::v1::Uuid* temp = sessionid_;
  sessionid_ = nullptr;
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponse::_internal_mutable_sessionid() {
  
  if (sessionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::firewall::v1::Uuid>(GetArenaForAllocation());
    sessionid_ = p;
  }
  return sessionid_;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionResponse::mutable_sessionid() {
  ::opi_api::security::firewall::v1::Uuid* _msg = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionResponse.sessionid)
  return _msg;
}
inline void SessionResponse::set_allocated_sessionid(::opi_api::security::firewall::v1::Uuid* sessionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sessionid_;
  }
  if (sessionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::security::firewall::v1::Uuid>::GetOwningArena(sessionid);
    if (message_arena != submessage_arena) {
      sessionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sessionid, submessage_arena);
    }
    
  } else {
    
  }
  sessionid_ = sessionid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionResponse.sessionid)
}

// uint64 inpackets = 2;
inline void SessionResponse::clear_inpackets() {
  inpackets_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_inpackets() const {
  return inpackets_;
}
inline uint64_t SessionResponse::inpackets() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.inpackets)
  return _internal_inpackets();
}
inline void SessionResponse::_internal_set_inpackets(uint64_t value) {
  
  inpackets_ = value;
}
inline void SessionResponse::set_inpackets(uint64_t value) {
  _internal_set_inpackets(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.inpackets)
}

// uint64 outpackets = 3;
inline void SessionResponse::clear_outpackets() {
  outpackets_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_outpackets() const {
  return outpackets_;
}
inline uint64_t SessionResponse::outpackets() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.outpackets)
  return _internal_outpackets();
}
inline void SessionResponse::_internal_set_outpackets(uint64_t value) {
  
  outpackets_ = value;
}
inline void SessionResponse::set_outpackets(uint64_t value) {
  _internal_set_outpackets(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.outpackets)
}

// uint64 inbytes = 4;
inline void SessionResponse::clear_inbytes() {
  inbytes_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_inbytes() const {
  return inbytes_;
}
inline uint64_t SessionResponse::inbytes() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.inbytes)
  return _internal_inbytes();
}
inline void SessionResponse::_internal_set_inbytes(uint64_t value) {
  
  inbytes_ = value;
}
inline void SessionResponse::set_inbytes(uint64_t value) {
  _internal_set_inbytes(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.inbytes)
}

// uint64 outbytes = 5;
inline void SessionResponse::clear_outbytes() {
  outbytes_ = uint64_t{0u};
}
inline uint64_t SessionResponse::_internal_outbytes() const {
  return outbytes_;
}
inline uint64_t SessionResponse::outbytes() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.outbytes)
  return _internal_outbytes();
}
inline void SessionResponse::_internal_set_outbytes(uint64_t value) {
  
  outbytes_ = value;
}
inline void SessionResponse::set_outbytes(uint64_t value) {
  _internal_set_outbytes(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.outbytes)
}

// .opi_api.security.firewall.v1.SessionState sessionstate = 6;
inline void SessionResponse::clear_sessionstate() {
  sessionstate_ = 0;
}
inline ::opi_api::security::firewall::v1::SessionState SessionResponse::_internal_sessionstate() const {
  return static_cast< ::opi_api::security::firewall::v1::SessionState >(sessionstate_);
}
inline ::opi_api::security::firewall::v1::SessionState SessionResponse::sessionstate() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.sessionstate)
  return _internal_sessionstate();
}
inline void SessionResponse::_internal_set_sessionstate(::opi_api::security::firewall::v1::SessionState value) {
  
  sessionstate_ = value;
}
inline void SessionResponse::set_sessionstate(::opi_api::security::firewall::v1::SessionState value) {
  _internal_set_sessionstate(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.sessionstate)
}

// .opi_api.security.firewall.v1.SessionCloseCode sessionclosecode = 7;
inline void SessionResponse::clear_sessionclosecode() {
  sessionclosecode_ = 0;
}
inline ::opi_api::security::firewall::v1::SessionCloseCode SessionResponse::_internal_sessionclosecode() const {
  return static_cast< ::opi_api::security::firewall::v1::SessionCloseCode >(sessionclosecode_);
}
inline ::opi_api::security::firewall::v1::SessionCloseCode SessionResponse::sessionclosecode() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.sessionclosecode)
  return _internal_sessionclosecode();
}
inline void SessionResponse::_internal_set_sessionclosecode(::opi_api::security::firewall::v1::SessionCloseCode value) {
  
  sessionclosecode_ = value;
}
inline void SessionResponse::set_sessionclosecode(::opi_api::security::firewall::v1::SessionCloseCode value) {
  _internal_set_sessionclosecode(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.sessionclosecode)
}

// .opi_api.security.firewall.v1.RequestStatus requeststatus = 8;
inline void SessionResponse::clear_requeststatus() {
  requeststatus_ = 0;
}
inline ::opi_api::security::firewall::v1::RequestStatus SessionResponse::_internal_requeststatus() const {
  return static_cast< ::opi_api::security::firewall::v1::RequestStatus >(requeststatus_);
}
inline ::opi_api::security::firewall::v1::RequestStatus SessionResponse::requeststatus() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.requeststatus)
  return _internal_requeststatus();
}
inline void SessionResponse::_internal_set_requeststatus(::opi_api::security::firewall::v1::RequestStatus value) {
  
  requeststatus_ = value;
}
inline void SessionResponse::set_requeststatus(::opi_api::security::firewall::v1::RequestStatus value) {
  _internal_set_requeststatus(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionResponse.requeststatus)
}

// .google.protobuf.Timestamp starttime = 9;
inline bool SessionResponse::_internal_has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline bool SessionResponse::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::_internal_starttime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::starttime() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.starttime)
  return _internal_starttime();
}
inline void SessionResponse::unsafe_arena_set_allocated_starttime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionResponse.starttime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::release_starttime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionResponse.starttime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::_internal_mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    starttime_ = p;
  }
  return starttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::mutable_starttime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionResponse.starttime)
  return _msg;
}
inline void SessionResponse::set_allocated_starttime(::PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionResponse.starttime)
}

// .google.protobuf.Timestamp endtime = 10;
inline bool SessionResponse::_internal_has_endtime() const {
  return this != internal_default_instance() && endtime_ != nullptr;
}
inline bool SessionResponse::has_endtime() const {
  return _internal_has_endtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::_internal_endtime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = endtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionResponse::endtime() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionResponse.endtime)
  return _internal_endtime();
}
inline void SessionResponse::unsafe_arena_set_allocated_endtime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* endtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  endtime_ = endtime;
  if (endtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionResponse.endtime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::release_endtime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = endtime_;
  endtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::unsafe_arena_release_endtime() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionResponse.endtime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = endtime_;
  endtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::_internal_mutable_endtime() {
  
  if (endtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    endtime_ = p;
  }
  return endtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionResponse::mutable_endtime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_endtime();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionResponse.endtime)
  return _msg;
}
inline void SessionResponse::set_allocated_endtime(::PROTOBUF_NAMESPACE_ID::Timestamp* endtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  if (endtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime));
    if (message_arena != submessage_arena) {
      endtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtime, submessage_arena);
    }
    
  } else {
    
  }
  endtime_ = endtime;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionResponse.endtime)
}

// -------------------------------------------------------------------

// SessionRequestArgs

// .opi_api.security.firewall.v1.Uuid sessionid = 1;
inline bool SessionRequestArgs::_internal_has_sessionid() const {
  return this != internal_default_instance() && sessionid_ != nullptr;
}
inline bool SessionRequestArgs::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void SessionRequestArgs::clear_sessionid() {
  if (GetArenaForAllocation() == nullptr && sessionid_ != nullptr) {
    delete sessionid_;
  }
  sessionid_ = nullptr;
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionRequestArgs::_internal_sessionid() const {
  const ::opi_api::security::firewall::v1::Uuid* p = sessionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::security::firewall::v1::Uuid&>(
      ::opi_api::security::firewall::v1::_Uuid_default_instance_);
}
inline const ::opi_api::security::firewall::v1::Uuid& SessionRequestArgs::sessionid() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequestArgs.sessionid)
  return _internal_sessionid();
}
inline void SessionRequestArgs::unsafe_arena_set_allocated_sessionid(
    ::opi_api::security::firewall::v1::Uuid* sessionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sessionid_);
  }
  sessionid_ = sessionid;
  if (sessionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.security.firewall.v1.SessionRequestArgs.sessionid)
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequestArgs::release_sessionid() {
  
  ::opi_api::security::firewall::v1::Uuid* temp = sessionid_;
  sessionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequestArgs::unsafe_arena_release_sessionid() {
  // @@protoc_insertion_point(field_release:opi_api.security.firewall.v1.SessionRequestArgs.sessionid)
  
  ::opi_api::security::firewall::v1::Uuid* temp = sessionid_;
  sessionid_ = nullptr;
  return temp;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequestArgs::_internal_mutable_sessionid() {
  
  if (sessionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::security::firewall::v1::Uuid>(GetArenaForAllocation());
    sessionid_ = p;
  }
  return sessionid_;
}
inline ::opi_api::security::firewall::v1::Uuid* SessionRequestArgs::mutable_sessionid() {
  ::opi_api::security::firewall::v1::Uuid* _msg = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:opi_api.security.firewall.v1.SessionRequestArgs.sessionid)
  return _msg;
}
inline void SessionRequestArgs::set_allocated_sessionid(::opi_api::security::firewall::v1::Uuid* sessionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sessionid_;
  }
  if (sessionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::security::firewall::v1::Uuid>::GetOwningArena(sessionid);
    if (message_arena != submessage_arena) {
      sessionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sessionid, submessage_arena);
    }
    
  } else {
    
  }
  sessionid_ = sessionid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.security.firewall.v1.SessionRequestArgs.sessionid)
}

// .opi_api.security.firewall.v1.SessionState sessionstate = 2;
inline void SessionRequestArgs::clear_sessionstate() {
  sessionstate_ = 0;
}
inline ::opi_api::security::firewall::v1::SessionState SessionRequestArgs::_internal_sessionstate() const {
  return static_cast< ::opi_api::security::firewall::v1::SessionState >(sessionstate_);
}
inline ::opi_api::security::firewall::v1::SessionState SessionRequestArgs::sessionstate() const {
  // @@protoc_insertion_point(field_get:opi_api.security.firewall.v1.SessionRequestArgs.sessionstate)
  return _internal_sessionstate();
}
inline void SessionRequestArgs::_internal_set_sessionstate(::opi_api::security::firewall::v1::SessionState value) {
  
  sessionstate_ = value;
}
inline void SessionRequestArgs::set_sessionstate(::opi_api::security::firewall::v1::SessionState value) {
  _internal_set_sessionstate(value);
  // @@protoc_insertion_point(field_set:opi_api.security.firewall.v1.SessionRequestArgs.sessionstate)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace firewall
}  // namespace security
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::security::firewall::v1::IpVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::IpVersion>() {
  return ::opi_api::security::firewall::v1::IpVersion_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::firewall::v1::ProtocolId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::ProtocolId>() {
  return ::opi_api::security::firewall::v1::ProtocolId_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::firewall::v1::SessionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::SessionState>() {
  return ::opi_api::security::firewall::v1::SessionState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::firewall::v1::SessionCloseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::SessionCloseCode>() {
  return ::opi_api::security::firewall::v1::SessionCloseCode_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::firewall::v1::AddSessionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::AddSessionStatus>() {
  return ::opi_api::security::firewall::v1::AddSessionStatus_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::firewall::v1::RequestStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::RequestStatus>() {
  return ::opi_api::security::firewall::v1::RequestStatus_descriptor();
}
template <> struct is_proto_enum< ::opi_api::security::firewall::v1::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::security::firewall::v1::ActionType>() {
  return ::opi_api::security::firewall::v1::ActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto
