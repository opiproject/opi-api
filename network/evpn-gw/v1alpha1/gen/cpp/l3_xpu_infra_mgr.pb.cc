// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: l3_xpu_infra_mgr.proto

#include "l3_xpu_infra_mgr.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace opi_api {
namespace network {
namespace evpn_gw {
namespace v1alpha1 {
PROTOBUF_CONSTEXPR Vrf::Vrf(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VrfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrfDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrfDefaultTypeInternal() {}
  union {
    Vrf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrfDefaultTypeInternal _Vrf_default_instance_;
PROTOBUF_CONSTEXPR VrfSpec::VrfSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.loopback_ip_prefix_)*/nullptr
  , /*decltype(_impl_.vtep_ip_prefix_)*/nullptr
  , /*decltype(_impl_.vni_)*/0u} {}
struct VrfSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrfSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrfSpecDefaultTypeInternal() {}
  union {
    VrfSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrfSpecDefaultTypeInternal _VrfSpec_default_instance_;
PROTOBUF_CONSTEXPR VrfStatus::VrfStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.import_rts_)*/{}
  , /*decltype(_impl_.export_rts_)*/{}
  , /*decltype(_impl_.logical_bridges_)*/{}
  , /*decltype(_impl_.rd_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.routing_table_)*/0u
  , /*decltype(_impl_.local_as_)*/0u
  , /*decltype(_impl_.oper_status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VrfStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VrfStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VrfStatusDefaultTypeInternal() {}
  union {
    VrfStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VrfStatusDefaultTypeInternal _VrfStatus_default_instance_;
PROTOBUF_CONSTEXPR CreateVrfRequest::CreateVrfRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vrf_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vrf_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateVrfRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateVrfRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateVrfRequestDefaultTypeInternal() {}
  union {
    CreateVrfRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateVrfRequestDefaultTypeInternal _CreateVrfRequest_default_instance_;
PROTOBUF_CONSTEXPR ListVrfsRequest::ListVrfsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListVrfsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListVrfsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListVrfsRequestDefaultTypeInternal() {}
  union {
    ListVrfsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListVrfsRequestDefaultTypeInternal _ListVrfsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListVrfsResponse::ListVrfsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vrfs_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListVrfsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListVrfsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListVrfsResponseDefaultTypeInternal() {}
  union {
    ListVrfsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListVrfsResponseDefaultTypeInternal _ListVrfsResponse_default_instance_;
PROTOBUF_CONSTEXPR GetVrfRequest::GetVrfRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetVrfRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetVrfRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetVrfRequestDefaultTypeInternal() {}
  union {
    GetVrfRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetVrfRequestDefaultTypeInternal _GetVrfRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteVrfRequest::DeleteVrfRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteVrfRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteVrfRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteVrfRequestDefaultTypeInternal() {}
  union {
    DeleteVrfRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteVrfRequestDefaultTypeInternal _DeleteVrfRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateVrfRequest::UpdateVrfRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vrf_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateVrfRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateVrfRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateVrfRequestDefaultTypeInternal() {}
  union {
    UpdateVrfRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateVrfRequestDefaultTypeInternal _UpdateVrfRequest_default_instance_;
PROTOBUF_CONSTEXPR Svi::Svi(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SviDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SviDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SviDefaultTypeInternal() {}
  union {
    Svi _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SviDefaultTypeInternal _Svi_default_instance_;
PROTOBUF_CONSTEXPR SviSpec::SviSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gw_ip_prefix_)*/{}
  , /*decltype(_impl_.vrf_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.logical_bridge_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enable_bgp_)*/false
  , /*decltype(_impl_.remote_as_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SviSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SviSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SviSpecDefaultTypeInternal() {}
  union {
    SviSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SviSpecDefaultTypeInternal _SviSpec_default_instance_;
PROTOBUF_CONSTEXPR SviStatus::SviStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oper_status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SviStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SviStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SviStatusDefaultTypeInternal() {}
  union {
    SviStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SviStatusDefaultTypeInternal _SviStatus_default_instance_;
PROTOBUF_CONSTEXPR CreateSviRequest::CreateSviRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.svi_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.svi_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateSviRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateSviRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateSviRequestDefaultTypeInternal() {}
  union {
    CreateSviRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateSviRequestDefaultTypeInternal _CreateSviRequest_default_instance_;
PROTOBUF_CONSTEXPR ListSvisRequest::ListSvisRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListSvisRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListSvisRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListSvisRequestDefaultTypeInternal() {}
  union {
    ListSvisRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListSvisRequestDefaultTypeInternal _ListSvisRequest_default_instance_;
PROTOBUF_CONSTEXPR ListSvisResponse::ListSvisResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.svis_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListSvisResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListSvisResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListSvisResponseDefaultTypeInternal() {}
  union {
    ListSvisResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListSvisResponseDefaultTypeInternal _ListSvisResponse_default_instance_;
PROTOBUF_CONSTEXPR GetSviRequest::GetSviRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetSviRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetSviRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetSviRequestDefaultTypeInternal() {}
  union {
    GetSviRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetSviRequestDefaultTypeInternal _GetSviRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteSviRequest::DeleteSviRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteSviRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteSviRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteSviRequestDefaultTypeInternal() {}
  union {
    DeleteSviRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteSviRequestDefaultTypeInternal _DeleteSviRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateSviRequest::UpdateSviRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.svi_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateSviRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateSviRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateSviRequestDefaultTypeInternal() {}
  union {
    UpdateSviRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateSviRequestDefaultTypeInternal _UpdateSviRequest_default_instance_;
}  // namespace v1alpha1
}  // namespace evpn_gw
}  // namespace network
}  // namespace opi_api
static ::_pb::Metadata file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[18];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_l3_5fxpu_5finfra_5fmgr_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_l3_5fxpu_5finfra_5fmgr_2eproto = nullptr;

const uint32_t TableStruct_l3_5fxpu_5finfra_5fmgr_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Vrf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Vrf, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Vrf, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Vrf, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfSpec, _impl_.vni_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfSpec, _impl_.loopback_ip_prefix_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfSpec, _impl_.vtep_ip_prefix_),
  0,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.routing_table_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.local_as_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.rd_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.rmac_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.import_rts_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.export_rts_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.logical_bridges_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::VrfStatus, _impl_.oper_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest, _impl_.vrf_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest, _impl_.vrf_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse, _impl_.vrfs_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::GetVrfRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::GetVrfRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest, _impl_.vrf_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Svi, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Svi, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Svi, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::Svi, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _impl_.vrf_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _impl_.logical_bridge_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _impl_.mac_address_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _impl_.gw_ip_prefix_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _impl_.enable_bgp_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviSpec, _impl_.remote_as_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::SviStatus, _impl_.oper_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest, _impl_.svi_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest, _impl_.svi_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse, _impl_.svis_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::GetSviRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::GetSviRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest, _impl_.svi_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest, _impl_.allow_missing_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::Vrf)},
  { 9, 18, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::VrfSpec)},
  { 21, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::VrfStatus)},
  { 35, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest)},
  { 43, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest)},
  { 51, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse)},
  { 59, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::GetVrfRequest)},
  { 66, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest)},
  { 74, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest)},
  { 83, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::Svi)},
  { 92, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::SviSpec)},
  { 104, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::SviStatus)},
  { 111, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest)},
  { 119, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest)},
  { 127, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse)},
  { 135, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::GetSviRequest)},
  { 142, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest)},
  { 150, -1, -1, sizeof(::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::opi_api::network::evpn_gw::v1alpha1::_Vrf_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_VrfSpec_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_VrfStatus_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_CreateVrfRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_ListVrfsRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_ListVrfsResponse_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_GetVrfRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_DeleteVrfRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_UpdateVrfRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_Svi_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_SviSpec_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_SviStatus_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_CreateSviRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_ListSvisRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_ListSvisResponse_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_GetSviRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_DeleteSviRequest_default_instance_._instance,
  &::opi_api::network::evpn_gw::v1alpha1::_UpdateSviRequest_default_instance_._instance,
};

const char descriptor_table_protodef_l3_5fxpu_5finfra_5fmgr_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026l3_xpu_infra_mgr.proto\022 opi_api.networ"
  "k.evpn_gw.v1alpha1\032\022networktypes.proto\032\034"
  "google/api/annotations.proto\032\027google/api"
  "/client.proto\032\033google/protobuf/empty.pro"
  "to\032\037google/api/field_behavior.proto\032 goo"
  "gle/protobuf/field_mask.proto\032\031google/ap"
  "i/resource.proto\"\206\002\n\003Vrf\022=\n\004name\030\001 \001(\tB/"
  "\340A\003\340A\005\372A&\n$opi_api.network.evpn_gw.v1alp"
  "ha1/Vrf\022<\n\004spec\030\002 \001(\0132).opi_api.network."
  "evpn_gw.v1alpha1.VrfSpecB\003\340A\002\022@\n\006status\030"
  "\003 \001(\0132+.opi_api.network.evpn_gw.v1alpha1"
  ".VrfStatusB\003\340A\003:@\352A=\n$opi_api.network.ev"
  "pn_gw.v1alpha1/Vrf\022\nvrfs/{vrf}*\004vrfs2\003vr"
  "f\"\310\001\n\007VrfSpec\022\025\n\003vni\030\001 \001(\rB\003\340A\001H\000\210\001\001\022P\n\022"
  "loopback_ip_prefix\030\002 \001(\0132/.opi_api.netwo"
  "rk.opinetcommon.v1alpha1.IPPrefixB\003\340A\002\022L"
  "\n\016vtep_ip_prefix\030\003 \001(\0132/.opi_api.network"
  ".opinetcommon.v1alpha1.IPPrefixB\003\340A\001B\006\n\004"
  "_vni\"\375\001\n\tVrfStatus\022\032\n\rrouting_table\030\001 \001("
  "\rB\003\340A\003\022\025\n\010local_as\030\002 \001(\rB\003\340A\003\022\017\n\002rd\030\003 \001("
  "\tB\003\340A\003\022\021\n\004rmac\030\004 \001(\014B\003\340A\003\022\027\n\nimport_rts\030"
  "\005 \003(\tB\003\340A\003\022\027\n\nexport_rts\030\006 \003(\tB\003\340A\003\022\034\n\017l"
  "ogical_bridges\030\007 \003(\tB\003\340A\003\022I\n\013oper_status"
  "\030\010 \001(\0162/.opi_api.network.evpn_gw.v1alpha"
  "1.VRFOperStatusB\003\340A\003\"`\n\020CreateVrfRequest"
  "\022\023\n\006vrf_id\030\001 \001(\tB\003\340A\001\0227\n\003vrf\030\002 \001(\0132%.opi"
  "_api.network.evpn_gw.v1alpha1.VrfB\003\340A\002\"B"
  "\n\017ListVrfsRequest\022\026\n\tpage_size\030\001 \001(\005B\003\340A"
  "\001\022\027\n\npage_token\030\002 \001(\tB\003\340A\001\"`\n\020ListVrfsRe"
  "sponse\0223\n\004vrfs\030\001 \003(\0132%.opi_api.network.e"
  "vpn_gw.v1alpha1.Vrf\022\027\n\017next_page_token\030\002"
  " \001(\t\"K\n\rGetVrfRequest\022:\n\004name\030\001 \001(\tB,\340A\002"
  "\372A&\n$opi_api.network.evpn_gw.v1alpha1/Vr"
  "f\"j\n\020DeleteVrfRequest\022:\n\004name\030\001 \001(\tB,\340A\002"
  "\372A&\n$opi_api.network.evpn_gw.v1alpha1/Vr"
  "f\022\032\n\rallow_missing\030\002 \001(\010B\003\340A\001\"\235\001\n\020Update"
  "VrfRequest\0227\n\003vrf\030\001 \001(\0132%.opi_api.networ"
  "k.evpn_gw.v1alpha1.VrfB\003\340A\002\0224\n\013update_ma"
  "sk\030\002 \001(\0132\032.google.protobuf.FieldMaskB\003\340A"
  "\001\022\032\n\rallow_missing\030\003 \001(\010B\003\340A\001\"\206\002\n\003Svi\022=\n"
  "\004name\030\001 \001(\tB/\340A\003\340A\005\372A&\n$opi_api.network."
  "evpn_gw.v1alpha1/Svi\022<\n\004spec\030\002 \001(\0132).opi"
  "_api.network.evpn_gw.v1alpha1.SviSpecB\003\340"
  "A\002\022@\n\006status\030\003 \001(\0132+.opi_api.network.evp"
  "n_gw.v1alpha1.SviStatusB\003\340A\003:@\352A=\n$opi_a"
  "pi.network.evpn_gw.v1alpha1/Svi\022\nsvis/{s"
  "vi}*\004svis2\003svi\"\253\002\n\007SviSpec\0229\n\003vrf\030\001 \001(\tB"
  ",\340A\002\372A&\n$opi_api.network.evpn_gw.v1alpha"
  "1/Vrf\022N\n\016logical_bridge\030\002 \001(\tB6\340A\002\372A0\n.o"
  "pi_api.network.evpn_gw.v1alpha1/LogicalB"
  "ridge\022\030\n\013mac_address\030\003 \001(\014B\003\340A\002\022J\n\014gw_ip"
  "_prefix\030\004 \003(\0132/.opi_api.network.opinetco"
  "mmon.v1alpha1.IPPrefixB\003\340A\002\022\027\n\nenable_bg"
  "p\030\005 \001(\010B\003\340A\001\022\026\n\tremote_as\030\006 \001(\rB\003\340A\001\"V\n\t"
  "SviStatus\022I\n\013oper_status\030\001 \001(\0162/.opi_api"
  ".network.evpn_gw.v1alpha1.SVIOperStatusB"
  "\003\340A\003\"`\n\020CreateSviRequest\022\023\n\006svi_id\030\001 \001(\t"
  "B\003\340A\001\0227\n\003svi\030\002 \001(\0132%.opi_api.network.evp"
  "n_gw.v1alpha1.SviB\003\340A\002\"B\n\017ListSvisReques"
  "t\022\026\n\tpage_size\030\001 \001(\005B\003\340A\001\022\027\n\npage_token\030"
  "\002 \001(\tB\003\340A\001\"`\n\020ListSvisResponse\0223\n\004svis\030\001"
  " \003(\0132%.opi_api.network.evpn_gw.v1alpha1."
  "Svi\022\027\n\017next_page_token\030\002 \001(\t\"K\n\rGetSviRe"
  "quest\022:\n\004name\030\001 \001(\tB,\340A\002\372A&\n$opi_api.net"
  "work.evpn_gw.v1alpha1/Svi\"j\n\020DeleteSviRe"
  "quest\022:\n\004name\030\001 \001(\tB,\340A\002\372A&\n$opi_api.net"
  "work.evpn_gw.v1alpha1/Svi\022\032\n\rallow_missi"
  "ng\030\002 \001(\010B\003\340A\001\"\235\001\n\020UpdateSviRequest\0227\n\003sv"
  "i\030\001 \001(\0132%.opi_api.network.evpn_gw.v1alph"
  "a1.SviB\003\340A\002\0224\n\013update_mask\030\002 \001(\0132\032.googl"
  "e.protobuf.FieldMaskB\003\340A\001\022\032\n\rallow_missi"
  "ng\030\003 \001(\010B\003\340A\001*b\n\rVRFOperStatus\022\037\n\033VRF_OP"
  "ER_STATUS_UNSPECIFIED\020\000\022\026\n\022VRF_OPER_STAT"
  "US_UP\020\001\022\030\n\024VRF_OPER_STATUS_DOWN\020\002*b\n\rSVI"
  "OperStatus\022\037\n\033SVI_OPER_STATUS_UNSPECIFIE"
  "D\020\000\022\026\n\022SVI_OPER_STATUS_UP\020\001\022\030\n\024SVI_OPER_"
  "STATUS_DOWN\020\0022\276\005\n\nVrfService\022\212\001\n\tCreateV"
  "rf\0222.opi_api.network.evpn_gw.v1alpha1.Cr"
  "eateVrfRequest\032%.opi_api.network.evpn_gw"
  ".v1alpha1.Vrf\"\"\202\323\344\223\002\017\"\010/v1/vrfs:\003vrf\332A\nv"
  "rf,vrf_id\022\203\001\n\010ListVrfs\0221.opi_api.network"
  ".evpn_gw.v1alpha1.ListVrfsRequest\0322.opi_"
  "api.network.evpn_gw.v1alpha1.ListVrfsRes"
  "ponse\"\020\202\323\344\223\002\n\022\010/v1/vrfs\022\202\001\n\006GetVrf\022/.opi"
  "_api.network.evpn_gw.v1alpha1.GetVrfRequ"
  "est\032%.opi_api.network.evpn_gw.v1alpha1.V"
  "rf\" \202\323\344\223\002\023\022\021/v1/{name=vrfs/*}\332A\004name\022y\n\t"
  "DeleteVrf\0222.opi_api.network.evpn_gw.v1al"
  "pha1.DeleteVrfRequest\032\026.google.protobuf."
  "Empty\" \202\323\344\223\002\023*\021/v1/{name=vrfs/*}\332A\004name\022"
  "\234\001\n\tUpdateVrf\0222.opi_api.network.evpn_gw."
  "v1alpha1.UpdateVrfRequest\032%.opi_api.netw"
  "ork.evpn_gw.v1alpha1.Vrf\"4\202\323\344\223\002\0342\025/v1/{v"
  "rf.name=vrfs/*}:\003vrf\332A\017vrf,update_mask2\276"
  "\005\n\nSviService\022\212\001\n\tCreateSvi\0222.opi_api.ne"
  "twork.evpn_gw.v1alpha1.CreateSviRequest\032"
  "%.opi_api.network.evpn_gw.v1alpha1.Svi\"\""
  "\202\323\344\223\002\017\"\010/v1/svis:\003svi\332A\nsvi,svi_id\022\203\001\n\010L"
  "istSvis\0221.opi_api.network.evpn_gw.v1alph"
  "a1.ListSvisRequest\0322.opi_api.network.evp"
  "n_gw.v1alpha1.ListSvisResponse\"\020\202\323\344\223\002\n\022\010"
  "/v1/svis\022\202\001\n\006GetSvi\022/.opi_api.network.ev"
  "pn_gw.v1alpha1.GetSviRequest\032%.opi_api.n"
  "etwork.evpn_gw.v1alpha1.Svi\" \202\323\344\223\002\023\022\021/v1"
  "/{name=svis/*}\332A\004name\022y\n\tDeleteSvi\0222.opi"
  "_api.network.evpn_gw.v1alpha1.DeleteSviR"
  "equest\032\026.google.protobuf.Empty\" \202\323\344\223\002\023*\021"
  "/v1/{name=svis/*}\332A\004name\022\234\001\n\tUpdateSvi\0222"
  ".opi_api.network.evpn_gw.v1alpha1.Update"
  "SviRequest\032%.opi_api.network.evpn_gw.v1a"
  "lpha1.Svi\"4\202\323\344\223\002\0342\025/v1/{svi.name=svis/*}"
  ":\003svi\332A\017svi,update_maskBw\n opi_api.netwo"
  "rk.evpn_gw.v1alpha1B\022L3XpuInfraMgrProtoP"
  "\001Z=github.com/opiproject/opi-api/network"
  "/evpn-gw/v1alpha1/gen/gob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_deps[7] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2fclient_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ffield_5fmask_2eproto,
  &::descriptor_table_networktypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto = {
    false, false, 4592, descriptor_table_protodef_l3_5fxpu_5finfra_5fmgr_2eproto,
    "l3_xpu_infra_mgr.proto",
    &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once, descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_deps, 7, 18,
    schemas, file_default_instances, TableStruct_l3_5fxpu_5finfra_5fmgr_2eproto::offsets,
    file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto, file_level_enum_descriptors_l3_5fxpu_5finfra_5fmgr_2eproto,
    file_level_service_descriptors_l3_5fxpu_5finfra_5fmgr_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter() {
  return &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_l3_5fxpu_5finfra_5fmgr_2eproto(&descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto);
namespace opi_api {
namespace network {
namespace evpn_gw {
namespace v1alpha1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VRFOperStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto);
  return file_level_enum_descriptors_l3_5fxpu_5finfra_5fmgr_2eproto[0];
}
bool VRFOperStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SVIOperStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto);
  return file_level_enum_descriptors_l3_5fxpu_5finfra_5fmgr_2eproto[1];
}
bool SVIOperStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Vrf::_Internal {
 public:
  static const ::opi_api::network::evpn_gw::v1alpha1::VrfSpec& spec(const Vrf* msg);
  static const ::opi_api::network::evpn_gw::v1alpha1::VrfStatus& status(const Vrf* msg);
};

const ::opi_api::network::evpn_gw::v1alpha1::VrfSpec&
Vrf::_Internal::spec(const Vrf* msg) {
  return *msg->_impl_.spec_;
}
const ::opi_api::network::evpn_gw::v1alpha1::VrfStatus&
Vrf::_Internal::status(const Vrf* msg) {
  return *msg->_impl_.status_;
}
Vrf::Vrf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.Vrf)
}
Vrf::Vrf(const Vrf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vrf* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::opi_api::network::evpn_gw::v1alpha1::VrfSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::opi_api::network::evpn_gw::v1alpha1::VrfStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.Vrf)
}

inline void Vrf::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Vrf::~Vrf() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.Vrf)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vrf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Vrf::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vrf::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.Vrf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vrf::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.Vrf.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.VrfSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.VrfStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vrf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.Vrf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.Vrf.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.network.evpn_gw.v1alpha1.VrfSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.evpn_gw.v1alpha1.VrfStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.Vrf)
  return target;
}

size_t Vrf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.Vrf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.network.evpn_gw.v1alpha1.VrfSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spec_);
  }

  // .opi_api.network.evpn_gw.v1alpha1.VrfStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vrf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vrf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vrf::GetClassData() const { return &_class_data_; }


void Vrf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vrf*>(&to_msg);
  auto& from = static_cast<const Vrf&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.Vrf)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _this->_internal_mutable_spec()->::opi_api::network::evpn_gw::v1alpha1::VrfSpec::MergeFrom(
        from._internal_spec());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::opi_api::network::evpn_gw::v1alpha1::VrfStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vrf::CopyFrom(const Vrf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.Vrf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vrf::IsInitialized() const {
  return true;
}

void Vrf::InternalSwap(Vrf* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vrf, _impl_.status_)
      + sizeof(Vrf::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Vrf, _impl_.spec_)>(
          reinterpret_cast<char*>(&_impl_.spec_),
          reinterpret_cast<char*>(&other->_impl_.spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vrf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[0]);
}

// ===================================================================

class VrfSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<VrfSpec>()._impl_._has_bits_);
  static void set_has_vni(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& loopback_ip_prefix(const VrfSpec* msg);
  static const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& vtep_ip_prefix(const VrfSpec* msg);
};

const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&
VrfSpec::_Internal::loopback_ip_prefix(const VrfSpec* msg) {
  return *msg->_impl_.loopback_ip_prefix_;
}
const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&
VrfSpec::_Internal::vtep_ip_prefix(const VrfSpec* msg) {
  return *msg->_impl_.vtep_ip_prefix_;
}
void VrfSpec::clear_loopback_ip_prefix() {
  if (GetArenaForAllocation() == nullptr && _impl_.loopback_ip_prefix_ != nullptr) {
    delete _impl_.loopback_ip_prefix_;
  }
  _impl_.loopback_ip_prefix_ = nullptr;
}
void VrfSpec::clear_vtep_ip_prefix() {
  if (GetArenaForAllocation() == nullptr && _impl_.vtep_ip_prefix_ != nullptr) {
    delete _impl_.vtep_ip_prefix_;
  }
  _impl_.vtep_ip_prefix_ = nullptr;
}
VrfSpec::VrfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
}
VrfSpec::VrfSpec(const VrfSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrfSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.loopback_ip_prefix_){nullptr}
    , decltype(_impl_.vtep_ip_prefix_){nullptr}
    , decltype(_impl_.vni_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_loopback_ip_prefix()) {
    _this->_impl_.loopback_ip_prefix_ = new ::opi_api::network::opinetcommon::v1alpha1::IPPrefix(*from._impl_.loopback_ip_prefix_);
  }
  if (from._internal_has_vtep_ip_prefix()) {
    _this->_impl_.vtep_ip_prefix_ = new ::opi_api::network::opinetcommon::v1alpha1::IPPrefix(*from._impl_.vtep_ip_prefix_);
  }
  _this->_impl_.vni_ = from._impl_.vni_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
}

inline void VrfSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.loopback_ip_prefix_){nullptr}
    , decltype(_impl_.vtep_ip_prefix_){nullptr}
    , decltype(_impl_.vni_){0u}
  };
}

VrfSpec::~VrfSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrfSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.loopback_ip_prefix_;
  if (this != internal_default_instance()) delete _impl_.vtep_ip_prefix_;
}

void VrfSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrfSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.loopback_ip_prefix_ != nullptr) {
    delete _impl_.loopback_ip_prefix_;
  }
  _impl_.loopback_ip_prefix_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vtep_ip_prefix_ != nullptr) {
    delete _impl_.vtep_ip_prefix_;
  }
  _impl_.vtep_ip_prefix_ = nullptr;
  _impl_.vni_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrfSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 vni = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vni(&has_bits);
          _impl_.vni_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.opinetcommon.v1alpha1.IPPrefix loopback_ip_prefix = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_loopback_ip_prefix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.opinetcommon.v1alpha1.IPPrefix vtep_ip_prefix = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vtep_ip_prefix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrfSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 vni = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (_internal_has_vni()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vni(), target);
  }

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix loopback_ip_prefix = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_loopback_ip_prefix()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::loopback_ip_prefix(this),
        _Internal::loopback_ip_prefix(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix vtep_ip_prefix = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_vtep_ip_prefix()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vtep_ip_prefix(this),
        _Internal::vtep_ip_prefix(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  return target;
}

size_t VrfSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix loopback_ip_prefix = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_loopback_ip_prefix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loopback_ip_prefix_);
  }

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix vtep_ip_prefix = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_vtep_ip_prefix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vtep_ip_prefix_);
  }

  // optional uint32 vni = 1 [(.google.api.field_behavior) = OPTIONAL];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vni());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrfSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrfSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrfSpec::GetClassData() const { return &_class_data_; }


void VrfSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrfSpec*>(&to_msg);
  auto& from = static_cast<const VrfSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_loopback_ip_prefix()) {
    _this->_internal_mutable_loopback_ip_prefix()->::opi_api::network::opinetcommon::v1alpha1::IPPrefix::MergeFrom(
        from._internal_loopback_ip_prefix());
  }
  if (from._internal_has_vtep_ip_prefix()) {
    _this->_internal_mutable_vtep_ip_prefix()->::opi_api::network::opinetcommon::v1alpha1::IPPrefix::MergeFrom(
        from._internal_vtep_ip_prefix());
  }
  if (from._internal_has_vni()) {
    _this->_internal_set_vni(from._internal_vni());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrfSpec::CopyFrom(const VrfSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.VrfSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrfSpec::IsInitialized() const {
  return true;
}

void VrfSpec::InternalSwap(VrfSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VrfSpec, _impl_.vni_)
      + sizeof(VrfSpec::_impl_.vni_)
      - PROTOBUF_FIELD_OFFSET(VrfSpec, _impl_.loopback_ip_prefix_)>(
          reinterpret_cast<char*>(&_impl_.loopback_ip_prefix_),
          reinterpret_cast<char*>(&other->_impl_.loopback_ip_prefix_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VrfSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[1]);
}

// ===================================================================

class VrfStatus::_Internal {
 public:
};

VrfStatus::VrfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
}
VrfStatus::VrfStatus(const VrfStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VrfStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.import_rts_){from._impl_.import_rts_}
    , decltype(_impl_.export_rts_){from._impl_.export_rts_}
    , decltype(_impl_.logical_bridges_){from._impl_.logical_bridges_}
    , decltype(_impl_.rd_){}
    , decltype(_impl_.rmac_){}
    , decltype(_impl_.routing_table_){}
    , decltype(_impl_.local_as_){}
    , decltype(_impl_.oper_status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rd().empty()) {
    _this->_impl_.rd_.Set(from._internal_rd(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rmac().empty()) {
    _this->_impl_.rmac_.Set(from._internal_rmac(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.routing_table_, &from._impl_.routing_table_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.oper_status_) -
    reinterpret_cast<char*>(&_impl_.routing_table_)) + sizeof(_impl_.oper_status_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
}

inline void VrfStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.import_rts_){arena}
    , decltype(_impl_.export_rts_){arena}
    , decltype(_impl_.logical_bridges_){arena}
    , decltype(_impl_.rd_){}
    , decltype(_impl_.rmac_){}
    , decltype(_impl_.routing_table_){0u}
    , decltype(_impl_.local_as_){0u}
    , decltype(_impl_.oper_status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.rd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VrfStatus::~VrfStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VrfStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.import_rts_.~RepeatedPtrField();
  _impl_.export_rts_.~RepeatedPtrField();
  _impl_.logical_bridges_.~RepeatedPtrField();
  _impl_.rd_.Destroy();
  _impl_.rmac_.Destroy();
}

void VrfStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VrfStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.import_rts_.Clear();
  _impl_.export_rts_.Clear();
  _impl_.logical_bridges_.Clear();
  _impl_.rd_.ClearToEmpty();
  _impl_.rmac_.ClearToEmpty();
  ::memset(&_impl_.routing_table_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.oper_status_) -
      reinterpret_cast<char*>(&_impl_.routing_table_)) + sizeof(_impl_.oper_status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VrfStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 routing_table = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.routing_table_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 local_as = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.local_as_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string rd = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rd();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.VrfStatus.rd"));
        } else
          goto handle_unusual;
        continue;
      // bytes rmac = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_rmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string import_rts = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_import_rts();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.VrfStatus.import_rts"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string export_rts = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_export_rts();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.VrfStatus.export_rts"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string logical_bridges = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_logical_bridges();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.VrfStatus.logical_bridges"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.VRFOperStatus oper_status = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_oper_status(static_cast<::opi_api::network::evpn_gw::v1alpha1::VRFOperStatus>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VrfStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 routing_table = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_routing_table() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_routing_table(), target);
  }

  // uint32 local_as = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_local_as() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_local_as(), target);
  }

  // string rd = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_rd().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rd().data(), static_cast<int>(this->_internal_rd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.VrfStatus.rd");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rd(), target);
  }

  // bytes rmac = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_rmac().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_rmac(), target);
  }

  // repeated string import_rts = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  for (int i = 0, n = this->_internal_import_rts_size(); i < n; i++) {
    const auto& s = this->_internal_import_rts(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.VrfStatus.import_rts");
    target = stream->WriteString(5, s, target);
  }

  // repeated string export_rts = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  for (int i = 0, n = this->_internal_export_rts_size(); i < n; i++) {
    const auto& s = this->_internal_export_rts(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.VrfStatus.export_rts");
    target = stream->WriteString(6, s, target);
  }

  // repeated string logical_bridges = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
  for (int i = 0, n = this->_internal_logical_bridges_size(); i < n; i++) {
    const auto& s = this->_internal_logical_bridges(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.VrfStatus.logical_bridges");
    target = stream->WriteString(7, s, target);
  }

  // .opi_api.network.evpn_gw.v1alpha1.VRFOperStatus oper_status = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_oper_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_oper_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  return target;
}

size_t VrfStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string import_rts = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.import_rts_.size());
  for (int i = 0, n = _impl_.import_rts_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.import_rts_.Get(i));
  }

  // repeated string export_rts = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.export_rts_.size());
  for (int i = 0, n = _impl_.export_rts_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.export_rts_.Get(i));
  }

  // repeated string logical_bridges = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.logical_bridges_.size());
  for (int i = 0, n = _impl_.logical_bridges_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.logical_bridges_.Get(i));
  }

  // string rd = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_rd().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rd());
  }

  // bytes rmac = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_rmac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rmac());
  }

  // uint32 routing_table = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_routing_table() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_routing_table());
  }

  // uint32 local_as = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_local_as() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_local_as());
  }

  // .opi_api.network.evpn_gw.v1alpha1.VRFOperStatus oper_status = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_oper_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_oper_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VrfStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VrfStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VrfStatus::GetClassData() const { return &_class_data_; }


void VrfStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VrfStatus*>(&to_msg);
  auto& from = static_cast<const VrfStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.import_rts_.MergeFrom(from._impl_.import_rts_);
  _this->_impl_.export_rts_.MergeFrom(from._impl_.export_rts_);
  _this->_impl_.logical_bridges_.MergeFrom(from._impl_.logical_bridges_);
  if (!from._internal_rd().empty()) {
    _this->_internal_set_rd(from._internal_rd());
  }
  if (!from._internal_rmac().empty()) {
    _this->_internal_set_rmac(from._internal_rmac());
  }
  if (from._internal_routing_table() != 0) {
    _this->_internal_set_routing_table(from._internal_routing_table());
  }
  if (from._internal_local_as() != 0) {
    _this->_internal_set_local_as(from._internal_local_as());
  }
  if (from._internal_oper_status() != 0) {
    _this->_internal_set_oper_status(from._internal_oper_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VrfStatus::CopyFrom(const VrfStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.VrfStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrfStatus::IsInitialized() const {
  return true;
}

void VrfStatus::InternalSwap(VrfStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.import_rts_.InternalSwap(&other->_impl_.import_rts_);
  _impl_.export_rts_.InternalSwap(&other->_impl_.export_rts_);
  _impl_.logical_bridges_.InternalSwap(&other->_impl_.logical_bridges_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rd_, lhs_arena,
      &other->_impl_.rd_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rmac_, lhs_arena,
      &other->_impl_.rmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VrfStatus, _impl_.oper_status_)
      + sizeof(VrfStatus::_impl_.oper_status_)
      - PROTOBUF_FIELD_OFFSET(VrfStatus, _impl_.routing_table_)>(
          reinterpret_cast<char*>(&_impl_.routing_table_),
          reinterpret_cast<char*>(&other->_impl_.routing_table_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VrfStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[2]);
}

// ===================================================================

class CreateVrfRequest::_Internal {
 public:
  static const ::opi_api::network::evpn_gw::v1alpha1::Vrf& vrf(const CreateVrfRequest* msg);
};

const ::opi_api::network::evpn_gw::v1alpha1::Vrf&
CreateVrfRequest::_Internal::vrf(const CreateVrfRequest* msg) {
  return *msg->_impl_.vrf_;
}
CreateVrfRequest::CreateVrfRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
}
CreateVrfRequest::CreateVrfRequest(const CreateVrfRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateVrfRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vrf_id_){}
    , decltype(_impl_.vrf_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vrf_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vrf_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_vrf_id().empty()) {
    _this->_impl_.vrf_id_.Set(from._internal_vrf_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_vrf()) {
    _this->_impl_.vrf_ = new ::opi_api::network::evpn_gw::v1alpha1::Vrf(*from._impl_.vrf_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
}

inline void CreateVrfRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vrf_id_){}
    , decltype(_impl_.vrf_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.vrf_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vrf_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateVrfRequest::~CreateVrfRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateVrfRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vrf_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.vrf_;
}

void CreateVrfRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateVrfRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vrf_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.vrf_ != nullptr) {
    delete _impl_.vrf_;
  }
  _impl_.vrf_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateVrfRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string vrf_id = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vrf_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest.vrf_id"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.Vrf vrf = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_vrf(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateVrfRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string vrf_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_vrf_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vrf_id().data(), static_cast<int>(this->_internal_vrf_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest.vrf_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vrf_id(), target);
  }

  // .opi_api.network.evpn_gw.v1alpha1.Vrf vrf = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_vrf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::vrf(this),
        _Internal::vrf(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  return target;
}

size_t CreateVrfRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string vrf_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_vrf_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vrf_id());
  }

  // .opi_api.network.evpn_gw.v1alpha1.Vrf vrf = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_vrf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vrf_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateVrfRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateVrfRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateVrfRequest::GetClassData() const { return &_class_data_; }


void CreateVrfRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateVrfRequest*>(&to_msg);
  auto& from = static_cast<const CreateVrfRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_vrf_id().empty()) {
    _this->_internal_set_vrf_id(from._internal_vrf_id());
  }
  if (from._internal_has_vrf()) {
    _this->_internal_mutable_vrf()->::opi_api::network::evpn_gw::v1alpha1::Vrf::MergeFrom(
        from._internal_vrf());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateVrfRequest::CopyFrom(const CreateVrfRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.CreateVrfRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateVrfRequest::IsInitialized() const {
  return true;
}

void CreateVrfRequest::InternalSwap(CreateVrfRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vrf_id_, lhs_arena,
      &other->_impl_.vrf_id_, rhs_arena
  );
  swap(_impl_.vrf_, other->_impl_.vrf_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateVrfRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[3]);
}

// ===================================================================

class ListVrfsRequest::_Internal {
 public:
};

ListVrfsRequest::ListVrfsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
}
ListVrfsRequest::ListVrfsRequest(const ListVrfsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListVrfsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
}

inline void ListVrfsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListVrfsRequest::~ListVrfsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListVrfsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.page_token_.Destroy();
}

void ListVrfsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListVrfsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListVrfsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListVrfsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_page_size(), target);
  }

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  return target;
}

size_t ListVrfsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListVrfsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListVrfsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListVrfsRequest::GetClassData() const { return &_class_data_; }


void ListVrfsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListVrfsRequest*>(&to_msg);
  auto& from = static_cast<const ListVrfsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListVrfsRequest::CopyFrom(const ListVrfsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListVrfsRequest::IsInitialized() const {
  return true;
}

void ListVrfsRequest::InternalSwap(ListVrfsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListVrfsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[4]);
}

// ===================================================================

class ListVrfsResponse::_Internal {
 public:
};

ListVrfsResponse::ListVrfsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
}
ListVrfsResponse::ListVrfsResponse(const ListVrfsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListVrfsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vrfs_){from._impl_.vrfs_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
}

inline void ListVrfsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vrfs_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListVrfsResponse::~ListVrfsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListVrfsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vrfs_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListVrfsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListVrfsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vrfs_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListVrfsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.network.evpn_gw.v1alpha1.Vrf vrfs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vrfs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListVrfsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.network.evpn_gw.v1alpha1.Vrf vrfs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vrfs_size()); i < n; i++) {
    const auto& repfield = this->_internal_vrfs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  return target;
}

size_t ListVrfsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.network.evpn_gw.v1alpha1.Vrf vrfs = 1;
  total_size += 1UL * this->_internal_vrfs_size();
  for (const auto& msg : this->_impl_.vrfs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListVrfsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListVrfsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListVrfsResponse::GetClassData() const { return &_class_data_; }


void ListVrfsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListVrfsResponse*>(&to_msg);
  auto& from = static_cast<const ListVrfsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vrfs_.MergeFrom(from._impl_.vrfs_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListVrfsResponse::CopyFrom(const ListVrfsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.ListVrfsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListVrfsResponse::IsInitialized() const {
  return true;
}

void ListVrfsResponse::InternalSwap(ListVrfsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vrfs_.InternalSwap(&other->_impl_.vrfs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListVrfsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[5]);
}

// ===================================================================

class GetVrfRequest::_Internal {
 public:
};

GetVrfRequest::GetVrfRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
}
GetVrfRequest::GetVrfRequest(const GetVrfRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetVrfRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
}

inline void GetVrfRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetVrfRequest::~GetVrfRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetVrfRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetVrfRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetVrfRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetVrfRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.GetVrfRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetVrfRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.GetVrfRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  return target;
}

size_t GetVrfRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetVrfRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetVrfRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetVrfRequest::GetClassData() const { return &_class_data_; }


void GetVrfRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetVrfRequest*>(&to_msg);
  auto& from = static_cast<const GetVrfRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetVrfRequest::CopyFrom(const GetVrfRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.GetVrfRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVrfRequest::IsInitialized() const {
  return true;
}

void GetVrfRequest::InternalSwap(GetVrfRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetVrfRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[6]);
}

// ===================================================================

class DeleteVrfRequest::_Internal {
 public:
};

DeleteVrfRequest::DeleteVrfRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
}
DeleteVrfRequest::DeleteVrfRequest(const DeleteVrfRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteVrfRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
}

inline void DeleteVrfRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteVrfRequest::~DeleteVrfRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteVrfRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteVrfRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteVrfRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteVrfRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteVrfRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  return target;
}

size_t DeleteVrfRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteVrfRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteVrfRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteVrfRequest::GetClassData() const { return &_class_data_; }


void DeleteVrfRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteVrfRequest*>(&to_msg);
  auto& from = static_cast<const DeleteVrfRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteVrfRequest::CopyFrom(const DeleteVrfRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.DeleteVrfRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteVrfRequest::IsInitialized() const {
  return true;
}

void DeleteVrfRequest::InternalSwap(DeleteVrfRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteVrfRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[7]);
}

// ===================================================================

class UpdateVrfRequest::_Internal {
 public:
  static const ::opi_api::network::evpn_gw::v1alpha1::Vrf& vrf(const UpdateVrfRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateVrfRequest* msg);
};

const ::opi_api::network::evpn_gw::v1alpha1::Vrf&
UpdateVrfRequest::_Internal::vrf(const UpdateVrfRequest* msg) {
  return *msg->_impl_.vrf_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateVrfRequest::_Internal::update_mask(const UpdateVrfRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateVrfRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateVrfRequest::UpdateVrfRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
}
UpdateVrfRequest::UpdateVrfRequest(const UpdateVrfRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateVrfRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vrf_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vrf()) {
    _this->_impl_.vrf_ = new ::opi_api::network::evpn_gw::v1alpha1::Vrf(*from._impl_.vrf_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
}

inline void UpdateVrfRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vrf_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateVrfRequest::~UpdateVrfRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateVrfRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.vrf_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateVrfRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateVrfRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.vrf_ != nullptr) {
    delete _impl_.vrf_;
  }
  _impl_.vrf_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateVrfRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.evpn_gw.v1alpha1.Vrf vrf = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_vrf(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateVrfRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.evpn_gw.v1alpha1.Vrf vrf = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_vrf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::vrf(this),
        _Internal::vrf(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  return target;
}

size_t UpdateVrfRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.evpn_gw.v1alpha1.Vrf vrf = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_vrf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vrf_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateVrfRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateVrfRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateVrfRequest::GetClassData() const { return &_class_data_; }


void UpdateVrfRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateVrfRequest*>(&to_msg);
  auto& from = static_cast<const UpdateVrfRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_vrf()) {
    _this->_internal_mutable_vrf()->::opi_api::network::evpn_gw::v1alpha1::Vrf::MergeFrom(
        from._internal_vrf());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateVrfRequest::CopyFrom(const UpdateVrfRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.UpdateVrfRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateVrfRequest::IsInitialized() const {
  return true;
}

void UpdateVrfRequest::InternalSwap(UpdateVrfRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateVrfRequest, _impl_.allow_missing_)
      + sizeof(UpdateVrfRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateVrfRequest, _impl_.vrf_)>(
          reinterpret_cast<char*>(&_impl_.vrf_),
          reinterpret_cast<char*>(&other->_impl_.vrf_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateVrfRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[8]);
}

// ===================================================================

class Svi::_Internal {
 public:
  static const ::opi_api::network::evpn_gw::v1alpha1::SviSpec& spec(const Svi* msg);
  static const ::opi_api::network::evpn_gw::v1alpha1::SviStatus& status(const Svi* msg);
};

const ::opi_api::network::evpn_gw::v1alpha1::SviSpec&
Svi::_Internal::spec(const Svi* msg) {
  return *msg->_impl_.spec_;
}
const ::opi_api::network::evpn_gw::v1alpha1::SviStatus&
Svi::_Internal::status(const Svi* msg) {
  return *msg->_impl_.status_;
}
Svi::Svi(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.Svi)
}
Svi::Svi(const Svi& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Svi* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::opi_api::network::evpn_gw::v1alpha1::SviSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::opi_api::network::evpn_gw::v1alpha1::SviStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.Svi)
}

inline void Svi::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Svi::~Svi() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.Svi)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Svi::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Svi::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Svi::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.Svi)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Svi::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.Svi.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.SviSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.SviStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Svi::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.Svi)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.Svi.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.network.evpn_gw.v1alpha1.SviSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.evpn_gw.v1alpha1.SviStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.Svi)
  return target;
}

size_t Svi::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.Svi)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.network.evpn_gw.v1alpha1.SviSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spec_);
  }

  // .opi_api.network.evpn_gw.v1alpha1.SviStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Svi::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Svi::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Svi::GetClassData() const { return &_class_data_; }


void Svi::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Svi*>(&to_msg);
  auto& from = static_cast<const Svi&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.Svi)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _this->_internal_mutable_spec()->::opi_api::network::evpn_gw::v1alpha1::SviSpec::MergeFrom(
        from._internal_spec());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::opi_api::network::evpn_gw::v1alpha1::SviStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Svi::CopyFrom(const Svi& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.Svi)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Svi::IsInitialized() const {
  return true;
}

void Svi::InternalSwap(Svi* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Svi, _impl_.status_)
      + sizeof(Svi::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Svi, _impl_.spec_)>(
          reinterpret_cast<char*>(&_impl_.spec_),
          reinterpret_cast<char*>(&other->_impl_.spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Svi::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[9]);
}

// ===================================================================

class SviSpec::_Internal {
 public:
};

void SviSpec::clear_gw_ip_prefix() {
  _impl_.gw_ip_prefix_.Clear();
}
SviSpec::SviSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.SviSpec)
}
SviSpec::SviSpec(const SviSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SviSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gw_ip_prefix_){from._impl_.gw_ip_prefix_}
    , decltype(_impl_.vrf_){}
    , decltype(_impl_.logical_bridge_){}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.enable_bgp_){}
    , decltype(_impl_.remote_as_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vrf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vrf_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_vrf().empty()) {
    _this->_impl_.vrf_.Set(from._internal_vrf(), 
      _this->GetArenaForAllocation());
  }
  _impl_.logical_bridge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.logical_bridge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_logical_bridge().empty()) {
    _this->_impl_.logical_bridge_.Set(from._internal_logical_bridge(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    _this->_impl_.mac_address_.Set(from._internal_mac_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.enable_bgp_, &from._impl_.enable_bgp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.remote_as_) -
    reinterpret_cast<char*>(&_impl_.enable_bgp_)) + sizeof(_impl_.remote_as_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.SviSpec)
}

inline void SviSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gw_ip_prefix_){arena}
    , decltype(_impl_.vrf_){}
    , decltype(_impl_.logical_bridge_){}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.enable_bgp_){false}
    , decltype(_impl_.remote_as_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.vrf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vrf_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.logical_bridge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.logical_bridge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SviSpec::~SviSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SviSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gw_ip_prefix_.~RepeatedPtrField();
  _impl_.vrf_.Destroy();
  _impl_.logical_bridge_.Destroy();
  _impl_.mac_address_.Destroy();
}

void SviSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SviSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gw_ip_prefix_.Clear();
  _impl_.vrf_.ClearToEmpty();
  _impl_.logical_bridge_.ClearToEmpty();
  _impl_.mac_address_.ClearToEmpty();
  ::memset(&_impl_.enable_bgp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.remote_as_) -
      reinterpret_cast<char*>(&_impl_.enable_bgp_)) + sizeof(_impl_.remote_as_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SviSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string vrf = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vrf();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.SviSpec.vrf"));
        } else
          goto handle_unusual;
        continue;
      // string logical_bridge = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_logical_bridge();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.SviSpec.logical_bridge"));
        } else
          goto handle_unusual;
        continue;
      // bytes mac_address = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix gw_ip_prefix = 4 [(.google.api.field_behavior) = REQUIRED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gw_ip_prefix(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool enable_bgp = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.enable_bgp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 remote_as = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.remote_as_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SviSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string vrf = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_vrf().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vrf().data(), static_cast<int>(this->_internal_vrf().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.SviSpec.vrf");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vrf(), target);
  }

  // string logical_bridge = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_logical_bridge().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_logical_bridge().data(), static_cast<int>(this->_internal_logical_bridge().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.SviSpec.logical_bridge");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_logical_bridge(), target);
  }

  // bytes mac_address = 3 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_mac_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_mac_address(), target);
  }

  // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix gw_ip_prefix = 4 [(.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gw_ip_prefix_size()); i < n; i++) {
    const auto& repfield = this->_internal_gw_ip_prefix(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool enable_bgp = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_enable_bgp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_bgp(), target);
  }

  // uint32 remote_as = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_remote_as() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_remote_as(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  return target;
}

size_t SviSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix gw_ip_prefix = 4 [(.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_gw_ip_prefix_size();
  for (const auto& msg : this->_impl_.gw_ip_prefix_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string vrf = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_vrf().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vrf());
  }

  // string logical_bridge = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_logical_bridge().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_logical_bridge());
  }

  // bytes mac_address = 3 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac_address());
  }

  // bool enable_bgp = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_enable_bgp() != 0) {
    total_size += 1 + 1;
  }

  // uint32 remote_as = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_remote_as() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remote_as());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SviSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SviSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SviSpec::GetClassData() const { return &_class_data_; }


void SviSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SviSpec*>(&to_msg);
  auto& from = static_cast<const SviSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gw_ip_prefix_.MergeFrom(from._impl_.gw_ip_prefix_);
  if (!from._internal_vrf().empty()) {
    _this->_internal_set_vrf(from._internal_vrf());
  }
  if (!from._internal_logical_bridge().empty()) {
    _this->_internal_set_logical_bridge(from._internal_logical_bridge());
  }
  if (!from._internal_mac_address().empty()) {
    _this->_internal_set_mac_address(from._internal_mac_address());
  }
  if (from._internal_enable_bgp() != 0) {
    _this->_internal_set_enable_bgp(from._internal_enable_bgp());
  }
  if (from._internal_remote_as() != 0) {
    _this->_internal_set_remote_as(from._internal_remote_as());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SviSpec::CopyFrom(const SviSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.SviSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SviSpec::IsInitialized() const {
  return true;
}

void SviSpec::InternalSwap(SviSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gw_ip_prefix_.InternalSwap(&other->_impl_.gw_ip_prefix_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vrf_, lhs_arena,
      &other->_impl_.vrf_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.logical_bridge_, lhs_arena,
      &other->_impl_.logical_bridge_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_address_, lhs_arena,
      &other->_impl_.mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SviSpec, _impl_.remote_as_)
      + sizeof(SviSpec::_impl_.remote_as_)
      - PROTOBUF_FIELD_OFFSET(SviSpec, _impl_.enable_bgp_)>(
          reinterpret_cast<char*>(&_impl_.enable_bgp_),
          reinterpret_cast<char*>(&other->_impl_.enable_bgp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SviSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[10]);
}

// ===================================================================

class SviStatus::_Internal {
 public:
};

SviStatus::SviStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.SviStatus)
}
SviStatus::SviStatus(const SviStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SviStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oper_status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.oper_status_ = from._impl_.oper_status_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.SviStatus)
}

inline void SviStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oper_status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SviStatus::~SviStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SviStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SviStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SviStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.oper_status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SviStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.evpn_gw.v1alpha1.SVIOperStatus oper_status = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_oper_status(static_cast<::opi_api::network::evpn_gw::v1alpha1::SVIOperStatus>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SviStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.evpn_gw.v1alpha1.SVIOperStatus oper_status = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_oper_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_oper_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  return target;
}

size_t SviStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.evpn_gw.v1alpha1.SVIOperStatus oper_status = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_oper_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_oper_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SviStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SviStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SviStatus::GetClassData() const { return &_class_data_; }


void SviStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SviStatus*>(&to_msg);
  auto& from = static_cast<const SviStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_oper_status() != 0) {
    _this->_internal_set_oper_status(from._internal_oper_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SviStatus::CopyFrom(const SviStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.SviStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SviStatus::IsInitialized() const {
  return true;
}

void SviStatus::InternalSwap(SviStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.oper_status_, other->_impl_.oper_status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SviStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[11]);
}

// ===================================================================

class CreateSviRequest::_Internal {
 public:
  static const ::opi_api::network::evpn_gw::v1alpha1::Svi& svi(const CreateSviRequest* msg);
};

const ::opi_api::network::evpn_gw::v1alpha1::Svi&
CreateSviRequest::_Internal::svi(const CreateSviRequest* msg) {
  return *msg->_impl_.svi_;
}
CreateSviRequest::CreateSviRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
}
CreateSviRequest::CreateSviRequest(const CreateSviRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateSviRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.svi_id_){}
    , decltype(_impl_.svi_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.svi_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.svi_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_svi_id().empty()) {
    _this->_impl_.svi_id_.Set(from._internal_svi_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_svi()) {
    _this->_impl_.svi_ = new ::opi_api::network::evpn_gw::v1alpha1::Svi(*from._impl_.svi_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
}

inline void CreateSviRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.svi_id_){}
    , decltype(_impl_.svi_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.svi_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.svi_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateSviRequest::~CreateSviRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateSviRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.svi_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.svi_;
}

void CreateSviRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateSviRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.svi_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.svi_ != nullptr) {
    delete _impl_.svi_;
  }
  _impl_.svi_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateSviRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string svi_id = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_svi_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.CreateSviRequest.svi_id"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.evpn_gw.v1alpha1.Svi svi = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_svi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateSviRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string svi_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_svi_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_svi_id().data(), static_cast<int>(this->_internal_svi_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.CreateSviRequest.svi_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_svi_id(), target);
  }

  // .opi_api.network.evpn_gw.v1alpha1.Svi svi = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_svi()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::svi(this),
        _Internal::svi(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  return target;
}

size_t CreateSviRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string svi_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_svi_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_svi_id());
  }

  // .opi_api.network.evpn_gw.v1alpha1.Svi svi = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_svi()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.svi_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateSviRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateSviRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateSviRequest::GetClassData() const { return &_class_data_; }


void CreateSviRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateSviRequest*>(&to_msg);
  auto& from = static_cast<const CreateSviRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_svi_id().empty()) {
    _this->_internal_set_svi_id(from._internal_svi_id());
  }
  if (from._internal_has_svi()) {
    _this->_internal_mutable_svi()->::opi_api::network::evpn_gw::v1alpha1::Svi::MergeFrom(
        from._internal_svi());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateSviRequest::CopyFrom(const CreateSviRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.CreateSviRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateSviRequest::IsInitialized() const {
  return true;
}

void CreateSviRequest::InternalSwap(CreateSviRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.svi_id_, lhs_arena,
      &other->_impl_.svi_id_, rhs_arena
  );
  swap(_impl_.svi_, other->_impl_.svi_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateSviRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[12]);
}

// ===================================================================

class ListSvisRequest::_Internal {
 public:
};

ListSvisRequest::ListSvisRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
}
ListSvisRequest::ListSvisRequest(const ListSvisRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListSvisRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
}

inline void ListSvisRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListSvisRequest::~ListSvisRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListSvisRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.page_token_.Destroy();
}

void ListSvisRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListSvisRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListSvisRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.ListSvisRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListSvisRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_page_size(), target);
  }

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.ListSvisRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  return target;
}

size_t ListSvisRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListSvisRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListSvisRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListSvisRequest::GetClassData() const { return &_class_data_; }


void ListSvisRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListSvisRequest*>(&to_msg);
  auto& from = static_cast<const ListSvisRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListSvisRequest::CopyFrom(const ListSvisRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.ListSvisRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListSvisRequest::IsInitialized() const {
  return true;
}

void ListSvisRequest::InternalSwap(ListSvisRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListSvisRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[13]);
}

// ===================================================================

class ListSvisResponse::_Internal {
 public:
};

ListSvisResponse::ListSvisResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
}
ListSvisResponse::ListSvisResponse(const ListSvisResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListSvisResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.svis_){from._impl_.svis_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
}

inline void ListSvisResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.svis_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListSvisResponse::~ListSvisResponse() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListSvisResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.svis_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListSvisResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListSvisResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.svis_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListSvisResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.network.evpn_gw.v1alpha1.Svi svis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_svis(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.ListSvisResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListSvisResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.network.evpn_gw.v1alpha1.Svi svis = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_svis_size()); i < n; i++) {
    const auto& repfield = this->_internal_svis(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.ListSvisResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  return target;
}

size_t ListSvisResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.network.evpn_gw.v1alpha1.Svi svis = 1;
  total_size += 1UL * this->_internal_svis_size();
  for (const auto& msg : this->_impl_.svis_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListSvisResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListSvisResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListSvisResponse::GetClassData() const { return &_class_data_; }


void ListSvisResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListSvisResponse*>(&to_msg);
  auto& from = static_cast<const ListSvisResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.svis_.MergeFrom(from._impl_.svis_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListSvisResponse::CopyFrom(const ListSvisResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.ListSvisResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListSvisResponse::IsInitialized() const {
  return true;
}

void ListSvisResponse::InternalSwap(ListSvisResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.svis_.InternalSwap(&other->_impl_.svis_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListSvisResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[14]);
}

// ===================================================================

class GetSviRequest::_Internal {
 public:
};

GetSviRequest::GetSviRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
}
GetSviRequest::GetSviRequest(const GetSviRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetSviRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
}

inline void GetSviRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetSviRequest::~GetSviRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetSviRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetSviRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetSviRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetSviRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.GetSviRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetSviRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.GetSviRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  return target;
}

size_t GetSviRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetSviRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetSviRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetSviRequest::GetClassData() const { return &_class_data_; }


void GetSviRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetSviRequest*>(&to_msg);
  auto& from = static_cast<const GetSviRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetSviRequest::CopyFrom(const GetSviRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.GetSviRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSviRequest::IsInitialized() const {
  return true;
}

void GetSviRequest::InternalSwap(GetSviRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetSviRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[15]);
}

// ===================================================================

class DeleteSviRequest::_Internal {
 public:
};

DeleteSviRequest::DeleteSviRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
}
DeleteSviRequest::DeleteSviRequest(const DeleteSviRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteSviRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
}

inline void DeleteSviRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteSviRequest::~DeleteSviRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteSviRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteSviRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteSviRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteSviRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteSviRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  return target;
}

size_t DeleteSviRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteSviRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteSviRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteSviRequest::GetClassData() const { return &_class_data_; }


void DeleteSviRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteSviRequest*>(&to_msg);
  auto& from = static_cast<const DeleteSviRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteSviRequest::CopyFrom(const DeleteSviRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.DeleteSviRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteSviRequest::IsInitialized() const {
  return true;
}

void DeleteSviRequest::InternalSwap(DeleteSviRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteSviRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[16]);
}

// ===================================================================

class UpdateSviRequest::_Internal {
 public:
  static const ::opi_api::network::evpn_gw::v1alpha1::Svi& svi(const UpdateSviRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateSviRequest* msg);
};

const ::opi_api::network::evpn_gw::v1alpha1::Svi&
UpdateSviRequest::_Internal::svi(const UpdateSviRequest* msg) {
  return *msg->_impl_.svi_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateSviRequest::_Internal::update_mask(const UpdateSviRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateSviRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateSviRequest::UpdateSviRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
}
UpdateSviRequest::UpdateSviRequest(const UpdateSviRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateSviRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.svi_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_svi()) {
    _this->_impl_.svi_ = new ::opi_api::network::evpn_gw::v1alpha1::Svi(*from._impl_.svi_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
}

inline void UpdateSviRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.svi_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateSviRequest::~UpdateSviRequest() {
  // @@protoc_insertion_point(destructor:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateSviRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.svi_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateSviRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateSviRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.svi_ != nullptr) {
    delete _impl_.svi_;
  }
  _impl_.svi_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateSviRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.evpn_gw.v1alpha1.Svi svi = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_svi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateSviRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.evpn_gw.v1alpha1.Svi svi = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_svi()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::svi(this),
        _Internal::svi(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  return target;
}

size_t UpdateSviRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.network.evpn_gw.v1alpha1.Svi svi = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_svi()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.svi_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateSviRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateSviRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateSviRequest::GetClassData() const { return &_class_data_; }


void UpdateSviRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateSviRequest*>(&to_msg);
  auto& from = static_cast<const UpdateSviRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_svi()) {
    _this->_internal_mutable_svi()->::opi_api::network::evpn_gw::v1alpha1::Svi::MergeFrom(
        from._internal_svi());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateSviRequest::CopyFrom(const UpdateSviRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.evpn_gw.v1alpha1.UpdateSviRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateSviRequest::IsInitialized() const {
  return true;
}

void UpdateSviRequest::InternalSwap(UpdateSviRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateSviRequest, _impl_.allow_missing_)
      + sizeof(UpdateSviRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateSviRequest, _impl_.svi_)>(
          reinterpret_cast<char*>(&_impl_.svi_),
          reinterpret_cast<char*>(&other->_impl_.svi_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateSviRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_getter, &descriptor_table_l3_5fxpu_5finfra_5fmgr_2eproto_once,
      file_level_metadata_l3_5fxpu_5finfra_5fmgr_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace evpn_gw
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::Vrf*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::Vrf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::Vrf >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::VrfSpec*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::VrfSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::VrfSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::VrfStatus*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::VrfStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::VrfStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::CreateVrfRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::ListVrfsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::ListVrfsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::GetVrfRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::GetVrfRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::GetVrfRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::DeleteVrfRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::UpdateVrfRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::Svi*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::Svi >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::Svi >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::SviSpec*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::SviSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::SviSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::SviStatus*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::SviStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::SviStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::CreateSviRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::ListSvisRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::ListSvisResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::GetSviRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::GetSviRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::GetSviRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::DeleteSviRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest*
Arena::CreateMaybeMessage< ::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::evpn_gw::v1alpha1::UpdateSviRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
