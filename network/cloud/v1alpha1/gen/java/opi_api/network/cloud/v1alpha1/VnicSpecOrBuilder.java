// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vnic.proto

package opi_api.network.cloud.v1alpha1;

public interface VnicSpecOrBuilder extends
    // @@protoc_insertion_point(interface_extends:opi_api.network.cloud.v1alpha1.VnicSpec)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * id of the subnet this vnic belongs to
   * </pre>
   *
   * <code>string subnet_name_ref = 1;</code>
   * @return The subnetNameRef.
   */
  java.lang.String getSubnetNameRef();
  /**
   * <pre>
   * id of the subnet this vnic belongs to
   * </pre>
   *
   * <code>string subnet_name_ref = 1;</code>
   * @return The bytes for subnetNameRef.
   */
  com.google.protobuf.ByteString
      getSubnetNameRefBytes();

  /**
   * <pre>
   * vnic encap information to be used while sending packets to this vnic
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap vnic_encap = 2;</code>
   * @return Whether the vnicEncap field is set.
   */
  boolean hasVnicEncap();
  /**
   * <pre>
   * vnic encap information to be used while sending packets to this vnic
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap vnic_encap = 2;</code>
   * @return The vnicEncap.
   */
  opi_api.network.opinetcommon.v1alpha1.Encap getVnicEncap();
  /**
   * <pre>
   * vnic encap information to be used while sending packets to this vnic
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap vnic_encap = 2;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.EncapOrBuilder getVnicEncapOrBuilder();

  /**
   * <pre>
   * overlay MAC of this VNIC
   * </pre>
   *
   * <code>bytes mac_address = 3;</code>
   * @return The macAddress.
   */
  com.google.protobuf.ByteString getMacAddress();

  /**
   * <pre>
   * enable or disable reverse path checks while rx/tx traffic from/to this vnic
   * </pre>
   *
   * <code>bool source_guard_enable = 4;</code>
   * @return The sourceGuardEnable.
   */
  boolean getSourceGuardEnable();

  /**
   * <pre>
   * fabric encap information to be used for traffic originated from this vnic
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 5;</code>
   * @return Whether the fabricEncap field is set.
   */
  boolean hasFabricEncap();
  /**
   * <pre>
   * fabric encap information to be used for traffic originated from this vnic
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 5;</code>
   * @return The fabricEncap.
   */
  opi_api.network.opinetcommon.v1alpha1.Encap getFabricEncap();
  /**
   * <pre>
   * fabric encap information to be used for traffic originated from this vnic
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 5;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.EncapOrBuilder getFabricEncapOrBuilder();

  /**
   * <pre>
   * VNFs (virtual network functions are workloads that implement network
   * features such as firewalls, virtual switches/bridges, security monitoring, etc.
   * since VNFs are devices in the middle, they can rx/tx traffic on behalf of other
   * workloads to allow for source/destination checks, and exceptions that of a mapping
   * </pre>
   *
   * <code>bool vnf = 6;</code>
   * @return The vnf.
   */
  boolean getVnf();

  /**
   * <pre>
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v4_security_policy_name_ref = 7;</code>
   * @return A list containing the ingressV4SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getIngressV4SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v4_security_policy_name_ref = 7;</code>
   * @return The count of ingressV4SecurityPolicyNameRef.
   */
  int getIngressV4SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v4_security_policy_name_ref = 7;</code>
   * @param index The index of the element to return.
   * @return The ingressV4SecurityPolicyNameRef at the given index.
   */
  java.lang.String getIngressV4SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v4_security_policy_name_ref = 7;</code>
   * @param index The index of the value to return.
   * @return The bytes of the ingressV4SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getIngressV4SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 8;</code>
   * @return A list containing the ingressV6SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getIngressV6SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 8;</code>
   * @return The count of ingressV6SecurityPolicyNameRef.
   */
  int getIngressV6SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 8;</code>
   * @param index The index of the element to return.
   * @return The ingressV6SecurityPolicyNameRef at the given index.
   */
  java.lang.String getIngressV6SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 8;</code>
   * @param index The index of the value to return.
   * @return The bytes of the ingressV6SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getIngressV6SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 9;</code>
   * @return A list containing the egressV4SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getEgressV4SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 9;</code>
   * @return The count of egressV4SecurityPolicyNameRef.
   */
  int getEgressV4SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 9;</code>
   * @param index The index of the element to return.
   * @return The egressV4SecurityPolicyNameRef at the given index.
   */
  java.lang.String getEgressV4SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 9;</code>
   * @param index The index of the value to return.
   * @return The bytes of the egressV4SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getEgressV4SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 10;</code>
   * @return A list containing the egressV6SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getEgressV6SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 10;</code>
   * @return The count of egressV6SecurityPolicyNameRef.
   */
  int getEgressV6SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 10;</code>
   * @param index The index of the element to return.
   * @return The egressV6SecurityPolicyNameRef at the given index.
   */
  java.lang.String getEgressV6SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 10;</code>
   * @param index The index of the value to return.
   * @return The bytes of the egressV6SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getEgressV6SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * if VNIC Is attahced to a PF/VF, this identifies the corresponding interface object
   * </pre>
   *
   * <code>string host_if_name_ref = 11;</code>
   * @return Whether the hostIfNameRef field is set.
   */
  boolean hasHostIfNameRef();
  /**
   * <pre>
   * if VNIC Is attahced to a PF/VF, this identifies the corresponding interface object
   * </pre>
   *
   * <code>string host_if_name_ref = 11;</code>
   * @return The hostIfNameRef.
   */
  java.lang.String getHostIfNameRef();
  /**
   * <pre>
   * if VNIC Is attahced to a PF/VF, this identifies the corresponding interface object
   * </pre>
   *
   * <code>string host_if_name_ref = 11;</code>
   * @return The bytes for hostIfNameRef.
   */
  com.google.protobuf.ByteString
      getHostIfNameRefBytes();

  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_SMART_SWITCH, vnic can be behind a
   * tunnel between the host and the DSC
   * </pre>
   *
   * <code>string tunnel_name_ref = 12;</code>
   * @return Whether the tunnelNameRef field is set.
   */
  boolean hasTunnelNameRef();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_SMART_SWITCH, vnic can be behind a
   * tunnel between the host and the DSC
   * </pre>
   *
   * <code>string tunnel_name_ref = 12;</code>
   * @return The tunnelNameRef.
   */
  java.lang.String getTunnelNameRef();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_SMART_SWITCH, vnic can be behind a
   * tunnel between the host and the DSC
   * </pre>
   *
   * <code>string tunnel_name_ref = 12;</code>
   * @return The bytes for tunnelNameRef.
   */
  com.google.protobuf.ByteString
      getTunnelNameRefBytes();

  /**
   * <pre>
   * max_sessions, if set, is total number of active sessions (across all
   * protocols) allowed from/to this vnic; zero means unlimited
   * </pre>
   *
   * <code>int32 max_sessions = 13;</code>
   * @return The maxSessions.
   */
  int getMaxSessions();

  /**
   * <pre>
   * guest workload's MAC in rx/tx direction is rewritten with this mac if non zero
   * </pre>
   *
   * <code>bytes public_mac_address = 14;</code>
   * @return The publicMacAddress.
   */
  com.google.protobuf.ByteString getPublicMacAddress();

  /**
   * <pre>
   * if allow_internet_access is set to false and traffic from the vnic hits a
   * route of class ROUTE_CLASS_INTERNET, then traffic is dropped. To allow
   * Internet connectivity for the vnic, AllowInternetAccess must be set to
   * true
   * </pre>
   *
   * <code>bool allow_internet_access = 15;</code>
   * @return The allowInternetAccess.
   */
  boolean getAllowInternetAccess();

  /**
   * <pre>
   * max_cps, if non-zero, is the maximum no. of connections per second (cps)
   * allowed for this vnic and if cps exceeds this configured limit all
   * new connections will get dropped; zero means unlimited
   * </pre>
   *
   * <code>int32 max_cps = 16;</code>
   * @return The maxCps.
   */
  int getMaxCps();

  /**
   * <pre>
   * CPS burst to be absorbed when CPS exceeds MaxCPS; zero means
   * no burst is allowed
   * </pre>
   *
   * <code>int32 cps_burst = 17;</code>
   * @return The cpsBurst.
   */
  int getCpsBurst();

  /**
   * <pre>
   * multiple vnics can be created with same MAC but only of them can be primary
   * VNIC and all 2nd-ary vnics refer to the primary vnic, both primary and
   * secondary vnic can have one or more local IP mappings behind them
   * </pre>
   *
   * <code>string primary_vnic_name_ref = 18;</code>
   * @return The primaryVnicNameRef.
   */
  java.lang.String getPrimaryVnicNameRef();
  /**
   * <pre>
   * multiple vnics can be created with same MAC but only of them can be primary
   * VNIC and all 2nd-ary vnics refer to the primary vnic, both primary and
   * secondary vnic can have one or more local IP mappings behind them
   * </pre>
   *
   * <code>string primary_vnic_name_ref = 18;</code>
   * @return The bytes for primaryVnicNameRef.
   */
  com.google.protobuf.ByteString
      getPrimaryVnicNameRefBytes();

  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>string v4_route_table_name_ref = 19;</code>
   * @return The v4RouteTableNameRef.
   */
  java.lang.String getV4RouteTableNameRef();
  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>string v4_route_table_name_ref = 19;</code>
   * @return The bytes for v4RouteTableNameRef.
   */
  com.google.protobuf.ByteString
      getV4RouteTableNameRefBytes();

  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>string v6_route_table_name_ref = 20;</code>
   * @return The v6RouteTableNameRef.
   */
  java.lang.String getV6RouteTableNameRef();
  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>string v6_route_table_name_ref = 20;</code>
   * @return The bytes for v6RouteTableNameRef.
   */
  com.google.protobuf.ByteString
      getV6RouteTableNameRefBytes();

  /**
   * <pre>
   * vnic if assigned a VIP in the underlay, can be used as
   * outer encap source IP, if configured, for traffic going to certain vpc
   * private service endpoints
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPAddress service_ip = 21;</code>
   * @return Whether the serviceIp field is set.
   */
  boolean hasServiceIp();
  /**
   * <pre>
   * vnic if assigned a VIP in the underlay, can be used as
   * outer encap source IP, if configured, for traffic going to certain vpc
   * private service endpoints
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPAddress service_ip = 21;</code>
   * @return The serviceIp.
   */
  opi_api.network.opinetcommon.v1alpha1.IPAddress getServiceIp();
  /**
   * <pre>
   * vnic if assigned a VIP in the underlay, can be used as
   * outer encap source IP, if configured, for traffic going to certain vpc
   * private service endpoints
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPAddress service_ip = 21;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.IPAddressOrBuilder getServiceIpOrBuilder();

  /**
   * <pre>
   * max_tcp_sessions is the maximum number of TCP sessions allowed from/to this
   * vnic, if it is non-zero; zero implies no limit
   * </pre>
   *
   * <code>int32 max_tcp_sessions = 22;</code>
   * @return The maxTcpSessions.
   */
  int getMaxTcpSessions();

  /**
   * <pre>
   * max_udp_sessions is the maximum number of UDP sessions allowed from/to this
   * vnic, if it is non-zero; zero implies no limit
   * </pre>
   *
   * <code>int32 max_udp_sessions = 23;</code>
   * @return The maxUdpSessions.
   */
  int getMaxUdpSessions();

  /**
   * <pre>
   * max_icmp_sessions is the maximum number of ICMP sessions allowed from/to this
   * vnic, if it is non-zero; zero implies no limit
   * </pre>
   *
   * <code>int32 max_icmp_sessions = 24;</code>
   * @return The maxIcmpSessions.
   */
  int getMaxIcmpSessions();

  /**
   * <pre>
   * max other session is the maximum number of non-TCP/UDP/ICMP sessions allowed
   * from/to this vnic; zero implies no limit
   * </pre>
   *
   * <code>int32 max_other_sessions = 25;</code>
   * @return The maxOtherSessions.
   */
  int getMaxOtherSessions();

  public opi_api.network.cloud.v1alpha1.VnicSpec.IfinfoCase getIfinfoCase();
}
