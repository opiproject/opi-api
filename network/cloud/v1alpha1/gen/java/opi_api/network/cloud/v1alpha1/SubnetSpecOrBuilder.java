// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: subnet.proto

package opi_api.network.cloud.v1alpha1;

public interface SubnetSpecOrBuilder extends
    // @@protoc_insertion_point(interface_extends:opi_api.network.cloud.v1alpha1.SubnetSpec)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * virtual private cloud this subnet is belongs to
   * </pre>
   *
   * <code>string vpc_name_ref = 1;</code>
   * @return The vpcNameRef.
   */
  java.lang.String getVpcNameRef();
  /**
   * <pre>
   * virtual private cloud this subnet is belongs to
   * </pre>
   *
   * <code>string vpc_name_ref = 1;</code>
   * @return The bytes for vpcNameRef.
   */
  com.google.protobuf.ByteString
      getVpcNameRefBytes();

  /**
   * <pre>
   * IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv4Prefix v4_prefix = 2;</code>
   * @return Whether the v4Prefix field is set.
   */
  boolean hasV4Prefix();
  /**
   * <pre>
   * IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv4Prefix v4_prefix = 2;</code>
   * @return The v4Prefix.
   */
  opi_api.network.opinetcommon.v1alpha1.IPv4Prefix getV4Prefix();
  /**
   * <pre>
   * IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv4Prefix v4_prefix = 2;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.IPv4PrefixOrBuilder getV4PrefixOrBuilder();

  /**
   * <pre>
   * IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv6Prefix v6_prefix = 3;</code>
   * @return Whether the v6Prefix field is set.
   */
  boolean hasV6Prefix();
  /**
   * <pre>
   * IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv6Prefix v6_prefix = 3;</code>
   * @return The v6Prefix.
   */
  opi_api.network.opinetcommon.v1alpha1.IPv6Prefix getV6Prefix();
  /**
   * <pre>
   * IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv6Prefix v6_prefix = 3;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.IPv6PrefixOrBuilder getV6PrefixOrBuilder();

  /**
   * <pre>
   * IPv4 Virtual Router (VR) IP of this subnet, this IP is owned by the device
   * and packets originated by this device carry this IP as source IP
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: ipv4 address is unsigned. --)
   * </pre>
   *
   * <code>uint32 ipv4_virtual_router_ip = 4;</code>
   * @return The ipv4VirtualRouterIp.
   */
  int getIpv4VirtualRouterIp();

  /**
   * <pre>
   * Ipv6 Virtual Router (VR) IP of this subnet, this IP is owned by the device
   * and packets originated by this device carry this IP as source IP
   * </pre>
   *
   * <code>bytes ipv6_virtual_router_ip = 5;</code>
   * @return The ipv6VirtualRouterIp.
   */
  com.google.protobuf.ByteString getIpv6VirtualRouterIp();

  /**
   * <pre>
   * Virtual Router (VR) MAC address, any packets originated or routed by
   * the device carry this MAC as source MAC
   * </pre>
   *
   * <code>bytes virtual_router_mac = 6;</code>
   * @return The virtualRouterMac.
   */
  com.google.protobuf.ByteString getVirtualRouterMac();

  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>string v4_route_table_name_ref = 7;</code>
   * @return The v4RouteTableNameRef.
   */
  java.lang.String getV4RouteTableNameRef();
  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>string v4_route_table_name_ref = 7;</code>
   * @return The bytes for v4RouteTableNameRef.
   */
  com.google.protobuf.ByteString
      getV4RouteTableNameRefBytes();

  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>string v6_route_table_name_ref = 8;</code>
   * @return The v6RouteTableNameRef.
   */
  java.lang.String getV6RouteTableNameRef();
  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>string v6_route_table_name_ref = 8;</code>
   * @return The bytes for v6RouteTableNameRef.
   */
  com.google.protobuf.ByteString
      getV6RouteTableNameRefBytes();

  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingess_v4_security_policy_name_ref = 9;</code>
   * @return A list containing the ingessV4SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getIngessV4SecurityPolicyNameRefList();
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingess_v4_security_policy_name_ref = 9;</code>
   * @return The count of ingessV4SecurityPolicyNameRef.
   */
  int getIngessV4SecurityPolicyNameRefCount();
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingess_v4_security_policy_name_ref = 9;</code>
   * @param index The index of the element to return.
   * @return The ingessV4SecurityPolicyNameRef at the given index.
   */
  java.lang.String getIngessV4SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingess_v4_security_policy_name_ref = 9;</code>
   * @param index The index of the value to return.
   * @return The bytes of the ingessV4SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getIngessV4SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 10;</code>
   * @return A list containing the ingressV6SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getIngressV6SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 10;</code>
   * @return The count of ingressV6SecurityPolicyNameRef.
   */
  int getIngressV6SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 10;</code>
   * @param index The index of the element to return.
   * @return The ingressV6SecurityPolicyNameRef at the given index.
   */
  java.lang.String getIngressV6SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string ingress_v6_security_policy_name_ref = 10;</code>
   * @param index The index of the value to return.
   * @return The bytes of the ingressV6SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getIngressV6SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 11;</code>
   * @return A list containing the egressV4SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getEgressV4SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 11;</code>
   * @return The count of egressV4SecurityPolicyNameRef.
   */
  int getEgressV4SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 11;</code>
   * @param index The index of the element to return.
   * @return The egressV4SecurityPolicyNameRef at the given index.
   */
  java.lang.String getEgressV4SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v4_security_policy_name_ref = 11;</code>
   * @param index The index of the value to return.
   * @return The bytes of the egressV4SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getEgressV4SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 12;</code>
   * @return A list containing the egressV6SecurityPolicyNameRef.
   */
  java.util.List<java.lang.String>
      getEgressV6SecurityPolicyNameRefList();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 12;</code>
   * @return The count of egressV6SecurityPolicyNameRef.
   */
  int getEgressV6SecurityPolicyNameRefCount();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 12;</code>
   * @param index The index of the element to return.
   * @return The egressV6SecurityPolicyNameRef at the given index.
   */
  java.lang.String getEgressV6SecurityPolicyNameRef(int index);
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated string egress_v6_security_policy_name_ref = 12;</code>
   * @param index The index of the value to return.
   * @return The bytes of the egressV6SecurityPolicyNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getEgressV6SecurityPolicyNameRefBytes(int index);

  /**
   * <pre>
   * AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
   * and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
   * traffic with same DOT1Q tag, in which case vnics are identified with
   * their MAC or IP based on the datapath in addition to the DOT1Q tag
   * - when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
   *   identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
   *   VNIC etc.)
   * - when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
   *   all traffic from vnics in that subnet is transmitted with this encap
   *   (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
   *   inherit the subnet's encap)
   * - it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
   *   certain tag value but some vnic's in that subnet to have different
   *   DOT1Q encap than that of subnet
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap access_encap = 13;</code>
   * @return Whether the accessEncap field is set.
   */
  boolean hasAccessEncap();
  /**
   * <pre>
   * AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
   * and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
   * traffic with same DOT1Q tag, in which case vnics are identified with
   * their MAC or IP based on the datapath in addition to the DOT1Q tag
   * - when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
   *   identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
   *   VNIC etc.)
   * - when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
   *   all traffic from vnics in that subnet is transmitted with this encap
   *   (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
   *   inherit the subnet's encap)
   * - it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
   *   certain tag value but some vnic's in that subnet to have different
   *   DOT1Q encap than that of subnet
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap access_encap = 13;</code>
   * @return The accessEncap.
   */
  opi_api.network.opinetcommon.v1alpha1.Encap getAccessEncap();
  /**
   * <pre>
   * AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
   * and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
   * traffic with same DOT1Q tag, in which case vnics are identified with
   * their MAC or IP based on the datapath in addition to the DOT1Q tag
   * - when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
   *   identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
   *   VNIC etc.)
   * - when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
   *   all traffic from vnics in that subnet is transmitted with this encap
   *   (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
   *   inherit the subnet's encap)
   * - it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
   *   certain tag value but some vnic's in that subnet to have different
   *   DOT1Q encap than that of subnet
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap access_encap = 13;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.EncapOrBuilder getAccessEncapOrBuilder();

  /**
   * <pre>
   * encapped traffic coming with the specified encap from fabric side will be
   * mapped to this subnet and traffic from workloads in this subnet will carry
   * this encap towards the fabric side
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 14;</code>
   * @return Whether the fabricEncap field is set.
   */
  boolean hasFabricEncap();
  /**
   * <pre>
   * encapped traffic coming with the specified encap from fabric side will be
   * mapped to this subnet and traffic from workloads in this subnet will carry
   * this encap towards the fabric side
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 14;</code>
   * @return The fabricEncap.
   */
  opi_api.network.opinetcommon.v1alpha1.Encap getFabricEncap();
  /**
   * <pre>
   * encapped traffic coming with the specified encap from fabric side will be
   * mapped to this subnet and traffic from workloads in this subnet will carry
   * this encap towards the fabric side
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 14;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.EncapOrBuilder getFabricEncapOrBuilder();

  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated string host_interface_name_ref = 15;</code>
   * @return A list containing the hostInterfaceNameRef.
   */
  java.util.List<java.lang.String>
      getHostInterfaceNameRefList();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated string host_interface_name_ref = 15;</code>
   * @return The count of hostInterfaceNameRef.
   */
  int getHostInterfaceNameRefCount();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated string host_interface_name_ref = 15;</code>
   * @param index The index of the element to return.
   * @return The hostInterfaceNameRef at the given index.
   */
  java.lang.String getHostInterfaceNameRef(int index);
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated string host_interface_name_ref = 15;</code>
   * @param index The index of the value to return.
   * @return The bytes of the hostInterfaceNameRef at the given index.
   */
  com.google.protobuf.ByteString
      getHostInterfaceNameRefBytes(int index);

  /**
   * <pre>
   * ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
   * header or in the Traffic Class field of IPv6 outer header, this value, if
   * non-zero, will be used as-is (i.e., not interpreted) during encap time by
   * the dataplane; tunnel objects, if configured with ToS, will override this
   * </pre>
   *
   * <code>int32 tos = 16;</code>
   * @return The tos.
   */
  int getTos();

  /**
   * <pre>
   * a subnet is marked connected if vnics in this subnet can communicate with
   * external endpoints via routes with some kind of NAT (e.g. 1:1 NAT, NAPT)
   * </pre>
   *
   * <code>bool connected = 17;</code>
   * @return The connected.
   */
  boolean getConnected();

  /**
   * <pre>
   * default ingress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security policies on a given vnic
   * </pre>
   *
   * <code>string ingress_default_sg_policy_name_ref = 18;</code>
   * @return The ingressDefaultSgPolicyNameRef.
   */
  java.lang.String getIngressDefaultSgPolicyNameRef();
  /**
   * <pre>
   * default ingress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security policies on a given vnic
   * </pre>
   *
   * <code>string ingress_default_sg_policy_name_ref = 18;</code>
   * @return The bytes for ingressDefaultSgPolicyNameRef.
   */
  com.google.protobuf.ByteString
      getIngressDefaultSgPolicyNameRefBytes();

  /**
   * <pre>
   * default egress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security polices on a given vnic
   * </pre>
   *
   * <code>string egress_default_sg_policy_name_ref = 19;</code>
   * @return The egressDefaultSgPolicyNameRef.
   */
  java.lang.String getEgressDefaultSgPolicyNameRef();
  /**
   * <pre>
   * default egress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security polices on a given vnic
   * </pre>
   *
   * <code>string egress_default_sg_policy_name_ref = 19;</code>
   * @return The bytes for egressDefaultSgPolicyNameRef.
   */
  com.google.protobuf.ByteString
      getEgressDefaultSgPolicyNameRefBytes();

  /**
   * <pre>
   * remote_subnet, if set, indicates that the subnet does not have any IP
   * mappings in local pod and such subnets are used to program all remote
   * pod IP mappings behind it
   * </pre>
   *
   * <code>bool remote_subnet = 20;</code>
   * @return The remoteSubnet.
   */
  boolean getRemoteSubnet();
}
